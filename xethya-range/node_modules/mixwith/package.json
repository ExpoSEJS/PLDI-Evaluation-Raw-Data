{
  "_args": [
    [
      {
        "raw": "mixwith@github:justinfagnani/mixwith.js",
        "scope": null,
        "escapedName": "mixwith",
        "name": "mixwith",
        "rawSpec": "github:justinfagnani/mixwith.js",
        "spec": "github:justinfagnani/mixwith.js",
        "type": "hosted",
        "hosted": {
          "type": "github",
          "ssh": "git@github.com:justinfagnani/mixwith.js.git",
          "sshUrl": "git+ssh://git@github.com/justinfagnani/mixwith.js.git",
          "httpsUrl": "git+https://github.com/justinfagnani/mixwith.js.git",
          "gitUrl": "git://github.com/justinfagnani/mixwith.js.git",
          "shortcut": "github:justinfagnani/mixwith.js",
          "directUrl": "https://raw.githubusercontent.com/justinfagnani/mixwith.js/master/package.json"
        }
      },
      "/home/blake/ExpoSE/Targets/xethya-range/node_modules/xethya-range"
    ]
  ],
  "_from": "justinfagnani/mixwith.js",
  "_id": "mixwith@0.1.1",
  "_inCache": true,
  "_location": "/mixwith",
  "_phantomChildren": {},
  "_requested": {
    "raw": "mixwith@github:justinfagnani/mixwith.js",
    "scope": null,
    "escapedName": "mixwith",
    "name": "mixwith",
    "rawSpec": "github:justinfagnani/mixwith.js",
    "spec": "github:justinfagnani/mixwith.js",
    "type": "hosted",
    "hosted": {
      "type": "github",
      "ssh": "git@github.com:justinfagnani/mixwith.js.git",
      "sshUrl": "git+ssh://git@github.com/justinfagnani/mixwith.js.git",
      "httpsUrl": "git+https://github.com/justinfagnani/mixwith.js.git",
      "gitUrl": "git://github.com/justinfagnani/mixwith.js.git",
      "shortcut": "github:justinfagnani/mixwith.js",
      "directUrl": "https://raw.githubusercontent.com/justinfagnani/mixwith.js/master/package.json"
    }
  },
  "_requiredBy": [
    "/xethya-range"
  ],
  "_resolved": "git://github.com/justinfagnani/mixwith.js.git#d34fe88ef3bb69d7e1751ad139208b656bf88a38",
  "_shasum": "1a0677dc769ca2b8a3fefca24c15357e88e9a63b",
  "_shrinkwrap": null,
  "_spec": "mixwith@github:justinfagnani/mixwith.js",
  "_where": "/home/blake/ExpoSE/Targets/xethya-range/node_modules/xethya-range",
  "author": {
    "name": "Jusitn Fagnani",
    "email": "justin@fagnani.com"
  },
  "bugs": {
    "url": "https://github.com/justinfagnani/mixwith.js/issues"
  },
  "dependencies": {},
  "description": "A simple, powerful mixin applier for JavaScript classes",
  "devDependencies": {
    "babel-plugin-transform-es2015-modules-umd": "^6.1.18",
    "chai": "^3.4.1",
    "event-stream": "^3.3.2",
    "gulp": "^3.9.0",
    "gulp-babel": "^6.1.0"
  },
  "directories": {
    "test": "test"
  },
  "gitHead": "d34fe88ef3bb69d7e1751ad139208b656bf88a38",
  "homepage": "https://github.com/justinfagnani/mixwith.js#readme",
  "keywords": [
    "mixin",
    "mixins",
    "classes"
  ],
  "license": "Apache-2.0",
  "main": "mixwith.js",
  "name": "mixwith",
  "optionalDependencies": {},
  "readme": "# mixwith.js\n\nA simple and powerful mixin library for ES6.\n\n`mixwith` differs from other mixin approaches because it does not copy properties from one object to another. Instead, `mixwith` works with \"subclass factories\" which create a new class that extends a superclass with the mixin - this is called a _mixin_ _application_.\n\n#### Example\n\nmy-mixin.js:\n\n```javascript\nlet MyMixin = (superclass) => class extends superclass {\n  // mixin methods here\n};\n```\n\nmy-class.js\n\n```javascript\nclass MyClass extends MyMixin(MySuperClass) {\n  // class methods here, go ahead, use super!\n}\n```\n\n### mixwith.js Helpers and Decorators\n\nThe subclass factory pattern does not require any support from a library. It's just a natural use of JavaScript class expressions. mixwith.js provides a few helpers that make mixins a little more powerful and easier to use.\n\nmixwith.js makes some use cases very easy:\n\n  * Determine if an object or class has had a particular mixin applied to it.\n  * Cache mixin applications so that a mixin repeatedly applied to the same superclass reuses its resulting subclass.\n  * De-duplicate mixin application so that including a mixin multiple times in a class hierarchy only applies it once to the prototype type chain.\n  * Add `instanceof` support to a mixin function.\n\n### mix().with()\n\nmixwith.js also provides a little bit of sugar with the `mix()` function that makes applying mixins read a little more naturally:\n\n```javascript\nclass MyClass extends mix(MySuperClass).with(MyMixin, OtherMixin) {\n  // class methods here, go ahead, use super!\n}\n```\n\n## Advantages of subclass factories over typical JavaScript mixins\n\nSubclass factory style mixins preserve the object-oriented inheritance properties that classes provide, like method overriding and `super` calls, while letting you compose classes out of mixins without being constrained to a single inheritance hierarchy, and without monkey-patching or copying.\n\n#### Method overriding that just works\n\nMethods in subclasses can naturally override methods in the mixin or superclass, and mixins override methods in the superclass. This means that precedence is preserved - the order is: _subclass_ -> _mixin__1_ -> ... -> _mixin__N_ -> _superclass_.\n\n#### `super` works\n\nSubclasses and mixins can use `super` normally, as defined in standard Javascript, and without needing the mixin library to do special chaining of functions.\n\n#### Mixins can have constructors\n\nSince `super()` works, mixins can define constructors. Combined with ES6 rest arguments and the spread operator, mixins can have generic constructors that work with any super constructor by passing along all arguments.\n\n#### Prototypes and instances are not mutated\n\nTypical JavaScript mixins usually used to either mutate each instance as created, which can be bad for performance and maintainability, or modify a prototype, which means every object inheriting from that prototype gets the mixin. Subclass factories don't mutate objects, they define new classes to subclass, leaving the original superclass intact.\n\n## Usage\n\n### Defining Mixins\n\nThe `Mixin` decorator function wraps a plain subclass factory to add deduplication, caching and `instanceof` support:\n\n```javascript\nlet MyMixin = Mixin((superclass) => class extends superclass {\n\n  constructor(args...) {\n    // mixins should either 1) not define a constructor, 2) require a specific\n    // constructor signature, or 3) pass along all arguments.\n    super(...args);\n  }\n\n  foo() {\n    console.log('foo from MyMixin');\n    // this will call superclass.foo()\n    super.foo();\n  }\n\n});\n```\n\nMixins defined with the mixwith.js decorators do not require any helpers to use, they still work like plain subclass factories.\n\n### Using Mixins\n\nClasses use mixins in their `extends` clause. Classes that use mixins can define and override constructors and methods as usual.\n\n```javascript\nclass MyClass extends mix(MySuperClass).with(MyMixin) {\n\n  constructor(a, b) {\n    super(a, b); // calls MyMixin(a, b)\n  }\n\n  foo() {\n    console.log('foo from MyClass');\n    super.foo(); // calls MyMixin.foo()\n  }\n\n}\n```\n\n# API Documentation\n\n<a name=\"apply\"></a>\n\n## apply(superclass, mixin) ⇒ <code>function</code>\nApplies `mixin` to `superclass`.\n\n`apply` stores a reference from the mixin application to the unwrapped mixin\nto make `isApplicationOf` and `hasMixin` work.\n\nThis function is usefull for mixin wrappers that want to automatically enable\n[hasMixin](#hasMixin) support.\n\n**Kind**: global function  \n**Returns**: <code>function</code> - A subclass of `superclass` produced by `mixin`  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| superclass | <code>function</code> | A class or constructor function |\n| mixin | <code>[MixinFunction](#MixinFunction)</code> | The mixin to apply |\n\n**Example**  \n```js\nconst Applier = (mixin) => wrap(mixin, (superclass) => apply(superclass, mixin));\n\n// M now works with `hasMixin` and `isApplicationOf`\nconst M = Applier((superclass) => class extends superclass {});\n\nclass C extends M(Object) {}\nlet i = new C();\nhasMixin(i, M); // true\n```\n<a name=\"isApplicationOf\"></a>\n\n## isApplicationOf(proto, mixin) ⇒ <code>boolean</code>\nReturns `true` iff `proto` is a prototype created by the application of\n`mixin` to a superclass.\n\n`isApplicationOf` works by checking that `proto` has a reference to `mixin`\nas created by `apply`.\n\n**Kind**: global function  \n**Returns**: <code>boolean</code> - whether `proto` is a prototype created by the application of\n`mixin` to a superclass  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| proto | <code>Object</code> | A prototype object created by [apply](#apply). |\n| mixin | <code>[MixinFunction](#MixinFunction)</code> | A mixin function used with [apply](#apply). |\n\n<a name=\"hasMixin\"></a>\n\n## hasMixin(o, mixin) ⇒ <code>boolean</code>\nReturns `true` iff `o` has an application of `mixin` on its prototype\nchain.\n\n**Kind**: global function  \n**Returns**: <code>boolean</code> - whether `o` has an application of `mixin` on its prototype\nchain  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| o | <code>Object</code> | An object |\n| mixin | <code>[MixinFunction](#MixinFunction)</code> | A mixin applied with [apply](#apply) |\n\n<a name=\"wrap\"></a>\n\n## wrap(mixin, wrapper) ⇒ <code>[MixinFunction](#MixinFunction)</code>\nSets up the function `mixin` to be wrapped by the function `wrapper`, while\nallowing properties on `mixin` to be available via `wrapper`, and allowing\n`wrapper` to be unwrapped to get to the original function.\n\n`wrap` does two things:\n  1. Sets the prototype of `mixin` to `wrapper` so that properties set on\n     `mixin` inherited by `wrapper`.\n  2. Sets a special property on `mixin` that points back to `mixin` so that\n     it can be retreived from `wrapper`\n\n**Kind**: global function  \n**Returns**: <code>[MixinFunction](#MixinFunction)</code> - `wrapper`  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| mixin | <code>[MixinFunction](#MixinFunction)</code> | A mixin function |\n| wrapper | <code>[MixinFunction](#MixinFunction)</code> | A function that wraps [mixin](mixin) |\n\n<a name=\"unwrap\"></a>\n\n## unwrap(wrapper) ⇒ <code>[MixinFunction](#MixinFunction)</code>\nUnwraps the function `wrapper` to return the original function wrapped by\none or more calls to `wrap`. Returns `wrapper` if it's not a wrapped\nfunction.\n\n**Kind**: global function  \n**Returns**: <code>[MixinFunction](#MixinFunction)</code> - The originally wrapped mixin  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| wrapper | <code>[MixinFunction](#MixinFunction)</code> | A wrapped mixin produced by [wrap](#wrap) |\n\n<a name=\"Cached\"></a>\n\n## Cached(mixin) ⇒ <code>[MixinFunction](#MixinFunction)</code>\nDecorates `mixin` so that it caches its applications. When applied multiple\ntimes to the same superclass, `mixin` will only create one subclass, memoize\nit and return it for each application.\n\nNote: If `mixin` somehow stores properties its classes constructor (static\nproperties), or on its classes prototype, it will be shared across all\napplications of `mixin` to a super class. It's reccomended that `mixin` only\naccess instance state.\n\n**Kind**: global function  \n**Returns**: <code>[MixinFunction](#MixinFunction)</code> - a new mixin function  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| mixin | <code>[MixinFunction](#MixinFunction)</code> | The mixin to wrap with caching behavior |\n\n<a name=\"DeDupe\"></a>\n\n## DeDupe(mixin) ⇒ <code>[MixinFunction](#MixinFunction)</code>\nDecorates `mixin` so that it only applies if it's not already on the\nprototype chain.\n\n**Kind**: global function  \n**Returns**: <code>[MixinFunction](#MixinFunction)</code> - a new mixin function  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| mixin | <code>[MixinFunction](#MixinFunction)</code> | The mixin to wrap with deduplication behavior |\n\n<a name=\"HasInstance\"></a>\n\n## HasInstance(mixin) ⇒ <code>[MixinFunction](#MixinFunction)</code>\nAdds [Symbol.hasInstance] (ES2015 custom instanceof support) to `mixin`.\n\n**Kind**: global function  \n**Returns**: <code>[MixinFunction](#MixinFunction)</code> - the given mixin function  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| mixin | <code>[MixinFunction](#MixinFunction)</code> | The mixin to add [Symbol.hasInstance] to |\n\n<a name=\"BareMixin\"></a>\n\n## BareMixin(mixin) ⇒ <code>[MixinFunction](#MixinFunction)</code>\nA basic mixin decorator that applies the mixin with [apply](#apply) so that it\ncan be used with [isApplicationOf](#isApplicationOf), [hasMixin](#hasMixin) and the other\nmixin decorator functions.\n\n**Kind**: global function  \n**Returns**: <code>[MixinFunction](#MixinFunction)</code> - a new mixin function  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| mixin | <code>[MixinFunction](#MixinFunction)</code> | The mixin to wrap |\n\n<a name=\"Mixin\"></a>\n\n## Mixin(mixin) ⇒ <code>[MixinFunction](#MixinFunction)</code>\nDecorates a mixin function to add deduplication, application caching and\ninstanceof support.\n\n**Kind**: global function  \n**Returns**: <code>[MixinFunction](#MixinFunction)</code> - a new mixin function  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| mixin | <code>[MixinFunction](#MixinFunction)</code> | The mixin to wrap |\n\n<a name=\"mix\"></a>\n\n## mix([superclass]) ⇒ <code>MixinBuilder</code>\nA fluent interface to apply a list of mixins to a superclass.\n\n```javascript\nclass X extends mix(Object).with(A, B, C) {}\n```\n\nThe mixins are applied in order to the superclass, so the prototype chain\nwill be: X->C'->B'->A'->Object.\n\nThis is purely a convenience function. The above example is equivalent to:\n\n```javascript\nclass X extends C(B(A(Object))) {}\n```\n\n**Kind**: global function  \n\n| Param | Type | Default |\n| --- | --- | --- |\n| [superclass] | <code>function</code> | <code>Object</code> |\n\n<a name=\"MixinFunction\"></a>\n\n## MixinFunction ⇒ <code>function</code>\nA function that returns a subclass of its argument.\n\n**Kind**: global typedef  \n**Returns**: <code>function</code> - A subclass of `superclass`  \n\n| Param | Type |\n| --- | --- |\n| superclass | <code>function</code> |\n\n**Example**  \n```js\nconst M = (superclass) => class extends superclass {\n  getMessage() {\n    return \"Hello\";\n  }\n}\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/justinfagnani/mixwith.js.git"
  },
  "scripts": {
    "build": "gulp",
    "test": "mocha build/test"
  },
  "version": "0.1.1"
}
