'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _classCallCheck = _interopDefault(require('babel-runtime/helpers/classCallCheck'));
var _createClass = _interopDefault(require('babel-runtime/helpers/createClass'));
var _Object$assign = _interopDefault(require('babel-runtime/core-js/object/assign'));
var _Object$getPrototypeOf = _interopDefault(require('babel-runtime/core-js/object/get-prototype-of'));
var _possibleConstructorReturn = _interopDefault(require('babel-runtime/helpers/possibleConstructorReturn'));
var _inherits = _interopDefault(require('babel-runtime/helpers/inherits'));
var mixwith = require('mixwith');

/**
 * xethya-range
 *
 * Copyright Â© 2016 Joel A. Villarreal Bertoldi. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.txt file in the root directory of this source tree.
 */

/**
 * Represents a range of number, described through boundaries.
 */
var Range = function () {
  /**
   * Instantiates a Range object.
   * @param  {Number} lowerBound The minimum number in this range.
   * @param  {Number} upperBound The maximum number in this range.
   * @constructor
   * @throws {Error} If lowerBound and upperBound are the same.
   */
  function Range(lowerBound, upperBound) {
    _classCallCheck(this, Range);

    if (typeof lowerBound === 'undefined') {
      throw new Error('Range#constructor: lowerBound is required');
    }
    if (typeof lowerBound !== 'number') {
      throw new Error('Range#constructor: lowerBound must be a Number');
    }
    if (typeof upperBound === 'undefined') {
      throw new Error('Range#constructor: upperBound is required');
    }
    if (typeof upperBound !== 'number') {
      throw new Error('Range#constructor: upperBound must be a Number');
    }
    if (lowerBound === upperBound) {
      throw new Error('Range#constructor: lowerBound and upperBound cannot be equal');
    }

    /**
     * @property {Number} lowerBound The minimum number in this range.
     */
    this.lowerBound = Math.min(lowerBound, upperBound);

    /**
     * @property {Number} upperBound The maximum number in this range.
     */
    this.upperBound = Math.max(lowerBound, upperBound);
  }

  /**
   * Checks if a value is in the defined range.
   *
   * @param  {Number} value Value to compare.
   * @return {Boolean} true if in range, false otherwise.
   * @function
   */


  _createClass(Range, [{
    key: 'includes',
    value: function includes(value) {
      if (typeof value === 'undefined') {
        throw new Error('Range#includes: value is required');
      }
      if (typeof value !== 'number') {
        throw new Error('Range#includes: value must be a Number');
      }
      return this.lowerBound <= value && value <= this.upperBound;
    }

    /**
     * Converts the Range object to a string representation.
     * @return {String}
     * @function
     */

  }, {
    key: 'toString',
    value: function toString() {
      return this.lowerBound.toString() + ' ~ ' + this.upperBound.toString();
    }

    /**
     * Creates a Range from an array of two numbers.
     *
     * @param  {Array.<Number>} values Boundaries of the range.
     * @return {Range}
     * @function
     * @static
     */

  }], [{
    key: 'fromArray',
    value: function fromArray(values) {
      if (!Array.isArray(values)) {
        throw new Error('Range#fromArray: values must be an Array of 2 numerical elements');
      }
      if (values.length !== 2) {
        throw new Error('Range#fromArray: values must be an Array of 2 numerical elements');
      }
      if (!values.every(function (value) {
        return typeof value === 'number';
      })) {
        throw new Error('Range#fromArray: values must be an Array of 2 numerical elements');
      }
      return new Range(Number(values[0]), Number(values[1]));
    }

    /**
     * Creates a Range from a string-based notation.
     *
     * @param  {String} notedRange A string representation of a Range,
     * using delimiters. Accepted formats: x,y x;y x:y x~y.
     * @return {Range}
     * @function
     * @static
     */

  }, {
    key: 'fromNotation',
    value: function fromNotation(notedRange) {
      if (!notedRange) {
        throw new Error('Range#fromNotation: notedRange must use one of these formats: ' + 'x,y x;y x:y x~y');
      }
      if (typeof notedRange !== 'string') {
        throw new Error('Range#fromNotation: notedRange must use one of these formats: ' + 'x,y x;y x:y x~y');
      }

      var range = void 0;
      var allowedDelimiters = [',', ';', ':', '~'];
      if (!allowedDelimiters.some(function (delimiter) {
        return notedRange.includes(delimiter);
      })) {
        throw new Error('Range#fromNotation: notedRange must use one of these formats: ' + 'x,y x;y x:y x~y');
      }
      var delimiterFound = false;
      while (!delimiterFound) {
        var delimiter = allowedDelimiters.shift();
        delimiterFound = notedRange.includes(delimiter);
        if (delimiterFound) {
          var data = notedRange.split(delimiter).map(function (d) {
            return d.trim();
          });
          if (data.length !== 2) {
            throw new Error('Range#fromNotation: notedRange must use one of these formats: ' + 'x,y x;y x:y x~y');
          } else {
            range = Range.fromArray(data.map(function (d) {
              return Number(d);
            }));
          }
        }
      }
      if (!range) {
        throw new Error('Range#fromNotation: notedRange must use one of these formats: ' + 'x,y x;y x:y x~y');
      }
      return range;
    }
  }]);

  return Range;
}();

var RangeableObject = mixwith.Mixin(function (superclass) {
  return function (_superclass) {
    _inherits(_class, _superclass);

    function _class() {
      var _ref;

      _classCallCheck(this, _class);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var _this = _possibleConstructorReturn(this, (_ref = _class.__proto__ || _Object$getPrototypeOf(_class)).call.apply(_ref, [this].concat(args)));

      _this.__meta__ = _Object$assign({}, _this.__meta__, {
        rangeDefinition: new Range(0, Infinity)
      });
      return _this;
    }

    _createClass(_class, [{
      key: 'rangeDefinition',
      get: function get() {
        return this.__meta__.rangeDefinition;
      },
      set: function set(_) {
        throw new Error('RangeableObject#rangeDefinition: object cannot be replaced');
      }
    }]);

    return _class;
  }(superclass);
});

exports.Range = Range;
exports.RangeableObject = RangeableObject;
//# sourceMappingURL=index.js.map