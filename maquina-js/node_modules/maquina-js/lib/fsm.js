'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var debug = require('debug')('maquina-js');

var MaquinaError = function MaquinaError(message) {
  var e = new Error('MaquinaError');
  e.message = message;
  return e;
};

function isValidIdentifier(id) {
  return (/[a-zA-Z_$]/.test(id)
  );
} // TODO: check for reserved words etc.

function transitionExists(t, machineTransitions) {
  if (machineTransitions[t.trigger]) {
    if (machineTransitions[t.trigger].some(function (element) {
      return element.source === t.source;
    })) {
      debug('error: trigger ' + t.trigger + ' already exists for state ' + t.source);
      return true;
    }
  }
  return false;
}

var StateMachine = function StateMachine(states) {
  var _this = this;

  var transitions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var initialState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  this.transitions = {};
  this.states = [];

  this.initialize = function (initialState) {
    if (_this.state) {
      debug('error: state machine is already initialized (current state: ' + _this.state + ')');
      return false;
    } else {
      if (_this.states.indexOf(initialState) === -1) {
        throw MaquinaError('invalid initial state');
      }
      _this.state = initialState;
    }
    return true;
  };

  // validations
  this.isValidTransition = function (t) {
    return (typeof t === 'undefined' ? 'undefined' : _typeof(t)) === 'object' && _this.states.indexOf(t.source) > -1 && _this.states.indexOf(t.target) > -1 && isValidIdentifier(t.trigger) && !transitionExists(t, _this.transitions) && (!t.before || typeof t.before === 'function') && (!t.after || typeof t.after === 'function');
  };

  this.isValidState = function (s) {
    return _this.states.indexOf(s) === -1 && typeof s === 'string';
  };

  // getters

  this.getState = function () {
    return _this.state;
  };

  // add and remove methods
  this.addTransition = function (t) {
    if (!_this.isValidTransition(t)) {
      debug('error: can not add invalid transition', t);
      return false;
    }

    if (!_this.transitions[t.trigger]) {
      _this.transitions[t.trigger] = [];
    }
    _this.transitions[t.trigger].push(t); // TODO: remove trigger prop
    debug('adding transition ' + t.trigger + ' to ' + t.source);
    _this[t.trigger] = function () {
      var transitionsArray = _this.transitions[t.trigger];
      var transitionToRun = transitionsArray.find(function (element) {
        return element.source === _this.state;
      });

      if (!transitionToRun) {
        debug('error: invalid trigger for ' + _this.state + ': ' + t.trigger);
        return false;
      }

      if (transitionToRun.before) {
        var beforeResult = transitionToRun.before();
        if (typeof beforeResult !== 'boolean') {
          debug('error: Invalid before hook output: expected boolean, got:', typeof beforeResult === 'undefined' ? 'undefined' : _typeof(beforeResult));
          throw MaquinaError('invalid before hook for trigger: ' + t.trigger);
        }
        if (beforeResult === false) {
          debug('before hook failed for trigger ' + t.trigger);
          return false;
        }
      }
      debug('executing trigger: ' + t.trigger);

      debug(_this.state + ' -> ' + transitionToRun.target);
      _this.state = transitionToRun.target;

      if (transitionToRun.after) {
        transitionToRun.after();
      }
      return true;
    };
  };

  this.addState = function (s) {
    if (!_this.isValidState(s)) {
      debug('error: invalid state', s);
      return false;
    }
    _this.states.push(s);
    return true;
  };

  this.removeState = function (s) {
    var stateIndex = _this.states.findIndex(function (x) {
      return x === s;
    });
    if (stateIndex === -1) {
      throw MaquinaError('state ' + s + ' not found for removal');
    }

    // remove transitions to and from this state

    var triggers = Object.keys(_this.transitions);

    triggers.forEach(function (t) {
      _this.transitions[t].forEach(function (transition) {
        if (transition.source === s || transition.target === s) {
          _this.removeTransition(t, transition.source);
        }
      });
    });

    // remove state
    debug('removing state', s);
    _this.states.splice(stateIndex, 1);
    return true;
  };

  this.removeTransition = function (trigger, source) {

    // full trigger removal
    if (!source) {
      debug('removing all transitions for trigger ' + trigger);
      delete _this.transitions[trigger];
      _this[trigger] = undefined;
      return;
    }

    // state trigger removal
    debug('removing transition ' + trigger + ' from ' + source);

    var transitionsArray = _this.transitions[trigger];
    var transitionIndex = transitionsArray.findIndex(function (element) {
      return element.source === source;
    });

    if (transitionIndex > -1) {
      _this.transitions[trigger].splice(transitionIndex, 1);
    }
  };

  // setup states and transitions
  var i = void 0;
  for (i = 0; i < states.length; i++) {
    this.addState(states[i]);
  }

  for (i = 0; i < transitions.length; i++) {
    this.addTransition(transitions[i]);
  }

  if (initialState && this.states.indexOf(initialState) === -1) {
    throw MaquinaError('invalid initial state');
  }

  // set initial state
  if (initialState) {
    this.initialize(initialState);
  }

  return this;
};

module.exports = StateMachine;