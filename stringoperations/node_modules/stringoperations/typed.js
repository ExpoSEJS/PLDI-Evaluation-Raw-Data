// @flow

/**
 * Returns all indexes of the given regex matches in the input string.
 * @param   {RegExp}   regex            - The Regular Expression to match.
 * @param   {string}   str              - The string to match occurrences in.
 * @param   {number}   [startingFrom=0] - The index position to start from.
 * @returns {number[]}                    An array of index matches.
 * @throws  {TypeError}                   If the first argument is not of type 'RegExp'.
 * @throws  {TypeError}                   If the second argument is not of type 'string'.
 * @throws  {TypeError}                   If the third argument is not of type 'number'.
 * @throws  {RangeError}                  If the given 'startingFrom' value is out of bounds.
 */
export function allIndexesOf (regex: RegExp, str: string, startingFrom: number = 0): number[] {
	if (!(regex instanceof RegExp))											throw new TypeError(`First argument to 'allIndexesOf' must be of type 'RegExp'`);
	if (typeof str !== "string") 												throw new TypeError(`Second argument to 'allIndexesOf' must be of type 'string'!`);
	if (typeof startingFrom !== "number")								throw new TypeError(`third argument to 'allIndexesOf' must be of type 'number'!`);
	if (startingFrom < 0 || startingFrom >= str.length) throw new RangeError(`Given 'startingFrom' value: ${startingFrom} is out of bounds!`);

	const matches: Array<number> = [];
	let match;
	while ((match = regex.exec(str)) != null) {
		if (match.index >= startingFrom) matches.push(match.index);
	}
	return matches;
}

/**
 * Capitalizes the given string.
 * @param   {string} str - The string to capitalize.
 * @returns {string}       The capitalized string.
 * @throws  {TypeError}    If the given input is not of type 'string'.
 */
export function capitalize (str: string): string {
	if (typeof str !== "string") throw new TypeError(`Given argument to 'capitalize' must be of type 'string'!`);
	return str.slice(0, 1).toUpperCase() + str.slice(1);
}

/**
 * Removes all whitespace from a string.
 * @param   {string}  str             - The string to remove whitespace from.
 * @param   {boolean} preserveSpaces  - If spaces should be preserved.
 * @returns {string}                    The string with all whitespace removed.
 * @throws  {TypeError}                 If the given input is not of type 'string'.
 */
export function removeWhitespace (str: string, preserveSpaces: boolean = false): string {
	if (typeof str !== "string") throw new TypeError(`Given argument to 'removeWhitespace' must be of type 'string'!`);

	// Convert tabs to spaces and remove anything but spaces.
	if (preserveSpaces) return str.replace(/[\t]/g, " ").replace(/[\n\r]/g, "").replace(/[ ]{2,}/g, " ");

	// Remove any kind of whitespace.
	return str.replace(/[ \n\t\r]/g, "");
}

/**
 * Lowercases the first character of the given string.
 * @param   {string} str - The string to lowercase the first character of.
 * @returns {string}       The string with the first character lowercased.
 * @throws  {TypeError}    If the given input is not of type 'string'.
 */
export function lowerCaseFirst (str: string): string {
	if (typeof str !== "string") throw new TypeError(`Given argument to 'lowerCaseFirst' must be of type 'string'!`);
	return str.slice(0, 1).toLowerCase() + str.slice(1);
}

/**
 * camelCases the given string.
 * @param   {string} str - The string to camelCase.
 * @returns {string}       The camelCased string.
 * @throws  {TypeError}    If the given input is not of type 'string'.
 */
export function camelCase (str: string): string {
	if (typeof str !== "string") throw new TypeError(`Given argument to 'camelCase' must be of type 'string'!`);
	return lowerCaseFirst(str
	// Replaces any - or _ characters with a space
		.replace(/[-_+]+/g, " ")
		.replace(/[ ]{2,}/g, " ")
		// Removes any non alphanumeric characters
		.replace(/[^\w\sa-zæøåàáäâëêéèïîíìöòóôüúùû&]/gi, "")

		.replace(/[A-Z]{2,}/g, $1 => $1.toLowerCase())
		// Uppercases the first character in each group immediately following a space
		// (delimited by spaces)
		.replace(/ (.)/g, $1 => $1.toUpperCase())
		// Removes spaces
		.replace(/ /g, ""));
}

/**
 * kebabCases the given string.
 * @param   {string} str - The string to kebabCase.
 * @returns {string}       The kebabCased string.
 * @throws  {TypeError}    If the given input is not of type 'string'.
 */
export function kebabCase (str: string): string {
	if (typeof str !== "string") throw new TypeError(`Given argument to 'kebabCase' must be of type 'string'!`);
	// Lower cases the string
	let _str = str;
	if (!/[a-zæøåàáäâëêéèïîíìöòóôüúùû]/.test(_str)) _str = str.toLowerCase();
	return _str.replace(/(?:_)[A-ZÅÀÁÂÄÆËÊÉÈÏÎÍÌÖÔÒÓØÜÛÚÙ]{2,}|[A-Z]{2,}(?=_)/g, $1 => ` ${$1.toLowerCase()}`)
		.replace(/[-_+]/g, " ")
		.replace(/[ \t\r]*[A-ZÅÀÁÂÄÆËÊÉÈÏÎÍÌÖÔÒÓØÜÛÚÙ]+[ \t\r]+/g, $1 => ` ${$1.toLowerCase()} `)
		.replace(/[A-ZÅÀÁÂÄÆËÊÉÈÏÎÍÌÖÔÒÓØÜÛÚÙ]/g, $1 => ` ${$1.toLowerCase()}`)
		.replace(/^[ \t\r]+/g, "")
		.replace(/\s{2,}/g, " ")
		.replace(/\s+/g, "-");
}

/**
 * Will return a matching primitive value from a given string. For instance, the string 'true' will return the boolean value true.
 * @param {string} str - The string to convert to a native primitive type.
 * @returns {any}        The primitive value or the string itself.
 * @throws {TypeError}   If the given argument is not a string.
 */
export function parsePrimitiveFromString (str: string): any {
	if (typeof str !== "string") 	throw new TypeError(`Given argument to 'parseTypeFromString' must be of type 'string'!`);
	if (str === "true") 					return true;
	if (str === "false") 					return false;
	if (/^[\d\.]+$/.test(str)) 		return parseFloat(str);
	if (str === "null")						return null;
	if (str === "undefined")			return undefined;
	if (str === "NaN")						return NaN;
	if (str === "Infinity")				return Infinity;
	return str;
}