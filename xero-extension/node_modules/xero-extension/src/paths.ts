import { Xero2 as Xero } from './xero';
import { stringify } from 'query-string';
import * as inflect from 'inflect';

export interface IOptions {
  singular?: boolean,
  headers?: any,
  query?: any
}
export interface CallOptions extends IOptions{
  method: string,
  path: string,
  body?: any
}
export class Methods extends Xero {
  constructor (config, public endpoint: string) {
    super(config.key, config.secret, config.rsa_key, undefined, {Accept: 'application/json'});
  }
  get  (path, options: IOptions = {}) {
    let opts = {
      method: 'GET',
      path,
      singular: options.singular || false,
      query: options.query,
      headers: options.headers
    };
    return this.call(opts);
	}
  post (path, body, options: IOptions = {}) {
    let opts = {
      method: 'POST',
      path,
      body,
      singular: options.singular || false,
      query: options.query,
      headers: options.headers
    }
    return this.call(opts);
  }
  put (path, body, options: IOptions = {}) {
    let opts = {
      method: 'PUT',
      path,
      body,
      singular: options.singular || false,
      query: options.query,
      headers: options.headers
    };
    return this.call(opts);
  }
  patch (path, body, options: IOptions = {}) {
    let opts = {
      method: 'PATCH',
      path,
      body,
      singular: options.singular || false,
      query: options.query,
      headers: options.headers
    };
    return this.call(opts);
  }
  delete (path, body, options: IOptions = {}) {
    let opts = {
      method: 'DELETE',
      path,
      body,
      singular: options.singular || false,
      query: options.query,
      headers: options.headers
      
    };
    return this.call(opts);
  }
  call (options:CallOptions) {
    return new Promise((resolve, reject) => {
      if (options.headers) this._setHeaders(options.headers);
      if (options.query) options.path = this._setQuery(options.path, options.query);
      super.call(options.method, options.path, options.body, (err, json) => {
        if (err) return reject(err);
          if (options.singular) return resolve(json[inflect.pluralize(this.endpoint)][0]);
          return resolve(json[inflect.pluralize(this.endpoint)]);
      })
    })
  }
  private _setHeaders (headers:{}[]) {
    Object.keys(headers).forEach(key => {
      super.oa._headers[key] = headers[key];
    })
  }
  private _setQuery (path, query) {
    return path + '?' +stringify(query);
  }
}