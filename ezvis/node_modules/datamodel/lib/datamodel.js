'use strict';
var path = require('path')
  , basename = path.basename(__filename, '.js')
  , assert = require('assert')
  , once = require('once')
  , Promise = typeof global.Promise == 'function' ?  global.Promise : require('es6-promise').Promise
  ;


function parallel(tasks, fn) {
  var errors = [], counter = 0, limit = Object.keys(tasks).length, results = {};
  if (limit === 0) {
    fn({}, []);
  }
  else {
    Object.keys(tasks).forEach(function(key) {
        tasks[key](function(out) {
            if (counter < limit) {
              if (out instanceof Error) {
                errors.push(key);
              }
              results[key] = out;
              counter++;
              if(counter === limit) {
                fn(results, errors);
              }
            }
          }
        );
      }
    );
  }
}

function Datamodel() {

  var self = this;
  self._declared = {};
  self._appended = {};
  self._prepended = {};
  self._appended = {};
  self._completed = {};
  self._transformer = null;
}

Datamodel.prototype.declare = function (key, fn)
{
  assert.equal(typeof key, 'string');
  assert.equal(typeof fn, 'function');
  var self = this;
  self._declared[key] = fn;
  return self;
}

Datamodel.prototype.prepend = function (key, fn)
{
  assert.equal(typeof key, 'string');
  assert.equal(typeof fn, 'function');
  var self = this;
  self._prepended[key] = fn;
  return self;
}

Datamodel.prototype.append = function (key, fn)
{
  assert.equal(typeof key, 'string');
  assert.equal(typeof fn, 'function');
  var self = this;
  self._appended[key] = fn;
  return self;
}

Datamodel.prototype.complete = function (key, fn)
{
  assert.equal(typeof key, 'string');
  assert.equal(typeof fn, 'function');
  var self = this;
  self._completed[key] = fn;
  return self;
}

Datamodel.prototype.transform = function (fn)
{
  assert.equal(typeof fn, 'function');
  var self = this;
  self._transformer = fn;
  return self;
}

Datamodel.prototype.send = function (fn)
{
  assert.equal(typeof fn, 'function');
  var self = this;
  self._sender = fn;
  return self;
}

var apply = function (self, input, output, fn)
{
  var results = {}, errors = [];

  function mapper(ino, v) {
    var ouo = {};
    Object.keys(ino).forEach(function(k) {
        ouo[k] = function (callback) {
          var cb = once(callback);
         try {
           ino[k].call(results, input, cb);
         }
         catch (e) {
           cb(e)
         }
      }
    });
    return ouo;
  }
  parallel(mapper(self._declared, 'declare'), function(res1, err1) {
      Object.keys(res1).forEach(function(key) {
        results[key] = res1[key];
      });
      errors = errors.concat(err1);
      parallel(mapper(self._prepended, 'prepended'), function(res2a, err2a) {
        Object.keys(res2a).forEach(function(key) {
          results[key] = res2a[key];
        });
        errors = errors.concat(err2a)
        parallel(mapper(self._appended, 'appended'), function(res2b, err2b) {
          Object.keys(res2b).forEach(function(key) {
            results[key] = res2b[key];
          });
          errors = errors.concat(err2b)
          parallel(mapper(self._completed, 'complete'), function(res3, err3) {
            Object.keys(res3).forEach(function(key) {
              results[key] = res3[key];
            });
            errors = errors.concat(err3).filter(function(e) {
                return (results[e] instanceof Error);
            });
            var err = null;
            if (errors.length > 0) {
              err = results[errors[0]];
              err.message = "[Datamodel." + errors[0] + "] " + err.message;
            }
            if (typeof self._transformer === 'function') {
              self._transformer.call(results, input, function(newresults) {
                results = newresults;
                if (output && typeof self._sender === 'function') {
                  if (err === null) {
                    try {
                      self._sender.call(results, output, fn);
                    }
                    catch(e) {
                      e.message = "[Datamodel.send] " + e.message;
                      fn(e)
                    }
                  }
                  else {
                    fn(err);
                  }
                }
                else {
                  fn(err, results);
                }
              });
            }
            else {
              if (output && typeof self._sender === 'function') {
                if (err === null) {
                    try {
                      self._sender.call(results, output, fn);
                    }
                    catch(e) {
                      e.message = "[Datamodel.send] " + e.message;
                      fn(e)
                    }
                }
                else {
                  fn(err);
                }
              }
              else {
                fn(err, results);
              }
            }
          });
        });
      });
  });
}
Datamodel.prototype.apply = function (input, output, fn)
{
  var self = this;
  if (typeof input === 'function' && output === undefined && fn === undefined) {
    fn = input;
    input = {};
    output = false;
  }
  else if (typeof input !== 'function' && typeof output === 'function' && fn === undefined) {
    fn = output;
    output = false;
  }

  if(typeof fn == 'function') {
    return apply(self, input, output, fn);
  }
  return new Promise(function(resolve, reject) {
      apply(self, input, output, function(e, r) {
          if (e) {
            reject(e);
          }
          else {
            resolve(r);
          }
      });
  });
}
Datamodel.prototype.attach = function (module) {
  var self = this;
  module.exports = self.takeout();
  return self;
};

Datamodel.prototype.takeout = function () {
  var self = this;
  return function(input, output, fn) {
    return self.apply(input, output, fn);
  }
};



module.exports = function (models) {
  var model = new Datamodel();

  if (Array.isArray(models)) {
    models.forEach(function(func, i) {
        if (typeof func === 'function') {
          func(model);
        }
    });
  }

  return model;
}
