//! moment.js
//! version : 2.18.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    var i = 0;
    i++;
}

function isObject(input) {
   var i = 0;
    i++;
}

function isObjectEmpty(obj) {
    var i = 0;
    i++;
}

function isUndefined(input) {
    var i = 0;
    i++;
}

function isNumber(input) {
   var i = 0;
    i++;
}

function isDate(input) {
    var i = 0;
    i++;
}

function map(arr, fn) {
    var i = 0;
    i++;
}

function hasOwnProp(a, b) {
   var i = 0;
    i++;
}

function extend(a, b) {
   var i = 0;
    i++;
}

function createUTC (input, format, locale, strict) {
    var i = 0;
    i++;
}

function defaultParsingFlags() {
   var i = 0;
    i++;
}

function getParsingFlags(m) {
    var i = 0;
    i++;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

var some$1 = some;

function isValid(m) {
    var i = 0;
    i++;
}

function createInvalid (flags) {
    var i = 0;
    i++;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i = 0;
    i++;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    var i = 0;
    i++;
}

function isMoment (obj) {
    var i = 0;
    i++;
}

function absFloor (number) {
    var i = 0;
    i++;
}

function toInt(argumentForCoercion) {
    var i = 0;
    i++;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var i = 0;
    i++;
}

function warn(msg) {
    var i = 0;
    i++;
}

function deprecate(msg, fn) {
    var i = 0;
    i++;
}

var deprecations = {};

function deprecateSimple(name, msg) {
    var i = 0;
    i++;
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
   var i = 0;
    i++;
}

function set (config) {
    var i = 0;
    i++;
}

function mergeConfigs(parentConfig, childConfig) {
    var i = 0;
    i++;
}

function Locale(config) {
    var i = 0;
    i++;
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var keys$1 = keys;

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var i = 0;
    i++;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var i = 0;
    i++;
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    var i = 0;
    i++;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    var i = 0;
    i++;
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
   var i = 0;
    i++;
}

function pastFuture (diff, output) {
    var i = 0;
    i++;
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var i = 0;
    i++;
}

function normalizeUnits(units) {
    var i = 0;
    i++;
}

function normalizeObjectUnits(inputObject) {
    var i = 0;
    i++;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    var i = 0;
    i++;
}

function getPrioritizedUnits(unitsObj) {
   var i = 0;
    i++;
}

function makeGetSet (unit, keepTime) {
    var i = 0;
    i++;
}

function get (mom, unit) {
    var i = 0;
    i++;
}

function set$1 (mom, unit, value) {
    var i = 0;
    i++;
}

// MOMENTS

function stringGet (units) {
   var i = 0;
    i++;
}


function stringSet (units, value) {
    var i = 0;
    i++;
}

function zeroFill(number, targetLength, forceSign) {
    var i = 0;
    i++;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var i = 0;
    i++;
}

function removeFormattingTokens(input) {
    var i = 0;
    i++;
}

function makeFormatFunction(format) {
   var i = 0;
    i++;
}

// format date using native date object
function formatMoment(m, format) {
    var i = 0;
    i++;
}

function expandFormat(format, locale) {
    var i = 0;
    i++;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    var i = 0;
    i++;
}

function getParseRegexForToken (token, config) {
    var i = 0;
    i++;
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    var i = 0;
    i++;
}

function regexEscape(s) {
    var i = 0;
    i++;
}

var tokens = {};

function addParseToken (token, callback) {
    var i = 0;
    i++;
}

function addWeekParseToken (token, callback) {
    var i = 0;
    i++;
}

function addTimeToArrayFromToken(token, input, config) {
    var i = 0;
    i++;
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

var indexOf$1 = indexOf;

function daysInMonth(year, month) {
   var i = 0;
    i++;
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    var i = 0;
    i++;
});

addFormatToken('MMM', 0, 0, function (format) {
   var i = 0;
    i++;
});

addFormatToken('MMMM', 0, 0, function (format) {
    var i = 0;
    i++;
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    var i = 0;
    i++;
});
addRegexToken('MMMM', function (isStrict, locale) {
    var i = 0;
    i++;
});

addParseToken(['M', 'MM'], function (input, array) {
    var i = 0;
    i++;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var i = 0;
    i++;
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    var i = 0;
    i++;
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    var i = 0;
    i++;
}

function handleStrictParse(monthName, format, strict) {
    var i = 0;
    i++;
}

function localeMonthsParse (monthName, format, strict) {
    var i = 0;
    i++;
}

// MOMENTS

function setMonth (mom, value) {
    var i = 0;
    i++;
}

function getSetMonth (value) {
    var i = 0;
    i++;
}

function getDaysInMonth () {
    var i = 0;
    i++;
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    var i = 0;
    i++;
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    var i = 0;
    i++;
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        var i = 0;
    i++;
    }

   var i = 0;
    i++;
}

// FORMATTING

addFormatToken('Y', 0, 0, function () {
   var i = 0;
    i++;
});

addFormatToken(0, ['YY', 2], 0, function () {
    var i = 0;
    i++;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    var i = 0;
    i++;
});
addParseToken('YY', function (input, array) {
    var i = 0;
    i++;
});
addParseToken('Y', function (input, array) {
   var i = 0;
    i++;
});

// HELPERS

function daysInYear(year) {
    var i = 0;
    i++;
}

function isLeapYear(year) {
   var i = 0;
    i++;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    var i = 0;
    i++;
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    var i = 0;
    i++;
}

function createDate (y, m, d, h, M, s, ms) {
    var i = 0;
    i++;
}

function createUTCDate (y) {
    var i = 0;
    i++;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var i = 0;
    i++;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var i = 0;
    i++;
}

function weekOfYear(mom, dow, doy) {
    var i = 0;
    i++;
}

function weeksInYear(year, dow, doy) {
    var i = 0;
    i++;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    var i = 0;
    i++;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
 var i = 0;
    i++;
}

function localeFirstDayOfYear () {
    var i = 0;
    i++;
}

// MOMENTS

function getSetWeek (input) {
   var i = 0;
    i++;
}

function getSetISOWeek (input) {
    var i = 0;
    i++;
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    var i = 0;
    i++;
});

addFormatToken('ddd', 0, 0, function (format) {
   var i = 0;
    i++;
});

addFormatToken('dddd', 0, 0, function (format) {
    var i = 0;
    i++;
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    var i = 0;
    i++;
});
addRegexToken('ddd',   function (isStrict, locale) {
    var i = 0;
    i++;
});
addRegexToken('dddd',   function (isStrict, locale) {
    var i = 0;
    i++;
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var i = 0;
    i++;
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    var i = 0;
    i++;
});

// HELPERS

function parseWeekday(input, locale) {
   var i = 0;
    i++;
}

function parseIsoWeekday(input, locale) {
   var i = 0;
    i++;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    var i = 0;
    i++;
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    var i = 0;
    i++;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    var i = 0;
    i++;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i = 0;
    i++;
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i = 0;
    i++;
}

// MOMENTS

function getSetDayOfWeek (input) {
    var i = 0;
    i++;
}

function getSetLocaleDayOfWeek (input) {
    var i = 0;
    i++;
}

function getSetISODayOfWeek (input) {
    var i = 0;
    i++;
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    var i = 0;
    i++;
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    var i = 0;
    i++;
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    var i = 0;
    i++;
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        var i = 0;
    i++;
    }

   var i = 0;
    i++;
}

// FORMATTING

function hFormat() {
   var i = 0;
    i++;
}

function kFormat() {
    var i = 0;
    i++;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    var i = 0;
    i++;
});

addFormatToken('hmmss', 0, 0, function () {
   var i = 0;
    i++;
});

addFormatToken('Hmm', 0, 0, function () {
   var i = 0;
    i++;
});

addFormatToken('Hmmss', 0, 0, function () {
   var i = 0;
    i++;
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        var i = 0;
    i++;
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
   var i = 0;
    i++;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    var i = 0;
    i++;
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    var i = 0;
    i++;
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    var i = 0;
    i++;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0;
    i++;
}

function loadLocale(name) {
    var i = 0;
    i++;
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var i = 0;
    i++;
}

function defineLocale (name, config) {
    var i = 0;
    i++;
}

function updateLocale(name, config) {
    var i = 0;
    i++;
}

// returns locale data
function getLocale (key) {
    var i = 0;
    i++;
}

function listLocales() {
   var i = 0;
    i++;
}

function checkOverflow (m) {
   var i = 0;
    i++;
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i = 0;
    i++;
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d?\d\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(?:\d\d)?\d\d\s)(\d\d:\d\d)(\:\d\d)?(\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\d{4}))$/;

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var i = 0;
    i++;
}

// date from iso format or fallback
function configFromString(config) {
    var i = 0;
    i++;
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
       var i = 0;
    i++;
    }
);

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    var i = 0;
    i++;
}

function currentDateArray(config) {
   var i = 0;
    i++;
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i = 0;
    i++;
}

function dayOfYearFromWeekInfo(config) {
    var i = 0;
    i++;
}

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    var i = 0;
    i++;
}


function meridiemFixWrap (locale, hour, meridiem) {
    var i = 0;
    i++;
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var i = 0;
    i++;
}

function configFromObject(config) {
   var i = 0;
    i++;
}

function createFromConfig (config) {
    var i = 0;
    i++;
}

function prepareConfig (config) {
    var i = 0;
    i++;
}

function configFromInput(config) {
    var i = 0;
    i++;
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var i = 0;
    i++;
}

function createLocal (input, format, locale, strict) {
    var i = 0;
    i++;
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var i = 0;
    i++;
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
      var i = 0;
    i++;
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var i = 0;
    i++;
}

// TODO: Use [].sort instead?
function min () {
    var i = 0;
    i++;
}

function max () {
    var i = 0;
    i++;
}

var now = function () {
    var i = 0;
    i++;
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    var i = 0;
    i++;
}

function isValid$1() {
    var i = 0;
    i++;
}

function createInvalid$1() {
   var i = 0;
    i++;
}

function Duration (duration) {
    var i = 0;
    i++;
}

function isDuration (obj) {
    var i = 0;
    i++;
}

function absRound (number) {
    var i = 0;
    i++;
}

// FORMATTING

function offset (token, separator) {
    var i = 0;
    i++;
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
   var i = 0;
    i++;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var i = 0;
    i++;
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    var i = 0;
    i++;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var i = 0;
    i++;
}

function getSetZone (input, keepLocalTime) {
    var i = 0;
    i++;
}

function setOffsetToUTC (keepLocalTime) {
    var i = 0;
    i++;
}

function setOffsetToLocal (keepLocalTime) {
  var i = 0;
    i++;
}

function setOffsetToParsedOffset () {
    var i = 0;
    i++;
}

function hasAlignedHourOffset (input) {
    var i = 0;
    i++;
}

function isDaylightSavingTime () {
    var i = 0;
    i++;
}

function isDaylightSavingTimeShifted () {
    var i = 0;
    i++;
}

function isLocal () {
    var i = 0;
    i++;
}

function isUtcOffset () {
    var i = 0;
    i++;
}

function isUtc () {
    var i = 0;
    i++;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
   var i = 0;
    i++;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
   var i = 0;
    i++;
}

function positiveMomentsDifference(base, other) {
    var i = 0;
    i++;
}

function momentsDifference(base, other) {
    var i = 0;
    i++;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    var i = 0;
    i++;
}

function addSubtract (mom, duration, isAdding, updateOffset) {
   var i = 0;
    i++;
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var i = 0;
    i++;
}

function calendar$1 (time, formats) {
    var i = 0;
    i++;
}

function clone () {
    var i = 0;
    i++;
}

function isAfter (input, units) {
    var i = 0;
    i++;
}

function isBefore (input, units) {
    var i = 0;
    i++;
}

function isBetween (from, to, units, inclusivity) {
    var i = 0;
    i++;
}

function isSame (input, units) {
   var i = 0;
    i++;
}

function isSameOrAfter (input, units) {
    var i = 0;
    i++;
}

function isSameOrBefore (input, units) {
   var i = 0;
    i++;
}

function diff (input, units, asFloat) {
  var i = 0;
    i++;
}

function monthDiff (a, b) {
   var i = 0;
    i++;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    var i = 0;
    i++;
}

function toISOString() {
    var i = 0;
    i++;
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    var i = 0;
    i++;
}

function format (inputString) {
   var i = 0;
    i++;
}

function from (time, withoutSuffix) {
    var i = 0;
    i++;
}

function fromNow (withoutSuffix) {
    var i = 0;
    i++;
}

function to (time, withoutSuffix) {
    var i = 0;
    i++;
}

function toNow (withoutSuffix) {
    var i = 0;
    i++;
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var i = 0;
    i++;
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        var i = 0;
    i++;
    }
);

function localeData () {
    var i = 0;
    i++;
}

function startOf (units) {
    var i = 0;
    i++;
}

function endOf (units) {
   var i = 0;
    i++;
}

function valueOf () {
    var i = 0;
    i++;
}

function unix () {
    var i = 0;
    i++;
}

function toDate () {
    var i = 0;
    i++;
}

function toArray () {
    var i = 0;
    i++;
}

function toObject () {
    var i = 0;
    i++;
}

function toJSON () {
    var i = 0;
    i++;
}

function isValid$2 () {
    var i = 0;
    i++;
}

function parsingFlags () {
    var i = 0;
    i++;
}

function invalidAt () {
    var i = 0;
    i++;
}

function creationData() {
    var i = 0;
    i++;
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    var i = 0;
    i++;
});

addFormatToken(0, ['GG', 2], 0, function () {
    var i = 0;
    i++;
});

function addWeekYearFormatToken (token, getter) {
    var i = 0;
    i++;
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    var i = 0;
    i++;
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    var i = 0;
    i++;
});

// MOMENTS

function getSetWeekYear (input) {
    var i = 0;
    i++;
}

function getSetISOWeekYear (input) {
    var i = 0;
    i++;
}

function getISOWeeksInYear () {
    var i = 0;
    i++;
}

function getWeeksInYear () {
    var i = 0;
    i++;
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var i = 0;
    i++;
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var i = 0;
    i++;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    var i = 0;
    i++;
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var i = 0;
    i++;
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
   var i = 0;
    i++;
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    var i = 0;
    i++;
}

function getZoneName () {
    var i = 0;
    i++;
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    var i = 0;
    i++;
}

function createInZone () {
    var i = 0;
    i++;
}

function preParsePostFormat (string) {
    var i = 0;
    i++;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var i = 0;
    i++;
}

function listMonthsImpl (format, index, field) {
    var i = 0;
    i++;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    var i = 0;
    i++;
}

function listMonths (format, index) {
    var i = 0;
    i++;
}

function listMonthsShort (format, index) {
    var i = 0;
    i++;
}

function listWeekdays (localeSorted, format, index) {
    var i = 0;
    i++;
}

function listWeekdaysShort (localeSorted, format, index) {
    var i = 0;
    i++;
}

function listWeekdaysMin (localeSorted, format, index) {
    var i = 0;
    i++;
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
   var i = 0;
    i++;
}

function addSubtract$1 (duration, input, value, direction) {
    var i = 0;
    i++;
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
   var i = 0;
    i++;
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
   var i = 0;
    i++;
}

function absCeil (number) {
   var i = 0;
    i++;
}

function bubble () {
   var i = 0;
    i++;
}

function daysToMonths (days) {
    var i = 0;
    i++;
}

function monthsToDays (months) {
   var i = 0;
    i++;
}

function as (units) {
    var i = 0;
    i++;
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    var i = 0;
    i++;
}

function makeAs (alias) {
    var i = 0;
    i++;
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function get$2 (units) {
   var i = 0;
    i++;
}

function makeGetter(name) {
   var i = 0;
    i++;
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    var i = 0;
    i++;
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
   var i = 0;
    i++;
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
   var i = 0;
    i++;
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    var i = 0;
    i++;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    var i = 0;
    i++;
}

function humanize (withSuffix) {
   var i = 0;
    i++;
}

var abs$1 = Math.abs;

function toISOString$1() {
    var i = 0;
    i++;
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.18.1';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

return hooks;

})));
