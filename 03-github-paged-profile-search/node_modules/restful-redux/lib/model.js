'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Return the model specific utility object
 * @param {object} modelOrDomain: the model object or entityType state object (if model `id` is provided)
 * @param {string} id: the model id if `modelOrDomain` represents the entityType state object
 */

var NO_ID = '_noid_';

var Model = function () {
  function Model(options, value) {
    _classCallCheck(this, Model);

    var entities = void 0;
    var id = void 0;
    var entityType = void 0;
    var meta = void 0;
    if (value) {
      // (id, value)
      id = determineId(options);
      options = undefined;
      meta = value._meta;
      options = {};
    } else {
      // (options)
      id = determineId(options.id);
      entities = options.entities;
      if (entities) {
        // allow for root state to be passed
        entities = entities.entities || entities;
      }
      entityType = options.entityType;
      value = deepValue(entities, [entityType, id]);
      meta = deepValue(entities, ['_meta', entityType, id]);
    }

    this.id = id;
    this._entities = entities;
    this._value = value;
    this._options = options;
    this._meta = meta || {};
    this._metadata = this._meta.data || {};
    this._fetchedInfo = this._meta.fetched ? this._meta.fetched : this._value ? { type: 'set' } : false;
  }

  _createClass(Model, [{
    key: 'data',
    value: function data() {
      return this._metadata;
    }

    /**
     * Return the (optionally formatted) model data
     */

  }, {
    key: 'value',
    value: function value() {
      if (!this._formattedValue) {
        this._formatted = true;
        var options = this._options;
        if (options.schema && options.denormalize) {
          this._formattedValue = options.denormalize(this._value, this._entities, options.schema);
        } else {
          var formatter = options.formatter;
          this._formattedValue = formatter ? formatter(options) : this._value;
        }
      }
      return this._formattedValue;
    }

    /**
     * Return true if the model has been fetched
     */

  }, {
    key: 'wasFetched',
    value: function wasFetched() {
      return this._fetchedInfo;
    }
  }, {
    key: 'canBeFetched',
    value: function canBeFetched() {
      return !(this._meta.fetchPending || this._meta.fetchError || this._meta.fetched || this.value());
    }

    /**
     * Return a boolean indicating if a model fetch is currently in progress
     */

  }, {
    key: 'isFetchPending',
    value: function isFetchPending() {
      return !!this._meta.fetchPending;
    }

    /**
     * Return a fetch error if one was encountered
     */

  }, {
    key: 'fetchError',
    value: function fetchError() {
      return this._meta.fetchError;
    }

    /**
     * Return a boolean indicating if a model fetch is currently in progress
     * @param {string} id: optinal identifier to see if a specific action is currently in progress
     */

  }, {
    key: 'isActionPending',
    value: function isActionPending(actionId) {
      var meta = this._meta;
      if (meta.actionPending) {
        return actionId ? meta.actionId === actionId : meta.actionId || true;
      }
      return false;
    }

    /**
     * Return true if either a fetch or action is pending
     */

  }, {
    key: 'isPending',
    value: function isPending(id) {
      return this.isFetchPending() || this.isActionPending(id);
    }

    /**
     * If an action was performed and successful, return { id, success, error }.  `success` and `error` will be mutually exclusive and will
     * represent the XHR response payload
     * @paramm {string} id: optional action id to only return true if a specific action was performed
     */

  }, {
    key: 'wasActionPerformed',
    value: function wasActionPerformed(id) {
      var meta = this._meta;
      if (!meta.actionPending && meta.actionId && (!id || id === meta.actionId)) {
        return {
          id: meta.actionId,
          success: meta.actionResponse,
          error: meta.actionError
        };
      }
    }
  }]);

  return Model;
}();

exports.default = Model;


Model.fromCache = function (options, cache) {
  var id = determineId(options.id);
  var entityType = options.entityType;
  var ModelClass = options.modelClass || Model;
  var entities = options.entities || {};
  // allow for root state to be provided
  entities = entities.entities || entities;
  var cachedEntities = cache[entityType] = cache[entityType] || {};
  var cachedMeta = cache._meta = cache._meta || {};
  var cachedModels = cachedEntities.__models = cachedEntities.__models || {};

  var cachedModel = cachedModels[id];
  var cachedData = getMetaAndValue(id, cache, entityType);
  var checkData = getMetaAndValue(id, entities, entityType);
  if (!cachedModel || cachedData.meta !== checkData.meta || cachedData.value !== checkData.value) {
    // we need to cache and return a new model
    cachedEntities[id] = checkData.value;
    var cachedMetaEntity = cachedMeta[entityType] = cachedMeta[entityType] || {};
    cachedMetaEntity[id] = checkData.meta;
    cachedModel = new ModelClass(options);
    cachedModels[id] = cachedModel;
  }
  return cachedModel;
};

function determineId(id) {
  return id === false ? NO_ID : id;
}

function getMetaAndValue(id, entities, entityType) {
  return {
    meta: deepValue(entities, ['_meta', entityType, id]) || null,
    value: deepValue(entities, [entityType, id]) || null
  };
}

function deepValue(parent, parts) {
  for (var i = 0; i < parts.length && parent; i++) {
    parent = parent[parts[i]];
  }
  return parent;
}