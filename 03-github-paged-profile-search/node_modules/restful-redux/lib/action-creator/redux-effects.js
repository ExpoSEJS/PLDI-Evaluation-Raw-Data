'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (options) {
  (0, _commonUtil.checkRequiredOptions)(['actionPrefix', 'entityType'], options);

  var actionPrefix = options.actionPrefix,
      entityType = options.entityType,
      normalize = options.normalize,
      debug = options.debug;

  var log = (0, _commonUtil.logger)('action-creator-redux-effects "' + entityType + '"');

  // return a callback handler which includes the provided id in the payload as a top level attribute
  function asyncResponseAction(_ref) {
    var fetchOrAction = _ref.fetchOrAction,
        type = _ref.type,
        id = _ref.id,
        actionId = _ref.actionId,
        replaceModel = _ref.replaceModel,
        isDelete = _ref.isDelete,
        schema = _ref.schema,
        resolver = _ref.resolver,
        formatter = _ref.formatter,
        reduxAction = _ref.reduxAction,
        clearAfter = _ref.clearAfter;

    return function (response) {
      // response is assumed to be in [normalize](https://github.com/paularmstrong/normalize) format of
      // {result: _id_, entities: {_entityType_: {_id_: ...}}}
      var payload = response.value;
      if (type === SUCCESS) {
        if (!actionId || replaceModel) {
          if (formatter) {
            payload = formatter(payload, id, entityType);
          }
          if (schema && normalize) {
            payload = Object.assign(normalize(payload.result || payload, schema), {
              id: payload.id,
              data: payload.data
            });
          } else if (!formatter) {
            payload = defaultFormat(payload, id, entityType);
          }
        } else {
          payload = {
            id: id,
            response: formatter ? formatter(response.value, id, actionId, entityType) : response.value
          };
        }
      } else {
        payload = { id: id, response: response };
      }
      if (actionId) {
        payload.actionId = actionId;
      }
      if (isDelete) {
        payload.delete = true;
      }

      var actionType = actionPrefix + '_' + fetchOrAction + '_' + type;
      var action = createAction(actionType, payload);
      var genericAction = createAction(fetchOrAction + '_' + type, payload);

      if (debug) {
        log('triggering ' + actionType + ' with ', action);
      }

      var rtn = [genericAction, action, function (dispatch) {
        if (resolver) {
          resolver(payload);
        }
        if (reduxAction) {
          dispatch(reduxAction);
        }
      }];

      if (clearAfter) {
        // requires `redux-thunk`
        rtn.push(function (dispatch) {
          setTimeout(function () {
            if (debug) {
              log('action timeout ' + entityType + ':' + id);
            }
            dispatch(asyncResponseAction({
              entityType: entityType,
              fetchOrAction: fetchOrAction,
              type: 'CLEAR',
              id: id
            }));
          }, clearAfter);
        });
      }

      return rtn;
    };
  }

  var rtn = {
    /* return an action which will set meta data to be associated with a model */
    createModelDataAction: function createModelDataAction(id, data) {
      return {
        type: actionPrefix + '_DATA',
        payload: {
          id: id,
          data: data
        }
      };
    }
  };

  REST_METHODS.forEach(function (options) {
    /**
     * return the action to be dispatched when an XHR-based action should be taken on a model/REST document
     * - ACTION_SUCCESS_{entityType}: the data was retrieved successfully
     * - ACTION_ERROR_{entityType}: there was an error with the request
     * - ACTION_PENDING_{entityType}: an XHR request was submitted
     * parameters include
     * - entityType: the entityType key used for all of the event type values
     * - id: the model id (to be added to the payloads for the reducer)
     * - url: the endpoint URI
     * - payload: [effects-fetch payload](https://github.com/redux-effects/redux-effects-fetch#creating-a-user)
     * - clearAfter: clear the action results after N milliseconds (optional)
     */
    rtn['create' + options.name + 'Action'] = function (_ref2) {
      var id = _ref2.id,
          actionId = _ref2.actionId,
          url = _ref2.url,
          params = _ref2.params,
          schema = _ref2.schema,
          formatter = _ref2.formatter,
          replaceModel = _ref2.replaceModel,
          successAction = _ref2.successAction,
          errorAction = _ref2.errorAction,
          clearAfter = _ref2.clearAfter;

      if (id === false) {
        id = NO_ID;
      }
      var fetchOrAction = options.fetchOrAction || ACTION;
      params = Object.assign({}, params, {
        method: options.method
      });

      var resolve = void 0,
          reject = void 0,
          promise = void 0;
      if (typeof Promise !== 'undefined') {
        promise = new Promise(function (_resolve, _reject) {
          resolve = function resolve(payload) {
            _resolve(payload);
          };
          reject = _reject;
        });
      }

      var pendingAction = createPendingAction(actionPrefix, id, actionId);
      var fetchAction = fetch(url, params);
      var composedAction = bind(fetchAction, asyncResponseAction({
        entityType: entityType,
        fetchOrAction: fetchOrAction,
        type: SUCCESS,
        id: id,
        actionId: actionId,
        replaceModel: replaceModel,
        isDelete: options.isDelete,
        schema: schema,
        formatter: formatter,
        resolver: resolve,
        reduxAction: successAction,
        clearAfter: clearAfter
      }), asyncResponseAction({
        entityType: entityType,
        fetchOrAction: fetchOrAction,
        type: ERROR,
        id: id,
        actionId: actionId,
        formatter: formatter,
        resolver: reject,
        reduxAction: errorAction,
        clearAfter: clearAfter
      }));

      var rtn = [composedAction, pendingAction];
      rtn.promise = promise;

      if (debug) {
        log('creating XHR action (' + id + ':' + actionId + ') with:\n\t', rtn);
      }
      return rtn;
    };
  });

  return rtn;
};

var _commonUtil = require('../common-util');

var NO_ID = '_noid_';

/**
 * IMPORTANT: Usage of [multi](https://github.com/ashaffer/redux-multi) middleware or a lib of similar nature is required
 */
var FETCH = 'FETCH';
var ACTION = 'ACTION';
var SUCCESS = 'SUCCESS';
var ERROR = 'ERROR';

var REST_METHODS = [{
  name: 'Fetch',
  method: 'GET',
  fetchOrAction: FETCH
}, {
  name: 'Get',
  method: 'GET',
  fetchOrAction: FETCH
}, {
  name: 'Delete',
  method: 'DELETE',
  isDelete: true
}, {
  name: 'Put',
  method: 'PUT'
}, {
  name: 'Patch',
  method: 'PATCH'
}, {
  name: 'Delete',
  method: 'DELETE'
}, {
  name: 'Post',
  method: 'POST'
}];

// create a dispatchable action that represents a pending model/REST document action
function createPendingAction(actionPrefix, id, actionId) {
  var type = actionId ? ACTION : FETCH;
  var payload = { id: id };
  if (actionId) {
    payload.actionId = actionId;
  }
  return createAction(actionPrefix + '_' + type + '_PENDING', payload);
}

// return an action using the given type and payload
function createAction(type, response) {
  return {
    type: type,
    payload: response
  };
}

// duplicate a little redix-effects/redux-effects-fetch/redux-actions code so this lib is not dependant on either lib
var EFFECT_COMPOSE = 'EFFECT_COMPOSE';
var EFFECT_FETCH = 'EFFECT_FETCH';

function bind(action) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return {
    type: EFFECT_COMPOSE,
    payload: action,
    meta: {
      steps: [args]
    }
  };
}

function fetch() {
  var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return {
    type: EFFECT_FETCH,
    payload: {
      url: url,
      params: params
    }
  };
}

// // {result: _id_, entities: {_entityType: {_id_: ...
function defaultFormat(value, id, entityType) {
  var rtn = {
    result: id,
    entities: {}
  };
  var entityTypeData = rtn.entities[entityType] = {};
  entityTypeData[id] = value;
  return rtn;
}