// Compiled by ClojureScript 1.7.170 {:static-fns true, :optimize-constants true, :target :nodejs}
goog.provide('cljs.tools.cli');
goog.require('cljs.core');
goog.require('clojure.string');
goog.require('goog.string.format');
goog.require('goog.string');
/**
 * Reduce arguments sequence into [opt-type opt ?optarg?] vectors and a vector
 *   of remaining arguments. Returns as [option-tokens remaining-args].
 * 
 *   Expands clumped short options like "-abc" into:
 *   [[:short-opt "-a"] [:short-opt "-b"] [:short-opt "-c"]]
 * 
 *   If "-b" were in the set of options that require arguments, "-abc" would
 *   then be interpreted as: [[:short-opt "-a"] [:short-opt "-b" "c"]]
 * 
 *   Long options with `=` are always parsed as option + optarg, even if nothing
 *   follows the `=` sign.
 * 
 *   If the :in-order flag is true, the first non-option, non-optarg argument
 *   stops options processing. This is useful for handling subcommand options.
 */
cljs.tools.cli.tokenize_args = (function cljs$tools$cli$tokenize_args(){
var argseq__1588__auto__ = ((((2) < arguments.length))?(new cljs.core.IndexedSeq(Array.prototype.slice.call(arguments,(2)),(0))):null);
return cljs.tools.cli.tokenize_args.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__1588__auto__);
});

cljs.tools.cli.tokenize_args.cljs$core$IFn$_invoke$arity$variadic = (function (required_set,args,options){
var map__5490 = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,options);
var map__5490__$1 = ((cljs.core.seq_QMARK_(map__5490))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__5490):map__5490);
var in_order = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__5490__$1,cljs.core.cst$kw$in_DASH_order);
var opts = cljs.core.PersistentVector.EMPTY;
var argv = cljs.core.PersistentVector.EMPTY;
var G__5492 = args;
var vec__5493 = G__5492;
var car = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5493,(0),null);
var cdr = cljs.core.nthnext(vec__5493,(1));
var opts__$1 = opts;
var argv__$1 = argv;
var G__5492__$1 = G__5492;
while(true){
var opts__$2 = opts__$1;
var argv__$2 = argv__$1;
var vec__5494 = G__5492__$1;
var car__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5494,(0),null);
var cdr__$1 = cljs.core.nthnext(vec__5494,(1));
if(cljs.core.truth_(car__$1)){
var pred__5495 = cljs.core.re_seq;
var expr__5496 = car__$1;
if(cljs.core.truth_((pred__5495.cljs$core$IFn$_invoke$arity$2 ? pred__5495.cljs$core$IFn$_invoke$arity$2(/^--$/,expr__5496) : pred__5495.call(null,/^--$/,expr__5496)))){
var G__5504 = opts__$2;
var G__5505 = cljs.core.into.cljs$core$IFn$_invoke$arity$2(argv__$2,cdr__$1);
var G__5506 = cljs.core.PersistentVector.EMPTY;
opts__$1 = G__5504;
argv__$1 = G__5505;
G__5492__$1 = G__5506;
continue;
} else {
if(cljs.core.truth_((pred__5495.cljs$core$IFn$_invoke$arity$2 ? pred__5495.cljs$core$IFn$_invoke$arity$2(/^--\S+=/,expr__5496) : pred__5495.call(null,/^--\S+=/,expr__5496)))){
var G__5507 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(opts__$2,cljs.core.into.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$kw$long_DASH_opt], null),clojure.string.split.cljs$core$IFn$_invoke$arity$3(car__$1,/=/,(2))));
var G__5508 = argv__$2;
var G__5509 = cdr__$1;
opts__$1 = G__5507;
argv__$1 = G__5508;
G__5492__$1 = G__5509;
continue;
} else {
if(cljs.core.truth_((pred__5495.cljs$core$IFn$_invoke$arity$2 ? pred__5495.cljs$core$IFn$_invoke$arity$2(/^--/,expr__5496) : pred__5495.call(null,/^--/,expr__5496)))){
var vec__5498 = ((cljs.core.contains_QMARK_(required_set,car__$1))?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(cdr__$1),cljs.core.rest(cdr__$1)], null):new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [null,cdr__$1], null));
var optarg = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5498,(0),null);
var cdr__$2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5498,(1),null);
var G__5510 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(opts__$2,cljs.core.into.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$kw$long_DASH_opt,car__$1], null),(cljs.core.truth_(optarg)?new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [optarg], null):cljs.core.PersistentVector.EMPTY)));
var G__5511 = argv__$2;
var G__5512 = cdr__$2;
opts__$1 = G__5510;
argv__$1 = G__5511;
G__5492__$1 = G__5512;
continue;
} else {
if(cljs.core.truth_((pred__5495.cljs$core$IFn$_invoke$arity$2 ? pred__5495.cljs$core$IFn$_invoke$arity$2(/^-./,expr__5496) : pred__5495.call(null,/^-./,expr__5496)))){
var vec__5499 = (function (){var os = cljs.core.PersistentVector.EMPTY;
var G__5501 = cljs.core.rest(car__$1);
var vec__5502 = G__5501;
var c = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5502,(0),null);
var cs = cljs.core.nthnext(vec__5502,(1));
var os__$1 = os;
var G__5501__$1 = G__5501;
while(true){
var os__$2 = os__$1;
var vec__5503 = G__5501__$1;
var c__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5503,(0),null);
var cs__$1 = cljs.core.nthnext(vec__5503,(1));
var o = [cljs.core.str("-"),cljs.core.str(c__$1)].join('');
if(cljs.core.contains_QMARK_(required_set,o)){
if(cljs.core.seq(cs__$1)){
return new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.conj.cljs$core$IFn$_invoke$arity$2(os__$2,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$kw$short_DASH_opt,o,clojure.string.join.cljs$core$IFn$_invoke$arity$1(cs__$1)], null)),cdr__$1], null);
} else {
return new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.conj.cljs$core$IFn$_invoke$arity$2(os__$2,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$kw$short_DASH_opt,o,cljs.core.first(cdr__$1)], null)),cljs.core.rest(cdr__$1)], null);
}
} else {
if(cljs.core.seq(cs__$1)){
var G__5513 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(os__$2,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$kw$short_DASH_opt,o], null));
var G__5514 = cs__$1;
os__$1 = G__5513;
G__5501__$1 = G__5514;
continue;
} else {
return new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.conj.cljs$core$IFn$_invoke$arity$2(os__$2,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$kw$short_DASH_opt,o], null)),cdr__$1], null);
}
}
break;
}
})();
var os = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5499,(0),null);
var cdr__$2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5499,(1),null);
var G__5515 = cljs.core.into.cljs$core$IFn$_invoke$arity$2(opts__$2,os);
var G__5516 = argv__$2;
var G__5517 = cdr__$2;
opts__$1 = G__5515;
argv__$1 = G__5516;
G__5492__$1 = G__5517;
continue;
} else {
if(cljs.core.truth_(in_order)){
var G__5518 = opts__$2;
var G__5519 = cljs.core.into.cljs$core$IFn$_invoke$arity$2(argv__$2,cljs.core.cons(car__$1,cdr__$1));
var G__5520 = cljs.core.PersistentVector.EMPTY;
opts__$1 = G__5518;
argv__$1 = G__5519;
G__5492__$1 = G__5520;
continue;
} else {
var G__5521 = opts__$2;
var G__5522 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(argv__$2,car__$1);
var G__5523 = cdr__$1;
opts__$1 = G__5521;
argv__$1 = G__5522;
G__5492__$1 = G__5523;
continue;
}
}
}
}
}
} else {
return new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [opts__$2,argv__$2], null);
}
break;
}
});

cljs.tools.cli.tokenize_args.cljs$lang$maxFixedArity = (2);

cljs.tools.cli.tokenize_args.cljs$lang$applyTo = (function (seq5487){
var G__5488 = cljs.core.first(seq5487);
var seq5487__$1 = cljs.core.next(seq5487);
var G__5489 = cljs.core.first(seq5487__$1);
var seq5487__$2 = cljs.core.next(seq5487__$1);
return cljs.tools.cli.tokenize_args.cljs$core$IFn$_invoke$arity$variadic(G__5488,G__5489,seq5487__$2);
});
cljs.tools.cli.spec_keys = new cljs.core.PersistentVector(null, 12, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$kw$id,cljs.core.cst$kw$short_DASH_opt,cljs.core.cst$kw$long_DASH_opt,cljs.core.cst$kw$required,cljs.core.cst$kw$desc,cljs.core.cst$kw$default,cljs.core.cst$kw$default_DASH_desc,cljs.core.cst$kw$parse_DASH_fn,cljs.core.cst$kw$assoc_DASH_fn,cljs.core.cst$kw$validate_DASH_fn,cljs.core.cst$kw$validate_DASH_msg,cljs.core.cst$kw$missing], null);
/**
 * Select only known spec entries from map and warn the user about unknown
 * entries at development time.
 */
cljs.tools.cli.select_spec_keys = (function cljs$tools$cli$select_spec_keys(map){
var unknown_keys_5524 = cljs.core.keys(cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.dissoc,map,cljs.tools.cli.spec_keys));
if(cljs.core.seq(unknown_keys_5524)){
cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([[cljs.core.str("Warning: The following options to parse-opts are unrecognized: "),cljs.core.str(clojure.string.join.cljs$core$IFn$_invoke$arity$2(", ",unknown_keys_5524))].join('')], 0));
} else {
}

return cljs.core.select_keys(map,cljs.tools.cli.spec_keys);
});
cljs.tools.cli.compile_spec = (function cljs$tools$cli$compile_spec(spec){
var sopt_lopt_desc = cljs.core.take_while.cljs$core$IFn$_invoke$arity$2((function (p1__5525_SHARP_){
return (typeof p1__5525_SHARP_ === 'string') || ((p1__5525_SHARP_ == null));
}),spec);
var spec_map = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,cljs.core.drop.cljs$core$IFn$_invoke$arity$2(cljs.core.count(sopt_lopt_desc),spec));
var vec__5529 = sopt_lopt_desc;
var short_opt = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5529,(0),null);
var long_opt = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5529,(1),null);
var desc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5529,(2),null);
var long_opt__$1 = (function (){var or__548__auto__ = long_opt;
if(cljs.core.truth_(or__548__auto__)){
return or__548__auto__;
} else {
return cljs.core.cst$kw$long_DASH_opt.cljs$core$IFn$_invoke$arity$1(spec_map);
}
})();
var vec__5530 = (cljs.core.truth_(long_opt__$1)?cljs.core.rest(cljs.core.re_find(/^(--[^ =]+)(?:[ =](.*))?/,long_opt__$1)):null);
var long_opt__$2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5530,(0),null);
var req = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5530,(1),null);
var id = (cljs.core.truth_(long_opt__$2)?cljs.core.keyword.cljs$core$IFn$_invoke$arity$1(cljs.core.subs.cljs$core$IFn$_invoke$arity$2(long_opt__$2,(2))):null);
var validate = cljs.core.cst$kw$validate.cljs$core$IFn$_invoke$arity$1(spec_map);
var vec__5531 = ((cljs.core.seq(validate))?cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.map,cljs.core.vector,cljs.core.partition.cljs$core$IFn$_invoke$arity$4((2),(2),cljs.core.repeat.cljs$core$IFn$_invoke$arity$1(null),validate)):null);
var validate_fn = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5531,(0),null);
var validate_msg = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5531,(1),null);
return cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 7, [cljs.core.cst$kw$id,id,cljs.core.cst$kw$short_DASH_opt,short_opt,cljs.core.cst$kw$long_DASH_opt,long_opt__$2,cljs.core.cst$kw$required,req,cljs.core.cst$kw$desc,desc,cljs.core.cst$kw$validate_DASH_fn,validate_fn,cljs.core.cst$kw$validate_DASH_msg,validate_msg], null),cljs.tools.cli.select_spec_keys(cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(spec_map,cljs.core.cst$kw$validate))], 0));
});
cljs.tools.cli.distinct_QMARK__STAR_ = (function cljs$tools$cli$distinct_QMARK__STAR_(coll){
if(cljs.core.seq(coll)){
return cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.distinct_QMARK_,coll);
} else {
return true;
}
});
cljs.tools.cli.wrap_val = (function cljs$tools$cli$wrap_val(map,key){
if(cljs.core.contains_QMARK_(map,key)){
return cljs.core.update_in.cljs$core$IFn$_invoke$arity$3(map,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [key], null),(function (p1__5532_SHARP_){
if((p1__5532_SHARP_ == null)){
return null;
} else {
if(cljs.core.coll_QMARK_(p1__5532_SHARP_)){
return p1__5532_SHARP_;
} else {
return new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [p1__5532_SHARP_], null);

}
}
}));
} else {
return map;
}
});
/**
 * Map a sequence of option specification vectors to a sequence of:
 * 
 *   {:id           Keyword  ; :server
 * :short-opt    String   ; "-s"
 * :long-opt     String   ; "--server"
 * :required     String   ; "HOSTNAME"
 * :desc         String   ; "Remote server"
 * :default      Object   ; #<Inet4Address example.com/93.184.216.119>
 * :default-desc String   ; "example.com"
 * :parse-fn     IFn      ; #(InetAddress/getByName %)
 * :assoc-fn     IFn      ; assoc
 * :validate-fn  [IFn]    ; [#(instance? Inet4Address %)
 *                        ;  #(not (.isMulticastAddress %)]
 * :validate-msg [String] ; ["Must be an IPv4 host"
 *                        ;  "Must not be a multicast address"]
 * :missing      String   ; "server must be specified"
 * }
 * 
 *   :id defaults to the keywordized name of long-opt without leading dashes, but
 *   may be overridden in the option spec.
 * 
 *   The option spec entry `:validate [fn msg ...]` desugars into the two vector
 *   entries :validate-fn and :validate-msg. Multiple pairs of validation
 *   functions and error messages may be provided.
 * 
 *   A :default entry will not be included in the compiled spec unless specified.
 * 
 *   An option spec may also be passed as a map containing the entries above,
 *   in which case that subset of the map is transferred directly to the result
 *   vector.
 * 
 *   An assertion error is thrown if any :id values are unset, or if there exist
 *   any duplicate :id, :short-opt, or :long-opt values.
 */
cljs.tools.cli.compile_option_specs = (function cljs$tools$cli$compile_option_specs(option_specs){
var _PERCENT_ = cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (spec){
return cljs.tools.cli.wrap_val(cljs.tools.cli.wrap_val(((cljs.core.map_QMARK_(spec))?cljs.tools.cli.select_spec_keys(spec):cljs.tools.cli.compile_spec(spec)),cljs.core.cst$kw$validate_DASH_fn),cljs.core.cst$kw$validate_DASH_msg);
}),option_specs);
if(cljs.core.every_QMARK_(cljs.core.comp.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,cljs.core.cst$kw$id),_PERCENT_)){
} else {
throw (new Error([cljs.core.str("Assert failed: "),cljs.core.str(cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([cljs.core.list(cljs.core.cst$sym$every_QMARK_,cljs.core.list(cljs.core.cst$sym$comp,cljs.core.cst$sym$identity,cljs.core.cst$kw$id),cljs.core.cst$sym$_PERCENT_)], 0)))].join('')));
}

if(cljs.core.truth_(cljs.tools.cli.distinct_QMARK__STAR_(cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.cst$kw$id,cljs.core.filter.cljs$core$IFn$_invoke$arity$2(cljs.core.cst$kw$default,_PERCENT_))))){
} else {
throw (new Error([cljs.core.str("Assert failed: "),cljs.core.str(cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([cljs.core.list(cljs.core.cst$sym$distinct_QMARK__STAR_,cljs.core.list(cljs.core.cst$sym$map,cljs.core.cst$kw$id,cljs.core.list(cljs.core.cst$sym$filter,cljs.core.cst$kw$default,cljs.core.cst$sym$_PERCENT_)))], 0)))].join('')));
}

if(cljs.core.truth_(cljs.tools.cli.distinct_QMARK__STAR_(cljs.core.remove.cljs$core$IFn$_invoke$arity$2(cljs.core.nil_QMARK_,cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.cst$kw$short_DASH_opt,_PERCENT_))))){
} else {
throw (new Error([cljs.core.str("Assert failed: "),cljs.core.str(cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([cljs.core.list(cljs.core.cst$sym$distinct_QMARK__STAR_,cljs.core.list(cljs.core.cst$sym$remove,cljs.core.cst$sym$nil_QMARK_,cljs.core.list(cljs.core.cst$sym$map,cljs.core.cst$kw$short_DASH_opt,cljs.core.cst$sym$_PERCENT_)))], 0)))].join('')));
}

if(cljs.core.truth_(cljs.tools.cli.distinct_QMARK__STAR_(cljs.core.remove.cljs$core$IFn$_invoke$arity$2(cljs.core.nil_QMARK_,cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.cst$kw$long_DASH_opt,_PERCENT_))))){
} else {
throw (new Error([cljs.core.str("Assert failed: "),cljs.core.str(cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([cljs.core.list(cljs.core.cst$sym$distinct_QMARK__STAR_,cljs.core.list(cljs.core.cst$sym$remove,cljs.core.cst$sym$nil_QMARK_,cljs.core.list(cljs.core.cst$sym$map,cljs.core.cst$kw$long_DASH_opt,cljs.core.cst$sym$_PERCENT_)))], 0)))].join('')));
}

return _PERCENT_;
});
cljs.tools.cli.default_option_map = (function cljs$tools$cli$default_option_map(specs){
return cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (m,s){
if(cljs.core.contains_QMARK_(s,cljs.core.cst$kw$default)){
return cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,cljs.core.cst$kw$id.cljs$core$IFn$_invoke$arity$1(s),cljs.core.cst$kw$default.cljs$core$IFn$_invoke$arity$1(s));
} else {
return m;
}
}),cljs.core.PersistentArrayMap.EMPTY,specs);
});
/**
 * Given specs, returns a map of spec id to error message if missing.
 */
cljs.tools.cli.missing_errors = (function cljs$tools$cli$missing_errors(specs){
return cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (m,s){
if(cljs.core.truth_(cljs.core.cst$kw$missing.cljs$core$IFn$_invoke$arity$1(s))){
return cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,cljs.core.cst$kw$id.cljs$core$IFn$_invoke$arity$1(s),cljs.core.cst$kw$missing.cljs$core$IFn$_invoke$arity$1(s));
} else {
return m;
}
}),cljs.core.PersistentArrayMap.EMPTY,specs);
});
cljs.tools.cli.find_spec = (function cljs$tools$cli$find_spec(specs,opt_type,opt){
return cljs.core.first(cljs.core.filter.cljs$core$IFn$_invoke$arity$2((function (p1__5533_SHARP_){
return cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(opt,(opt_type.cljs$core$IFn$_invoke$arity$1 ? opt_type.cljs$core$IFn$_invoke$arity$1(p1__5533_SHARP_) : opt_type.call(null,p1__5533_SHARP_)));
}),specs));
});
cljs.tools.cli.pr_join = (function cljs$tools$cli$pr_join(){
var argseq__1588__auto__ = ((((0) < arguments.length))?(new cljs.core.IndexedSeq(Array.prototype.slice.call(arguments,(0)),(0))):null);
return cljs.tools.cli.pr_join.cljs$core$IFn$_invoke$arity$variadic(argseq__1588__auto__);
});

cljs.tools.cli.pr_join.cljs$core$IFn$_invoke$arity$variadic = (function (xs){
return cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([clojure.string.join.cljs$core$IFn$_invoke$arity$2(" ",xs)], 0));
});

cljs.tools.cli.pr_join.cljs$lang$maxFixedArity = (0);

cljs.tools.cli.pr_join.cljs$lang$applyTo = (function (seq5534){
return cljs.tools.cli.pr_join.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq5534));
});
cljs.tools.cli.missing_required_error = (function cljs$tools$cli$missing_required_error(opt,example_required){
return [cljs.core.str("Missing required argument for "),cljs.core.str(cljs.tools.cli.pr_join.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([opt,example_required], 0)))].join('');
});
cljs.tools.cli.parse_error = (function cljs$tools$cli$parse_error(opt,optarg,msg){
return [cljs.core.str("Error while parsing option "),cljs.core.str(cljs.tools.cli.pr_join.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([opt,optarg], 0))),cljs.core.str(": "),cljs.core.str(msg)].join('');
});
cljs.tools.cli.validation_error = (function cljs$tools$cli$validation_error(opt,optarg,msg){
return [cljs.core.str("Failed to validate "),cljs.core.str(cljs.tools.cli.pr_join.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([opt,optarg], 0))),cljs.core.str((cljs.core.truth_(msg)?[cljs.core.str(": "),cljs.core.str(msg)].join(''):""))].join('');
});
cljs.tools.cli.validate = (function cljs$tools$cli$validate(value,spec,opt,optarg){
var map__5554 = spec;
var map__5554__$1 = ((cljs.core.seq_QMARK_(map__5554))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__5554):map__5554);
var validate_fn = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__5554__$1,cljs.core.cst$kw$validate_DASH_fn);
var validate_msg = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__5554__$1,cljs.core.cst$kw$validate_DASH_msg);
var or__548__auto__ = (function (){var G__5566 = validate_fn;
var vec__5568 = G__5566;
var vfn = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5568,(0),null);
var vfns = cljs.core.nthnext(vec__5568,(1));
var G__5567 = validate_msg;
var vec__5569 = G__5567;
var msg = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5569,(0),null);
var msgs = cljs.core.nthnext(vec__5569,(1));
var G__5566__$1 = G__5566;
var G__5567__$1 = G__5567;
while(true){
var vec__5570 = G__5566__$1;
var vfn__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5570,(0),null);
var vfns__$1 = cljs.core.nthnext(vec__5570,(1));
var vec__5571 = G__5567__$1;
var msg__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5571,(0),null);
var msgs__$1 = cljs.core.nthnext(vec__5571,(1));
if(cljs.core.truth_(vfn__$1)){
if(cljs.core.truth_((function (){try{return (vfn__$1.cljs$core$IFn$_invoke$arity$1 ? vfn__$1.cljs$core$IFn$_invoke$arity$1(value) : vfn__$1.call(null,value));
}catch (e5572){if((e5572 instanceof Error)){
var e = e5572;
return null;
} else {
throw e5572;

}
}})())){
var G__5573 = vfns__$1;
var G__5574 = msgs__$1;
G__5566__$1 = G__5573;
G__5567__$1 = G__5574;
continue;
} else {
return new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$kw$cljs$tools$cli_SLASH_error,cljs.tools.cli.validation_error(opt,optarg,msg__$1)], null);
}
} else {
return null;
}
break;
}
})();
if(cljs.core.truth_(or__548__auto__)){
return or__548__auto__;
} else {
return new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [value,null], null);
}
});
cljs.tools.cli.parse_value = (function cljs$tools$cli$parse_value(value,spec,opt,optarg){
var map__5578 = spec;
var map__5578__$1 = ((cljs.core.seq_QMARK_(map__5578))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__5578):map__5578);
var parse_fn = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__5578__$1,cljs.core.cst$kw$parse_DASH_fn);
var vec__5579 = (cljs.core.truth_(parse_fn)?(function (){try{return new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(parse_fn.cljs$core$IFn$_invoke$arity$1 ? parse_fn.cljs$core$IFn$_invoke$arity$1(value) : parse_fn.call(null,value)),null], null);
}catch (e5580){if((e5580 instanceof Error)){
var e = e5580;
return new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [null,cljs.tools.cli.parse_error(opt,optarg,[cljs.core.str(e)].join(''))], null);
} else {
throw e5580;

}
}})():new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [value,null], null));
var value__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5579,(0),null);
var error = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5579,(1),null);
if(cljs.core.truth_(error)){
return new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$kw$cljs$tools$cli_SLASH_error,error], null);
} else {
return cljs.tools.cli.validate(value__$1,spec,opt,optarg);
}
});
cljs.tools.cli.parse_optarg = (function cljs$tools$cli$parse_optarg(spec,opt,optarg){
var map__5582 = spec;
var map__5582__$1 = ((cljs.core.seq_QMARK_(map__5582))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__5582):map__5582);
var required = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__5582__$1,cljs.core.cst$kw$required);
if(cljs.core.truth_((function (){var and__536__auto__ = required;
if(cljs.core.truth_(and__536__auto__)){
return (optarg == null);
} else {
return and__536__auto__;
}
})())){
return new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$kw$cljs$tools$cli_SLASH_error,cljs.tools.cli.missing_required_error(opt,required)], null);
} else {
return cljs.tools.cli.parse_value((cljs.core.truth_(required)?optarg:true),spec,opt,optarg);
}
});
/**
 * Reduce sequence of [opt-type opt ?optarg?] tokens into a map of
 *   {option-id value} merged over the default values in the option
 *   specifications.
 * 
 *   If the :no-defaults flag is true, only options specified in the tokens are
 *   included in the option-map.
 * 
 *   Unknown options, missing options, missing required arguments, option
 *   argument parsing exceptions, and validation failures are collected into
 *   a vector of error message strings.
 * 
 *   If the :strict flag is true, required arguments that match other options
 *   are treated as missing, instead of a literal value beginning with - or --.
 * 
 *   Returns [option-map error-messages-vector].
 */
cljs.tools.cli.parse_option_tokens = (function cljs$tools$cli$parse_option_tokens(){
var argseq__1588__auto__ = ((((2) < arguments.length))?(new cljs.core.IndexedSeq(Array.prototype.slice.call(arguments,(2)),(0))):null);
return cljs.tools.cli.parse_option_tokens.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__1588__auto__);
});

cljs.tools.cli.parse_option_tokens.cljs$core$IFn$_invoke$arity$variadic = (function (specs,tokens,options){
var map__5588 = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,options);
var map__5588__$1 = ((cljs.core.seq_QMARK_(map__5588))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__5588):map__5588);
var no_defaults = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__5588__$1,cljs.core.cst$kw$no_DASH_defaults);
var strict = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__5588__$1,cljs.core.cst$kw$strict);
var defaults = cljs.tools.cli.default_option_map(specs);
var requireds = cljs.tools.cli.missing_errors(specs);
return ((function (map__5588,map__5588__$1,no_defaults,strict,defaults,requireds){
return (function (p1__5584_SHARP_){
var vec__5589 = p1__5584_SHARP_;
var m = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5589,(0),null);
var ids = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5589,(1),null);
var errors = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5589,(2),null);
if(cljs.core.truth_(no_defaults)){
return new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.select_keys(m,ids),errors], null);
} else {
return new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [m,errors], null);
}
});})(map__5588,map__5588__$1,no_defaults,strict,defaults,requireds))
.call(null,((function (map__5588,map__5588__$1,no_defaults,strict,defaults,requireds){
return (function (p1__5583_SHARP_){
return cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (map__5588,map__5588__$1,no_defaults,strict,defaults,requireds){
return (function (p__5590,p__5591){
var vec__5592 = p__5590;
var m = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5592,(0),null);
var ids = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5592,(1),null);
var errors = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5592,(2),null);
var vec__5593 = p__5591;
var id = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5593,(0),null);
var error = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5593,(1),null);
if(cljs.core.contains_QMARK_(m,id)){
return new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [m,ids,errors], null);
} else {
return new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [m,ids,cljs.core.conj.cljs$core$IFn$_invoke$arity$2(errors,error)], null);
}
});})(map__5588,map__5588__$1,no_defaults,strict,defaults,requireds))
,p1__5583_SHARP_,requireds);
});})(map__5588,map__5588__$1,no_defaults,strict,defaults,requireds))
.call(null,cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (map__5588,map__5588__$1,no_defaults,strict,defaults,requireds){
return (function (p__5594,p__5595){
var vec__5596 = p__5594;
var m = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5596,(0),null);
var ids = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5596,(1),null);
var errors = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5596,(2),null);
var vec__5597 = p__5595;
var opt_type = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5597,(0),null);
var opt = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5597,(1),null);
var optarg = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5597,(2),null);
var temp__4423__auto__ = cljs.tools.cli.find_spec(specs,opt_type,opt);
if(cljs.core.truth_(temp__4423__auto__)){
var spec = temp__4423__auto__;
var vec__5598 = cljs.tools.cli.parse_optarg(spec,opt,optarg);
var value = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5598,(0),null);
var error = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5598,(1),null);
var id = cljs.core.cst$kw$id.cljs$core$IFn$_invoke$arity$1(spec);
if(!(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(value,cljs.core.cst$kw$cljs$tools$cli_SLASH_error))){
var temp__4423__auto____$1 = (function (){var and__536__auto__ = strict;
if(cljs.core.truth_(and__536__auto__)){
var or__548__auto__ = cljs.tools.cli.find_spec(specs,cljs.core.cst$kw$short_DASH_opt,optarg);
if(cljs.core.truth_(or__548__auto__)){
return or__548__auto__;
} else {
return cljs.tools.cli.find_spec(specs,cljs.core.cst$kw$long_DASH_opt,optarg);
}
} else {
return and__536__auto__;
}
})();
if(cljs.core.truth_(temp__4423__auto____$1)){
var matched_spec = temp__4423__auto____$1;
return new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [m,ids,cljs.core.conj.cljs$core$IFn$_invoke$arity$2(errors,cljs.tools.cli.missing_required_error(opt,cljs.core.cst$kw$required.cljs$core$IFn$_invoke$arity$1(spec)))], null);
} else {
return new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$kw$assoc_DASH_fn.cljs$core$IFn$_invoke$arity$2(spec,cljs.core.assoc).call(null,m,id,value),cljs.core.conj.cljs$core$IFn$_invoke$arity$2(ids,id),errors], null);
}
} else {
return new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [m,ids,cljs.core.conj.cljs$core$IFn$_invoke$arity$2(errors,error)], null);
}
} else {
return new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [m,ids,cljs.core.conj.cljs$core$IFn$_invoke$arity$2(errors,[cljs.core.str("Unknown option: "),cljs.core.str(cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([opt], 0)))].join(''))], null);
}
});})(map__5588,map__5588__$1,no_defaults,strict,defaults,requireds))
,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [defaults,cljs.core.PersistentVector.EMPTY,cljs.core.PersistentVector.EMPTY], null),tokens)));
});

cljs.tools.cli.parse_option_tokens.cljs$lang$maxFixedArity = (2);

cljs.tools.cli.parse_option_tokens.cljs$lang$applyTo = (function (seq5585){
var G__5586 = cljs.core.first(seq5585);
var seq5585__$1 = cljs.core.next(seq5585);
var G__5587 = cljs.core.first(seq5585__$1);
var seq5585__$2 = cljs.core.next(seq5585__$1);
return cljs.tools.cli.parse_option_tokens.cljs$core$IFn$_invoke$arity$variadic(G__5586,G__5587,seq5585__$2);
});
cljs.tools.cli.make_summary_parts = (function cljs$tools$cli$make_summary_parts(show_defaults_QMARK_,specs){
var map__5601 = specs;
var map__5601__$1 = ((cljs.core.seq_QMARK_(map__5601))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__5601):map__5601);
var short_opt = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__5601__$1,cljs.core.cst$kw$short_DASH_opt);
var long_opt = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__5601__$1,cljs.core.cst$kw$long_DASH_opt);
var required = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__5601__$1,cljs.core.cst$kw$required);
var default$ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__5601__$1,cljs.core.cst$kw$default);
var default_desc = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__5601__$1,cljs.core.cst$kw$default_DASH_desc);
var desc = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__5601__$1,cljs.core.cst$kw$desc);
var opt = (cljs.core.truth_((function (){var and__536__auto__ = short_opt;
if(cljs.core.truth_(and__536__auto__)){
return long_opt;
} else {
return and__536__auto__;
}
})())?[cljs.core.str(short_opt),cljs.core.str(", "),cljs.core.str(long_opt)].join(''):(cljs.core.truth_(long_opt)?[cljs.core.str("    "),cljs.core.str(long_opt)].join(''):(cljs.core.truth_(short_opt)?short_opt:null)));
var vec__5602 = (cljs.core.truth_(required)?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [[cljs.core.str(opt),cljs.core.str(" "),cljs.core.str(required)].join(''),(function (){var or__548__auto__ = default_desc;
if(cljs.core.truth_(or__548__auto__)){
return or__548__auto__;
} else {
return [cljs.core.str(default$)].join('');
}
})()], null):new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [opt,""], null));
var opt__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5602,(0),null);
var dd = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5602,(1),null);
if(cljs.core.truth_(show_defaults_QMARK_)){
return new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [opt__$1,dd,(function (){var or__548__auto__ = desc;
if(cljs.core.truth_(or__548__auto__)){
return or__548__auto__;
} else {
return "";
}
})()], null);
} else {
return new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [opt__$1,(function (){var or__548__auto__ = desc;
if(cljs.core.truth_(or__548__auto__)){
return or__548__auto__;
} else {
return "";
}
})()], null);
}
});
cljs.tools.cli.format_lines = (function cljs$tools$cli$format_lines(lens,parts){
var fmt = (function (){var G__5605 = cljs.core.count(lens);
switch (G__5605) {
case (2):
return "  %%-%ds  %%-%ds";

break;
case (3):
return "  %%-%ds  %%-%ds  %%-%ds";

break;
default:
throw (new Error([cljs.core.str("No matching clause: "),cljs.core.str(cljs.core.count(lens))].join('')));

}
})();
var fmt__$1 = cljs.core.apply.cljs$core$IFn$_invoke$arity$3(goog.string.format,fmt,lens);
return cljs.core.map.cljs$core$IFn$_invoke$arity$2(((function (fmt,fmt__$1){
return (function (p1__5603_SHARP_){
return clojure.string.trimr(cljs.core.apply.cljs$core$IFn$_invoke$arity$3(goog.string.format,fmt__$1,p1__5603_SHARP_));
});})(fmt,fmt__$1))
,parts);
});
cljs.tools.cli.required_arguments = (function cljs$tools$cli$required_arguments(specs){
return cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (s,p__5609){
var map__5610 = p__5609;
var map__5610__$1 = ((cljs.core.seq_QMARK_(map__5610))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__5610):map__5610);
var required = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__5610__$1,cljs.core.cst$kw$required);
var short_opt = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__5610__$1,cljs.core.cst$kw$short_DASH_opt);
var long_opt = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__5610__$1,cljs.core.cst$kw$long_DASH_opt);
if(cljs.core.truth_(required)){
return cljs.core.into.cljs$core$IFn$_invoke$arity$2(s,cljs.core.remove.cljs$core$IFn$_invoke$arity$2(cljs.core.nil_QMARK_,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [short_opt,long_opt], null)));
} else {
return s;
}
}),cljs.core.PersistentHashSet.EMPTY,specs);
});
/**
 * Reduce options specs into a options summary for printing at a terminal.
 */
cljs.tools.cli.summarize = (function cljs$tools$cli$summarize(specs){
if(cljs.core.seq(specs)){
var show_defaults_QMARK_ = cljs.core.some((function (p1__5611_SHARP_){
var and__536__auto__ = cljs.core.cst$kw$required.cljs$core$IFn$_invoke$arity$1(p1__5611_SHARP_);
if(cljs.core.truth_(and__536__auto__)){
return cljs.core.contains_QMARK_(p1__5611_SHARP_,cljs.core.cst$kw$default);
} else {
return and__536__auto__;
}
}),specs);
var parts = cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(cljs.tools.cli.make_summary_parts,show_defaults_QMARK_),specs);
var lens = cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.map,((function (show_defaults_QMARK_,parts){
return (function() { 
var G__5612__delegate = function (cols){
return cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.max,cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.count,cols));
};
var G__5612 = function (var_args){
var cols = null;
if (arguments.length > 0) {
var G__5613__i = 0, G__5613__a = new Array(arguments.length -  0);
while (G__5613__i < G__5613__a.length) {G__5613__a[G__5613__i] = arguments[G__5613__i + 0]; ++G__5613__i;}
  cols = new cljs.core.IndexedSeq(G__5613__a,0);
} 
return G__5612__delegate.call(this,cols);};
G__5612.cljs$lang$maxFixedArity = 0;
G__5612.cljs$lang$applyTo = (function (arglist__5614){
var cols = cljs.core.seq(arglist__5614);
return G__5612__delegate(cols);
});
G__5612.cljs$core$IFn$_invoke$arity$variadic = G__5612__delegate;
return G__5612;
})()
;})(show_defaults_QMARK_,parts))
,parts);
var lines = cljs.tools.cli.format_lines(lens,parts);
return clojure.string.join.cljs$core$IFn$_invoke$arity$2("\n",lines);
} else {
return "";
}
});
/**
 * Extract the map of default options from a sequence of option vectors.
 */
cljs.tools.cli.get_default_options = (function cljs$tools$cli$get_default_options(option_specs){
return cljs.tools.cli.default_option_map(cljs.tools.cli.compile_option_specs(option_specs));
});
/**
 * Parse arguments sequence according to given option specifications and the
 *   GNU Program Argument Syntax Conventions:
 * 
 *  https://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
 * 
 *   Option specifications are a sequence of vectors with the following format:
 * 
 *  [short-opt long-opt-with-required-description description
 *   :property value]
 * 
 *   The first three string parameters in an option spec are positional and
 *   optional, and may be nil in order to specify a later parameter.
 * 
 *   By default, options are toggles that default to nil, but the second string
 *   parameter may be used to specify that an option requires an argument.
 * 
 *  e.g. ["-p" "--port PORT"] specifies that --port requires an argument,
 *       of which PORT is a short description.
 * 
 *   The :property value pairs are optional and take precedence over the
 *   positional string arguments. The valid properties are:
 * 
 *  :id           The key for this option in the resulting option map. This
 *                is normally set to the keywordized name of the long option
 *                without the leading dashes.
 * 
 *                Multiple option entries can share the same :id in order to
 *                transform a value in different ways, but only one of these
 *                option entries may contain a :default entry.
 * 
 *                This option is mandatory.
 * 
 *  :short-opt    The short format for this option, normally set by the first
 *                positional string parameter: e.g. "-p". Must be unique.
 * 
 *  :long-opt     The long format for this option, normally set by the second
 *                positional string parameter; e.g. "--port". Must be unique.
 * 
 *  :required     A description of the required argument for this option if
 *                one is required; normally set in the second positional
 *                string parameter after the long option: "--port PORT".
 * 
 *                The absence of this entry indicates that the option is a
 *                boolean toggle that is set to true when specified on the
 *                command line.
 * 
 *  :desc         A optional short description of this option.
 * 
 *  :default      The default value of this option. If none is specified, the
 *                resulting option map will not contain an entry for this
 *                option unless set on the command line.
 * 
 *  :default-desc An optional description of the default value. This should be
 *                used when the string representation of the default value is
 *                too ugly to be printed on the command line.
 * 
 *  :parse-fn     A function that receives the required option argument and
 *                returns the option value.
 * 
 *                If this is a boolean option, parse-fn will receive the value
 *                true. This may be used to invert the logic of this option:
 * 
 *                ["-q" "--quiet"
 *                 :id :verbose
 *                 :default true
 *                 :parse-fn not]
 * 
 *  :assoc-fn     A function that receives the current option map, the current
 *                option :id, and the current parsed option value, and returns
 *                a new option map.
 * 
 *                This may be used to create non-idempotent options, like
 *                setting a verbosity level by specifying an option multiple
 *                times. ("-vvv" -> 3)
 * 
 *                ["-v" "--verbose"
 *                 :default 0
 *                 :assoc-fn (fn [m k _] (update-in m [k] inc))]
 * 
 *  :validate     A vector of [validate-fn validate-msg ...]. Multiple pairs
 *                of validation functions and error messages may be provided.
 * 
 *  :validate-fn  A vector of functions that receives the parsed option value
 *                and returns a falsy value or throws an exception when the
 *                value is invalid. The validations are tried in the given
 *                order.
 * 
 *  :validate-msg A vector of error messages corresponding to :validate-fn
 *                that will be added to the :errors vector on validation
 *                failure.
 * 
 *   parse-opts returns a map with four entries:
 * 
 *  {:options     The options map, keyed by :id, mapped to the parsed value
 *   :arguments   A vector of unprocessed arguments
 *   :summary     A string containing a minimal options summary
 *   :errors      A possible vector of error message strings generated during
 *                parsing; nil when no errors exist}
 * 
 *   A few function options may be specified to influence the behavior of
 *   parse-opts:
 * 
 *  :in-order     Stop option processing at the first unknown argument. Useful
 *                for building programs with subcommands that have their own
 *                option specs.
 * 
 *  :no-defaults  Only include option values specified in arguments and do not
 *                include any default values in the resulting options map.
 *                Useful for parsing options from multiple sources; i.e. from a
 *                config file and from the command line.
 * 
 *  :strict       Parse required arguments strictly: if a required argument value
 *                matches any other option, it is considered to be missing (and
 *                you have a parse error).
 * 
 *  :summary-fn   A function that receives the sequence of compiled option specs
 *                (documented at #'clojure.tools.cli/compile-option-specs), and
 *                returns a custom option summary string.
 *   
 */
cljs.tools.cli.parse_opts = (function cljs$tools$cli$parse_opts(){
var argseq__1588__auto__ = ((((2) < arguments.length))?(new cljs.core.IndexedSeq(Array.prototype.slice.call(arguments,(2)),(0))):null);
return cljs.tools.cli.parse_opts.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__1588__auto__);
});

cljs.tools.cli.parse_opts.cljs$core$IFn$_invoke$arity$variadic = (function (args,option_specs,options){
var map__5618 = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,options);
var map__5618__$1 = ((cljs.core.seq_QMARK_(map__5618))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__5618):map__5618);
var in_order = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__5618__$1,cljs.core.cst$kw$in_DASH_order);
var no_defaults = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__5618__$1,cljs.core.cst$kw$no_DASH_defaults);
var strict = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__5618__$1,cljs.core.cst$kw$strict);
var summary_fn = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__5618__$1,cljs.core.cst$kw$summary_DASH_fn);
var specs = cljs.tools.cli.compile_option_specs(option_specs);
var req = cljs.tools.cli.required_arguments(specs);
var vec__5619 = cljs.tools.cli.tokenize_args.cljs$core$IFn$_invoke$arity$variadic(req,args,cljs.core.array_seq([cljs.core.cst$kw$in_DASH_order,in_order], 0));
var tokens = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5619,(0),null);
var rest_args = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5619,(1),null);
var vec__5620 = cljs.tools.cli.parse_option_tokens.cljs$core$IFn$_invoke$arity$variadic(specs,tokens,cljs.core.array_seq([cljs.core.cst$kw$no_DASH_defaults,no_defaults,cljs.core.cst$kw$strict,strict], 0));
var opts = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5620,(0),null);
var errors = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__5620,(1),null);
return new cljs.core.PersistentArrayMap(null, 4, [cljs.core.cst$kw$options,opts,cljs.core.cst$kw$arguments,rest_args,cljs.core.cst$kw$summary,(function (){var or__548__auto__ = summary_fn;
if(cljs.core.truth_(or__548__auto__)){
return or__548__auto__;
} else {
return cljs.tools.cli.summarize;
}
})().call(null,specs),cljs.core.cst$kw$errors,((cljs.core.seq(errors))?errors:null)], null);
});

cljs.tools.cli.parse_opts.cljs$lang$maxFixedArity = (2);

cljs.tools.cli.parse_opts.cljs$lang$applyTo = (function (seq5615){
var G__5616 = cljs.core.first(seq5615);
var seq5615__$1 = cljs.core.next(seq5615);
var G__5617 = cljs.core.first(seq5615__$1);
var seq5615__$2 = cljs.core.next(seq5615__$1);
return cljs.tools.cli.parse_opts.cljs$core$IFn$_invoke$arity$variadic(G__5616,G__5617,seq5615__$2);
});
