/root/Targets/gulp-vue2blade
└─┬ gulp-vue2blade@0.1.6 
  ├── de-indent@1.0.2 
  ├─┬ gulp-util@3.0.8 
  │ ├── array-differ@1.0.0 
  │ ├── array-uniq@1.0.3 
  │ ├── beeper@1.1.1 
  │ ├─┬ chalk@1.1.3 
  │ │ ├── ansi-styles@2.2.1 
  │ │ ├── escape-string-regexp@1.0.5 
  │ │ ├─┬ has-ansi@2.0.0 
  │ │ │ └── ansi-regex@2.1.1 
  │ │ ├── strip-ansi@3.0.1 
  │ │ └── supports-color@2.0.0 
  │ ├── dateformat@2.2.0 
  │ ├─┬ fancy-log@1.3.0 
  │ │ └── time-stamp@1.1.0 
  │ ├─┬ gulplog@1.0.0 
  │ │ └── glogg@1.0.0 
  │ ├─┬ has-gulplog@0.1.0 
  │ │ └── sparkles@1.0.0 
  │ ├── lodash._reescape@3.0.0 
  │ ├── lodash._reevaluate@3.0.0 
  │ ├── lodash._reinterpolate@3.0.0 
  │ ├─┬ lodash.template@3.6.2 
  │ │ ├── lodash._basecopy@3.0.1 
  │ │ ├── lodash._basetostring@3.0.1 
  │ │ ├── lodash._basevalues@3.0.0 
  │ │ ├── lodash._isiterateecall@3.0.9 
  │ │ ├─┬ lodash.escape@3.2.0 
  │ │ │ └── lodash._root@3.0.1 
  │ │ ├─┬ lodash.keys@3.1.2 
  │ │ │ ├── lodash._getnative@3.9.1 
  │ │ │ ├── lodash.isarguments@3.1.0 
  │ │ │ └── lodash.isarray@3.0.4 
  │ │ ├── lodash.restparam@3.6.1 
  │ │ └── lodash.templatesettings@3.1.1 
  │ ├── minimist@1.2.0 
  │ ├─┬ multipipe@0.1.2 
  │ │ └─┬ duplexer2@0.0.2 
  │ │   └─┬ readable-stream@1.1.14 
  │ │     ├── isarray@0.0.1 
  │ │     └── string_decoder@0.10.31 
  │ ├── object-assign@3.0.0 
  │ ├── replace-ext@0.0.1 
  │ └─┬ vinyl@0.5.3 
  │   ├── clone@1.0.2 
  │   └── clone-stats@0.0.1 
  ├── he@1.1.1 
  ├─┬ js2php@0.1.0 
  │ └── espree@2.2.5 
  ├── object-assign@4.1.1 
  └─┬ through2@2.0.3 
    ├─┬ readable-stream@2.3.3 
    │ ├── core-util-is@1.0.2 
    │ ├── inherits@2.0.3 
    │ ├── isarray@1.0.0 
    │ ├── process-nextick-args@1.0.7 
    │ ├── safe-buffer@5.1.1 
    │ ├── string_decoder@1.0.3 
    │ └── util-deprecate@1.0.2 
    └── xtend@4.0.1 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/gulp-vue2blade/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 48% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","create","toString","resolve","Set","getOwnPropertyNames","join","RegExp","reduce","bind","defineProperties","call","max","fromCharCode","assign"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0219 took 31.362s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Binding arguments in strict mode (183:12) on program var core = require('./core'),
    scope = require('./scope'),
    utils = require('./utils'),
    espree = require('espree');

module.exports = function(code) {
  var ast = espree.parse(code, {
    loc : true,
    range : true,
    tokens : true,
    comment : true,
    ecmaFeatures: {
      arrowFunctions: true, // enable parsing of arrow functions
      blockBindings: true, // enable parsing of let/const
      destructuring: true, // enable parsing of destructured arrays and objects
      regexYFlag: true, // enable parsing of regular expression y flag
      regexUFlag: true, // enable parsing of regular expression u flag
      templateStrings: true, // enable parsing of template strings
      binaryLiterals: true, // enable parsing of binary literals
      octalLiterals: true, // enable parsing of ES6 octal literals
      unicodeCodePointEscapes: true, // enable parsing unicode code point escape sequences
      defaultParams: true, // enable parsing of default parameters
      restParams: true, // enable parsing of rest parameters
      forOf: true, // enable parsing of for-of statement
      objectLiteralComputedProperties: true, // enable parsing computed object literal properties
      objectLiteralShorthandMethods: true, // enable parsing of shorthand object literal methods
      objectLiteralShorthandProperties: true, // enable parsing of shorthand object literal properties
      objectLiteralDuplicateProperties: true, // Allow duplicate object literal properties (except '__proto__')
      generators: true, // enable parsing of generators/yield
      spread: true, // enable parsing spread operator
      superInFunctions: true, // enable super in functions
      classes: true, // enable parsing classes
      newTarget: false, // enable parsing of new.target
      modules: true, // enable parsing of modules
      jsx: true, // enable React JSX parsing
      globalReturn: true, // enable return in global scope
      experimentalObjectRestSpread: true // allow experimental object rest/spread
    }
  });

  var rootScope = scope.create(ast, scope.KIND_ROOT);

  function visit(node, parent) {
    var content = "", semicolon = false;

    // set parent node
    if (parent) { node.parent = parent; }

    if (node.type == "Program" || node.type == "BlockStatement" || node.type == "ClassBody") {

      for (var i=0,length = node.body.length;i<length;i++) {
        content += visit(node.body[i], node);
      }

    } else if (node.type == "VariableDeclaration") {
      // declaration of one or multiple variables
      for (var i=0,length=node.declarations.length;i<length;i++) {
        content += visit(node.declarations[i], node);
      }

    } else if (node.type == "VariableDeclarator") {
      scope.get(node).register(node);

      // declaration of one variable
      content = '$' + node.id.name;

      if (node.init) {
        content += ' = ' + visit(node.init, node);
        semicolon = true;
      } else if (node.parent.parent.type !== "ForInStatement" &&
                 node.parent.parent.type !== "ForStatement" &&
                 node.parent.parent.type !== "ForOfStatement") {
        content += ' = null';
        semicolon = true;
      }

    } else if (node.type == "Identifier") {
      var identifier = (node.name || node.value);

      if (!node.static && !node.isCallee && !node.isMemberExpression) {
        scope.get(node).getDefinition(node);
        content = "$";
      }

      content += identifier;

    } else if (node.type == "Punctuator") {
      content = node.value;

    } else if (node.type == "Literal") {

      var value = (node.raw.match(/^["']undefined["']$/)) ? "NULL" : node.raw;
      content = value;

    } else if (node.type == "BinaryExpression" || node.type == "LogicalExpression") {

      if (node.operator == 'in') {
        content = visit({
          type: 'CallExpression',
          callee: {
            type: 'Identifier',
            name: 'isset',
          },
          arguments: [{
            type: 'MemberExpression',
            computed: true,
            object: node.right,
            property: node.left
          }]
        }, node);

      } else {
        content = visit(node.left, node) + " " + node.operator + " " + visit(node.right, node);
      }

    } else if (node.type == "AssignmentExpression" ||
               node.type == "AssignmentPattern") {
      scope.get(node).register(node.left);

      content = visit(node.left, node) + " " + (node.operator || "=") + " " + visit(node.right, node);

    } else if (node.type == "ConditionalExpression") {
      content = "(" + visit(node.test, node) + ")" +
        " ? " + visit(node.consequent, node) +
        " : " + visit(node.alternate, node);

    } else if (node.type == "UnaryExpression") {

      // override typeof unary expression
      if (node.operator == 'typeof') {
        content = visit({
          type: 'CallExpression',
          callee: {
            type: 'Identifier',
            name: 'gettype',
          },
          arguments: [node.argument]
        }, node);

      // override delete unary expression
      } else if (node.operator == 'delete') {
        content = visit({
          type: 'CallExpression',
          callee: {
            type: 'Identifier',
            name: 'unset',
          },
          arguments: [node.argument]
        }, node);

      } else {
        content = node.operator + visit(node.argument, node);
      }

    } else if (node.type == "ExpressionStatement") {
      content = visit(node.expression, node);
      semicolon = true;

    } else if (node.type == "CallExpression") {

      var calleeDefined = scope.get(node).getDefinition(node.callee);

      node.callee.isCallee = (!calleeDefined || calleeDefined && (calleeDefined.type != "Identifier" &&
                                                                  calleeDefined.type != "VariableDeclarator"));

      content += visit(node.callee, node);

      // inline anonymous call
      if ((node.callee.isCallee && node.callee.type == "FunctionDeclaration") ||
           node.type == "ArrowFunctionExpression") {
        var identifier = null;
        if (node.parent.type == "VariableDeclarator") {
          // var something = (function() { return 0; })();
          identifier = node.parent.id.name;
        } else if (node.parent.type == "AssignmentExpression") {
          // something = (function() { return 0; })();
          identifier = node.parent.left.name;
        }
        content += ";$" + identifier + " = " + "$" + identifier;
      }

      if (node.arguments) {
        var arguments = [];

        for (var i=0, length = node.arguments.length; i < length; i++) {
          arguments.push( visit(node.arguments[i], node) );
        }

        content += "(" + arguments.join(', ') + ")";
      }

      // allow semicolon if parent node isn't MemberExpression or Property
      if (node.parent && node.parent.type == "ExpressionStatement") {
        semicolon = true;
      }

    } else if (node.type == "MemberExpression") {
      var newNode = core.evaluate(node);

      if (node != newNode) {
        // fix parent node type
        content = visit(newNode, node.parent);

      } else {

        var object, property;

        if (node.object.type == "MemberExpression" && node.object.object && node.object.property) {
          object = node.object.object,
          property = node.object.property;
        } else {
          object = node.object;
          property = node.property;
        }

        object.static = (object.name || object.value || "").match(/^[A-Z]/);
        property.static = (property.name || property.value || "").match(/^[A-Z]/);

        var accessor;
        if (node.property.static && object.static) {
          accessor = "\\"; // namespace
        } else if ((property.static || object.static) || object.type == "Super") {
          accessor = "::"; // static
        } else {
          accessor = "->"; // instance
        }

        if (node.computed) {
          content = visit(node.object, node) + "[" + visit(node.property, node) + "]";
        } else {
          node.property.isMemberExpression = true;
          content = visit(node.object, node) + accessor + visit(node.property, node);
        }
      }

    } else if (node.type == "FunctionDeclaration" ||
               node.type == "ArrowFunctionExpression") {
      var param,
          parameters = [],
          defaults = node.defaults || [];

      // function declaration creates a new scope
      scope.create(node);

      // compute function params
      for (var i=0; i < node.params.length; i++) {
        if (defaults[i]) {
          param = visit({
            type: "BinaryExpression",
            left: node.params[i],
            operator: '=',
            right: defaults[i]
          }, node);
        } else {
          param = visit(node.params[i], node)
        }

        // register parameter identifiers
        if (scope.get(node).parent) {
          scope.get(node).register(node.params[i]);
        }

        parameters.push(param);
      }

      var func_contents = visit(node.body, node),
          using = scope.get(node).using;

      content = "function " + ((node.id) ? node.id.name : "");
      content += "(" + parameters.join(", ") + ") ";

      // try to use parent's variables
      // http://php.net/manual/pt_BR/functions.anonymous.php
      if (using.length > 0) {
        content += "use (" + using.map(function(identifier) {
          return "&$" + identifier;
        }).join(', ') + ") ";
      }

      content += "{\n";
      content += func_contents;
      content += "}\n";

    } else if (node.type == "ObjectExpression") {
      var properties = [];
      for (var i=0; i < node.properties.length; i++) {
        properties.push( visit(node.properties[i], node) )
      }
      content = "array(" + properties.join(", ") + ")";

    } else if (node.type == "ArrayExpression") {
      var elements = [];
      for (var i=0; i < node.elements.length; i++) {
        elements.push( visit(node.elements[i], node) )
      }
      content = "array(" + elements.join(", ") + ")";

    } else if (node.type == "Property") {
      var property = (node.key.type == 'Identifier') ? node.key.name : node.key.value;
      content = '"'+property+'" => ' + visit(node.value, node);

    } else if (node.type == "ReturnStatement") {
      semicolon = true;
      content = "return";

      if (node.argument) {
        content += " " + visit(node.argument, node);
      }

    } else if (node.type == "ClassDeclaration") {
      content = "class " + node.id.name

      if (node.superClass) {
        content += " extends " + node.superClass.name;
      }

      var s = scope.create(node);
      content += "\n{\n";
      content += visit(node.body, node);

      if (s.getters.length > 0) {
        content += "function __get($_property) {\n";
        for (var i=0;i<s.getters.length;i++) {
          content += "if ($_property === '"+s.getters[i].key.name+"') {\n";
          content += visit(s.getters[i].value.body, node);
          content += "}\n";
        }
        content += "}\n";
      }

      if (s.setters.length > 0) {
        content += "function __set($_property, $value) {\n";
        for (var i=0;i<s.setters.length;i++) {
          content += "if ($_property === '"+s.setters[i].key.name+"') {\n";
          content += visit(s.setters[i].value.body, node);
          content += "}\n";
        }
        content += "}\n";
      }

      content += "\n}\n";


    } else if (node.type == "MethodDefinition") {
      scope.get(node).register(node);

      // define getters and setters on scope
      if (node.kind == "get" || node.kind == "set") {
        return "";
      }

      var isConstructor = (node.key.name == "constructor");
      if (isConstructor) { node.key.name = "__construct"; }

      // Re-use FunctionDeclaration structure for method definitions
      node.value.type = "FunctionDeclaration";
      node.value.id = { name: node.key.name };

      var tmpContent = visit(node.value, node);

      // try to define public properties there were defined on constructor
      if (isConstructor) {
        node.key.name = "__construct";
        var definitions = scope.get(node.value).definitions;
        for(var i in definitions) {
          if (definitions[i] && definitions[i].type == "MemberExpression") {
            definitions[i].property.isMemberExpression = false;
            content += "public " + visit(definitions[i].property, null) + ";\n";
          }
        }
      }

      // every method is public.
      content += "public ";
      if (node.static) { content += "static "; }

      content += tmpContent;

    } else if (node.type == "ThisExpression") {
      content = "$this";

    } else if (node.type == "Super") {
      content = "parent";

    } else if (node.type == "IfStatement") {
      content = "if ("+visit(node.test, node)+") {\n";
      content += visit(node.consequent, node) + "}";

      if (node.alternate) {
        content += " else ";

        if (node.alternate.type == "BlockStatement") {
          content += "{"+visit(node.alternate, node)+"}";

        } else {
          content += visit(node.alternate, node)
        }
      }

    } else if (node.type == "SequenceExpression") {
      var expressions = [];

      for (var i=0;i<node.expressions.length;i++) {
        expressions.push( visit(node.expressions[i], node) );
      }

      content = expressions.join(', ') + ";";

    } else if (node.type == "WhileStatement") {

      content = "while (" + visit(node.test, node) + ") {";
      content += visit(node.body, node);
      content += "}";

    } else if (node.type == "DoWhileStatement") {

      content = "do {";
      content += visit(node.body, node);
      content += "} while (" + visit(node.test, node) + ")";
      semicolon = true;

    } else if (node.type == "ForStatement") {
      content = "for (";
      content += visit(node.init, node);
      content += visit(node.test, node) + ";" ;
      content += visit(node.update, node);
      content += ") {";
      content += visit(node.body, node);
      content += "}";

    } else if (node.type == "ForInStatement" || node.type == "ForOfStatement") {
      content = "foreach (" + visit(node.right, node) + " as " + visit(node.left, node)+ " => $___)";
      content += "{" + visit(node.body, node) + "}";

    } else if (node.type == "UpdateExpression") {

      if (node.prefix) {
        content += node.operator;
      }

      content += visit(node.argument, node);

      if (!node.prefix) {
        content += node.operator;
      }

    } else if (node.type == "SwitchStatement") {
      content = "switch (" + visit(node.discriminant, node) + ")";
      content += "{";
      for (var i=0; i < node.cases.length; i++) {
        content += visit(node.cases[i], node) + "\n";
      }
      content += "}";

    } else if (node.type == "SwitchCase") {

      if (node.test) {
        content += "case " + visit(node.test, node) + ":\n";
      } else {
        content =  "default:\n";
      }

      for (var i=0; i < node.consequent.length; i++) {
        content += visit(node.consequent[i], node);
      }

    } else if (node.type == "BreakStatement") {
      content = "break;";

    } else if (node.type == "NewExpression") {
      // re-use CallExpression for NewExpression's
      var newNode = utils.clone(node);
      newNode.type = "CallExpression";

      return "new " + visit(newNode, node);

    } else if (node.type == "FunctionExpression") {

      // Re-use FunctionDeclaration structure for method definitions
      node.type = "FunctionDeclaration";
      node.id = { name: node.id || "" };

      content = visit(node, node.parent);


      // Modules & Export (http://wiki.ecmascript.org/doku.php?id=harmony:modules_examples)
    } else if (node.type == "ModuleDeclaration") {
      content = "namespace " + utils.classize(node.id.value) + ";\n";
      content += visit(node.body, node);

    } else if (node.type == "ExportNamedDeclaration") {
      content = visit(node.declaration, node);

    } else if (node.type == "ImportDeclaration") {
      for (var i=0,length = node.specifiers.length;i<length;i++) {
        content += visit(node.specifiers[i], node);
      }

    } else if (node.type == "ImportSpecifier") {
        var namespace = utils.classize(node.parent.source.value);
        content += "use \\" + namespace + "\\" + node.imported.name;

        // alias
        if (node.local) { content += " as " + node.local.name; }

        content += ";\n";

    } else if (node.type == "TemplateLiteral") {
      var expressions = node.expressions
        , quasis = node.quasis
        , nodes = quasis.concat(expressions).sort(function(a, b) {
            return b.range[0] < a.range[0];
          })
        , cooked = "";

      for (var i=0; i<nodes.length; i++) {
        if (nodes[i].type == "TemplateElement") {
          cooked += nodes[i].value.cooked;
        } else {
          cooked += '{' + visit(nodes[i], node) + '}';
        }
      }

      content += '"' + cooked + '"';

    } else {
      console.log("'" + node.type + "' not implemented.", node);
    }

    // append semicolon when required
    if (semicolon && !content.match(/;\n?$/)) {
      content += ";\n";
    }

    return content;
  }

  return "<?php\n" + visit(ast);
}
 at SyntaxError: Binding arguments in strict mode (183:12)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$2.checkLVal (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1472:14)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1050:10)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseBlock (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:981:25)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:709:33)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/gulp-vue2blade/node_modules/gulp-vue2blade/index.js. Coverage (Term): 5% Coverage (LOC): 7%
*- File /root/Targets/gulp-vue2blade/node_modules/gulp-vue2blade/build.js. Coverage (Term): 10% Coverage (LOC): 16%
*- File /root/Targets/gulp-vue2blade/node_modules/he/he.js. Coverage (Term): 85% Coverage (LOC): 96%
*- File /root/Targets/gulp-vue2blade/node_modules/de-indent/index.js. Coverage (Term): 16% Coverage (LOC): 20%
*- File /root/Targets/gulp-vue2blade/node_modules/gulp-util/index.js. Coverage (Term): 98% Coverage (LOC): 100%
*- File /root/Targets/gulp-vue2blade/node_modules/vinyl/index.js. Coverage (Term): 20% Coverage (LOC): 33%
*- File /root/Targets/gulp-vue2blade/node_modules/clone/clone.js. Coverage (Term): 16% Coverage (LOC): 22%
*- File /root/Targets/gulp-vue2blade/node_modules/clone-stats/index.js. Coverage (Term): 43% Coverage (LOC): 50%
*- File /root/Targets/gulp-vue2blade/node_modules/vinyl/lib/cloneBuffer.js. Coverage (Term): 53% Coverage (LOC): 63%
*- File /root/Targets/gulp-vue2blade/node_modules/vinyl/lib/isBuffer.js. Coverage (Term): 95% Coverage (LOC): 100%
*- File /root/Targets/gulp-vue2blade/node_modules/vinyl/lib/isStream.js. Coverage (Term): 62% Coverage (LOC): 83%
*- File /root/Targets/gulp-vue2blade/node_modules/vinyl/lib/isNull.js. Coverage (Term): 61% Coverage (LOC): 80%
*- File /root/Targets/gulp-vue2blade/node_modules/vinyl/lib/inspectStream.js. Coverage (Term): 40% Coverage (LOC): 45%
*- File /root/Targets/gulp-vue2blade/node_modules/replace-ext/index.js. Coverage (Term): 32% Coverage (LOC): 45%
*- File /root/Targets/gulp-vue2blade/node_modules/chalk/index.js. Coverage (Term): 46% Coverage (LOC): 56%
*- File /root/Targets/gulp-vue2blade/node_modules/escape-string-regexp/index.js. Coverage (Term): 85% Coverage (LOC): 90%
*- File /root/Targets/gulp-vue2blade/node_modules/ansi-styles/index.js. Coverage (Term): 98% Coverage (LOC): 100%
*- File /root/Targets/gulp-vue2blade/node_modules/strip-ansi/index.js. Coverage (Term): 57% Coverage (LOC): 86%
*- File /root/Targets/gulp-vue2blade/node_modules/ansi-regex/index.js. Coverage (Term): 93% Coverage (LOC): 100%
*- File /root/Targets/gulp-vue2blade/node_modules/has-ansi/index.js. Coverage (Term): 97% Coverage (LOC): 100%
*- File /root/Targets/gulp-vue2blade/node_modules/supports-color/index.js. Coverage (Term): 63% Coverage (LOC): 56%
*- File /root/Targets/gulp-vue2blade/node_modules/dateformat/lib/dateformat.js. Coverage (Term): 17% Coverage (LOC): 41%
*- File /root/Targets/gulp-vue2blade/node_modules/gulp-util/lib/log.js. Coverage (Term): 38% Coverage (LOC): 42%
*- File /root/Targets/gulp-vue2blade/node_modules/has-gulplog/index.js. Coverage (Term): 71% Coverage (LOC): 86%
*- File /root/Targets/gulp-vue2blade/node_modules/sparkles/index.js. Coverage (Term): 31% Coverage (LOC): 37%
*- File /root/Targets/gulp-vue2blade/node_modules/gulp-util/lib/template.js. Coverage (Term): 47% Coverage (LOC): 63%
*- File /root/Targets/gulp-vue2blade/node_modules/lodash.template/index.js. Coverage (Term): 20% Coverage (LOC): 33%
*- File /root/Targets/gulp-vue2blade/node_modules/lodash._basecopy/index.js. Coverage (Term): 29% Coverage (LOC): 36%
*- File /root/Targets/gulp-vue2blade/node_modules/lodash._basetostring/index.js. Coverage (Term): 53% Coverage (LOC): 80%
*- File /root/Targets/gulp-vue2blade/node_modules/lodash._basevalues/index.js. Coverage (Term): 31% Coverage (LOC): 44%
*- File /root/Targets/gulp-vue2blade/node_modules/lodash._isiterateecall/index.js. Coverage (Term): 20% Coverage (LOC): 43%
*- File /root/Targets/gulp-vue2blade/node_modules/lodash._reinterpolate/index.js. Coverage (Term): 95% Coverage (LOC): 100%
*- File /root/Targets/gulp-vue2blade/node_modules/lodash.keys/index.js. Coverage (Term): 19% Coverage (LOC): 33%
*- File /root/Targets/gulp-vue2blade/node_modules/lodash._getnative/index.js. Coverage (Term): 82% Coverage (LOC): 89%
*- File /root/Targets/gulp-vue2blade/node_modules/lodash.isarguments/index.js. Coverage (Term): 30% Coverage (LOC): 64%
*- File /root/Targets/gulp-vue2blade/node_modules/lodash.isarray/index.js. Coverage (Term): 69% Coverage (LOC): 86%
*- File /root/Targets/gulp-vue2blade/node_modules/lodash.restparam/index.js. Coverage (Term): 29% Coverage (LOC): 34%
*- File /root/Targets/gulp-vue2blade/node_modules/lodash.templatesettings/index.js. Coverage (Term): 98% Coverage (LOC): 100%
*- File /root/Targets/gulp-vue2blade/node_modules/lodash.escape/index.js. Coverage (Term): 41% Coverage (LOC): 59%
*- File /root/Targets/gulp-vue2blade/node_modules/lodash._root/index.js. Coverage (Term): 86% Coverage (LOC): 100%
*- File /root/Targets/gulp-vue2blade/node_modules/lodash._reescape/index.js. Coverage (Term): 95% Coverage (LOC): 100%
*- File /root/Targets/gulp-vue2blade/node_modules/lodash._reevaluate/index.js. Coverage (Term): 95% Coverage (LOC): 100%
*- File /root/Targets/gulp-vue2blade/node_modules/gulp-util/lib/env.js. Coverage (Term): 97% Coverage (LOC): 100%
*- File /root/Targets/gulp-vue2blade/node_modules/minimist/index.js. Coverage (Term): 22% Coverage (LOC): 34%
*- File /root/Targets/gulp-vue2blade/node_modules/beeper/index.js. Coverage (Term): 13% Coverage (LOC): 17%
*- File /root/Targets/gulp-vue2blade/node_modules/gulp-util/lib/noop.js. Coverage (Term): 70% Coverage (LOC): 83%
*- File /root/Targets/gulp-vue2blade/node_modules/through2/through2.js. Coverage (Term): 24% Coverage (LOC): 26%
*- File /root/Targets/gulp-vue2blade/node_modules/through2/node_modules/readable-stream/transform.js. Coverage (Term): 95% Coverage (LOC): 100%
*- File /root/Targets/gulp-vue2blade/node_modules/through2/node_modules/readable-stream/readable.js. Coverage (Term): 61% Coverage (LOC): 60%
*- File /root/Targets/gulp-vue2blade/node_modules/through2/node_modules/readable-stream/lib/_stream_readable.js. Coverage (Term): 8% Coverage (LOC): 14%
*- File /root/Targets/gulp-vue2blade/node_modules/process-nextick-args/index.js. Coverage (Term): 22% Coverage (LOC): 19%
*- File /root/Targets/gulp-vue2blade/node_modules/through2/node_modules/isarray/index.js. Coverage (Term): 62% Coverage (LOC): 83%
*- File /root/Targets/gulp-vue2blade/node_modules/through2/node_modules/readable-stream/lib/internal/streams/stream.js. Coverage (Term): 95% Coverage (LOC): 100%
*- File /root/Targets/gulp-vue2blade/node_modules/safe-buffer/index.js. Coverage (Term): 36% Coverage (LOC): 44%
*- File /root/Targets/gulp-vue2blade/node_modules/core-util-is/lib/util.js. Coverage (Term): 33% Coverage (LOC): 64%
*- File /root/Targets/gulp-vue2blade/node_modules/inherits/inherits.js. Coverage (Term): 74% Coverage (LOC): 88%
*- File /root/Targets/gulp-vue2blade/node_modules/through2/node_modules/readable-stream/lib/internal/streams/BufferList.js. Coverage (Term): 19% Coverage (LOC): 29%
*- File /root/Targets/gulp-vue2blade/node_modules/through2/node_modules/readable-stream/lib/internal/streams/destroy.js. Coverage (Term): 15% Coverage (LOC): 21%
*- File /root/Targets/gulp-vue2blade/node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js. Coverage (Term): 14% Coverage (LOC): 19%
*- File /root/Targets/gulp-vue2blade/node_modules/util-deprecate/node.js. Coverage (Term): 95% Coverage (LOC): 100%
*- File /root/Targets/gulp-vue2blade/node_modules/through2/node_modules/readable-stream/lib/_stream_duplex.js. Coverage (Term): 35% Coverage (LOC): 44%
*- File /root/Targets/gulp-vue2blade/node_modules/through2/node_modules/readable-stream/lib/_stream_transform.js. Coverage (Term): 14% Coverage (LOC): 22%
*- File /root/Targets/gulp-vue2blade/node_modules/through2/node_modules/readable-stream/lib/_stream_passthrough.js. Coverage (Term): 59% Coverage (LOC): 73%
*- File /root/Targets/gulp-vue2blade/node_modules/xtend/immutable.js. Coverage (Term): 32% Coverage (LOC): 33%
*- File /root/Targets/gulp-vue2blade/node_modules/gulp-util/lib/isStream.js. Coverage (Term): 62% Coverage (LOC): 83%
*- File /root/Targets/gulp-vue2blade/node_modules/gulp-util/lib/isBuffer.js. Coverage (Term): 64% Coverage (LOC): 86%
*- File /root/Targets/gulp-vue2blade/node_modules/gulp-util/lib/isNull.js. Coverage (Term): 61% Coverage (LOC): 80%
*- File /root/Targets/gulp-vue2blade/node_modules/gulp-util/lib/combine.js. Coverage (Term): 36% Coverage (LOC): 45%
*- File /root/Targets/gulp-vue2blade/node_modules/multipipe/index.js. Coverage (Term): 19% Coverage (LOC): 20%
*- File /root/Targets/gulp-vue2blade/node_modules/duplexer2/index.js. Coverage (Term): 20% Coverage (LOC): 24%
*- File /root/Targets/gulp-vue2blade/node_modules/readable-stream/readable.js. Coverage (Term): 90% Coverage (LOC): 92%
*- File /root/Targets/gulp-vue2blade/node_modules/readable-stream/lib/_stream_readable.js. Coverage (Term): 7% Coverage (LOC): 11%
*- File /root/Targets/gulp-vue2blade/node_modules/isarray/index.js. Coverage (Term): 53% Coverage (LOC): 80%
*- File /root/Targets/gulp-vue2blade/node_modules/readable-stream/lib/_stream_writable.js. Coverage (Term): 9% Coverage (LOC): 16%
*- File /root/Targets/gulp-vue2blade/node_modules/readable-stream/lib/_stream_duplex.js. Coverage (Term): 49% Coverage (LOC): 51%
*- File /root/Targets/gulp-vue2blade/node_modules/readable-stream/lib/_stream_transform.js. Coverage (Term): 15% Coverage (LOC): 23%
*- File /root/Targets/gulp-vue2blade/node_modules/readable-stream/lib/_stream_passthrough.js. Coverage (Term): 58% Coverage (LOC): 71%
*- File /root/Targets/gulp-vue2blade/node_modules/gulp-util/lib/buffer.js. Coverage (Term): 27% Coverage (LOC): 33%
*- File /root/Targets/gulp-vue2blade/node_modules/gulp-util/lib/PluginError.js. Coverage (Term): 19% Coverage (LOC): 25%
*- File /root/Targets/gulp-vue2blade/node_modules/array-differ/index.js. Coverage (Term): 32% Coverage (LOC): 56%
*- File /root/Targets/gulp-vue2blade/node_modules/array-uniq/index.js. Coverage (Term): 36% Coverage (LOC): 44%
*- File /root/Targets/gulp-vue2blade/node_modules/gulp-util/node_modules/object-assign/index.js. Coverage (Term): 19% Coverage (LOC): 29%
*- File /root/Targets/gulp-vue2blade/node_modules/object-assign/index.js. Coverage (Term): 54% Coverage (LOC): 53%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
