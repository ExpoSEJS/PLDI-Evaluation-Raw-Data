/root/Targets/chinchilla
└─┬ chinchilla@0.0.9 
  └── underscore@1.5.2 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/chinchilla/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 28.999999999999996% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","call","join","RegExp","sort"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0413 took 8.7812s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (42:11) on program (function() {
    var gen1_rethrowErrors = function(continuation, block) {
        return function(error, result) {
            if (error) {
                return continuation(error);
            } else {
                try {
                    return block(result);
                } catch (ex) {
                    return continuation(ex);
                }
            }
        };
    };
    var gen2_continuationOrDefault = function(args) {
        var c = args[args.length - 1];
        if (c instanceof Function) {
            return c;
        } else {
            return function(error, result) {
                if (error) {
                    throw error;
                } else {
                    return result;
                }
            };
        }
    };
    var gen3_asyncIf = function(condition, thenBody, cb) {
        if (condition) {
            try {
                thenBody(cb);
            } catch (ex) {
                cb(ex);
            }
        } else {
            cb();
        }
    };
    var self = this;
    var assert;
    assert = require("chai").assert;
    module.exports = function(chai, utils) {
        var self = this;
        var haveSelector, beVisible;
        haveSelector = function(assert, locator, options, continuation) {
            var gen4_arguments = Array.prototype.slice.call(arguments, 0, arguments.length - 1);
            continuation = gen2_continuationOrDefault(arguments);
            assert = gen4_arguments[0];
            locator = gen4_arguments[1];
            options = gen4_arguments[2];
            var scope, count;
            scope = utils.flag(assert, "object");
            if (utils.flag(assert, "negate")) {
                throw new Error("This assertion cannot be used with a negation.\nPlease use 'not have selector' instead.");
            }
            count = void 0;
            if (options) {
                count = options.count;
            }
            return scope.hasSelector(locator, {
                count: count
            }, gen1_rethrowErrors(continuation, function(gen5_asyncResult) {
                var hasSelector, message;
                hasSelector = gen5_asyncResult;
                message = "to exist";
                return gen3_asyncIf(count && !hasSelector, function(continuation) {
                    var gen6_arguments = Array.prototype.slice.call(arguments, 0, arguments.length - 1);
                    continuation = gen2_continuationOrDefault(arguments);
                    return scope.find(locator, gen1_rethrowErrors(continuation, function(gen7_asyncResult) {
                        return continuation(void 0, message = "to have " + count + " occurrences (only " + gen7_asyncResult.length + " found)");
                    }));
                }, gen1_rethrowErrors(continuation, function(gen8_asyncResult) {
                    gen8_asyncResult;
                    return continuation(void 0, {
                        hasSelector: hasSelector,
                        message: message
                    });
                }));
            }));
        };
        chai.Assertion.addMethod("haveSelector", function(locator, options, continuation) {
            var gen9_arguments = Array.prototype.slice.call(arguments, 0, arguments.length - 1);
            continuation = gen2_continuationOrDefault(arguments);
            locator = gen9_arguments[0];
            options = gen9_arguments[1];
            return haveSelector(this, locator, options, gen1_rethrowErrors(continuation, function(gen10_asyncResult) {
                var result;
                result = gen10_asyncResult;
                return continuation(void 0, assert(result.hasSelector, "expected element '" + locator + "' " + result.message));
            }));
        });
        chai.Assertion.addMethod("notHaveSelector", function(locator, options, continuation) {
            var gen11_arguments = Array.prototype.slice.call(arguments, 0, arguments.length - 1);
            continuation = gen2_continuationOrDefault(arguments);
            locator = gen11_arguments[0];
            options = gen11_arguments[1];
            return haveSelector(this, locator, options, gen1_rethrowErrors(continuation, function(gen12_asyncResult) {
                var result;
                result = gen12_asyncResult;
                return continuation(void 0, assert(!result.hasSelector, "expected element '" + locator + "' not " + result.message));
            }));
        });
        beVisible = function(assert, locator, gen13_options, continuation) {
            var gen14_arguments = Array.prototype.slice.call(arguments, 0, arguments.length - 1);
            continuation = gen2_continuationOrDefault(arguments);
            assert = gen14_arguments[0];
            locator = gen14_arguments[1];
            gen13_options = gen14_arguments[2];
            var options;
            options = gen13_options !== void 0 && Object.prototype.hasOwnProperty.call(gen13_options, "options") && gen13_options.options !== void 0 ? gen13_options.options : void 0;
            var scope;
            scope = utils.flag(assert, "object");
            if (utils.flag(assert, "negate")) {
                throw new Error("This assertion cannot be used with a negation.\nPlease use 'not be visible' instead.");
            }
            return scope.isVisible(locator, {
                options: options
            }, continuation);
        };
        chai.Assertion.addMethod("beVisible", function(locator, continuation) {
            var gen15_arguments = Array.prototype.slice.call(arguments, 0, arguments.length - 1);
            continuation = gen2_continuationOrDefault(arguments);
            locator = gen15_arguments[0];
            return beVisible(this, locator, gen1_rethrowErrors(continuation, function(gen16_asyncResult) {
                var isVisible;
                isVisible = gen16_asyncResult;
                return continuation(void 0, assert(isVisible, "expected element '" + locator + "' to be visible"));
            }));
        });
        return chai.Assertion.addMethod("notBeVisible", function(locator, continuation) {
            var gen17_arguments = Array.prototype.slice.call(arguments, 0, arguments.length - 1);
            continuation = gen2_continuationOrDefault(arguments);
            locator = gen17_arguments[0];
            return beVisible(this, locator, {
                options: {
                    timeout: 10
                }
            }, gen1_rethrowErrors(continuation, function(gen18_asyncResult) {
                var isVisible;
                isVisible = gen18_asyncResult;
                return continuation(void 0, assert(!isVisible, "expected element '" + locator + "' not to be visible"));
            }));
        });
    };
}).call(this); at SyntaxError: Unexpected token (42:11)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$3.parseExprAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1822:12)
    at Parser.parseExprAtom (/root/ExpoSE/lib/Tropigate/bin/Expression.js:28:30)
    at Parser.pp$3.parseExprSubscripts (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1715:21)
    at Parser.parseMaybeUnary (/root/ExpoSE/lib/Tropigate/bin/Unary.js:34:29)
    at Parser.pp$3.parseExprOps (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1637:21)
    at Parser.pp$3.parseMaybeConditional (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1620:21)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1597:21)
    at Parser.pp$3.parseExpression (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1573:21)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/chinchilla/node_modules/chinchilla/build/index.js. Coverage (Term): 43% Coverage (LOC): 46%
*- File /root/Targets/chinchilla/node_modules/chinchilla/build/lib/scope.js. Coverage (Term): 27% Coverage (LOC): 29%
*- File /root/Targets/chinchilla/node_modules/underscore/underscore.js. Coverage (Term): 18% Coverage (LOC): 32%
*- File /root/Targets/chinchilla/node_modules/chinchilla/build/lib/finders.js. Coverage (Term): 18% Coverage (LOC): 21%
*- File /root/Targets/chinchilla/node_modules/chinchilla/build/lib/waitUntil.js. Coverage (Term): 14% Coverage (LOC): 21%
*- File /root/Targets/chinchilla/node_modules/chinchilla/build/lib/actions.js. Coverage (Term): 6% Coverage (LOC): 9%
*- File /root/Targets/chinchilla/node_modules/chinchilla/build/lib/query.js. Coverage (Term): 12% Coverage (LOC): 15%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
