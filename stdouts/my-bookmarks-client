/root/Targets/my-bookmarks-client
└─┬ my-bookmarks-client@0.0.1 
  ├─┬ react@0.13.1 
  │ └─┬ envify@3.4.1 
  │   ├─┬ jstransform@11.0.3 
  │   │ ├── base62@1.2.0 
  │   │ ├─┬ commoner@0.10.8 
  │   │ │ ├── commander@2.11.0 
  │   │ │ ├─┬ detective@4.5.0 
  │   │ │ │ ├── acorn@4.0.13 
  │   │ │ │ └── defined@1.0.0 
  │   │ │ ├─┬ glob@5.0.15 
  │   │ │ │ ├─┬ inflight@1.0.6 
  │   │ │ │ │ └── wrappy@1.0.2 
  │   │ │ │ ├─┬ minimatch@3.0.4 
  │   │ │ │ │ └─┬ brace-expansion@1.1.8 
  │   │ │ │ │   ├── balanced-match@1.0.0 
  │   │ │ │ │   └── concat-map@0.0.1 
  │   │ │ │ ├── once@1.4.0 
  │   │ │ │ └── path-is-absolute@1.0.1 
  │   │ │ ├── graceful-fs@4.1.11 
  │   │ │ ├── iconv-lite@0.4.19 
  │   │ │ ├─┬ mkdirp@0.5.1 
  │   │ │ │ └── minimist@0.0.8 
  │   │ │ ├── private@0.1.7 
  │   │ │ ├── q@1.5.0 
  │   │ │ └─┬ recast@0.11.23 
  │   │ │   ├── ast-types@0.9.6 
  │   │ │   ├── esprima@3.1.3 
  │   │ │   └── source-map@0.5.7 
  │   │ ├── esprima-fb@15001.1.0-dev-harmony-fb 
  │   │ ├── object-assign@2.1.1 
  │   │ └─┬ source-map@0.4.4 
  │   │   └── amdefine@1.0.1 
  │   └── through@2.3.8 
  ├─┬ slug@0.8.0 
  │ └── unicode@10.0.0 
  └─┬ superagent@1.1.0 
    ├── component-emitter@1.1.2 
    ├── cookiejar@2.0.1 
    ├─┬ debug@2.6.9 
    │ └── ms@2.0.0 
    ├── extend@1.2.1 
    ├─┬ form-data@0.1.3 
    │ ├── async@0.9.2 
    │ └─┬ combined-stream@0.0.7 
    │   └── delayed-stream@0.0.5 
    ├── formidable@1.0.14 
    ├── methods@1.0.1 
    ├── mime@1.2.11 
    ├── qs@2.3.3 
    ├─┬ readable-stream@1.0.27-1 
    │ ├── core-util-is@1.0.2 
    │ ├── inherits@2.0.3 
    │ ├── isarray@0.0.1 
    │ └── string_decoder@0.10.31 
    └── reduce-component@1.0.1 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/my-bookmarks-client/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0727 took 5.2184s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (44:6) on program var React = require('react');
var request = require('superagent');
var slug = require('slug');


// Utilitaires pour requêter notre serveur.
var data = {

  // On récupère les bookmarks.
  getBookmarks: function(callback) {
    request
      .get('/api/bookmarks')
      .set('Accept', 'application/json')
      .end(function (err, res) {
        callback(err, res.body);
      });
  },

  // On crée une bookmark.
  createBookmark: function(bookmark, callback) {
    request
      .post('/api/bookmarks')
      .send(bookmark)
      .end(function (err, res) {
        callback(err, res.body);
      });
  },

  // On supprimme une bookmark. On récree son identifiant à partir du lien.
  deleteBookmark: function(bookmark, callback) {
    console.log(bookmark);
    request
      .del('/api/bookmarks/' + slug(bookmark.link))
      .end(callback);
  }

}


// C'est le composant principal de l'application.
var App = React.createClass({
  render: function() {
    return (
      <div>
      <h1>My Single Page Application</h1>
      <BookmarkList bookmarks={this.props.bookmarks}></BookmarkList>
      </div>
    )
  }
});



// Le composant liste de bookmark.
var BookmarkList = React.createClass({

  // On définit l'état du composant bookmarks cela est utile pour le rendu
  // dynamique.
  getInitialState: function() {
    return {bookmarks: this.props.bookmarks};
  },

  // Quand le bouton ajout est cliqué, on récupère les valeurs des
  // différents champs.
  // Puis on met à jour la liste des composants. Enfin on provoque un nouveau
  // rendu en changeant l'état et on envoie une requête de création au serveur.
  onAddClicked: function() {
    var bookmarks = this.state.bookmarks;
    var title = this.refs.titleInput.getDOMNode().value;
    var link = this.refs.linkInput.getDOMNode().value;

    var bookmark = {title: title, link: link};
    bookmarks.push(bookmark);

    // Changement d'état.
    this.setState({bookmarks: bookmarks});
    // Requête au server.
    data.createBookmark(bookmark, function () {});
  },

  // Quand on supprime une ligne, on met à jour la liste des lignes. Puis on
  // provoque le rendu du composant en changeant l'état. Pour enfin envoyer une
  // requête de suppression au serveur.
  removeLine: function(line) {
    var bookmarks = this.state.bookmarks;
    var index = 0;
    while (index < bookmarks.length && bookmarks[index].link !== line.link) {
      index++;
    }
    if (index < bookmarks.length) {
      var bookmark = bookmarks.splice(index, 1)[0];

      // Changement d'état.
      this.setState({ bookmarks: bookmarks });
      // Requête au server.
      data.deleteBookmark(bookmark, function () {});
    }
  },

  // Rendu du composant.
  render: function() {
    var removeLine = this.removeLine;

    // Ici on prépare la liste à partir des proprités.
    var bookmarks = this.state.bookmarks.map(function(bookmark) {
      return (
        <Bookmark title={bookmark.title} link={bookmark.link}
                  removeLine={removeLine}>
        </Bookmark>
      );
    });
    return (
      <div>
        <div>
          <label>title</label>
          <input ref="titleInput" type="text" ></input>
        </div>
        <div>
          <label>url</label>
          <input ref="linkInput" type="text"></input>
        </div>
        <div>
          <button onClick={this.onAddClicked}>+</button>
        </div>
        <div>
          {bookmarks}
        </div>
      </div>
    );
  }
});


// Le composant qui va définir une ligne de bookmark.
var Bookmark = React.createClass({

  // On supprime la ligne courante du parent quand le bouton supprimé est
  // cliqué.
  onDeleteClicked: function() {
    this.props.removeLine(this.props);
  },

  // Le rendu se fait grâce à un format de template appelé JSX.
  render: function() {
    return (
      <div>
        <p class="title">{this.props.title}</p>
        <p class="link">
          <a href={this.props.link}>{this.props.link}</a>
        </p>
        <p>
          <button onClick={this.onDeleteClicked}>X</button>
        </p>
      </div>
    );
  }
});


// Ici on démarre !
data.getBookmarks(function(err, bookmarks) {
  React.render(<App bookmarks={bookmarks.rows}></App>,
               document.getElementById('app'));
});
 at SyntaxError: Unexpected token (44:6)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$3.parseExprAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1822:12)
    at Parser.parseExprAtom (/root/ExpoSE/lib/Tropigate/bin/Expression.js:28:30)
    at Parser.pp$3.parseExprSubscripts (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1715:21)
    at Parser.parseMaybeUnary (/root/ExpoSE/lib/Tropigate/bin/Unary.js:34:29)
    at Parser.pp$3.parseExprOps (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1637:21)
    at Parser.pp$3.parseMaybeConditional (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1620:21)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1597:21)
    at Parser.pp$3.parseParenAndDistinguishExpression (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1861:32)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
