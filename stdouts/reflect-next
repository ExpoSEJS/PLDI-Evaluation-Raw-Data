/root/Targets/reflect-next
└─┬ reflect-next@0.0.9 
  ├── JSONSelect@0.4.0 
  └─┬ reflect-tree-builder@0.0.2 
    └── reflect-builder@0.0.1 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/reflect-next/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /2 queued / 1 running / 1 errors / 96% coverage ] ****** [1 done /1 queued / 2 running / 1 errors / 96% coverage ] ****** [1 done /0 queued / 3 running / 1 errors / 96% coverage ] ****** [1 done /0 queued / 3 running / 1 errors / 96% coverage ] ****** [2 done /1 queued / 3 running / 2 errors / 96% coverage ] ****** [2 done /0 queued / 4 running / 2 errors / 96% coverage ] ****** [2 done /0 queued / 4 running / 2 errors / 96% coverage ] ****** [3 done /0 queued / 4 running / 3 errors / 96% coverage ] ****** [3 done /0 queued / 4 running / 3 errors / 96% coverage ] ****** [4 done /2 queued / 4 running / 4 errors / 96% coverage ] ****** [4 done /1 queued / 5 running / 4 errors / 96% coverage ] ****** [4 done /0 queued / 6 running / 4 errors / 96% coverage ] ****** [4 done /0 queued / 6 running / 4 errors / 96% coverage ] ****** [5 done /2 queued / 6 running / 5 errors / 96% coverage ] ****** [5 done /1 queued / 7 running / 5 errors / 96% coverage ] ****** [5 done /0 queued / 8 running / 5 errors / 96% coverage ] ****** [5 done /0 queued / 8 running / 5 errors / 96% coverage ] ****** [6 done /2 queued / 8 running / 6 errors / 96% coverage ] ****** [6 done /1 queued / 9 running / 6 errors / 96% coverage ] ****** [6 done /0 queued / 10 running / 6 errors / 96% coverage ] ****** [6 done /0 queued / 10 running / 6 errors / 96% coverage ] ****** [7 done /1 queued / 10 running / 7 errors / 96% coverage ] ****** [7 done /0 queued / 11 running / 7 errors / 96% coverage ] ****** [7 done /0 queued / 11 running / 7 errors / 96% coverage ] ****** [8 done /2 queued / 11 running / 8 errors / 95% coverage ] ****** [8 done /1 queued / 12 running / 8 errors / 95% coverage ] ****** [8 done /0 queued / 13 running / 8 errors / 95% coverage ] ****** [8 done /0 queued / 13 running / 8 errors / 95% coverage ] ****** [9 done /0 queued / 13 running / 9 errors / 95% coverage ] ****** [9 done /0 queued / 13 running / 9 errors / 95% coverage ] ****** [10 done /1 queued / 13 running / 10 errors / 95% coverage ] ****** [10 done /0 queued / 14 running / 10 errors / 95% coverage ] ****** [10 done /0 queued / 14 running / 10 errors / 95% coverage ] ****** [11 done /0 queued / 13 running / 11 errors / 95% coverage ] ****** [12 done /0 queued / 12 running / 12 errors / 95% coverage ] ****** [13 done /1 queued / 12 running / 13 errors / 95% coverage ] ****** [13 done /0 queued / 13 running / 13 errors / 95% coverage ] ****** [13 done /0 queued / 13 running / 13 errors / 95% coverage ] ****** [14 done /1 queued / 13 running / 14 errors / 95% coverage ] ****** [14 done /0 queued / 14 running / 14 errors / 95% coverage ] ****** [14 done /0 queued / 14 running / 14 errors / 95% coverage ] ****** [15 done /3 queued / 14 running / 15 errors / 95% coverage ] ****** [15 done /2 queued / 15 running / 15 errors / 95% coverage ] ****** [15 done /1 queued / 16 running / 15 errors / 95% coverage ] ****** [15 done /1 queued / 16 running / 15 errors / 95% coverage ] ****** [16 done /2 queued / 16 running / 16 errors / 95% coverage ] ****** [16 done /2 queued / 16 running / 16 errors / 95% coverage ] ****** [17 done /4 queued / 16 running / 17 errors / 95% coverage ] ****** [17 done /4 queued / 16 running / 17 errors / 95% coverage ] ****** [18 done /8 queued / 16 running / 18 errors / 95% coverage ] ****** [18 done /8 queued / 16 running / 18 errors / 95% coverage ] ****** [19 done /9 queued / 16 running / 19 errors / 95% coverage ] ****** [19 done /9 queued / 16 running / 19 errors / 95% coverage ] ****** [20 done /9 queued / 16 running / 20 errors / 95% coverage ] ****** [20 done /9 queued / 16 running / 20 errors / 95% coverage ] ****** [21 done /10 queued / 16 running / 20 errors / 96% coverage ] ****** [21 done /10 queued / 16 running / 20 errors / 96% coverage ] ****** [22 done /12 queued / 16 running / 21 errors / 96% coverage ] ****** [22 done /12 queued / 16 running / 21 errors / 96% coverage ] ****** [23 done /11 queued / 16 running / 21 errors / 96% coverage ] ****** [23 done /11 queued / 16 running / 21 errors / 96% coverage ] ****** [24 done /13 queued / 16 running / 22 errors / 96% coverage ] ****** [24 done /13 queued / 16 running / 22 errors / 96% coverage ] ****** [25 done /16 queued / 16 running / 23 errors / 96% coverage ] ****** [25 done /16 queued / 16 running / 23 errors / 96% coverage ] ****** [26 done /15 queued / 16 running / 24 errors / 96% coverage ] ****** [26 done /15 queued / 16 running / 24 errors / 96% coverage ] ****** [27 done /16 queued / 16 running / 25 errors / 96% coverage ] ****** [27 done /16 queued / 16 running / 25 errors / 96% coverage ] ****** [28 done /15 queued / 16 running / 26 errors / 96% coverage ] ****** [28 done /15 queued / 16 running / 26 errors / 96% coverage ] ****** [29 done /17 queued / 16 running / 27 errors / 96% coverage ] ****** [29 done /17 queued / 16 running / 27 errors / 96% coverage ] ****** [30 done /17 queued / 16 running / 28 errors / 96% coverage ] ****** [30 done /17 queued / 16 running / 28 errors / 96% coverage ] ****** [31 done /16 queued / 16 running / 29 errors / 96% coverage ] ****** [31 done /16 queued / 16 running / 29 errors / 96% coverage ] ****** [32 done /17 queued / 16 running / 30 errors / 96% coverage ] ****** [32 done /17 queued / 16 running / 30 errors / 96% coverage ] ****** [33 done /18 queued / 16 running / 31 errors / 96% coverage ] ****** [33 done /18 queued / 16 running / 31 errors / 96% coverage ] ****** [34 done /19 queued / 16 running / 32 errors / 96% coverage ] ****** [34 done /19 queued / 16 running / 32 errors / 96% coverage ] ****** [35 done /21 queued / 16 running / 33 errors / 96% coverage ] ****** [35 done /21 queued / 16 running / 33 errors / 96% coverage ] ****** [36 done /21 queued / 16 running / 34 errors / 96% coverage ] ****** [36 done /21 queued / 16 running / 34 errors / 96% coverage ] ****** [37 done /21 queued / 16 running / 35 errors / 96% coverage ] ****** [37 done /21 queued / 16 running / 35 errors / 96% coverage ] ****** [38 done /20 queued / 16 running / 36 errors / 96% coverage ] ****** [38 done /20 queued / 16 running / 36 errors / 96% coverage ] ****** [39 done /19 queued / 16 running / 37 errors / 96% coverage ] ****** [39 done /19 queued / 16 running / 37 errors / 96% coverage ] ****** [40 done /18 queued / 16 running / 38 errors / 96% coverage ] ****** [40 done /18 queued / 16 running / 38 errors / 96% coverage ] ****** [41 done /17 queued / 16 running / 39 errors / 96% coverage ] ****** [41 done /17 queued / 16 running / 39 errors / 96% coverage ] ****** [42 done /16 queued / 16 running / 40 errors / 96% coverage ] ****** [42 done /16 queued / 16 running / 40 errors / 96% coverage ] ****** [43 done /17 queued / 16 running / 41 errors / 96% coverage ] ****** [43 done /17 queued / 16 running / 41 errors / 96% coverage ] ****** [44 done /17 queued / 16 running / 42 errors / 96% coverage ] ****** [44 done /17 queued / 16 running / 42 errors / 96% coverage ] ****** [45 done /19 queued / 16 running / 43 errors / 96% coverage ] ****** [45 done /19 queued / 16 running / 43 errors / 96% coverage ] ****** [46 done /20 queued / 16 running / 44 errors / 96% coverage ] ****** [46 done /20 queued / 16 running / 44 errors / 96% coverage ] ****** [47 done /22 queued / 16 running / 45 errors / 96% coverage ] ****** [47 done /22 queued / 16 running / 45 errors / 96% coverage ] ****** [48 done /23 queued / 16 running / 46 errors / 96% coverage ] ****** [48 done /23 queued / 16 running / 46 errors / 96% coverage ] ****** [49 done /23 queued / 16 running / 47 errors / 96% coverage ] ****** [49 done /23 queued / 16 running / 47 errors / 96% coverage ] ****** [50 done /22 queued / 16 running / 48 errors / 96% coverage ] ****** [50 done /22 queued / 16 running / 48 errors / 96% coverage ] ****** [51 done /23 queued / 16 running / 49 errors / 96% coverage ] ****** [51 done /23 queued / 16 running / 49 errors / 96% coverage ] ****** [52 done /24 queued / 16 running / 50 errors / 96% coverage ] ****** [52 done /24 queued / 16 running / 50 errors / 96% coverage ] ****** [53 done /25 queued / 16 running / 51 errors / 96% coverage ] ****** [53 done /25 queued / 16 running / 51 errors / 96% coverage ] ****** [54 done /27 queued / 16 running / 52 errors / 96% coverage ] ****** [54 done /27 queued / 16 running / 52 errors / 96% coverage ] ****** [55 done /27 queued / 16 running / 53 errors / 96% coverage ] ****** [55 done /27 queued / 16 running / 53 errors / 96% coverage ] ****** [56 done /27 queued / 16 running / 54 errors / 96% coverage ] ****** [56 done /27 queued / 16 running / 54 errors / 96% coverage ] ****** [57 done /26 queued / 16 running / 55 errors / 96% coverage ] ****** [57 done /26 queued / 16 running / 55 errors / 96% coverage ] ****** [58 done /25 queued / 16 running / 56 errors / 96% coverage ] ****** [58 done /25 queued / 16 running / 56 errors / 96% coverage ] ****** [59 done /24 queued / 16 running / 57 errors / 96% coverage ] ****** [59 done /24 queued / 16 running / 57 errors / 96% coverage ] ****** [60 done /25 queued / 16 running / 58 errors / 96% coverage ] ****** [60 done /25 queued / 16 running / 58 errors / 96% coverage ] ****** [61 done /25 queued / 16 running / 59 errors / 96% coverage ] ****** [61 done /25 queued / 16 running / 59 errors / 96% coverage ] ****** [62 done /27 queued / 16 running / 60 errors / 96% coverage ] ****** [62 done /27 queued / 16 running / 60 errors / 96% coverage ] ****** [63 done /26 queued / 16 running / 61 errors / 96% coverage ] ****** [63 done /26 queued / 16 running / 61 errors / 96% coverage ] ****** [64 done /28 queued / 16 running / 62 errors / 96% coverage ] ****** [64 done /28 queued / 16 running / 62 errors / 96% coverage ] ****** [65 done /27 queued / 16 running / 63 errors / 96% coverage ] ****** [65 done /27 queued / 16 running / 63 errors / 96% coverage ] ****** [66 done /26 queued / 16 running / 64 errors / 96% coverage ] ****** [66 done /26 queued / 16 running / 64 errors / 96% coverage ] ****** [67 done /25 queued / 16 running / 65 errors / 96% coverage ] ****** [67 done /25 queued / 16 running / 65 errors / 96% coverage ] ****** [68 done /26 queued / 16 running / 66 errors / 96% coverage ] ****** [68 done /26 queued / 16 running / 66 errors / 96% coverage ] ****** [69 done /27 queued / 16 running / 67 errors / 96% coverage ] ****** [69 done /27 queued / 16 running / 67 errors / 96% coverage ] ****** [70 done /26 queued / 16 running / 68 errors / 96% coverage ] ****** [70 done /26 queued / 16 running / 68 errors / 96% coverage ] ****** [71 done /26 queued / 16 running / 69 errors / 96% coverage ] ****** [71 done /26 queued / 16 running / 69 errors / 96% coverage ] ****** [72 done /29 queued / 16 running / 70 errors / 96% coverage ] ****** [72 done /29 queued / 16 running / 70 errors / 96% coverage ] ****** [73 done /28 queued / 16 running / 71 errors / 96% coverage ] ****** [73 done /28 queued / 16 running / 71 errors / 96% coverage ] ****** [74 done /27 queued / 16 running / 72 errors / 96% coverage ] ****** [74 done /27 queued / 16 running / 72 errors / 96% coverage ] ****** [75 done /26 queued / 16 running / 73 errors / 96% coverage ] ****** [75 done /26 queued / 16 running / 73 errors / 96% coverage ] ****** [76 done /27 queued / 16 running / 74 errors / 96% coverage ] ****** [76 done /27 queued / 16 running / 74 errors / 96% coverage ] ****** [77 done /28 queued / 16 running / 75 errors / 96% coverage ] ****** [77 done /28 queued / 16 running / 75 errors / 96% coverage ] ****** [78 done /32 queued / 16 running / 76 errors / 96% coverage ] ****** [78 done /32 queued / 16 running / 76 errors / 96% coverage ] ****** [79 done /36 queued / 16 running / 76 errors / 96% coverage ] ****** [79 done /36 queued / 16 running / 76 errors / 96% coverage ] ****** [80 done /38 queued / 16 running / 77 errors / 96% coverage ] ****** [80 done /38 queued / 16 running / 77 errors / 96% coverage ] ****** [81 done /41 queued / 16 running / 78 errors / 96% coverage ] ****** [81 done /41 queued / 16 running / 78 errors / 96% coverage ] ****** [82 done /41 queued / 16 running / 79 errors / 96% coverage ] ****** [82 done /41 queued / 16 running / 79 errors / 96% coverage ] ****** [83 done /42 queued / 16 running / 80 errors / 96% coverage ] ****** [83 done /42 queued / 16 running / 80 errors / 96% coverage ] ****** [84 done /45 queued / 16 running / 81 errors / 96% coverage ] ****** [84 done /45 queued / 16 running / 81 errors / 96% coverage ] ****** [85 done /46 queued / 16 running / 82 errors / 96% coverage ] ****** [85 done /46 queued / 16 running / 82 errors / 96% coverage ] ****** [86 done /45 queued / 16 running / 83 errors / 96% coverage ] ****** [86 done /45 queued / 16 running / 83 errors / 96% coverage ] ****** [87 done /46 queued / 16 running / 84 errors / 96% coverage ] ****** [87 done /46 queued / 16 running / 84 errors / 96% coverage ] ****** [88 done /46 queued / 16 running / 85 errors / 96% coverage ] ****** [88 done /46 queued / 16 running / 85 errors / 96% coverage ] ****** [89 done /45 queued / 16 running / 86 errors / 96% coverage ] ****** [89 done /45 queued / 16 running / 86 errors / 96% coverage ] ****** [90 done /44 queued / 16 running / 87 errors / 96% coverage ] ****** [90 done /44 queued / 16 running / 87 errors / 96% coverage ] ****** [91 done /43 queued / 16 running / 88 errors / 96% coverage ] ****** [91 done /43 queued / 16 running / 88 errors / 96% coverage ] ****** [92 done /42 queued / 16 running / 89 errors / 96% coverage ] ****** [92 done /42 queued / 16 running / 89 errors / 96% coverage ] ****** [93 done /43 queued / 16 running / 90 errors / 96% coverage ] ****** [93 done /43 queued / 16 running / 90 errors / 96% coverage ] ****** [94 done /42 queued / 16 running / 91 errors / 96% coverage ] ****** [94 done /42 queued / 16 running / 91 errors / 96% coverage ] ****** [95 done /41 queued / 16 running / 92 errors / 96% coverage ] ****** [95 done /41 queued / 16 running / 92 errors / 96% coverage ] ****** [96 done /40 queued / 16 running / 93 errors / 96% coverage ] ****** [96 done /40 queued / 16 running / 93 errors / 96% coverage ] ****** [97 done /39 queued / 16 running / 94 errors / 96% coverage ] ****** [97 done /39 queued / 16 running / 94 errors / 96% coverage ] ****** [98 done /38 queued / 16 running / 94 errors / 96% coverage ] ****** [98 done /38 queued / 16 running / 94 errors / 96% coverage ] ****** [99 done /38 queued / 16 running / 94 errors / 96% coverage ] ****** [99 done /38 queued / 16 running / 94 errors / 96% coverage ] ****** [100 done /37 queued / 16 running / 95 errors / 96% coverage ] ****** [100 done /37 queued / 16 running / 95 errors / 96% coverage ] ****** [101 done /39 queued / 16 running / 96 errors / 96% coverage ] ****** [101 done /39 queued / 16 running / 96 errors / 96% coverage ] ****** [102 done /38 queued / 16 running / 97 errors / 96% coverage ] ****** [102 done /38 queued / 16 running / 97 errors / 96% coverage ] ****** [103 done /39 queued / 16 running / 98 errors / 96% coverage ] ****** [103 done /39 queued / 16 running / 98 errors / 96% coverage ] ****** [104 done /38 queued / 16 running / 99 errors / 96% coverage ] ****** [104 done /38 queued / 16 running / 99 errors / 96% coverage ] ****** [105 done /41 queued / 16 running / 100 errors / 96% coverage ] ****** [105 done /41 queued / 16 running / 100 errors / 96% coverage ] ****** [106 done /41 queued / 16 running / 101 errors / 96% coverage ] ****** [106 done /41 queued / 16 running / 101 errors / 96% coverage ] ****** [107 done /42 queued / 16 running / 102 errors / 96% coverage ] ****** [107 done /42 queued / 16 running / 102 errors / 96% coverage ] ****** [108 done /44 queued / 16 running / 103 errors / 96% coverage ] ****** [108 done /44 queued / 16 running / 103 errors / 96% coverage ] ****** [109 done /44 queued / 16 running / 103 errors / 96% coverage ] ****** [109 done /44 queued / 16 running / 103 errors / 96% coverage ] ****** [110 done /44 queued / 16 running / 103 errors / 96% coverage ] ****** [110 done /44 queued / 16 running / 103 errors / 96% coverage ] ****** [111 done /43 queued / 16 running / 104 errors / 96% coverage ] ****** [111 done /43 queued / 16 running / 104 errors / 96% coverage ] ****** [112 done /43 queued / 16 running / 105 errors / 96% coverage ] ****** [112 done /43 queued / 16 running / 105 errors / 96% coverage ] ****** [113 done /42 queued / 16 running / 106 errors / 96% coverage ] ****** [113 done /42 queued / 16 running / 106 errors / 96% coverage ] ****** [114 done /42 queued / 16 running / 107 errors / 96% coverage ] ****** [114 done /42 queued / 16 running / 107 errors / 96% coverage ] ****** [115 done /43 queued / 16 running / 108 errors / 96% coverage ] ****** [115 done /43 queued / 16 running / 108 errors / 96% coverage ] ****** [116 done /42 queued / 16 running / 108 errors / 96% coverage ] ****** [116 done /42 queued / 16 running / 108 errors / 96% coverage ] ****** [117 done /42 queued / 16 running / 109 errors / 96% coverage ] ****** [117 done /42 queued / 16 running / 109 errors / 96% coverage ] ****** [118 done /41 queued / 16 running / 109 errors / 96% coverage ] ****** [118 done /41 queued / 16 running / 109 errors / 96% coverage ] ****** [119 done /45 queued / 16 running / 110 errors / 96% coverage ] ****** [119 done /45 queued / 16 running / 110 errors / 96% coverage ] ****** [120 done /47 queued / 16 running / 111 errors / 96% coverage ] ****** [120 done /47 queued / 16 running / 111 errors / 96% coverage ] ****** [121 done /46 queued / 16 running / 112 errors / 96% coverage ] ****** [121 done /46 queued / 16 running / 112 errors / 96% coverage ] ****** [122 done /48 queued / 16 running / 113 errors / 96% coverage ] ****** [122 done /48 queued / 16 running / 113 errors / 96% coverage ] ****** [123 done /47 queued / 16 running / 113 errors / 96% coverage ] ****** [123 done /47 queued / 16 running / 113 errors / 96% coverage ] ****** [124 done /47 queued / 16 running / 114 errors / 96% coverage ] ****** [124 done /47 queued / 16 running / 114 errors / 96% coverage ] ****** [125 done /50 queued / 16 running / 115 errors / 96% coverage ] ****** [125 done /50 queued / 16 running / 115 errors / 96% coverage ] ****** [126 done /51 queued / 16 running / 116 errors / 96% coverage ] ****** [126 done /51 queued / 16 running / 116 errors / 96% coverage ] ****** [127 done /50 queued / 16 running / 117 errors / 96% coverage ] ****** [127 done /50 queued / 16 running / 117 errors / 96% coverage ] ****** [128 done /49 queued / 16 running / 118 errors / 96% coverage ] ****** [128 done /49 queued / 16 running / 118 errors / 96% coverage ] ****** [129 done /48 queued / 16 running / 119 errors / 96% coverage ] ****** [129 done /48 queued / 16 running / 119 errors / 96% coverage ] ****** [130 done /47 queued / 16 running / 120 errors / 96% coverage ] ****** [130 done /47 queued / 16 running / 120 errors / 96% coverage ] ****** [131 done /47 queued / 16 running / 121 errors / 96% coverage ] ****** [131 done /47 queued / 16 running / 121 errors / 96% coverage ] ****** [132 done /46 queued / 16 running / 122 errors / 96% coverage ] ****** [132 done /46 queued / 16 running / 122 errors / 96% coverage ] ****** [133 done /46 queued / 16 running / 123 errors / 96% coverage ] ****** [133 done /46 queued / 16 running / 123 errors / 96% coverage ] ****** [134 done /46 queued / 16 running / 124 errors / 96% coverage ] ****** [134 done /46 queued / 16 running / 124 errors / 96% coverage ] ****** [135 done /48 queued / 16 running / 125 errors / 96% coverage ] ****** [135 done /48 queued / 16 running / 125 errors / 96% coverage ] ****** [136 done /49 queued / 16 running / 126 errors / 96% coverage ] ****** [136 done /49 queued / 16 running / 126 errors / 96% coverage ] ****** [137 done /51 queued / 16 running / 127 errors / 96% coverage ] ****** [137 done /51 queued / 16 running / 127 errors / 96% coverage ] ****** [138 done /51 queued / 16 running / 128 errors / 96% coverage ] ****** [138 done /51 queued / 16 running / 128 errors / 96% coverage ] ****** [139 done /50 queued / 16 running / 129 errors / 96% coverage ] ****** [139 done /50 queued / 16 running / 129 errors / 96% coverage ] ****** [140 done /50 queued / 16 running / 130 errors / 96% coverage ] ****** [140 done /50 queued / 16 running / 130 errors / 96% coverage ] ****** [141 done /49 queued / 16 running / 131 errors / 96% coverage ] ****** [141 done /49 queued / 16 running / 131 errors / 96% coverage ] ****** [142 done /50 queued / 16 running / 132 errors / 96% coverage ] ****** [142 done /50 queued / 16 running / 132 errors / 96% coverage ] ****** [143 done /49 queued / 16 running / 133 errors / 96% coverage ] ****** [143 done /49 queued / 16 running / 133 errors / 96% coverage ] ****** [144 done /50 queued / 16 running / 134 errors / 96% coverage ] ****** [144 done /50 queued / 16 running / 134 errors / 96% coverage ] ****** [145 done /49 queued / 16 running / 135 errors / 96% coverage ] ****** [145 done /49 queued / 16 running / 135 errors / 96% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","toString","apply","bound ","call","bound stringify","TypeError","create","isArray","Array","join"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0,"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":0} start 0.0569 took 38.948s
*-- Errors occured in test {"_bound":0,"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":0}
* Error: TypeError: Cannot read property 'match' of undefined
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":0,"_bound":2} start 40.506 took 27.7002s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":0,"_bound":2}
* Error: TypeError: Cannot read property 'match' of null
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":0,"_bound":2}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":1,"_bound":3} start 40.7829 took 30.0573s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":1,"_bound":3}
* Error: TypeError: Cannot read property 'match' of undefined
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":1,"_bound":3}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":0,"_bound":1} start 40.1232 took 32.0872s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":0,"_bound":1}
* Error: TypeError: Cannot read property 'type' of undefined
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":0,"_bound":1}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_type_2":0,"_bound":3,"ExpansionArg_int":0} start 74.3495 took 31.3763s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_type_2":0,"_bound":3,"ExpansionArg_int":0}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_type_2":0,"_bound":3}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":2,"_bound":4,"ExpansionArg_int":0} start 69.4189 took 40.8019s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":2,"_bound":4,"ExpansionArg_int":0}
* Error: TypeError: Cannot read property 'match' of null
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":2,"_bound":4}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":2,"_bound":4,"ExpansionArg_int":0} start 73.7969 took 41.1849s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":2,"_bound":4,"ExpansionArg_int":0}
* Error: TypeError: Cannot read property 'type' of undefined
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":2,"_bound":4}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":0,"_bound":2} start 74.0767 took 44.1632s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":0,"_bound":2}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":0,"_bound":2}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_int":0,"ExpansionArg_type_2":0,"_bound":4} start 107.7889 took 29.382s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_int":0,"ExpansionArg_type_2":0,"_bound":4}
* Error: TypeError: Cannot read property 'type' of null
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_int":0,"ExpansionArg_type_2":0,"_bound":4}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_int":0,"ExpansionArg_type_2":0,"_bound":5,"ExpansionArg_string":"PureString"} start 106.9902 took 33.8439s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_int":0,"ExpansionArg_type_2":0,"_bound":5,"ExpansionArg_string":"PureString"}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_int":0,"ExpansionArg_type_2":0,"_bound":5}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":2,"ExpansionArg_int":3,"_bound":7} start 111.7039 took 37.7069s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":2,"ExpansionArg_int":3,"_bound":7}
* Error: TypeError: Cannot read property 'match' of null
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":2,"ExpansionArg_int":3,"_bound":7}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":1,"ExpansionArg_int":0,"_bound":5} start 113.3792 took 38.8535s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":1,"ExpansionArg_int":0,"_bound":5}
* Error: TypeError: Cannot read property 'match' of null
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":1,"ExpansionArg_int":0,"_bound":5}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_type_2":0,"_bound":3,"ExpansionArg_int":0} start 68.6911 took 84.6705s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_type_2":0,"_bound":3,"ExpansionArg_int":0}
* Error: TypeError: Function.prototype.apply was called on undefined, which is a undefined and not a function
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_type_2":0,"_bound":3}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":2,"_bound":4,"ExpansionArg_int":0} start 71.4003 took 85.6155s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":2,"_bound":4,"ExpansionArg_int":0}
* Error: TypeError: Cannot read property 'match' of undefined
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":2,"_bound":4}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":3,"ExpansionArg_type_2":0,"_bound":4,"ExpansionArg_string":"PureString"} start 121.5738 took 56.6408s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":3,"ExpansionArg_type_2":0,"_bound":4,"ExpansionArg_string":"PureString"}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":3,"ExpansionArg_type_2":0,"_bound":4}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_type_2":2,"_bound":5,"ExpansionArg_int":0} start 139.1249 took 42.4727s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_type_2":2,"_bound":5,"ExpansionArg_int":0}
* Error: TypeError: Cannot read property 'type' of null
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_type_2":2,"_bound":5}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_string":"","ExpansionArg_type_2":0,"_bound":6,"ExpansionArg_array_length":0} start 142.5676 took 49.8223s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_string":"","ExpansionArg_type_2":0,"_bound":6,"ExpansionArg_array_length":0}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_string":"","ExpansionArg_type_2":0,"_bound":6}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":4,"_bound":7,"ExpansionArg_array_length":0} start 143.5175 took 53.0906s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":4,"_bound":7,"ExpansionArg_array_length":0}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":4,"_bound":7}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":3,"ExpansionArg_int":0,"_bound":6,"ExpansionArg_string":"PureString"} start 112.6117 took 88.1442s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":3,"ExpansionArg_int":0,"_bound":6,"ExpansionArg_string":"PureString"}
* Error: TypeError: Cannot read property 'match' of null
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":3,"ExpansionArg_int":0,"_bound":6}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":3,"ExpansionArg_int":0,"_bound":6,"ExpansionArg_string":"PureString"} start 116.206 took 84.5514s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":3,"ExpansionArg_int":0,"_bound":6,"ExpansionArg_string":"PureString"}
* Error: TypeError: Cannot read property 'type' of undefined
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":3,"ExpansionArg_int":0,"_bound":6}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":3,"ExpansionArg_int":0,"ExpansionArg_type_2":0,"_bound":4,"ExpansionArg_string":"PureString","ExpandedSwitcher":0} start 154.2353 took 51.0198s
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":3,"_bound":6,"ExpansionArg_string":"PureString"} start 108.5307 took 96.7244s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":3,"_bound":6,"ExpansionArg_string":"PureString"}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":3,"_bound":6}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":3,"ExpansionArg_type":0,"ExpansionArg_type_2":0,"_bound":3} start 119.7505 took 90.9864s
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":3,"_bound":5,"ExpansionArg_string":"PureString"} start 120.6047 took 90.1323s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":3,"_bound":5,"ExpansionArg_string":"PureString"}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":3,"_bound":5}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":3,"_bound":5,"ExpansionArg_string":"PureString"} start 154.9772 took 55.7599s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":3,"_bound":5,"ExpansionArg_string":"PureString"}
* Error: TypeError: Function.prototype.apply was called on undefined, which is a undefined and not a function
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":3,"_bound":5}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":2,"ExpansionArg_int":3,"_bound":6} start 158.5452 took 59.8526s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":2,"ExpansionArg_int":3,"_bound":6}
* Error: TypeError: Cannot read property 'match' of undefined
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":2,"ExpansionArg_int":3,"_bound":6}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":3,"ExpansionArg_int":0,"_bound":5,"ExpansionArg_string":"PureString"} start 158.9898 took 59.4082s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":3,"ExpansionArg_int":0,"_bound":5,"ExpansionArg_string":"PureString"}
* Error: TypeError: Cannot read property 'match' of undefined
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":3,"ExpansionArg_int":0,"_bound":5}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":1,"ExpansionArg_int":0,"_bound":5} start 116.7367 took 101.6613s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":1,"ExpansionArg_int":0,"_bound":5}
* Error: TypeError: Cannot read property 'type' of undefined
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":1,"ExpansionArg_int":0,"_bound":5}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_string":"","ExpansionArg_type_2":0,"_bound":7,"ExpansionArg_array_length":0} start 179.3687 took 52.6583s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_string":"","ExpansionArg_type_2":0,"_bound":7,"ExpansionArg_array_length":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_string":"","ExpansionArg_type_2":0,"_bound":7}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":1,"ExpansionArg_string":"","ExpansionArg_type_2":0,"_bound":5} start 179.9373 took 59.5268s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":1,"ExpansionArg_string":"","ExpansionArg_type_2":0,"_bound":5}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":1,"ExpansionArg_string":"","ExpansionArg_type_2":0,"_bound":5}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_type_2":1,"ExpansionArg_int":0,"_bound":6} start 183.2171 took 57.9464s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_type_2":1,"ExpansionArg_int":0,"_bound":6}
* Error: TypeError: Cannot read property 'type' of null
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_type_2":1,"ExpansionArg_int":0,"_bound":6}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":7,"ExpansionArg_array_length":0} start 206.532 took 65.6308s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":7,"ExpansionArg_array_length":0}
* Error: TypeError: Cannot read property 'type' of undefined
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":7}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":8,"ExpansionArg_array_length":0} start 216.947 took 58.5762s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":8,"ExpansionArg_array_length":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":8}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":8,"ExpansionArg_array_length":0} start 219.493 took 56.0303s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":8,"ExpansionArg_array_length":0}
* Error: TypeError: Function.prototype.apply was called on undefined, which is a undefined and not a function
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":8}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_type_2":0,"_bound":8,"ExpansionArg_array_element_0_type":0} start 197.8088 took 86.7445s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_type_2":0,"_bound":8,"ExpansionArg_array_element_0_type":0}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_type_2":0,"_bound":8}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":5,"ExpansionArg_array_length":0,"ExpansionArg_type_2":0,"_bound":7,"ExpansionArg_bool":false} start 193.471 took 91.0825s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":5,"ExpansionArg_array_length":0,"ExpansionArg_type_2":0,"_bound":7,"ExpansionArg_bool":false}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":5,"ExpansionArg_array_length":0,"ExpansionArg_type_2":0,"_bound":7}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":2,"ExpansionArg_string":"","ExpansionArg_type_2":0,"_bound":6,"ExpansionArg_int":0} start 180.3007 took 104.2528s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":2,"ExpansionArg_string":"","ExpansionArg_type_2":0,"_bound":6,"ExpansionArg_int":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":2,"ExpansionArg_string":"","ExpansionArg_type_2":0,"_bound":6}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":3,"ExpansionArg_string":"","_bound":7} start 220.5023 took 64.0512s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":3,"ExpansionArg_string":"","_bound":7}
* Error: TypeError: Cannot read property 'match' of undefined
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":3,"ExpansionArg_string":"","_bound":7}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":3,"ExpansionArg_string":"","_bound":8} start 213.6774 took 85.3679s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":3,"ExpansionArg_string":"","_bound":8}
* Error: TypeError: Cannot read property 'match' of null
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":3,"ExpansionArg_string":"","_bound":8}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":3,"ExpansionArg_array_length":0,"_bound":10,"ExpansionArg_string_2":"PureString"} start 209.6 took 89.4453s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":3,"ExpansionArg_array_length":0,"_bound":10,"ExpansionArg_string_2":"PureString"}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":3,"ExpansionArg_array_length":0,"_bound":10}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":11,"ExpansionArg_bool":false} start 204.6026 took 94.4428s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":11,"ExpansionArg_bool":false}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":11}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":3,"ExpansionArg_string":"","_bound":9} start 242.7262 took 56.319s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":3,"ExpansionArg_string":"","_bound":9}
* Error: TypeError: Function.prototype.apply was called on undefined, which is a undefined and not a function
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":3,"ExpansionArg_string":"","_bound":9}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":7,"ExpansionArg_array_length":0} start 202.3267 took 96.7186s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":7,"ExpansionArg_array_length":0}
* Error: TypeError: Cannot read property 'match' of null
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":7}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":5,"ExpansionArg_array_length":0,"ExpansionArg_type_2":0,"_bound":8,"ExpansionArg_bool":false} start 240.3018 took 72.9285s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":5,"ExpansionArg_array_length":0,"ExpansionArg_type_2":0,"_bound":8,"ExpansionArg_bool":false}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":5,"ExpansionArg_array_length":0,"ExpansionArg_type_2":0,"_bound":8}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":4,"ExpansionArg_string":"","ExpansionArg_type_2":0,"ExpandedSwitcher":0,"_bound":5,"ExpansionArg_array_length":0} start 222.5919 took 90.6384s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":4,"ExpansionArg_string":"","ExpansionArg_type_2":0,"ExpandedSwitcher":0,"_bound":5,"ExpansionArg_array_length":0}
* Error: TypeError: Function.prototype.apply was called on undefined, which is a undefined and not a function
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":4,"ExpansionArg_string":"","ExpansionArg_type_2":0,"ExpandedSwitcher":0,"_bound":5}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":12,"ExpansionArg_array_element_0_type":0} start 211.8429 took 101.3874s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":12,"ExpansionArg_array_element_0_type":0}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":12}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_type_2":0,"_bound":9,"ExpansionArg_array_element_0_type":0} start 233.3684 took 85.8343s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_type_2":0,"_bound":9,"ExpansionArg_array_element_0_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_type_2":0,"_bound":9}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":9,"ExpansionArg_array_element_0_type":0} start 274.1541 took 74.3592s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":9,"ExpansionArg_array_element_0_type":0}
* Error: TypeError: Cannot read property 'type' of undefined
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":9}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":9,"ExpansionArg_bool":false} start 282.817 took 73.4677s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":9,"ExpansionArg_bool":false}
* Error: TypeError: Function.prototype.apply was called on undefined, which is a undefined and not a function
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":9}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":8,"ExpansionArg_bool":false} start 289.8127 took 68.0507s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":8,"ExpansionArg_bool":false}
* Error: TypeError: Cannot read property 'type' of undefined
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":8}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":10,"ExpansionArg_array_element_0_type":0} start 298.0079 took 72.2662s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":10,"ExpansionArg_array_element_0_type":0}
* Error: TypeError: Function.prototype.apply was called on undefined, which is a undefined and not a function
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":10}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":9,"ExpansionArg_array_length":0} start 303.96 took 70.8814s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":9,"ExpansionArg_array_length":0}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":9}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":10,"ExpansionArg_array_element_0_type":0} start 278.5367 took 100.9361s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":10,"ExpansionArg_array_element_0_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":10}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":0,"_bound":10,"ExpansionArg_array_element_1_type":0} start 286.3051 took 93.1679s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":0,"_bound":10,"ExpansionArg_array_element_1_type":0}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":0,"_bound":10}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":5,"ExpansionArg_array_length":0,"ExpansionArg_type_2":0,"_bound":6,"ExpansionArg_bool":false} start 318.3447 took 66.0648s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":5,"ExpansionArg_array_length":0,"ExpansionArg_type_2":0,"_bound":6,"ExpansionArg_bool":false}
* Error: TypeError: Function.prototype.apply was called on undefined, which is a undefined and not a function
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":5,"ExpansionArg_array_length":0,"ExpansionArg_type_2":0,"_bound":6}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":8,"ExpansionArg_bool":false} start 314.2548 took 70.1548s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":8,"ExpansionArg_bool":false}
* Error: TypeError: Cannot read property 'match' of null
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":8}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":9,"ExpansionArg_bool":false} start 294.2287 took 95.3828s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":9,"ExpansionArg_bool":false}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":9}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":1,"ExpansionArg_string":"","_bound":6} start 300.6826 took 90.6607s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":1,"ExpansionArg_string":"","_bound":6}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":1,"ExpansionArg_string":"","_bound":6}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":2,"ExpansionArg_array_length":0,"_bound":9,"ExpansionArg_int":0} start 306.5204 took 87.1409s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":2,"ExpansionArg_array_length":0,"_bound":9,"ExpansionArg_int":0}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":2,"ExpansionArg_array_length":0,"_bound":9}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":9,"ExpansionArg_array_element_0_type":0} start 310.3041 took 85.8252s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":9,"ExpansionArg_array_element_0_type":0}
* Error: TypeError: Cannot read property 'match' of null
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":9}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_type_2":3,"ExpansionArg_int":0,"_bound":7,"ExpansionArg_string":"PureString"} start 307.8089 took 108.4964s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_type_2":3,"ExpansionArg_int":0,"_bound":7,"ExpansionArg_string":"PureString"}
* Error: TypeError: Cannot read property 'type' of null
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_type_2":3,"ExpansionArg_int":0,"_bound":7}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":0,"_bound":11,"ExpansionArg_array_element_1_type":0} start 319.8812 took 98.6075s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":0,"_bound":11,"ExpansionArg_array_element_1_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":0,"_bound":11}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":1,"ExpansionArg_string":"","_bound":7} start 350.1922 took 68.3005s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":1,"ExpansionArg_string":"","_bound":7}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":1,"ExpansionArg_string":"","_bound":7}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_type_2":0,"_bound":7,"ExpansionArg_array_element_0_type":0} start 316.3567 took 106.8743s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_type_2":0,"_bound":7,"ExpansionArg_array_element_0_type":0}
* Error: TypeError: Function.prototype.apply was called on undefined, which is a undefined and not a function
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_type_2":0,"_bound":7}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":1,"ExpansionArg_array_length":0,"_bound":8} start 372.3614 took 71.1083s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":1,"ExpansionArg_array_length":0,"_bound":8}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":1,"ExpansionArg_array_length":0,"_bound":8}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":2,"ExpansionArg_string":"","_bound":8,"ExpansionArg_int_2":0} start 380.9268 took 65.5944s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":2,"ExpansionArg_string":"","_bound":8,"ExpansionArg_int_2":0}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":2,"ExpansionArg_string":"","_bound":8}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":5,"ExpansionArg_bool":true,"_bound":10} start 357.2428 took 99.085s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":5,"ExpansionArg_bool":true,"_bound":10}
* Error: TypeError: Function.prototype.apply was called on undefined, which is a undefined and not a function
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":5,"ExpansionArg_bool":true,"_bound":10}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":11,"ExpansionArg_array_element_0_type":0} start 394.2407 took 65.4216s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":11,"ExpansionArg_array_element_0_type":0}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":11}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":6,"ExpansionArg_array_length":0} start 358.573 took 109.6424s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":6,"ExpansionArg_array_length":0}
* Error: TypeError: Cannot read property 'match' of undefined
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":6}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":10,"ExpansionArg_bool":false} start 376.9603 took 101.9339s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":10,"ExpansionArg_bool":false}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":10}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":2,"ExpansionArg_string":"","_bound":7,"ExpansionArg_int_2":0} start 391.8532 took 89.6489s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":2,"ExpansionArg_string":"","_bound":7,"ExpansionArg_int_2":0}
* Error: TypeError: Function.prototype.apply was called on undefined, which is a undefined and not a function
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":2,"ExpansionArg_string":"","_bound":7}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":5,"_bound":9,"ExpansionArg_bool":false} start 424.1848 took 60.2851s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":5,"_bound":9,"ExpansionArg_bool":false}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":5,"_bound":9}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":2,"ExpansionArg_string":"","_bound":7,"ExpansionArg_int":0} start 383.6932 took 100.7768s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":2,"ExpansionArg_string":"","_bound":7,"ExpansionArg_int":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":2,"ExpansionArg_string":"","_bound":7}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":1,"ExpansionArg_string":"","_bound":6} start 385.8863 took 105.6517s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":1,"ExpansionArg_string":"","_bound":6}
* Error: TypeError: Function.prototype.apply was called on undefined, which is a undefined and not a function
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":1,"ExpansionArg_string":"","_bound":6}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":5,"ExpansionArg_bool":true,"_bound":9} start 387.857 took 103.6811s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":5,"ExpansionArg_bool":true,"_bound":9}
* Error: TypeError: Cannot read property 'match' of null
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":5,"ExpansionArg_bool":true,"_bound":9}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"_bound":11,"ExpansionArg_array_element_1_type":0} start 390.4783 took 101.0599s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"_bound":11,"ExpansionArg_array_element_1_type":0}
* Error: TypeError: Cannot read property 'type' of undefined
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"_bound":11}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":8,"ExpansionArg_array_length":0} start 417.1004 took 74.4378s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":8,"ExpansionArg_array_length":0}
* Error: TypeError: Cannot read property 'type' of null
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_type_2":4,"ExpansionArg_string":"","_bound":8}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":4,"_bound":8,"ExpansionArg_array_length":0} start 396.5421 took 104.6133s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":4,"_bound":8,"ExpansionArg_array_length":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":4,"_bound":8}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":4,"ExpandedSwitcher":0,"_bound":6,"ExpansionArg_array_length":0} start 419.0371 took 91.7349s
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_type_2":0,"_bound":12,"ExpansionArg_array_element_2_type":0} start 444.7733 took 70.1018s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_type_2":0,"_bound":12,"ExpansionArg_array_element_2_type":0}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_type_2":0,"_bound":12}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":2,"ExpansionArg_type_2":0,"_bound":9,"ExpansionArg_array_element_0_int":0} start 446.9825 took 72.4603s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":2,"ExpansionArg_type_2":0,"_bound":9,"ExpansionArg_array_element_0_int":0}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":2,"ExpansionArg_type_2":0,"_bound":9}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":7,"ExpansionArg_bool":false} start 469.1321 took 55.3159s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":7,"ExpansionArg_bool":false}
* Error: TypeError: Cannot read property 'match' of undefined
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":7}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"_bound":14,"ExpansionArg_array_element_1_type":0} start 421.1145 took 107.1824s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"_bound":14,"ExpansionArg_array_element_1_type":0}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"_bound":14}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":5,"_bound":10,"ExpansionArg_bool":false} start 460.8792 took 72.7761s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":5,"_bound":10,"ExpansionArg_bool":false}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":5,"_bound":10}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":2,"_bound":11,"ExpansionArg_int":0} start 458.6681 took 86.2523s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":2,"_bound":11,"ExpansionArg_int":0}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":2,"_bound":11}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":3,"ExpansionArg_bool":false,"_bound":12,"ExpansionArg_string":"PureString"} start 495.6175 took 62.1861s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":3,"ExpansionArg_bool":false,"_bound":12,"ExpansionArg_string":"PureString"}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":3,"ExpansionArg_bool":false,"_bound":12}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"_bound":12,"ExpansionArg_array_element_1_type":0} start 480.2244 took 81.707s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"_bound":12,"ExpansionArg_array_element_1_type":0}
* Error: TypeError: Function.prototype.apply was called on undefined, which is a undefined and not a function
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"_bound":12}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":4,"ExpansionArg_bool":false,"_bound":13,"ExpansionArg_array_length_2":0} start 485.5807 took 93.8009s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":4,"ExpansionArg_bool":false,"_bound":13,"ExpansionArg_array_length_2":0}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":4,"ExpansionArg_bool":false,"_bound":13}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":2,"ExpansionArg_int_2":1,"_bound":8} start 483.0061 took 99.4991s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":2,"ExpansionArg_int_2":1,"_bound":8}
* Error: TypeError: Function.prototype.apply was called on undefined, which is a undefined and not a function
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":2,"ExpansionArg_int_2":1,"_bound":8}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":5,"ExpansionArg_bool":true,"_bound":8} start 524.9689 took 61.3187s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":5,"ExpansionArg_bool":true,"_bound":8}
* Error: TypeError: Cannot read property 'match' of undefined
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":0,"ExpansionArg_type_2":5,"ExpansionArg_bool":true,"_bound":8}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":2,"ExpansionArg_bool":false,"_bound":11,"ExpansionArg_int":0} start 492.1912 took 99.1202s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":2,"ExpansionArg_bool":false,"_bound":11,"ExpansionArg_int":0}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":2,"ExpansionArg_bool":false,"_bound":11}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":1,"ExpansionArg_bool":false,"_bound":10} start 489.6711 took 101.7056s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":1,"ExpansionArg_bool":false,"_bound":10}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":1,"ExpansionArg_bool":false,"_bound":10}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"_bound":12,"ExpansionArg_array_element_1_type":0} start 497.9487 took 97.6609s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"_bound":12,"ExpansionArg_array_element_1_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":0,"ExpansionArg_type_2":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"_bound":12}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":1,"ExpansionArg_array_length":0,"_bound":9} start 502.5487 took 99.8526s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":1,"ExpansionArg_array_length":0,"_bound":9}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":1,"ExpansionArg_array_length":0,"_bound":9}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":9,"ExpansionArg_bool":false} start 500.6181 took 109.4489s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":9,"ExpansionArg_bool":false}
* Error: TypeError: Cannot read property 'type' of null
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":9}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":12,"ExpansionArg_bool":false} start 517.0646 took 97.6989s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":12,"ExpansionArg_bool":false}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"_bound":12}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":3,"ExpansionArg_array_length":0,"_bound":11,"ExpansionArg_string_2":"PureString"} start 512.7278 took 104.3693s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":3,"ExpansionArg_array_length":0,"_bound":11,"ExpansionArg_string_2":"PureString"}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":3,"ExpansionArg_array_length":0,"_bound":11}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":1,"ExpansionArg_array_length":0,"ExpandedSwitcher":0,"_bound":7} start 522.4969 took 98.1401s
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":3,"ExpansionArg_array_length":0,"ExpandedSwitcher":0,"_bound":9,"ExpansionArg_string_2":"PureString"} start 529.7889 took 100.7518s
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":1,"ExpansionArg_int":0,"_bound":12} start 564.1614 took 71.4639s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":1,"ExpansionArg_int":0,"_bound":12}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":1,"ExpansionArg_int":0,"_bound":12}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_int":0,"ExpansionArg_type_2":0,"_bound":11,"ExpansionArg_array_element_0_string":"PureString"} start 545.5176 took 90.1077s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_int":0,"ExpansionArg_type_2":0,"_bound":11,"ExpansionArg_array_element_0_string":"PureString"}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_int":0,"ExpansionArg_type_2":0,"_bound":11}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":3,"ExpansionArg_bool":false,"_bound":13,"ExpansionArg_string":"PureString"} start 536.215 took 113.1541s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":3,"ExpansionArg_bool":false,"_bound":13,"ExpansionArg_string":"PureString"}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":3,"ExpansionArg_bool":false,"_bound":13}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_0_int":0,"ExpansionArg_type_2":0,"_bound":10} start 588.3635 took 77.7441s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_0_int":0,"ExpansionArg_type_2":0,"_bound":10}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_0_int":0,"ExpansionArg_type_2":0,"_bound":10}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":2,"ExpansionArg_array_length":0,"_bound":10,"ExpansionArg_int":0} start 559.2164 took 110.5164s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":2,"ExpansionArg_array_length":0,"_bound":10,"ExpansionArg_int":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":2,"ExpansionArg_array_length":0,"_bound":10}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":5,"ExpansionArg_bool":false,"ExpansionArg_type_2":6,"_bound":8,"ExpansionArg_bool_2":false} start 618.0941 took 60.5313s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":5,"ExpansionArg_bool":false,"ExpansionArg_type_2":6,"_bound":8,"ExpansionArg_bool_2":false}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":5,"ExpansionArg_bool":false,"ExpansionArg_type_2":6,"_bound":8}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":3,"ExpansionArg_int":0,"_bound":13,"ExpansionArg_string":"PureString"} start 594.8578 took 89.0645s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":3,"ExpansionArg_int":0,"_bound":13,"ExpansionArg_string":"PureString"}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":3,"ExpansionArg_int":0,"_bound":13}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"_bound":11,"ExpansionArg_array_element_1_type":0} start 615.5425 took 71.2311s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"_bound":11,"ExpansionArg_array_element_1_type":0}
* Error: TypeError: Cannot read property 'match' of null
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":1,"ExpansionArg_type_2":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"_bound":11}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":1,"ExpansionArg_type_2":3,"_bound":6,"ExpansionArg_string":"PureString"} start 597.2188 took 99.8619s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":1,"ExpansionArg_type_2":3,"_bound":6,"ExpansionArg_string":"PureString"}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":1,"ExpansionArg_type_2":3,"_bound":6}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":5,"ExpansionArg_array_length":0,"ExpandedSwitcher":0,"_bound":10,"ExpansionArg_bool":false} start 583.5812 took 116.5442s
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":2,"ExpansionArg_array_length":0,"ExpandedSwitcher":0,"_bound":8,"ExpansionArg_int":0} start 593.3305 took 106.7958s
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":2,"ExpansionArg_bool":false,"_bound":12,"ExpansionArg_int":0} start 602.9659 took 107.921s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":2,"ExpansionArg_bool":false,"_bound":12,"ExpansionArg_int":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":2,"ExpansionArg_bool":false,"_bound":12}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":4,"ExpansionArg_bool":false,"_bound":14,"ExpansionArg_array_length_2":0} start 580.2952 took 134.4994s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":4,"ExpansionArg_bool":false,"_bound":14,"ExpansionArg_array_length_2":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":4,"ExpansionArg_bool":false,"_bound":14}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":1,"ExpansionArg_bool":false,"_bound":11} start 610.6563 took 106.315s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":1,"ExpansionArg_bool":false,"_bound":11}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":1,"ExpansionArg_bool":false,"_bound":11}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":1,"_bound":7} start 621.3271 took 106.403s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":1,"_bound":7}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":1,"_bound":7}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":10,"ExpansionArg_array_element_0_type":0} start 666.7875 took 64.447s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":10,"ExpansionArg_array_element_0_type":0}
* Error: TypeError: Cannot read property 'type' of null
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":1,"ExpansionArg_type_2":4,"ExpansionArg_array_length":1,"_bound":10}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":3,"ExpansionArg_string_2":"","ExpandedSwitcher":0,"_bound":10} start 633.3238 took 97.9107s
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":5,"ExpansionArg_string":"","_bound":14,"ExpansionArg_bool":false} start 684.8503 took 50.5608s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":5,"ExpansionArg_string":"","_bound":14,"ExpansionArg_bool":false}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":5,"ExpansionArg_string":"","_bound":14}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":5,"ExpansionArg_bool":true,"ExpandedSwitcher":0,"_bound":11} start 700.7494 took 48.0664s
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":5,"_bound":8,"ExpansionArg_bool":false} start 636.8736 took 113.4287s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":5,"_bound":8,"ExpansionArg_bool":false}
* Error: TypeError: Function.prototype.apply was called on undefined, which is a undefined and not a function
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":4,"ExpansionArg_array_length":0,"ExpansionArg_type_2":5,"_bound":8}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_string":"","ExpansionArg_type_2":0,"_bound":12,"ExpansionArg_array_element_0_bool":false} start 641.0863 took 111.7871s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_string":"","ExpansionArg_type_2":0,"_bound":12,"ExpansionArg_array_element_0_bool":false}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_string":"","ExpansionArg_type_2":0,"_bound":12}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":5,"ExpansionArg_bool":false,"ExpansionArg_type_2":1,"ExpansionArg_bool_2":false,"_bound":9} start 687.5052 took 70.9676s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":5,"ExpansionArg_bool":false,"ExpansionArg_type_2":1,"ExpansionArg_bool_2":false,"_bound":9}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":5,"ExpansionArg_bool":false,"ExpansionArg_type_2":1,"ExpansionArg_bool_2":false,"_bound":9}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":0,"_bound":9,"ExpansionArg_array_element_1_type":0} start 650.4852 took 111.2805s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":0,"_bound":9,"ExpansionArg_array_element_1_type":0}
* Error: TypeError: Function.prototype.apply was called on undefined, which is a undefined and not a function
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_type_2":0,"_bound":9}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":0,"ExpansionArg_type":3,"ExpansionArg_string":"","ExpansionArg_type_2":2,"ExpansionArg_int":1,"ExpandedSwitcher":0,"_bound":9} start 702.5351 took 64.4521s
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":5,"ExpansionArg_bool":false,"ExpansionArg_type_2":4,"ExpansionArg_bool_2":false,"_bound":12,"ExpansionArg_array_length":0} start 679.6354 took 90.9962s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":5,"ExpansionArg_bool":false,"ExpansionArg_type_2":4,"ExpansionArg_bool_2":false,"_bound":12,"ExpansionArg_array_length":0}
* Error: TypeError: argument must be a Program parse node
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":1,"ExpansionArg_type":5,"ExpansionArg_bool":false,"ExpansionArg_type_2":4,"ExpansionArg_bool_2":false,"_bound":12}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":5,"ExpansionArg_bool":false,"ExpansionArg_type_2":6,"_bound":9,"ExpansionArg_bool_2":false} start 671.4583 took 105.0112s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":5,"ExpansionArg_bool":false,"ExpansionArg_type_2":6,"_bound":9,"ExpansionArg_bool_2":false}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":5,"ExpansionArg_bool":false,"ExpansionArg_type_2":6,"_bound":9}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":3,"_bound":8,"ExpansionArg_string":"PureString"} start 728.5554 took 52.3151s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":3,"_bound":8,"ExpansionArg_string":"PureString"}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":2,"ExpansionArg_int":0,"ExpansionArg_type_2":3,"_bound":8}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":1,"ExpansionArg_type_2":2,"ExpansionArg_string":"","_bound":8,"ExpansionArg_int":0} start 732.1324 took 55.1356s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":1,"ExpansionArg_type_2":2,"ExpansionArg_string":"","_bound":8,"ExpansionArg_int":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":1,"ExpansionArg_type_2":2,"ExpansionArg_string":"","_bound":8}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":1,"ExpansionArg_type_2":1,"ExpansionArg_string":"","_bound":7} start 715.2495 took 78.358s
*-- Errors occured in test {"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":1,"ExpansionArg_type_2":1,"ExpansionArg_string":"","_bound":7}
* Error: Tropigate failed because SyntaxError: Unexpected token (222:24) on program var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

 at SyntaxError: Unexpected token (222:24)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$2.parseMaybeDefault (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1455:25)
    at Parser.pp$2.parseBindingList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1440:27)
    at Parser.pp$1.parseFunctionParams (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1072:24)
    at Parser.parseFunctionParams (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:24:19)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1064:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":false,"Target_Switch_Base":2,"ExpansionArg_type":1,"ExpansionArg_type_2":1,"ExpansionArg_string":"","_bound":7}'
