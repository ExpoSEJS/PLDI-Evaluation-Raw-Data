
> keygrip@0.2.4 install /root/Targets/katana/node_modules/keygrip
> [ -x /usr/bin/nodejs ] && /usr/bin/nodejs ./install.js || node ./install.js

/root/Targets/katana
└─┬ katana@0.4.3 
  ├── async@0.2.10 
  ├─┬ co-prompt@1.0.0 
  │ └── keypress@0.2.1 
  ├── colors@0.6.2 
  ├─┬ commander@1.3.2 
  │ └── keypress@0.1.0 
  ├── cookies@0.3.8 
  ├── crypto@0.0.3 
  ├── formidable@1.0.17 
  ├── keygrip@0.2.4 
  ├── mime@1.2.11 
  ├── mkdirp@0.3.5 
  ├─┬ node-static@0.7.10 
  │ └─┬ optimist@0.6.1 
  │   ├── minimist@0.0.10 
  │   └── wordwrap@0.0.3 
  ├── progress@1.1.8 
  ├── qs@0.5.6 
  ├─┬ request@2.16.6 
  │ ├── aws-sign@0.2.0 
  │ ├── cookie-jar@0.2.0 
  │ ├── forever-agent@0.2.0 
  │ ├─┬ form-data@0.0.10 
  │ │ └─┬ combined-stream@0.0.7 
  │ │   └── delayed-stream@0.0.5 
  │ ├─┬ hawk@0.10.2 
  │ │ ├── boom@0.3.8 
  │ │ ├── cryptiles@0.1.3 
  │ │ ├── hoek@0.7.6 
  │ │ └── sntp@0.1.4 
  │ ├── json-stringify-safe@3.0.0 
  │ ├── node-uuid@1.4.8 
  │ ├── oauth-sign@0.2.0 
  │ └── tunnel-agent@0.2.0 
  ├── semver@1.1.4 
  ├─┬ tar@0.1.20 
  │ ├── block-stream@0.0.9 
  │ ├─┬ fstream@0.1.31 
  │ │ ├─┬ graceful-fs@3.0.11 
  │ │ │ └── natives@1.1.0 
  │ │ ├─┬ mkdirp@0.5.1 
  │ │ │ └── minimist@0.0.8 
  │ │ └─┬ rimraf@2.6.2 
  │ │   └─┬ glob@7.1.2 
  │ │     ├── fs.realpath@1.0.0 
  │ │     ├─┬ inflight@1.0.6 
  │ │     │ └── wrappy@1.0.2 
  │ │     ├─┬ minimatch@3.0.4 
  │ │     │ └─┬ brace-expansion@1.1.8 
  │ │     │   ├── balanced-match@1.0.0 
  │ │     │   └── concat-map@0.0.1 
  │ │     ├── once@1.4.0 
  │ │     └── path-is-absolute@1.0.1 
  │ └── inherits@2.0.3 
  ├── underscore@1.4.4 
  ├── validator@0.4.28 
  └─┬ winston@0.7.3 
    ├── cycle@1.0.3 
    ├── eyes@0.1.8 
    ├── pkginfo@0.3.1 
    └── stack-trace@0.0.10 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/katana/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 21% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","call","join","RegExp","sort"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0431 took 14.1102s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Invalid number (121:28) on program var Path = require('path');
var Fs   = require('fs');

var async = require('async');

var join      = Path.join;
var normalize = Path.normalize;
var dirname   = Path.dirname;
var basename  = Path.basename;
var extension = Path.extname;

var sep = Path.sep;

// https://github.com/nodeca/fs-tools/blob/master/lib/fs-tools.js
var utils = module.exports;

utils.walkFlat = function(path, iterator, callback) {
  Fs.readdir(path, function(error, files) {
    if (error) {
      return callback(error.code==='ENOENT' ? null : error);
    }

    async.forEach(files, function(file, next) {
      iterator(join(path, file), next);
    }, callback);
  });
}

utils.walkDeep = function(path, match, iterator, callback) {
  utils.walkFlat(normalize(path), function(path, next) {
    Fs.lstat(path, function(error, stats) {
      if (error) {
        return next(error);
      }

      if (match(path, stats)) {
        if (stats.isDirectory()) {
          iterator(path, stats, function() {
            utils.walkDeep(path, match, iterator, next);
          });
        } else {
          iterator(path, stats, next);
        }

        return;
      }

      next();
    });
  }, callback);
}

utils.copyFile = function(source, destination, callback) {
  var _done = false;
  function done() {
    if (!_done) {
      _done = true; callback.apply(callback, arguments);
    }
  }

  var read  = Fs.createReadStream(source, { bufferSize: 64 * 1024 }).on('error', done);
  var write = Fs.createWriteStream(destination).on('error', done).on('close', done);

  read.pipe(write);
}

utils.walk = function(path, pattern, iterator, callback) {
  if (!callback) {
    callback = iterator; iterator = pattern; pattern = null;
  }

  if (!pattern) {
    var match = function() { return true; }
  } else if (typeof(pattern) === 'function') {
    var match = pattern;
  } else {
    pattern = new RegExp(pattern);
    var match = function(path) { return pattern.test(path); }
  }

  path = normalize(path);

  Fs.lstat(path, function(error, stats) {
    if (error) {
      return callback(error.code==='ENOENT' ? null : error);
    }

    if (!stats.isDirectory()) {
      return callback(new Error('Path is not a directory!'));
    }

    utils.walkDeep(path, match, iterator, callback);
  });
}

utils.remove = function(path, callback) {
  path = normalize(path);

  Fs.lstat(path, function(error, stats) {
    if (error) {
      return callback(error.code==='ENOENT' ? null : error);
    }

    if (!stats.isDirectory()) {
      return Fs.unlink(path, callback);
    }

    async.series([
      async.apply(utils.walkFlat, path, utils.remove),
      async.apply(Fs.rmdir, path)
    ], function(error) {
      callback(error);
    });
  });
}

utils.mkdir = function(path, mode, callback) {
  path = normalize(path);

  if (typeof(mode) === 'function') {
    callback = mode; mode = 0755;
  } else if (typeof(mode) === 'string') {
    mode = parseInt(mode, 8);
  }

  Fs.exists(path, function(exists) {
    if (exists) {
      return callback();
    }

    var parent = dirname(path);

    utils.mkdir(parent, mode, function(error) {
      if (error) {
        return callback(error);
      }

      Fs.mkdir(path, mode, function(error) {
        if (error && error.code==='EEXIST') {
          return callback();
        }

        callback(error);
      });
    });
  });
}

utils.copy = function(source, destination, callback) {
  source      = normalize(source);
  destination = normalize(destination);

  if (source === destination) {
    return callback();
  }

  Fs.lstat(source, function(error, stats) {
    if (error) {
      return callback(error);
    }

    utils.mkdir(dirname(destination), function(error) {
      if (error) {
        return callback(error);
      }

      var chmod = async.apply(Fs.chmod, destination, stats.mode);
      var done  = function(error) { callback(error); }

      if (stats.isFile()) {
        return async.series([async.apply(utils.copyFile, source, destination), chmod], done);
      }

      if (stats.isSymbolicLink()) {
        return async.waterfall([
          function(next) {
            Fs.exists(destination, function(exists) {
              if (exists) {
                return utils.remove(destination, next);
              }

              next();
            });
          },
          async.apply(Fs.readlink, source),
          function(path, next) {
            Fs.symlink(path, destination, next);
          },
          chmod
        ], done);
      }

      if (stats.isDirectory()) {
        return async.series([
          function(next) {
            Fs.mkdir(destination, 0755, function(error) {
              if (error && error.code==='EEXISTS') {
                return next();
              }

              next(error);
            });
          },
          async.apply(utils.walkFlat, source, function(path, next) {
            utils.copy(path, destination + sep + path.replace(source, ''), next);
          }),
          chmod
        ], done);
      }

      callback(new Error('Unsupported type of the source'));
    });
  });
}

utils.move = function(source, destination, callback) {
  Fs.rename(source, destination, function(error) {
    if (!error) {
      return callback();
    }

    async.series([
      async.apply(utils.copy, source, destination),
      async.apply(utils.remove, source)
    ], function(error) {
      callback(error);
    });
  });
}

utils.find = function(path, options, callback) {
  var files = [];

  if (!callback) {
    callback = options; options = {};
  }

  if (typeof(options) === 'function') {
    options = {
      pattern: options
    };
  }

  options.filesOnly===undefined && (options.filesOnly = true);
  options.hiddens===undefined && (options.hiddens = false);

  utils.walk(path, options.pattern, function(file, stats, next) {
    if (options.filesOnly && stats.isDirectory()) {
      return next();
    }

    var name = basename(file, extension(file));
    if (!options.hiddens && (!name || name[0]==='.')) {
      return next();
    }

    files.push(file);

    next();
  }, function(error) {
    callback(error, files);
  });
}
 at SyntaxError: Invalid number (121:28)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$7.readNumber (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2896:52)
    at Parser.pp$7.getTokenFromCode (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2720:19)
    at Parser.pp$7.readToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2477:17)
    at Parser.readToken (/root/ExpoSE/lib/Tropigate/bin/Tokens.js:124:26)
    at Parser.pp$7.nextToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2468:15)
    at Parser.pp$7.next (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2413:10)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1607:12)
    at Parser.pp$3.parseExpression (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1573:21)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:727:47)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/katana/node_modules/katana/lib/katana.js. Coverage (Term): 4% Coverage (LOC): 4%
*- File /root/Targets/katana/node_modules/async/lib/async.js. Coverage (Term): 11% Coverage (LOC): 16%
*- File /root/Targets/katana/node_modules/underscore/underscore.js. Coverage (Term): 18% Coverage (LOC): 32%
*- File /root/Targets/katana/node_modules/qs/index.js. Coverage (Term): 6% Coverage (LOC): 13%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
