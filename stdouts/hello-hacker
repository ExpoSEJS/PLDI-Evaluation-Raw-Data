
> leveldown@1.7.2 install /root/Targets/hello-hacker/node_modules/leveldown
> prebuild-install || node-gyp rebuild


> spi@0.2.0 install /root/Targets/hello-hacker/node_modules/spi
> node-gyp rebuild

make: Entering directory '/root/Targets/hello-hacker/node_modules/spi/build'
  CXX(target) Release/obj.target/_spi/src/spi_binding.o
  SOLINK_MODULE(target) Release/obj.target/_spi.node
  COPY Release/_spi.node
make: Leaving directory '/root/Targets/hello-hacker/node_modules/spi/build'
/root/Targets/hello-hacker
└─┬ hello-hacker@0.0.3 
  ├─┬ browserify@14.4.0 
  │ ├── assert@1.4.1 
  │ ├─┬ browser-pack@6.0.2 
  │ │ ├─┬ combine-source-map@0.7.2 
  │ │ │ ├── convert-source-map@1.1.3 
  │ │ │ ├── inline-source-map@0.6.2 
  │ │ │ ├── lodash.memoize@3.0.4 
  │ │ │ └── source-map@0.5.7 
  │ │ └── umd@3.0.1 
  │ ├─┬ browser-resolve@1.11.2 
  │ │ └── resolve@1.1.7 
  │ ├─┬ browserify-zlib@0.1.4 
  │ │ └── pako@0.2.9 
  │ ├─┬ buffer@5.0.7 
  │ │ ├── base64-js@1.2.1 
  │ │ └── ieee754@1.1.8 
  │ ├── cached-path-relative@1.0.1 
  │ ├─┬ concat-stream@1.5.2 
  │ │ ├─┬ readable-stream@2.0.6 
  │ │ │ └── string_decoder@0.10.31 
  │ │ └── typedarray@0.0.6 
  │ ├─┬ console-browserify@1.1.0 
  │ │ └── date-now@0.1.4 
  │ ├── constants-browserify@1.0.0 
  │ ├─┬ crypto-browserify@3.11.1 
  │ │ ├─┬ browserify-cipher@1.0.0 
  │ │ │ ├─┬ browserify-aes@1.0.8 
  │ │ │ │ └── buffer-xor@1.0.3 
  │ │ │ ├─┬ browserify-des@1.0.0 
  │ │ │ │ └── des.js@1.0.0 
  │ │ │ └─┬ evp_bytestokey@1.0.3 
  │ │ │   └─┬ md5.js@1.3.4 
  │ │ │     └── hash-base@3.0.4 
  │ │ ├─┬ browserify-sign@4.0.4 
  │ │ │ ├── bn.js@4.11.8 
  │ │ │ ├── browserify-rsa@4.0.1 
  │ │ │ ├─┬ elliptic@6.4.0 
  │ │ │ │ ├── brorand@1.1.0 
  │ │ │ │ ├── hash.js@1.1.3 
  │ │ │ │ ├── hmac-drbg@1.0.1 
  │ │ │ │ ├── minimalistic-assert@1.0.0 
  │ │ │ │ └── minimalistic-crypto-utils@1.0.1 
  │ │ │ └─┬ parse-asn1@5.1.0 
  │ │ │   └── asn1.js@4.9.1 
  │ │ ├── create-ecdh@4.0.0 
  │ │ ├─┬ create-hash@1.1.3 
  │ │ │ ├── cipher-base@1.0.4 
  │ │ │ └─┬ ripemd160@2.0.1 
  │ │ │   └── hash-base@2.0.2 
  │ │ ├── create-hmac@1.1.6 
  │ │ ├─┬ diffie-hellman@5.0.2 
  │ │ │ └── miller-rabin@4.0.1 
  │ │ ├── pbkdf2@3.0.14 
  │ │ ├── public-encrypt@4.0.0 
  │ │ └── randombytes@2.0.5 
  │ ├── defined@1.0.0 
  │ ├── deps-sort@2.0.0 
  │ ├── domain-browser@1.1.7 
  │ ├── duplexer2@0.1.4 
  │ ├── events@1.1.1 
  │ ├─┬ glob@7.1.2 
  │ │ ├── fs.realpath@1.0.0 
  │ │ ├─┬ inflight@1.0.6 
  │ │ │ └── wrappy@1.0.2 
  │ │ ├─┬ minimatch@3.0.4 
  │ │ │ └─┬ brace-expansion@1.1.8 
  │ │ │   ├── balanced-match@1.0.0 
  │ │ │   └── concat-map@0.0.1 
  │ │ ├── once@1.4.0 
  │ │ └── path-is-absolute@1.0.1 
  │ ├─┬ has@1.0.1 
  │ │ └── function-bind@1.1.1 
  │ ├── htmlescape@1.1.1 
  │ ├── https-browserify@1.0.0 
  │ ├── inherits@2.0.3 
  │ ├─┬ insert-module-globals@7.0.1 
  │ │ ├── is-buffer@1.1.5 
  │ │ └─┬ lexical-scope@1.2.0 
  │ │   └── astw@2.2.0 
  │ ├─┬ JSONStream@1.3.1 
  │ │ ├── jsonparse@1.3.1 
  │ │ └── through@2.3.8 
  │ ├─┬ labeled-stream-splicer@2.0.0 
  │ │ ├── isarray@0.0.1 
  │ │ └── stream-splicer@2.0.0 
  │ ├─┬ module-deps@4.1.1 
  │ │ ├── detective@4.5.0 
  │ │ └── stream-combiner2@1.1.1 
  │ ├── os-browserify@0.1.2 
  │ ├─┬ parents@1.0.1 
  │ │ └── path-platform@0.11.15 
  │ ├── path-browserify@0.0.0 
  │ ├── process@0.11.10 
  │ ├── punycode@1.4.1 
  │ ├── querystring-es3@0.2.1 
  │ ├── read-only-stream@2.0.0 
  │ ├─┬ readable-stream@2.3.3 
  │ │ ├── core-util-is@1.0.2 
  │ │ ├── isarray@1.0.0 
  │ │ ├── process-nextick-args@1.0.7 
  │ │ ├── safe-buffer@5.1.1 
  │ │ └── util-deprecate@1.0.2 
  │ ├─┬ resolve@1.4.0 
  │ │ └── path-parse@1.0.5 
  │ ├─┬ shasum@1.0.2 
  │ │ ├── json-stable-stringify@0.0.1 
  │ │ └── sha.js@2.4.9 
  │ ├─┬ shell-quote@1.6.1 
  │ │ ├── array-filter@0.0.1 
  │ │ ├── array-map@0.0.0 
  │ │ ├── array-reduce@0.0.0 
  │ │ └── jsonify@0.0.0 
  │ ├── stream-browserify@2.0.1 
  │ ├─┬ stream-http@2.7.2 
  │ │ ├── builtin-status-codes@3.0.0 
  │ │ └── to-arraybuffer@1.0.1 
  │ ├── string_decoder@1.0.3 
  │ ├── subarg@1.0.0 
  │ ├─┬ syntax-error@1.3.0 
  │ │ └── acorn@4.0.13 
  │ ├── through2@2.0.3 
  │ ├── timers-browserify@1.4.2 
  │ ├── tty-browserify@0.0.0 
  │ ├─┬ url@0.11.0 
  │ │ ├── punycode@1.3.2 
  │ │ └── querystring@0.2.0 
  │ ├─┬ util@0.10.3 
  │ │ └── inherits@2.0.1 
  │ ├─┬ vm-browserify@0.0.4 
  │ │ └── indexof@0.0.1 
  │ └── xtend@4.0.1 
  ├─┬ config-chain@1.1.11 
  │ ├── ini@1.3.4 
  │ └── proto-list@1.2.4 
  ├─┬ ecstatic@3.0.0 
  │ ├── he@1.1.1 
  │ ├── mime@1.4.1 
  │ ├── minimist@1.2.0 
  │ └── url-join@2.0.2 
  ├── flates@0.0.5 
  ├─┬ javascript-editor@1.0.3 
  │ ├── codemirror@5.30.0 
  │ ├── esprima@2.7.2 
  │ ├── extend@1.1.3 
  │ └── inherits@1.0.0 
  ├─┬ level@1.7.0 
  │ ├─┬ level-packager@1.2.1 
  │ │ └─┬ levelup@1.3.9 
  │ │   ├── deferred-leveldown@1.2.2 
  │ │   ├── level-codec@7.0.1 
  │ │   ├─┬ level-errors@1.0.5 
  │ │   │ └─┬ errno@0.1.4 
  │ │   │   └── prr@0.0.0 
  │ │   ├─┬ level-iterator-stream@1.3.1 
  │ │   │ └─┬ readable-stream@1.1.14 
  │ │   │   ├── isarray@0.0.1 
  │ │   │   └── string_decoder@0.10.31 
  │ │   ├── prr@1.0.1 
  │ │   └── semver@5.4.1 
  │ └─┬ leveldown@1.7.2 
  │   ├── abstract-leveldown@2.6.3 
  │   ├── fast-future@1.0.2 
  │   ├── nan@2.6.2 
  │   └─┬ prebuild-install@2.2.2 
  │     ├── expand-template@1.1.0 
  │     ├── github-from-package@0.0.0 
  │     ├─┬ mkdirp@0.5.1 
  │     │ └── minimist@0.0.8 
  │     ├── node-abi@2.1.1 
  │     ├── noop-logger@0.1.1 
  │     ├─┬ npmlog@4.1.2 
  │     │ ├─┬ are-we-there-yet@1.1.4 
  │     │ │ └── delegates@1.0.0 
  │     │ ├── console-control-strings@1.1.0 
  │     │ ├─┬ gauge@2.7.4 
  │     │ │ ├── aproba@1.2.0 
  │     │ │ ├── has-unicode@2.0.1 
  │     │ │ ├── object-assign@4.1.1 
  │     │ │ ├── signal-exit@3.0.2 
  │     │ │ ├─┬ string-width@1.0.2 
  │     │ │ │ ├── code-point-at@1.1.0 
  │     │ │ │ └─┬ is-fullwidth-code-point@1.0.0 
  │     │ │ │   └── number-is-nan@1.0.1 
  │     │ │ ├─┬ strip-ansi@3.0.1 
  │     │ │ │ └── ansi-regex@2.1.1 
  │     │ │ └── wide-align@1.1.2 
  │     │ └── set-blocking@2.0.0 
  │     ├── os-homedir@1.0.2 
  │     ├─┬ pump@1.0.2 
  │     │ └── end-of-stream@1.4.0 
  │     ├─┬ rc@1.2.1 
  │     │ ├── deep-extend@0.4.2 
  │     │ └── strip-json-comments@2.0.1 
  │     ├─┬ simple-get@1.4.3 
  │     │ └── unzip-response@1.0.2 
  │     ├─┬ tar-fs@1.15.3 
  │     │ ├── chownr@1.0.1 
  │     │ └─┬ tar-stream@1.5.4 
  │     │   └── bl@1.2.1 
  │     └── tunnel-agent@0.6.0 
  ├─┬ optimist@0.6.1 
  │ ├── minimist@0.0.10 
  │ └── wordwrap@0.0.3 
  ├── ramrod@1.0.0 
  ├─┬ spi@0.2.0 
  │ └── bindings@1.2.1 
  └─┬ stream-cb@1.1.0 
    └─┬ readable-stream@1.0.34 
      ├── isarray@0.0.1 
      └── string_decoder@0.10.31 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/hello-hacker/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 41% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","bind"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0429 took 2.471s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected character '#' (1:78) on program #! /usr/bin/env node

'use strict';

const path = require('path');
const fs = require('fs');
const url = require('url');
const mime = require('mime');
const urlJoin = require('url-join');
const showDir = require('./ecstatic/show-dir');
const version = require('../package.json').version;
const status = require('./ecstatic/status-handlers');
const generateEtag = require('./ecstatic/etag');
const optsParser = require('./ecstatic/opts');

let ecstatic = null;

// See: https://github.com/jesusabdullah/node-ecstatic/issues/109
function decodePathname(pathname) {
  const pieces = pathname.replace(/\\/g, '/').split('/');

  return pieces.map((rawPiece) => {
    const piece = decodeURIComponent(rawPiece);

    if (process.platform === 'win32' && /\\/.test(piece)) {
      throw new Error('Invalid forward slash character');
    }

    return piece;
  }).join('/');
}


// Check to see if we should try to compress a file with gzip.
function shouldCompress(req) {
  const headers = req.headers;

  return headers && headers['accept-encoding'] &&
    headers['accept-encoding']
      .split(',')
      .some(el => ['*', 'compress', 'gzip', 'deflate'].indexOf(el) !== -1)
    ;
}

function hasGzipId12(gzipped, cb) {
  const stream = fs.createReadStream(gzipped, { start: 0, end: 1 });
  let buffer = Buffer('');
  let hasBeenCalled = false;

  stream.on('data', (chunk) => {
    buffer = Buffer.concat([buffer, chunk], 2);
  });

  stream.on('error', (err) => {
    if (hasBeenCalled) {
      throw err;
    }

    hasBeenCalled = true;
    cb(err);
  });

  stream.on('close', () => {
    if (hasBeenCalled) {
      return;
    }

    hasBeenCalled = true;
    cb(null, buffer[0] === 31 && buffer[1] === 139);
  });
}


module.exports = function createMiddleware(_dir, _options) {
  let dir;
  let options;

  if (typeof _dir === 'string') {
    dir = _dir;
    options = _options;
  } else {
    options = _dir;
    dir = options.root;
  }

  const root = path.join(path.resolve(dir), '/');
  const opts = optsParser(options);
  const cache = opts.cache;
  const autoIndex = opts.autoIndex;
  const baseDir = opts.baseDir;
  let defaultExt = opts.defaultExt;
  const handleError = opts.handleError;
  const headers = opts.headers;
  const serverHeader = opts.serverHeader;
  const weakEtags = opts.weakEtags;
  const handleOptionsMethod = opts.handleOptionsMethod;

  opts.root = dir;
  if (defaultExt && /^\./.test(defaultExt)) {
    defaultExt = defaultExt.replace(/^\./, '');
  }

  // Support hashes and .types files in mimeTypes @since 0.8
  if (opts.mimeTypes) {
    try {
      // You can pass a JSON blob here---useful for CLI use
      opts.mimeTypes = JSON.parse(opts.mimeTypes);
    } catch (e) {
      // swallow parse errors, treat this as a string mimetype input
    }
    if (typeof opts.mimeTypes === 'string') {
      mime.load(opts.mimeTypes);
    } else if (typeof opts.mimeTypes === 'object') {
      mime.define(opts.mimeTypes);
    }
  }

  function shouldReturn304(req, serverLastModified, serverEtag) {
    if (!req || !req.headers) {
      return false;
    }

    const clientModifiedSince = req.headers['if-modified-since'];
    const clientEtag = req.headers['if-none-match'];
    let clientModifiedDate;

    if (!clientModifiedSince && !clientEtag) {
      // Client did not provide any conditional caching headers
      return false;
    }

    if (clientModifiedSince) {
      // Catch "illegal access" dates that will crash v8
      // https://github.com/jfhbrook/node-ecstatic/pull/179
      try {
        clientModifiedDate = new Date(Date.parse(clientModifiedSince));
      } catch (err) {
        return false;
      }

      if (clientModifiedDate.toString() === 'Invalid Date') {
        return false;
      }
      // If the client's copy is older than the server's, don't return 304
      if (clientModifiedDate < new Date(serverLastModified)) {
        return false;
      }
    }

    if (clientEtag) {
      // Do a strong or weak etag comparison based on setting
      // https://www.ietf.org/rfc/rfc2616.txt Section 13.3.3
      if (opts.weakCompare && clientEtag !== serverEtag
        && clientEtag !== `W/${serverEtag}` && `W/${clientEtag}` !== serverEtag) {
        return false;
      } else if (!opts.weakCompare && (clientEtag !== serverEtag || clientEtag.indexOf('W/') === 0)) {
        return false;
      }
    }

    return true;
  }

  return function middleware(req, res, next) {
    // Figure out the path for the file from the given url
    const parsed = url.parse(req.url);
    let pathname = null;
    let file = null;
    let gzipped = null;

    // Strip any null bytes from the url
    // This was at one point necessary because of an old bug in url.parse
    //
    // See: https://github.com/jfhbrook/node-ecstatic/issues/16#issuecomment-3039914
    // See: https://github.com/jfhbrook/node-ecstatic/commit/43f7e72a31524f88f47e367c3cc3af710e67c9f4
    //
    // But this opens up a regex dos attack vector! D:
    //
    // Based on some research (ie asking #node-dev if this is still an issue),
    // it's *probably* not an issue. :)
    /*
    while (req.url.indexOf('%00') !== -1) {
      req.url = req.url.replace(/\%00/g, '');
    }
    */

    try {
      decodeURIComponent(req.url); // check validity of url
      pathname = decodePathname(parsed.pathname);
    } catch (err) {
      status[400](res, next, { error: err });
      return;
    }

    file = path.normalize(
      path.join(
        root,
        path.relative(path.join('/', baseDir), pathname)
      )
    );
    gzipped = `${file}.gz`;

    if (serverHeader !== false) {
      // Set common headers.
      res.setHeader('server', `ecstatic-${version}`);
    }

    Object.keys(headers).forEach((key) => {
      res.setHeader(key, headers[key]);
    });

    if (req.method === 'OPTIONS' && handleOptionsMethod) {
      res.end();
      return;
    }

    // TODO: This check is broken, which causes the 403 on the
    // expected 404.
    if (file.slice(0, root.length) !== root) {
      status[403](res, next);
      return;
    }

    if (req.method && (req.method !== 'GET' && req.method !== 'HEAD')) {
      status[405](res, next);
      return;
    }


    function serve(stat) {
      // Do a MIME lookup, fall back to octet-stream and handle gzip
      // special case.
      const defaultType = opts.contentType || 'application/octet-stream';
      let contentType = mime.lookup(file, defaultType);
      let charSet;
      const range = (req.headers && req.headers.range);
      const lastModified = (new Date(stat.mtime)).toUTCString();
      const etag = generateEtag(stat, weakEtags);
      let stream = null;

      if (contentType) {
        charSet = mime.charsets.lookup(contentType, 'utf-8');
        if (charSet) {
          contentType += `; charset=${charSet}`;
        }
      }

      if (file === gzipped) { // is .gz picked up
        res.setHeader('Content-Encoding', 'gzip');

        // strip gz ending and lookup mime type
        contentType = mime.lookup(path.basename(file, '.gz'), defaultType);
      }

      if (range) {
        const total = stat.size;
        const parts = range.replace(/bytes=/, '').split('-');
        const partialstart = parts[0];
        const partialend = parts[1];
        const start = parseInt(partialstart, 10);
        const end = Math.min(
          total - 1,
          partialend ? parseInt(partialend, 10) : total - 1
        );
        const chunksize = (end - start) + 1;
        let fstream = null;

        if (start > end || isNaN(start) || isNaN(end)) {
          status['416'](res, next);
          return;
        }

        fstream = fs.createReadStream(file, { start, end });
        fstream.on('error', (err) => {
          status['500'](res, next, { error: err });
        });
        res.on('close', () => {
          fstream.destroy();
        });
        res.writeHead(206, {
          'Content-Range': `bytes ${start}-${end}/${total}`,
          'Accept-Ranges': 'bytes',
          'Content-Length': chunksize,
          'Content-Type': contentType,
        });
        fstream.pipe(res);
        return;
      }

      // TODO: Helper for this, with default headers.
      res.setHeader('last-modified', lastModified);
      res.setHeader('etag', etag);

      if (typeof cache === 'function') {
        let requestSpecificCache = cache(pathname);
        if (typeof requestSpecificCache === 'number') {
          requestSpecificCache = `max-age=${requestSpecificCache}`;
        }
        res.setHeader('cache-control', requestSpecificCache);
      } else {
        res.setHeader('cache-control', cache);
      }

      // Return a 304 if necessary
      if (shouldReturn304(req, lastModified, etag)) {
        status[304](res, next);
        return;
      }

      res.setHeader('content-length', stat.size);
      res.setHeader('content-type', contentType);

      // set the response statusCode if we have a request statusCode.
      // This only can happen if we have a 404 with some kind of 404.html
      // In all other cases where we have a file we serve the 200
      res.statusCode = req.statusCode || 200;

      if (req.method === 'HEAD') {
        res.end();
        return;
      }

      stream = fs.createReadStream(file);

      stream.pipe(res);
      stream.on('error', (err) => {
        status['500'](res, next, { error: err });
      });
    }


    function statFile() {
      fs.stat(file, (err, stat) => {
        if (err && (err.code === 'ENOENT' || err.code === 'ENOTDIR')) {
          if (req.statusCode === 404) {
            // This means we're already trying ./404.html and can not find it.
            // So send plain text response with 404 status code
            status[404](res, next);
          } else if (!path.extname(parsed.pathname).length && defaultExt) {
            // If there is no file extension in the path and we have a default
            // extension try filename and default extension combination before rendering 404.html.
            middleware({
              url: `${parsed.pathname}.${defaultExt}${(parsed.search) ? parsed.search : ''}`,
              headers: req.headers,
            }, res, next);
          } else {
            // Try to serve default ./404.html
            middleware({
              url: (handleError ? `/${path.join(baseDir, `404.${defaultExt}`)}` : req.url),
              headers: req.headers,
              statusCode: 404,
            }, res, next);
          }
        } else if (err) {
          status[500](res, next, { error: err });
        } else if (stat.isDirectory()) {
          if (!autoIndex && !opts.showDir) {
            status[404](res, next);
            return;
          }

          // 302 to / if necessary
          if (!parsed.pathname.match(/\/$/)) {
            res.statusCode = 302;
            const q = parsed.query ? `?${parsed.query}` : '';
            res.setHeader('location', `${parsed.pathname}/${q}`);
            res.end();
            return;
          }

          if (autoIndex) {
            middleware({
              url: urlJoin(
                encodeURIComponent(pathname),
                `/index.${defaultExt}`
              ),
              headers: req.headers,
            }, res, (autoIndexError) => {
              if (autoIndexError) {
                status[500](res, next, { error: autoIndexError });
                return;
              }
              if (opts.showDir) {
                showDir(opts, stat)(req, res);
                return;
              }

              status[403](res, next);
            });
            return;
          }

          if (opts.showDir) {
            showDir(opts, stat)(req, res);
          }
        } else {
          serve(stat);
        }
      });
    }

    // Look for a gzipped file if this is turned on
    if (opts.gzip && shouldCompress(req)) {
      fs.stat(gzipped, (err, stat) => {
        if (!err && stat.isFile()) {
          hasGzipId12(gzipped, (gzipErr, isGzip) => {
            if (!gzipErr && isGzip) {
              file = gzipped;
              serve(stat);
            } else {
              statFile();
            }
          });
        } else {
          statFile();
        }
      });
    } else {
      statFile();
    }
  };
};


ecstatic = module.exports;
ecstatic.version = version;
ecstatic.showDir = showDir;


if (!module.parent) {
  /* eslint-disable global-require */
  /* eslint-disable no-console */
  const defaults = require('./ecstatic/defaults.json');
  const http = require('http');
  const minimist = require('minimist');
  const aliases = require('./ecstatic/aliases.json');

  const opts = minimist(process.argv.slice(2), {
    alias: aliases,
    default: defaults,
    boolean: Object.keys(defaults).filter(
      key => typeof defaults[key] === 'boolean'
    ),
  });
  const envPORT = parseInt(process.env.PORT, 10);
  const port = envPORT > 1024 && envPORT <= 65536 ? envPORT : opts.port || opts.p || 8000;
  const dir = opts.root || opts._[0] || process.cwd();

  if (opts.help || opts.h) {
    console.error('usage: ecstatic [dir] {options} --port PORT');
    console.error('see https://npm.im/ecstatic for more docs');
  } else {
    http.createServer(ecstatic(dir, opts))
      .listen(port, () => {
        console.log(`ecstatic serving ${dir} at http://0.0.0.0:${port}`);
      })
    ;
  }
}
 at SyntaxError: Unexpected character '#' (1:78)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$7.getTokenFromCode (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2756:10)
    at Parser.pp$7.readToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2477:17)
    at Parser.readToken (/root/ExpoSE/lib/Tropigate/bin/Tokens.js:124:26)
    at Parser.pp$7.nextToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2468:15)
    at Parser.pp$7.next (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2413:10)
    at Parser.pp.eat (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:536:12)
    at Parser.pp.semicolon (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:581:15)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:918:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/hello-hacker/node_modules/hello-hacker/index.js. Coverage (Term): 6% Coverage (LOC): 4%
*- File /root/Targets/hello-hacker/node_modules/flates/flates.js. Coverage (Term): 46% Coverage (LOC): 80%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
