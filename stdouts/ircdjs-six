
> bcrypt@1.0.3 install /root/Targets/ircdjs-six/node_modules/bcrypt
> node-pre-gyp install --fallback-to-build

[bcrypt] Success: "/root/Targets/ircdjs-six/node_modules/bcrypt/lib/binding/bcrypt_lib.node" is installed via remote
/root/Targets/ircdjs-six
└─┬ ircdjs-six@0.1.4 
  ├─┬ bcrypt@1.0.3 
  │ ├── nan@2.6.2 
  │ └─┬ node-pre-gyp@0.6.36 
  │   ├─┬ mkdirp@0.5.1 
  │   │ └── minimist@0.0.8 
  │   ├─┬ nopt@4.0.1 
  │   │ ├── abbrev@1.1.1 
  │   │ └─┬ osenv@0.1.4 
  │   │   ├── os-homedir@1.0.2 
  │   │   └── os-tmpdir@1.0.2 
  │   ├─┬ npmlog@4.1.2 
  │   │ ├─┬ are-we-there-yet@1.1.4 
  │   │ │ └── delegates@1.0.0 
  │   │ ├── console-control-strings@1.1.0 
  │   │ ├─┬ gauge@2.7.4 
  │   │ │ ├── aproba@1.2.0 
  │   │ │ ├── has-unicode@2.0.1 
  │   │ │ ├── object-assign@4.1.1 
  │   │ │ ├── signal-exit@3.0.2 
  │   │ │ ├─┬ string-width@1.0.2 
  │   │ │ │ ├── code-point-at@1.1.0 
  │   │ │ │ └─┬ is-fullwidth-code-point@1.0.0 
  │   │ │ │   └── number-is-nan@1.0.1 
  │   │ │ ├─┬ strip-ansi@3.0.1 
  │   │ │ │ └── ansi-regex@2.1.1 
  │   │ │ └── wide-align@1.1.2 
  │   │ └── set-blocking@2.0.0 
  │   ├─┬ rc@1.2.1 
  │   │ ├── deep-extend@0.4.2 
  │   │ ├── ini@1.3.4 
  │   │ ├── minimist@1.2.0 
  │   │ └── strip-json-comments@2.0.1 
  │   ├─┬ request@2.83.0 
  │   │ ├── aws-sign2@0.7.0 
  │   │ ├── aws4@1.6.0 
  │   │ ├── caseless@0.12.0 
  │   │ ├─┬ combined-stream@1.0.5 
  │   │ │ └── delayed-stream@1.0.0 
  │   │ ├── extend@3.0.1 
  │   │ ├── forever-agent@0.6.1 
  │   │ ├─┬ form-data@2.3.1 
  │   │ │ └── asynckit@0.4.0 
  │   │ ├─┬ har-validator@5.0.3 
  │   │ │ ├─┬ ajv@5.2.3 
  │   │ │ │ ├── co@4.6.0 
  │   │ │ │ ├── fast-deep-equal@1.0.0 
  │   │ │ │ ├── json-schema-traverse@0.3.1 
  │   │ │ │ └─┬ json-stable-stringify@1.0.1 
  │   │ │ │   └── jsonify@0.0.0 
  │   │ │ └── har-schema@2.0.0 
  │   │ ├─┬ hawk@6.0.2 
  │   │ │ ├── boom@4.3.1 
  │   │ │ ├─┬ cryptiles@3.1.2 
  │   │ │ │ └── boom@5.2.0 
  │   │ │ ├── hoek@4.2.0 
  │   │ │ └── sntp@2.0.2 
  │   │ ├─┬ http-signature@1.2.0 
  │   │ │ ├── assert-plus@1.0.0 
  │   │ │ ├─┬ jsprim@1.4.1 
  │   │ │ │ ├── extsprintf@1.3.0 
  │   │ │ │ ├── json-schema@0.2.3 
  │   │ │ │ └── verror@1.10.0 
  │   │ │ └─┬ sshpk@1.13.1 
  │   │ │   ├── asn1@0.2.3 
  │   │ │   ├── bcrypt-pbkdf@1.0.1 
  │   │ │   ├── dashdash@1.14.1 
  │   │ │   ├── ecc-jsbn@0.1.1 
  │   │ │   ├── getpass@0.1.7 
  │   │ │   ├── jsbn@0.1.1 
  │   │ │   └── tweetnacl@0.14.5 
  │   │ ├── is-typedarray@1.0.0 
  │   │ ├── isstream@0.1.2 
  │   │ ├── json-stringify-safe@5.0.1 
  │   │ ├─┬ mime-types@2.1.17 
  │   │ │ └── mime-db@1.30.0 
  │   │ ├── oauth-sign@0.8.2 
  │   │ ├── performance-now@2.1.0 
  │   │ ├── qs@6.5.1 
  │   │ ├── safe-buffer@5.1.1 
  │   │ ├── stringstream@0.0.5 
  │   │ ├─┬ tough-cookie@2.3.3 
  │   │ │ └── punycode@1.4.1 
  │   │ ├── tunnel-agent@0.6.0 
  │   │ └── uuid@3.1.0 
  │   ├─┬ rimraf@2.6.2 
  │   │ └─┬ glob@7.1.2 
  │   │   ├── fs.realpath@1.0.0 
  │   │   ├── inflight@1.0.6 
  │   │   ├─┬ minimatch@3.0.4 
  │   │   │ └─┬ brace-expansion@1.1.8 
  │   │   │   ├── balanced-match@1.0.0 
  │   │   │   └── concat-map@0.0.1 
  │   │   └── path-is-absolute@1.0.1 
  │   ├── semver@5.4.1 
  │   ├─┬ tar@2.2.1 
  │   │ ├── block-stream@0.0.9 
  │   │ ├─┬ fstream@1.0.11 
  │   │ │ └── graceful-fs@4.1.11 
  │   │ └── inherits@2.0.3 
  │   └─┬ tar-pack@3.4.0 
  │     ├─┬ debug@2.6.9 
  │     │ └── ms@2.0.0 
  │     ├── fstream-ignore@1.0.5 
  │     ├─┬ once@1.4.0 
  │     │ └── wrappy@1.0.2 
  │     ├─┬ readable-stream@2.3.3 
  │     │ ├── core-util-is@1.0.2 
  │     │ ├── isarray@1.0.0 
  │     │ ├── process-nextick-args@1.0.7 
  │     │ ├── string_decoder@1.0.3 
  │     │ └── util-deprecate@1.0.2 
  │     └── uid-number@0.0.6 
  ├── carrier@0.3.0 
  ├─┬ commander@2.11.0  (git://github.com/visionmedia/commander.js.git#0ae835315a4ff9162c963eb2223c327fd9119996)
  │ └── @types/node@7.0.43 
  ├── line-reader@0.4.0 
  └─┬ winston@0.7.3 
    ├── async@0.2.10 
    ├── colors@0.6.2 
    ├── cycle@1.0.3 
    ├── eyes@0.1.8 
    ├── pkginfo@0.3.1 
    ├─┬ request@2.16.6 
    │ ├── aws-sign@0.2.0 
    │ ├── cookie-jar@0.2.0 
    │ ├── forever-agent@0.2.0 
    │ ├─┬ form-data@0.0.10 
    │ │ └─┬ combined-stream@0.0.7 
    │ │   └── delayed-stream@0.0.5 
    │ ├─┬ hawk@0.10.2 
    │ │ ├── boom@0.3.8 
    │ │ ├── cryptiles@0.1.3 
    │ │ ├── hoek@0.7.6 
    │ │ └── sntp@0.1.4 
    │ ├── json-stringify-safe@3.0.0 
    │ ├── mime@1.2.11 
    │ ├── node-uuid@1.4.8 
    │ ├── oauth-sign@0.2.0 
    │ ├── qs@0.5.6 
    │ └── tunnel-agent@0.2.0 
    └── stack-trace@0.0.10 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/ircdjs-six/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0422 took 4.9584s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (31:4) on program //
// ::::::::::..     .,-::::::::::::-.         ....:::::: .::::::.
// ;;;;;;;``;;;;  ,;;;'````' ;;,   `';,    ;;;;;;;;;````;;;`    `
// [[[ [[[,/[[['  [[[        `[[     [[    ''`  `[[.    '[==/[[[[,
// $$$ $$$$$$c    $$$         $$,    $$   ,,,    `$$      '''    $
// 888 888b "88bo,`88bo,__,o, 888_,o8P'd8b888boood88     88b    dP
// MMM MMMM   "W"   "YUMMMMMP"MMMMP"`  YMP"MMMMMMMM"      "YMmMY"
//
//                                            A Node.JS IRC Server
// ircd.js
// IRCD.js By Alex Young
// IRCDjs-six Extension by Kyle Rambeau
// libs:
// http://github.com/pgte/carrier

// rfcs:
// http://www.networksorcery.com/enp/rfc/rfc2812.txt
// http://tools.ietf.org/html/rfc1459
//
// spells out some stuff the RFC was light on:
// http://docs.dal.net/docs/misc.html#5

var net = require('net'),
    tls = require('tls'),
    carrier = require('carrier'),
    fs = require('fs'),
    readline = require('readline'),
    lr = require('line-reader'),
    irc = require('./protocol'),
    path = require('path'),
    assert = require('assert'),
    Channel = require('./channel').Channel,
    User = require('./user').User,
    History = require('./storage').History,
    ChannelDatabase = require('./storage').ChannelDatabase,
    UserDatabase = require('./storage').UserDatabase,
    LinkServer = require('./linkserver').LinkServer,
    LinkDatabase = require('./storage').LinkDatabase,
    ServerCommands = require('./commands'),
    winston = require('winston'),
    commander = require('commander'),
    exists = fs.exists || path.exists // 0.8 moved exists to fs
    ;
winston.remove(winston.transports.Console);
winston.add(winston.transports.Console, {
    colorize: true,
    prettyPrint: true
});
function AbstractConnection(stream) {
    this.stream = stream;
    this.object = null;

    this.__defineGetter__('id', function () {
        return this.object ? this.object.id : 'Unregistered';
    });
}

function Server() {
    this.history = new History(this);
    this.users = new UserDatabase(this);
    this.channels = new ChannelDatabase(this);
    this.config = null;
    this.servers = new LinkDatabase(this);
    this.linkserver = null;
    this.commands = new ServerCommands(this, this.servers);
    this.startupTime = new Date();
}

Server.boot = function () {
    var server = new Server();

    server.file = server.cliParse();

    server.loadConfig(function () {
        server.start();
        server.createDefaultChannels();
    });

    process.on('SIGHUP', function () {
        winston.info('Reloading config...');
        server.loadConfig();
    });

    process.on('SIGTERM', function () {
        winston.info('Exiting...');
        server.close();
    });
};

Server.prototype = {
    version: 'v-0.1.2-six',
    created: '2016-03-21',
    debug: false,
    get name() {
        return this.config.serverName;
    },
    get info() {
        return this.config.serverDescription;
    },
    get token() {
        return this.config.token;
    },
    get host() {
        return ':' + this.config.hostname;
    },
    get numChannels() {
        return Object.keys(this.channels.registered).length;
    },
    cliParse: function () {
        var file = null;

        commander.option('-f --file [file]', 'Configuration file (Defaults: /etc/ircdjs/config.json or ../config/config.json)')
            .parse(process.argv);
        // When the -f switch is passwd without a parameter, commander.js evaluates it to true.
        if (commander.file && commander.file !== true) file = commander.file;
        return file;
    },
    reloadConfig: function (user) {
        var server = this,
            paths = [
                path.join('/', 'etc', 'ircdjs', 'config.json'),
                path.join(__dirname, '..', 'config', 'config.json')
            ], oldConfig = this.server.config;

        this.config = null;
        if (server.file) paths.unshift(server.file);

        paths.forEach(function (name) {
            exists(name, function (exists) {
                if (!exists || server.config) return;
                try {

                    server.config = JSON.parse(fs.readFileSync(name).toString());
                    server.config.idleTimeout = server.config.idleTimeout || 60;
                    winston.info('[Server] - Configuration reloaded');
                    user.send(this.host, irc.reply.reHashing, user.nick, ":Configuration has been reloaded.");

                } catch (exception) {
                    user.send(this.host, irc.reply.reHashing, user.nick, ":Reloading failed: " + exception);
                    winston.error('[Server] Could not reload config! Rolling back...', exception);
                    server.config = oldConfig; //TODO doesnt old load config dafunk
                }
            });
        });
    },
    loadConfig: function (fn) {
        var server = this,
            paths = [
                path.join('/', 'etc', 'ircdjs', 'config.json'),
                path.join(__dirname, '..', 'config', 'config.json')
            ];

        this.config = null;
        if (server.file) paths.unshift(server.file);

        paths.forEach(function (name) {
            exists(name, function (exists) {
                if (!exists || server.config) return;
                try {
                    server.config = JSON.parse(fs.readFileSync(name).toString());
                    server.config.idleTimeout = server.config.idleTimeout || 60;
                    winston.info('IRCn Server ' + server.version);
                    winston.info(' ');

                    winston.info('[Server] Starting IRC Server with Config file: ' + name);
                    if (fn) fn();
                } catch (exception) {
                    winston.error('[Server] Please ensure you have a valid config file.', exception);
                }
            });
        });
    },

    normalizeName: function (name) {
        return name &&
            name.toLowerCase()
                .replace(/{/g, '[')
                .replace(/}/g, ']')
                .replace(/\|/g, '\\')
                .trim();
    },

    isValidPositiveInteger: function (str) {
        var n = ~~Number(str);
        return String(n) === str && n >= 0;
    },

    valueExists: function (value, collection, field) {
        var self = this;
        value = this.normalizeName(value);
        return collection.some(function (u) {
            return self.normalizeName(u[field]) === value;
        })
    },

    //We are only accepting channels with # in the name
    channelTarget: function (target) {
        var prefix = target[0];
        var channelPrefixes = ['#'];
        return (channelPrefixes.indexOf(prefix) !== -1);
    },

    parse: function (data) {
        var parts = data.trim().split(/ :/),
            args = parts[0].split(' ');

        parts = [parts.shift(), parts.join(' :')];

        if (parts.length > 0) {
            args.push(parts[1]);
        }

        if (data.match(/^:/)) {
            args[1] = args.splice(0, 1, args[1]);
            args[1] = (args[1] + '').replace(/^:/, '');
        }

        return {
            command: args[0].toUpperCase(),
            args: args.slice(1)
        };
    },

    respondToMessage: function (user, message) {
        this.commands[message.command].apply(this.commands, [user].concat(message.args));
    },

    respond: function (data, client) {
        var message = this.parse(data);

        if (this.validCommand(message.command)) {
            if (this.config.serverPassword && !client.object.passwordAccepted) {
                this.queueResponse(client, message);
            } else {
                this.respondToMessage(client.object, message);
            }
        }
    },

    getInfo: function (user) {
        var self = this;
        try {
            lr.eachLine('./config/info.txt', function (line, last) {
                user.send(self.host, irc.reply.showInfo, user.nick, ':' + line);
                if (last) {
                    user.send(self.host, irc.reply.endInfo, user.nick, ":End of /INFO list");
                }
            });
        } catch (e) {
            winston.error(e);
            user.send(self.host, irc.reply.showInfo, user.nick, ':No text to send.');
            user.send(self.host, irc.reply.endInfo, user.nick, ":End of /INFO list");


        }

    },
    queueResponse: function (client, message) {
        if ('PASS' === message.command) {
            // Respond now
            client.object.pendingAuth = false;
            this.respondToMessage(client.object, message);
        } else {
            client.object.queue(message);
        }
    },

    validCommand: function (command) {
        return this.commands[command];
    },

    createDefaultChannels: function () {
        var self = this;
        if (this.config.channels) {
            Object.keys(this.config.channels).forEach(function (channel) {
                var channelName = '';
                if (!self.channelTarget(channel)) {
                    channelName = "#" + channel;
                } else {
                    channelName = channel;
                }
                var newChannel = self.channels.registered[self.normalizeName(channelName)] = new Channel(channelName, self);
                newChannel.topic = self.config.channels[channel].topic;
            });
        }
    },

    motd: function (user) {
        var self = this;
        user.send(this.host, irc.reply.motdStart, user.nick, ':- ' + this.name + ' Message of the day -');
        try {
            lr.eachLine('./config/motd.txt', function (line, last) {
                user.send(self.host, irc.reply.motd, user.nick, ' :' + line);
                if (last) {
                    user.send(self.host, irc.reply.motdEnd, user.nick, ':End of /MOTD command');
                }
            });
        } catch (e) {
            user.send(this.host, irc.errors.noMotd, user.nick, ' :MOTD File is missing');
            winston.error(e);
        }


    },

    startTimeoutHandler: function () {
        var self = this;
        var timeout = this.config.pingTimeout || 10;
        this.timeoutHandler = setInterval(function () {
            self.users.forEach(function (user) {
                if (user.hasTimedOut()) {
                    winston.info('User timed out:', user.mask);
                    self.disconnect(user);
                } else {
                    // TODO: If no other activity is detected
                    user.send('PING', self.config.hostname, self.host);
                }
            });
        }, timeout * 1000);
    },

    stopTimeoutHandler: function () {
        clearInterval(this.timeoutHandler);
    },

    start: function (callback) {
        var server = this, key, cert, options;
        if (this.config.key && this.config.cert) {
            try {
                key = fs.readFileSync(this.config.key);
                cert = fs.readFileSync(this.config.cert);
            } catch (exception) {
                winston.error('Fatal error:', exception);
            }
            options = {key: key, cert: cert};
            this.server = tls.createServer(options, handleStream);
        } else {
            this.server = net.createServer(handleStream);
        }
        this.server.maxConnections = this.config.maxConnections;
        assert.ok(callback === undefined || typeof callback == 'function');
        this.server.listen(this.config.port, callback);

        this.linkserver = new LinkServer(server);

        function handleStream(stream) {
            try {
                var carry = carrier.carry(stream),
                    client = new AbstractConnection(stream);

                client.object = new User(client, server);
                if (server.config.serverPassword) {
                    client.object.pendingAuth = true;
                }

                stream.on('end', function () {
                    server.end(client);
                });
                stream.on('error', winston.error);
                carry.on('line', function (line) {
                    server.data(client, line);
                });
            } catch (exception) {
                winston.error('Fatal error:', exception);
            }
        }
    },

    close: function (callback) {
        if (callback !== undefined) {
            assert.ok(typeof callback === 'function');
            this.server.once('close', callback);
        }
        this.stopTimeoutHandler();
        this.server.serviceProc.close();
        WSRC.close();
        this.server.close();
    },

    end: function (client) {
        var user = client.object;

        if (user) {
            this.disconnect(user);
        }
    },

    disconnect: function (user) {
        user.channels.forEach(function (channel) {
            channel.users.forEach(function (channelUser) {
                if (channelUser !== user) {
                    channelUser.send(user.mask, 'QUIT', ':' + user.quitMessage);
                }
            });

            channel.users.splice(channel.users.indexOf(user), 1);
        });

        user.closeStream();
        this.users.remove(user);
        user = null;
    },

    data: function (client, line) {
        line = line.slice(0, 512);
        //winston.info('[Server] - [' + this.name + ', C: ' + client.id + '] ' + line);
        this.respond(line, client);
    }
};

exports.Server = Server;
exports.winston = winston;

if (!module.parent) {
    Server.boot();

}
 at SyntaxError: Unexpected token (31:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
