/root/Targets/cloudant-envoy
└─┬ cloudant-envoy@0.4.4 
  ├─┬ async@2.5.0 
  │ └── lodash@4.17.4 
  ├── basic-auth@1.1.0 
  ├─┬ body-parser@1.18.2 
  │ ├── bytes@3.0.0 
  │ ├── content-type@1.0.4 
  │ ├─┬ debug@2.6.9 
  │ │ └── ms@2.0.0 
  │ ├── depd@1.1.1 
  │ ├─┬ http-errors@1.6.2 
  │ │ ├── inherits@2.0.3 
  │ │ └── setprototypeof@1.0.3 
  │ ├── iconv-lite@0.4.19 
  │ ├─┬ on-finished@2.3.0 
  │ │ └── ee-first@1.1.1 
  │ ├── qs@6.5.1 
  │ ├─┬ raw-body@2.3.2 
  │ │ └── unpipe@1.0.0 
  │ └─┬ type-is@1.6.15 
  │   └── media-typer@0.3.0 
  ├─┬ cf-deployment-tracker-client@0.1.3 
  │ ├─┬ cwd@0.10.0 
  │ │ ├─┬ find-pkg@0.1.2 
  │ │ │ └─┬ find-file-up@0.1.3 
  │ │ │   └─┬ resolve-dir@0.1.1 
  │ │ │     ├─┬ expand-tilde@1.2.2 
  │ │ │     │ └── os-homedir@1.0.2 
  │ │ │     └─┬ global-modules@0.2.3 
  │ │ │       ├─┬ global-prefix@0.1.5 
  │ │ │       │ ├─┬ homedir-polyfill@1.0.1 
  │ │ │       │ │ └── parse-passwd@1.0.0 
  │ │ │       │ ├── ini@1.3.4 
  │ │ │       │ └─┬ which@1.3.0 
  │ │ │       │   └── isexe@2.0.0 
  │ │ │       └── is-windows@0.2.0 
  │ │ └── fs-exists-sync@0.1.0 
  │ └─┬ restler@3.3.0 
  │   ├── iconv-lite@0.2.11 
  │   ├── qs@1.2.0 
  │   ├─┬ xml2js@0.4.0 
  │   │ ├── sax@0.5.8 
  │   │ └── xmlbuilder@9.0.4 
  │   └── yaml@0.2.3 
  ├─┬ cfenv@1.0.4 
  │ ├─┬ js-yaml@3.7.0 
  │ │ ├─┬ argparse@1.0.9 
  │ │ │ └── sprintf-js@1.0.3 
  │ │ └── esprima@2.7.3 
  │ ├── ports@1.1.0 
  │ └── underscore@1.8.3 
  ├─┬ cloudant@1.8.0 
  │ ├── async@2.1.2 
  │ ├─┬ cloudant-nano@6.5.0 
  │ │ ├─┬ cloudant-follow@0.13.0 
  │ │ │ ├── browser-request@0.3.3 
  │ │ │ └─┬ request@2.81.0 
  │ │ │   ├─┬ har-validator@4.2.1 
  │ │ │   │ ├── ajv@4.11.8 
  │ │ │   │ └── har-schema@1.0.5 
  │ │ │   ├── performance-now@0.2.0 
  │ │ │   └── qs@6.4.0 
  │ │ └── errs@0.3.2 
  │ ├─┬ debug@2.2.0 
  │ │ └── ms@0.7.1 
  │ └─┬ request@2.76.0 
  │   ├── aws-sign2@0.6.0 
  │   ├── caseless@0.11.0 
  │   ├── form-data@2.1.4 
  │   ├─┬ har-validator@2.0.6 
  │   │ ├─┬ chalk@1.1.3 
  │   │ │ ├── ansi-styles@2.2.1 
  │   │ │ ├── escape-string-regexp@1.0.5 
  │   │ │ ├─┬ has-ansi@2.0.0 
  │   │ │ │ └── ansi-regex@2.1.1 
  │   │ │ ├── strip-ansi@3.0.1 
  │   │ │ └── supports-color@2.0.0 
  │   │ ├── commander@2.11.0 
  │   │ ├─┬ is-my-json-valid@2.16.1 
  │   │ │ ├── generate-function@2.0.0 
  │   │ │ ├─┬ generate-object-property@1.2.0 
  │   │ │ │ └── is-property@1.0.2 
  │   │ │ ├── jsonpointer@4.0.1 
  │   │ │ └── xtend@4.0.1 
  │   │ └─┬ pinkie-promise@2.0.1 
  │   │   └── pinkie@2.0.4 
  │   ├─┬ hawk@3.1.3 
  │   │ ├── boom@2.10.1 
  │   │ ├── cryptiles@2.0.5 
  │   │ ├── hoek@2.16.3 
  │   │ └── sntp@1.0.9 
  │   ├─┬ http-signature@1.1.1 
  │   │ └── assert-plus@0.2.0 
  │   ├── node-uuid@1.4.8 
  │   ├── qs@6.3.2 
  │   └── tunnel-agent@0.4.3 
  ├─┬ compression@1.7.1 
  │ ├─┬ accepts@1.3.4 
  │ │ └── negotiator@0.6.1 
  │ ├─┬ compressible@2.0.11 
  │ │ └── mime-db@1.30.0 
  │ ├── on-headers@1.0.1 
  │ ├── safe-buffer@5.1.1 
  │ └── vary@1.1.2 
  ├─┬ express@4.16.0 
  │ ├── array-flatten@1.1.1 
  │ ├── content-disposition@0.5.2 
  │ ├── cookie@0.3.1 
  │ ├── cookie-signature@1.0.6 
  │ ├── encodeurl@1.0.1 
  │ ├── escape-html@1.0.3 
  │ ├── etag@1.8.1 
  │ ├── finalhandler@1.1.0 
  │ ├── fresh@0.5.2 
  │ ├── merge-descriptors@1.0.1 
  │ ├── methods@1.1.2 
  │ ├── parseurl@1.3.2 
  │ ├── path-to-regexp@0.1.7 
  │ ├─┬ proxy-addr@2.0.2 
  │ │ ├── forwarded@0.1.2 
  │ │ └── ipaddr.js@1.5.2 
  │ ├── range-parser@1.2.0 
  │ ├─┬ send@0.16.0 
  │ │ ├── destroy@1.0.4 
  │ │ └── mime@1.4.1 
  │ ├── serve-static@1.13.0 
  │ ├── setprototypeof@1.1.0 
  │ ├── statuses@1.3.1 
  │ └── utils-merge@1.0.1 
  ├─┬ express-session@1.15.6 
  │ ├── crc@3.4.4 
  │ └─┬ uid-safe@2.1.5 
  │   └── random-bytes@1.0.0 
  ├─┬ morgan@1.9.0 
  │ └── basic-auth@2.0.0 
  ├─┬ request@2.83.0 
  │ ├── aws-sign2@0.7.0 
  │ ├── aws4@1.6.0 
  │ ├── caseless@0.12.0 
  │ ├─┬ combined-stream@1.0.5 
  │ │ └── delayed-stream@1.0.0 
  │ ├── extend@3.0.1 
  │ ├── forever-agent@0.6.1 
  │ ├─┬ form-data@2.3.1 
  │ │ └── asynckit@0.4.0 
  │ ├─┬ har-validator@5.0.3 
  │ │ ├─┬ ajv@5.2.3 
  │ │ │ ├── co@4.6.0 
  │ │ │ ├── fast-deep-equal@1.0.0 
  │ │ │ ├── json-schema-traverse@0.3.1 
  │ │ │ └─┬ json-stable-stringify@1.0.1 
  │ │ │   └── jsonify@0.0.0 
  │ │ └── har-schema@2.0.0 
  │ ├─┬ hawk@6.0.2 
  │ │ ├── boom@4.3.1 
  │ │ ├─┬ cryptiles@3.1.2 
  │ │ │ └── boom@5.2.0 
  │ │ ├── hoek@4.2.0 
  │ │ └── sntp@2.0.2 
  │ ├─┬ http-signature@1.2.0 
  │ │ ├── assert-plus@1.0.0 
  │ │ ├─┬ jsprim@1.4.1 
  │ │ │ ├── assert-plus@1.0.0 
  │ │ │ ├── extsprintf@1.3.0 
  │ │ │ ├── json-schema@0.2.3 
  │ │ │ └─┬ verror@1.10.0 
  │ │ │   ├── assert-plus@1.0.0 
  │ │ │   └── core-util-is@1.0.2 
  │ │ └─┬ sshpk@1.13.1 
  │ │   ├── asn1@0.2.3 
  │ │   ├── assert-plus@1.0.0 
  │ │   ├── bcrypt-pbkdf@1.0.1 
  │ │   ├─┬ dashdash@1.14.1 
  │ │   │ └── assert-plus@1.0.0 
  │ │   ├── ecc-jsbn@0.1.1 
  │ │   ├─┬ getpass@0.1.7 
  │ │   │ └── assert-plus@1.0.0 
  │ │   ├── jsbn@0.1.1 
  │ │   └── tweetnacl@0.14.5 
  │ ├── is-typedarray@1.0.0 
  │ ├── isstream@0.1.2 
  │ ├── json-stringify-safe@5.0.1 
  │ ├── mime-types@2.1.17 
  │ ├── oauth-sign@0.8.2 
  │ ├── performance-now@2.1.0 
  │ ├── stringstream@0.0.5 
  │ ├─┬ tough-cookie@2.3.3 
  │ │ └── punycode@1.4.1 
  │ └── tunnel-agent@0.6.0 
  └── uuid@3.1.0 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/cloudant-envoy/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 1 running / 0 errors / 28.999999999999996% coverage ] ****** [1 done /0 queued / 1 running / 0 errors / 28.999999999999996% coverage ] ****** [2 done /0 queued / 1 running / 1 errors / 42% coverage ] ****** [2 done /0 queued / 1 running / 1 errors / 42% coverage ] ****** [3 done /0 queued / 1 running / 2 errors / 42% coverage ] ****** [3 done /0 queued / 1 running / 2 errors / 42% coverage ] ****** [4 done /0 queued / 1 running / 3 errors / 42% coverage ] ****** [4 done /0 queued / 1 running / 3 errors / 42% coverage ] ****** [5 done /0 queued / 1 running / 4 errors / 43% coverage ] ****** [5 done /0 queued / 1 running / 4 errors / 43% coverage ] ****** [6 done /1 queued / 1 running / 5 errors / 43% coverage ] ****** [6 done /0 queued / 2 running / 5 errors / 43% coverage ] ****** [6 done /0 queued / 2 running / 5 errors / 43% coverage ] ****** [7 done /1 queued / 2 running / 6 errors / 43% coverage ] ****** [7 done /0 queued / 3 running / 6 errors / 43% coverage ] ****** [7 done /0 queued / 3 running / 6 errors / 43% coverage ] ****** [8 done /0 queued / 2 running / 7 errors / 43% coverage ] ****** [9 done /2 queued / 2 running / 8 errors / 43% coverage ] ****** [9 done /1 queued / 3 running / 8 errors / 43% coverage ] ****** [9 done /0 queued / 4 running / 8 errors / 43% coverage ] ****** [9 done /0 queued / 4 running / 8 errors / 43% coverage ] ****** [10 done /1 queued / 4 running / 9 errors / 43% coverage ] ****** [10 done /0 queued / 5 running / 9 errors / 43% coverage ] ****** [10 done /0 queued / 5 running / 9 errors / 43% coverage ] ****** [11 done /0 queued / 5 running / 10 errors / 43% coverage ] ****** [11 done /0 queued / 5 running / 10 errors / 43% coverage ] ****** [12 done /1 queued / 5 running / 11 errors / 43% coverage ] ****** [12 done /0 queued / 6 running / 11 errors / 43% coverage ] ****** [12 done /0 queued / 6 running / 11 errors / 43% coverage ] ****** [13 done /1 queued / 6 running / 12 errors / 43% coverage ] ****** [13 done /0 queued / 7 running / 12 errors / 43% coverage ] ****** [13 done /0 queued / 7 running / 12 errors / 43% coverage ] ****** [14 done /1 queued / 7 running / 13 errors / 43% coverage ] ****** [14 done /0 queued / 8 running / 13 errors / 43% coverage ] ****** [14 done /0 queued / 8 running / 13 errors / 43% coverage ] ****** [15 done /1 queued / 8 running / 14 errors / 43% coverage ] ****** [15 done /0 queued / 9 running / 14 errors / 43% coverage ] ****** [15 done /0 queued / 9 running / 14 errors / 43% coverage ] ****** [16 done /1 queued / 9 running / 15 errors / 43% coverage ] ****** [16 done /0 queued / 10 running / 15 errors / 43% coverage ] ****** [16 done /0 queued / 10 running / 15 errors / 43% coverage ] ****** [17 done /1 queued / 10 running / 16 errors / 43% coverage ] ****** [17 done /0 queued / 11 running / 16 errors / 43% coverage ] ****** [17 done /0 queued / 11 running / 16 errors / 43% coverage ] ****** [18 done /1 queued / 11 running / 17 errors / 43% coverage ] ****** [18 done /0 queued / 12 running / 17 errors / 43% coverage ] ****** [18 done /0 queued / 12 running / 17 errors / 43% coverage ] ****** [19 done /1 queued / 12 running / 18 errors / 43% coverage ] ****** [19 done /0 queued / 13 running / 18 errors / 43% coverage ] ****** [19 done /0 queued / 13 running / 18 errors / 43% coverage ] ****** [20 done /1 queued / 13 running / 19 errors / 43% coverage ] ****** [20 done /0 queued / 14 running / 19 errors / 43% coverage ] ****** [20 done /0 queued / 14 running / 19 errors / 43% coverage ] ****** [21 done /1 queued / 14 running / 20 errors / 43% coverage ] ****** [21 done /0 queued / 15 running / 20 errors / 43% coverage ] ****** [21 done /0 queued / 15 running / 20 errors / 43% coverage ] ****** [22 done /2 queued / 15 running / 21 errors / 43% coverage ] ****** [22 done /1 queued / 16 running / 21 errors / 43% coverage ] ****** [22 done /1 queued / 16 running / 21 errors / 43% coverage ] ****** [23 done /2 queued / 16 running / 22 errors / 43% coverage ] ****** [23 done /2 queued / 16 running / 22 errors / 43% coverage ] ****** [24 done /3 queued / 16 running / 23 errors / 43% coverage ] ****** [24 done /3 queued / 16 running / 23 errors / 43% coverage ] ****** [25 done /6 queued / 16 running / 24 errors / 43% coverage ] ****** [25 done /6 queued / 16 running / 24 errors / 43% coverage ] ****** [26 done /7 queued / 16 running / 25 errors / 43% coverage ] ****** [26 done /7 queued / 16 running / 25 errors / 43% coverage ] ****** [27 done /8 queued / 16 running / 26 errors / 43% coverage ] ****** [27 done /8 queued / 16 running / 26 errors / 43% coverage ] ****** [28 done /9 queued / 16 running / 27 errors / 43% coverage ] ****** [28 done /9 queued / 16 running / 27 errors / 43% coverage ] ****** [29 done /10 queued / 16 running / 28 errors / 43% coverage ] ****** [29 done /10 queued / 16 running / 28 errors / 43% coverage ] ****** [30 done /11 queued / 16 running / 29 errors / 43% coverage ] ****** [30 done /11 queued / 16 running / 29 errors / 43% coverage ] ****** [31 done /12 queued / 16 running / 30 errors / 43% coverage ] ****** [31 done /12 queued / 16 running / 30 errors / 43% coverage ] ****** [32 done /13 queued / 16 running / 31 errors / 43% coverage ] ****** [32 done /13 queued / 16 running / 31 errors / 43% coverage ] ****** [33 done /14 queued / 16 running / 32 errors / 43% coverage ] ****** [33 done /14 queued / 16 running / 32 errors / 43% coverage ] ****** [34 done /15 queued / 16 running / 33 errors / 43% coverage ] ****** [34 done /15 queued / 16 running / 33 errors / 43% coverage ] ****** [35 done /16 queued / 16 running / 34 errors / 43% coverage ] ****** [35 done /16 queued / 16 running / 34 errors / 43% coverage ] ****** [36 done /18 queued / 16 running / 35 errors / 43% coverage ] ****** [36 done /18 queued / 16 running / 35 errors / 43% coverage ] ****** [37 done /19 queued / 16 running / 36 errors / 43% coverage ] ****** [37 done /19 queued / 16 running / 36 errors / 43% coverage ] ****** [38 done /21 queued / 16 running / 37 errors / 43% coverage ] ****** [38 done /21 queued / 16 running / 37 errors / 43% coverage ] ****** [39 done /21 queued / 16 running / 38 errors / 43% coverage ] ****** [39 done /21 queued / 16 running / 38 errors / 43% coverage ] ****** [40 done /22 queued / 16 running / 39 errors / 43% coverage ] ****** [40 done /22 queued / 16 running / 39 errors / 43% coverage ] ****** [41 done /23 queued / 16 running / 40 errors / 43% coverage ] ****** [41 done /23 queued / 16 running / 40 errors / 43% coverage ] ****** [42 done /23 queued / 16 running / 41 errors / 43% coverage ] ****** [42 done /23 queued / 16 running / 41 errors / 43% coverage ] ****** [43 done /27 queued / 16 running / 42 errors / 43% coverage ] ****** [43 done /27 queued / 16 running / 42 errors / 43% coverage ] ****** [44 done /27 queued / 16 running / 43 errors / 43% coverage ] ****** [44 done /27 queued / 16 running / 43 errors / 43% coverage ] ****** [45 done /28 queued / 16 running / 44 errors / 43% coverage ] ****** [45 done /28 queued / 16 running / 44 errors / 43% coverage ] ****** [46 done /31 queued / 16 running / 45 errors / 43% coverage ] ****** [46 done /31 queued / 16 running / 45 errors / 43% coverage ] ****** [47 done /32 queued / 16 running / 46 errors / 43% coverage ] ****** [47 done /32 queued / 16 running / 46 errors / 43% coverage ] ****** [48 done /35 queued / 16 running / 47 errors / 43% coverage ] ****** [48 done /35 queued / 16 running / 47 errors / 43% coverage ] ****** [49 done /36 queued / 16 running / 48 errors / 43% coverage ] ****** [49 done /36 queued / 16 running / 48 errors / 43% coverage ] ****** [50 done /38 queued / 16 running / 49 errors / 43% coverage ] ****** [50 done /38 queued / 16 running / 49 errors / 43% coverage ] ****** [51 done /40 queued / 16 running / 50 errors / 43% coverage ] ****** [51 done /40 queued / 16 running / 50 errors / 43% coverage ] ****** [52 done /42 queued / 16 running / 51 errors / 43% coverage ] ****** [52 done /42 queued / 16 running / 51 errors / 43% coverage ] ****** [53 done /42 queued / 16 running / 52 errors / 43% coverage ] ****** [53 done /42 queued / 16 running / 52 errors / 43% coverage ] ****** [54 done /44 queued / 16 running / 53 errors / 43% coverage ] ****** [54 done /44 queued / 16 running / 53 errors / 43% coverage ] ****** [55 done /44 queued / 16 running / 54 errors / 43% coverage ] ****** [55 done /44 queued / 16 running / 54 errors / 43% coverage ] ****** [56 done /45 queued / 16 running / 55 errors / 43% coverage ] ****** [56 done /45 queued / 16 running / 55 errors / 43% coverage ] ****** [57 done /46 queued / 16 running / 56 errors / 43% coverage ] ****** [57 done /46 queued / 16 running / 56 errors / 43% coverage ] ****** [58 done /46 queued / 16 running / 57 errors / 43% coverage ] ****** [58 done /46 queued / 16 running / 57 errors / 43% coverage ] ****** [59 done /47 queued / 16 running / 58 errors / 43% coverage ] ****** [59 done /47 queued / 16 running / 58 errors / 43% coverage ] ****** [60 done /47 queued / 16 running / 59 errors / 43% coverage ] ****** [60 done /47 queued / 16 running / 59 errors / 43% coverage ] ****** [61 done /47 queued / 16 running / 60 errors / 43% coverage ] ****** [61 done /47 queued / 16 running / 60 errors / 43% coverage ] ****** [62 done /48 queued / 16 running / 61 errors / 43% coverage ] ****** [62 done /48 queued / 16 running / 61 errors / 43% coverage ] ****** [63 done /49 queued / 16 running / 62 errors / 43% coverage ] ****** [63 done /49 queued / 16 running / 62 errors / 43% coverage ] ****** [64 done /49 queued / 16 running / 63 errors / 43% coverage ] ****** [64 done /49 queued / 16 running / 63 errors / 43% coverage ] ****** [65 done /50 queued / 16 running / 64 errors / 43% coverage ] ****** [65 done /50 queued / 16 running / 64 errors / 43% coverage ] ****** [66 done /51 queued / 16 running / 65 errors / 43% coverage ] ****** [66 done /51 queued / 16 running / 65 errors / 43% coverage ] ****** [67 done /51 queued / 16 running / 66 errors / 43% coverage ] ****** [67 done /51 queued / 16 running / 66 errors / 43% coverage ] ****** [68 done /52 queued / 16 running / 67 errors / 43% coverage ] ****** [68 done /52 queued / 16 running / 67 errors / 43% coverage ] ****** [69 done /52 queued / 16 running / 68 errors / 43% coverage ] ****** [69 done /52 queued / 16 running / 68 errors / 43% coverage ] ****** [70 done /53 queued / 16 running / 69 errors / 43% coverage ] ****** [70 done /53 queued / 16 running / 69 errors / 43% coverage ] ****** [71 done /53 queued / 16 running / 70 errors / 43% coverage ] ****** [71 done /53 queued / 16 running / 70 errors / 43% coverage ] ****** [72 done /54 queued / 16 running / 71 errors / 43% coverage ] ****** [72 done /54 queued / 16 running / 71 errors / 43% coverage ] ****** [73 done /54 queued / 16 running / 72 errors / 43% coverage ] ****** [73 done /54 queued / 16 running / 72 errors / 43% coverage ] ****** [74 done /54 queued / 16 running / 73 errors / 43% coverage ] ****** [74 done /54 queued / 16 running / 73 errors / 43% coverage ] ****** [75 done /56 queued / 16 running / 74 errors / 43% coverage ] ****** [75 done /56 queued / 16 running / 74 errors / 43% coverage ] ****** [76 done /57 queued / 16 running / 75 errors / 43% coverage ] ****** [76 done /57 queued / 16 running / 75 errors / 43% coverage ] ****** [77 done /59 queued / 16 running / 76 errors / 43% coverage ] ****** [77 done /59 queued / 16 running / 76 errors / 43% coverage ] ****** [78 done /59 queued / 16 running / 77 errors / 43% coverage ] ****** [78 done /59 queued / 16 running / 77 errors / 43% coverage ] ****** [79 done /60 queued / 16 running / 78 errors / 43% coverage ] ****** [79 done /60 queued / 16 running / 78 errors / 43% coverage ] ****** [80 done /61 queued / 16 running / 79 errors / 43% coverage ] ****** [80 done /61 queued / 16 running / 79 errors / 43% coverage ] ****** [81 done /62 queued / 16 running / 80 errors / 43% coverage ] ****** [81 done /62 queued / 16 running / 80 errors / 43% coverage ] ****** [82 done /63 queued / 16 running / 81 errors / 43% coverage ] ****** [82 done /63 queued / 16 running / 81 errors / 43% coverage ] ****** [83 done /64 queued / 16 running / 82 errors / 43% coverage ] ****** [83 done /64 queued / 16 running / 82 errors / 43% coverage ] ****** [84 done /65 queued / 16 running / 83 errors / 43% coverage ] ****** [84 done /65 queued / 16 running / 83 errors / 43% coverage ] ****** [85 done /66 queued / 16 running / 84 errors / 43% coverage ] ****** [85 done /66 queued / 16 running / 84 errors / 43% coverage ] ****** [86 done /67 queued / 16 running / 85 errors / 43% coverage ] ****** [86 done /67 queued / 16 running / 85 errors / 43% coverage ] ****** [87 done /69 queued / 16 running / 86 errors / 43% coverage ] ****** [87 done /69 queued / 16 running / 86 errors / 43% coverage ] ****** [88 done /69 queued / 16 running / 87 errors / 43% coverage ] ****** [88 done /69 queued / 16 running / 87 errors / 43% coverage ] ****** [89 done /70 queued / 16 running / 88 errors / 43% coverage ] ****** [89 done /70 queued / 16 running / 88 errors / 43% coverage ] ****** [90 done /71 queued / 16 running / 89 errors / 43% coverage ] ****** [90 done /71 queued / 16 running / 89 errors / 43% coverage ] ****** [91 done /72 queued / 16 running / 90 errors / 43% coverage ] ****** [91 done /72 queued / 16 running / 90 errors / 43% coverage ] ****** [92 done /72 queued / 16 running / 91 errors / 43% coverage ] ****** [92 done /72 queued / 16 running / 91 errors / 43% coverage ] ****** [93 done /73 queued / 16 running / 92 errors / 43% coverage ] ****** [93 done /73 queued / 16 running / 92 errors / 43% coverage ] ****** [94 done /75 queued / 16 running / 93 errors / 43% coverage ] ****** [94 done /75 queued / 16 running / 93 errors / 43% coverage ] ****** [95 done /76 queued / 16 running / 94 errors / 43% coverage ] ****** [95 done /76 queued / 16 running / 94 errors / 43% coverage ] ****** [96 done /80 queued / 16 running / 95 errors / 43% coverage ] ****** [96 done /80 queued / 16 running / 95 errors / 43% coverage ] ****** [97 done /82 queued / 16 running / 96 errors / 43% coverage ] ****** [97 done /82 queued / 16 running / 96 errors / 43% coverage ] ****** [98 done /83 queued / 16 running / 97 errors / 43% coverage ] ****** [98 done /83 queued / 16 running / 97 errors / 43% coverage ] ****** [99 done /84 queued / 16 running / 98 errors / 43% coverage ] ****** [99 done /84 queued / 16 running / 98 errors / 43% coverage ] ****** [100 done /85 queued / 16 running / 99 errors / 43% coverage ] ****** [100 done /85 queued / 16 running / 99 errors / 43% coverage ] ****** [101 done /85 queued / 16 running / 100 errors / 43% coverage ] ****** [101 done /85 queued / 16 running / 100 errors / 43% coverage ] ****** [102 done /87 queued / 16 running / 101 errors / 43% coverage ] ****** [102 done /87 queued / 16 running / 101 errors / 43% coverage ] ****** [103 done /90 queued / 16 running / 102 errors / 43% coverage ] ****** [103 done /90 queued / 16 running / 102 errors / 43% coverage ] ****** [104 done /91 queued / 16 running / 103 errors / 43% coverage ] ****** [104 done /91 queued / 16 running / 103 errors / 43% coverage ] ****** [105 done /94 queued / 16 running / 104 errors / 43% coverage ] ****** [105 done /94 queued / 16 running / 104 errors / 43% coverage ] ****** [106 done /95 queued / 16 running / 105 errors / 43% coverage ] ****** [106 done /95 queued / 16 running / 105 errors / 43% coverage ] ****** [107 done /96 queued / 16 running / 106 errors / 43% coverage ] ****** [107 done /96 queued / 16 running / 106 errors / 43% coverage ] ****** [108 done /97 queued / 16 running / 107 errors / 43% coverage ] ****** [108 done /97 queued / 16 running / 107 errors / 43% coverage ] ****** [109 done /98 queued / 16 running / 108 errors / 43% coverage ] ****** [109 done /98 queued / 16 running / 108 errors / 43% coverage ] ****** [110 done /99 queued / 16 running / 109 errors / 43% coverage ] ****** [110 done /99 queued / 16 running / 109 errors / 43% coverage ] ****** [111 done /100 queued / 16 running / 110 errors / 43% coverage ] ****** [111 done /100 queued / 16 running / 110 errors / 43% coverage ] ****** [112 done /100 queued / 16 running / 111 errors / 43% coverage ] ****** [112 done /100 queued / 16 running / 111 errors / 43% coverage ] ****** [113 done /100 queued / 16 running / 112 errors / 43% coverage ] ****** [113 done /100 queued / 16 running / 112 errors / 43% coverage ] ****** [114 done /100 queued / 16 running / 113 errors / 43% coverage ] ****** [114 done /100 queued / 16 running / 113 errors / 43% coverage ] ****** [115 done /100 queued / 16 running / 114 errors / 43% coverage ] ****** [115 done /100 queued / 16 running / 114 errors / 43% coverage ] ****** [116 done /101 queued / 16 running / 115 errors / 43% coverage ] ****** [116 done /101 queued / 16 running / 115 errors / 43% coverage ] ****** [117 done /102 queued / 16 running / 116 errors / 43% coverage ] ****** [117 done /102 queued / 16 running / 116 errors / 43% coverage ] ****** [118 done /103 queued / 16 running / 117 errors / 43% coverage ] ****** [118 done /103 queued / 16 running / 117 errors / 43% coverage ] ****** [119 done /103 queued / 16 running / 118 errors / 43% coverage ] ****** [119 done /103 queued / 16 running / 118 errors / 43% coverage ] ****** [120 done /105 queued / 16 running / 119 errors / 43% coverage ] ****** [120 done /105 queued / 16 running / 119 errors / 43% coverage ] ****** [121 done /105 queued / 16 running / 120 errors / 43% coverage ] ****** [121 done /105 queued / 16 running / 120 errors / 43% coverage ] ****** [122 done /107 queued / 16 running / 121 errors / 43% coverage ] ****** [122 done /107 queued / 16 running / 121 errors / 43% coverage ] ****** [123 done /108 queued / 16 running / 122 errors / 43% coverage ] ****** [123 done /108 queued / 16 running / 122 errors / 43% coverage ] ****** [124 done /108 queued / 16 running / 123 errors / 43% coverage ] ****** [124 done /108 queued / 16 running / 123 errors / 43% coverage ] ****** [125 done /110 queued / 16 running / 124 errors / 43% coverage ] ****** [125 done /110 queued / 16 running / 124 errors / 43% coverage ] ****** [126 done /111 queued / 16 running / 125 errors / 43% coverage ] ****** [126 done /111 queued / 16 running / 125 errors / 43% coverage ] ****** [127 done /111 queued / 16 running / 126 errors / 43% coverage ] ****** [127 done /111 queued / 16 running / 126 errors / 43% coverage ] ****** [128 done /112 queued / 16 running / 127 errors / 43% coverage ] ****** [128 done /112 queued / 16 running / 127 errors / 43% coverage ] ****** [129 done /116 queued / 16 running / 128 errors / 43% coverage ] ****** [129 done /116 queued / 16 running / 128 errors / 43% coverage ] ****** [130 done /117 queued / 16 running / 129 errors / 43% coverage ] ****** [130 done /117 queued / 16 running / 129 errors / 43% coverage ] ****** [131 done /119 queued / 16 running / 130 errors / 43% coverage ] ****** [131 done /119 queued / 16 running / 130 errors / 43% coverage ] ****** [132 done /120 queued / 16 running / 131 errors / 43% coverage ] ****** [132 done /120 queued / 16 running / 131 errors / 43% coverage ] ****** [133 done /121 queued / 16 running / 132 errors / 43% coverage ] ****** [133 done /121 queued / 16 running / 132 errors / 43% coverage ] ****** [134 done /122 queued / 16 running / 133 errors / 43% coverage ] ****** [134 done /122 queued / 16 running / 133 errors / 43% coverage ] ****** [135 done /124 queued / 16 running / 134 errors / 43% coverage ] ****** [135 done /124 queued / 16 running / 134 errors / 43% coverage ] ****** [136 done /125 queued / 16 running / 135 errors / 43% coverage ] ****** [136 done /125 queued / 16 running / 135 errors / 43% coverage ] ****** [137 done /125 queued / 16 running / 136 errors / 43% coverage ] ****** [137 done /125 queued / 16 running / 136 errors / 43% coverage ] ****** [138 done /127 queued / 16 running / 137 errors / 43% coverage ] ****** [138 done /127 queued / 16 running / 137 errors / 43% coverage ] ****** [139 done /128 queued / 16 running / 138 errors / 43% coverage ] ****** [139 done /128 queued / 16 running / 138 errors / 43% coverage ] ****** [140 done /129 queued / 16 running / 139 errors / 43% coverage ] ****** [140 done /129 queued / 16 running / 139 errors / 43% coverage ] ****** [141 done /130 queued / 16 running / 140 errors / 43% coverage ] ****** [141 done /130 queued / 16 running / 140 errors / 43% coverage ] ****** [142 done /132 queued / 16 running / 141 errors / 43% coverage ] ****** [142 done /132 queued / 16 running / 141 errors / 43% coverage ] ****** [143 done /132 queued / 16 running / 142 errors / 43% coverage ] ****** [143 done /132 queued / 16 running / 142 errors / 43% coverage ] ****** [144 done /132 queued / 16 running / 143 errors / 43% coverage ] ****** [144 done /132 queued / 16 running / 143 errors / 43% coverage ] ****** [145 done /133 queued / 16 running / 144 errors / 43% coverage ] ****** [145 done /133 queued / 16 running / 144 errors / 43% coverage ] ****** [146 done /134 queued / 16 running / 145 errors / 43% coverage ] ****** [146 done /134 queued / 16 running / 145 errors / 43% coverage ] ****** [147 done /134 queued / 16 running / 146 errors / 43% coverage ] ****** [147 done /134 queued / 16 running / 146 errors / 43% coverage ] ****** [148 done /135 queued / 16 running / 147 errors / 43% coverage ] ****** [148 done /135 queued / 16 running / 147 errors / 43% coverage ] ****** [149 done /136 queued / 16 running / 148 errors / 43% coverage ] ****** [149 done /136 queued / 16 running / 148 errors / 43% coverage ] ****** [150 done /136 queued / 16 running / 149 errors / 43% coverage ] ****** [150 done /136 queued / 16 running / 149 errors / 43% coverage ] ****** [151 done /137 queued / 16 running / 150 errors / 43% coverage ] ****** [151 done /137 queued / 16 running / 150 errors / 43% coverage ] ****** [152 done /137 queued / 16 running / 151 errors / 43% coverage ] ****** [152 done /137 queued / 16 running / 151 errors / 43% coverage ] ****** [153 done /137 queued / 16 running / 152 errors / 43% coverage ] ****** [153 done /137 queued / 16 running / 152 errors / 43% coverage ] ****** [154 done /138 queued / 16 running / 153 errors / 43% coverage ] ****** [154 done /138 queued / 16 running / 153 errors / 43% coverage ] ****** [155 done /140 queued / 16 running / 154 errors / 43% coverage ] ****** [155 done /140 queued / 16 running / 154 errors / 43% coverage ] ****** [156 done /140 queued / 16 running / 155 errors / 43% coverage ] ****** [156 done /140 queued / 16 running / 155 errors / 43% coverage ] ****** [157 done /144 queued / 16 running / 156 errors / 43% coverage ] ****** [157 done /144 queued / 16 running / 156 errors / 43% coverage ] ****** [158 done /145 queued / 16 running / 157 errors / 43% coverage ] ****** [158 done /145 queued / 16 running / 157 errors / 43% coverage ] ****** [159 done /146 queued / 16 running / 158 errors / 43% coverage ] ****** [159 done /146 queued / 16 running / 158 errors / 43% coverage ] ****** [160 done /148 queued / 16 running / 159 errors / 43% coverage ] ****** [160 done /148 queued / 16 running / 159 errors / 43% coverage ] ****** [161 done /149 queued / 16 running / 160 errors / 43% coverage ] ****** [161 done /149 queued / 16 running / 160 errors / 43% coverage ] ****** [162 done /150 queued / 16 running / 161 errors / 43% coverage ] ****** [162 done /150 queued / 16 running / 161 errors / 43% coverage ] ****** [163 done /152 queued / 16 running / 162 errors / 43% coverage ] ****** [163 done /152 queued / 16 running / 162 errors / 43% coverage ] ****** [164 done /153 queued / 16 running / 163 errors / 43% coverage ] ****** [164 done /153 queued / 16 running / 163 errors / 43% coverage ] ****** [165 done /154 queued / 16 running / 164 errors / 43% coverage ] ****** [165 done /154 queued / 16 running / 164 errors / 43% coverage ] ****** [166 done /155 queued / 16 running / 165 errors / 43% coverage ] ****** [166 done /155 queued / 16 running / 165 errors / 43% coverage ] ****** [167 done /156 queued / 16 running / 166 errors / 43% coverage ] ****** [167 done /156 queued / 16 running / 166 errors / 43% coverage ] ****** [168 done /157 queued / 16 running / 167 errors / 43% coverage ] ****** [168 done /157 queued / 16 running / 167 errors / 43% coverage ] ****** [169 done /158 queued / 16 running / 168 errors / 43% coverage ] ****** [169 done /158 queued / 16 running / 168 errors / 43% coverage ] ****** [170 done /159 queued / 16 running / 169 errors / 43% coverage ] ****** [170 done /159 queued / 16 running / 169 errors / 43% coverage ] ****** [171 done /160 queued / 16 running / 170 errors / 43% coverage ] ****** [171 done /160 queued / 16 running / 170 errors / 43% coverage ] ****** [172 done /161 queued / 16 running / 171 errors / 43% coverage ] ****** [172 done /161 queued / 16 running / 171 errors / 43% coverage ] ****** [173 done /161 queued / 16 running / 172 errors / 43% coverage ] ****** [173 done /161 queued / 16 running / 172 errors / 43% coverage ] ****** [174 done /161 queued / 16 running / 173 errors / 43% coverage ] ****** [174 done /161 queued / 16 running / 173 errors / 43% coverage ] ****** [175 done /162 queued / 16 running / 174 errors / 43% coverage ] ****** [175 done /162 queued / 16 running / 174 errors / 43% coverage ] ****** [176 done /163 queued / 16 running / 175 errors / 43% coverage ] ****** [176 done /163 queued / 16 running / 175 errors / 43% coverage ] ****** [177 done /164 queued / 16 running / 176 errors / 43% coverage ] ****** [177 done /164 queued / 16 running / 176 errors / 43% coverage ] ****** [178 done /166 queued / 16 running / 177 errors / 43% coverage ] ****** [178 done /166 queued / 16 running / 177 errors / 43% coverage ] ****** [179 done /167 queued / 16 running / 178 errors / 43% coverage ] ****** [179 done /167 queued / 16 running / 178 errors / 43% coverage ] ****** [180 done /167 queued / 16 running / 179 errors / 43% coverage ] ****** [180 done /167 queued / 16 running / 179 errors / 43% coverage ] ****** [181 done /168 queued / 16 running / 180 errors / 43% coverage ] ****** [181 done /168 queued / 16 running / 180 errors / 43% coverage ] ****** [182 done /168 queued / 16 running / 181 errors / 43% coverage ] ****** [182 done /168 queued / 16 running / 181 errors / 43% coverage ] ****** [183 done /170 queued / 16 running / 182 errors / 43% coverage ] ****** [183 done /170 queued / 16 running / 182 errors / 43% coverage ] ****** [184 done /170 queued / 16 running / 183 errors / 43% coverage ] ****** [184 done /170 queued / 16 running / 183 errors / 43% coverage ] ****** [185 done /171 queued / 16 running / 184 errors / 43% coverage ] ****** [185 done /171 queued / 16 running / 184 errors / 43% coverage ] ****** [186 done /172 queued / 16 running / 185 errors / 43% coverage ] ****** [186 done /172 queued / 16 running / 185 errors / 43% coverage ] ****** [187 done /174 queued / 16 running / 186 errors / 43% coverage ] ****** [187 done /174 queued / 16 running / 186 errors / 43% coverage ] ****** [188 done /178 queued / 16 running / 187 errors / 43% coverage ] ****** [188 done /178 queued / 16 running / 187 errors / 43% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","toString","apply","bound ","captureStackTrace","cwd","max","getFileName","getLineNumber","getColumnNumber","isEval","getFunctionName","create","reduce","parseInt","charCodeAt","abs","Number","toUpperCase","join","call","RegExp","getOwnPropertyNames","getOwnPropertyDescriptor","isArray","Array","Int32Array"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0,"Switcher":false,"Target_Switch_Base":0} start 0.0313 took 4.0321s
*-- Test Case {"Switcher":true,"Target_Switch_Base":0,"_bound":1,"ExpansionArg_type":0} start 4.1425 took 42.946s
*-- Errors occured in test {"Switcher":true,"Target_Switch_Base":0,"_bound":1,"ExpansionArg_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"Target_Switch_Base":0,"_bound":1}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":1,"_bound":2} start 47.6823 took 44.454s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":1,"_bound":2}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":1,"_bound":2}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":2,"_bound":3,"ExpansionArg_int":0} start 92.493 took 43.5666s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":2,"_bound":3,"ExpansionArg_int":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":2,"_bound":3}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":3,"ExpansionArg_int":0,"_bound":4,"ExpansionArg_string":"PureString"} start 136.499 took 46.0338s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":3,"ExpansionArg_int":0,"_bound":4,"ExpansionArg_string":"PureString"}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":3,"ExpansionArg_int":0,"_bound":4}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_string":"","_bound":5,"ExpansionArg_array_length":0} start 183.079 took 50.4982s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_string":"","_bound":5,"ExpansionArg_array_length":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_string":"","_bound":5}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"_bound":7,"ExpansionArg_array_element_0_type":0} start 233.9426 took 44.1237s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"_bound":7,"ExpansionArg_array_element_0_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"_bound":7}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":5,"ExpansionArg_array_length":0,"_bound":6,"ExpansionArg_bool":false} start 234.0831 took 46.3805s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":5,"ExpansionArg_array_length":0,"_bound":6,"ExpansionArg_bool":false}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":5,"ExpansionArg_array_length":0,"_bound":6}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":2,"_bound":8,"ExpansionArg_array_element_0_int":0} start 278.5037 took 43.6563s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":2,"_bound":8,"ExpansionArg_array_element_0_int":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":2,"_bound":8}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"_bound":9,"ExpansionArg_array_element_1_type":0} start 278.4148 took 44.7395s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"_bound":9,"ExpansionArg_array_element_1_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"_bound":9}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_0_int":0,"_bound":9} start 322.5924 took 44.9439s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_0_int":0,"_bound":9}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_0_int":0,"_bound":9}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"_bound":10} start 323.423 took 45.3807s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"_bound":10}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"_bound":10}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"_bound":11,"ExpansionArg_array_element_1_type":0} start 322.4301 took 48.1154s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"_bound":11,"ExpansionArg_array_element_1_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"_bound":11}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_int":0,"_bound":10,"ExpansionArg_array_element_0_string":"PureString"} start 322.783 took 48.7776s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_int":0,"_bound":10,"ExpansionArg_array_element_0_string":"PureString"}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_int":0,"_bound":10}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"_bound":11,"ExpansionArg_array_element_2_type":0} start 323.6168 took 48.747s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"_bound":11,"ExpansionArg_array_element_2_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"_bound":11}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":1,"_bound":10,"ExpansionArg_array_element_1_type":0} start 367.8219 took 41.1311s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":1,"_bound":10,"ExpansionArg_array_element_1_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":1,"_bound":10}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_string":"","_bound":11,"ExpansionArg_array_element_0_bool":false} start 371.9163 took 39.5843s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_string":"","_bound":11,"ExpansionArg_array_element_0_bool":false}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_string":"","_bound":11}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"_bound":13,"ExpansionArg_array_element_2_type":0} start 371.0282 took 42.1161s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"_bound":13,"ExpansionArg_array_element_2_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"_bound":13}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"_bound":12,"ExpansionArg_array_element_2_type":0} start 369.3031 took 44.4066s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"_bound":12,"ExpansionArg_array_element_2_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"_bound":12}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":1,"_bound":12} start 372.7342 took 42.2715s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":1,"_bound":12}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":1,"_bound":12}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","_bound":12,"ExpansionArg_array_element_1_type":0} start 372.0856 took 43.4136s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","_bound":12,"ExpansionArg_array_element_1_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","_bound":12}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":3,"_bound":11,"ExpansionArg_array_element_1_string":"PureString"} start 369.2036 took 47.0029s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":3,"_bound":11,"ExpansionArg_array_element_1_string":"PureString"}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":3,"_bound":11}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":1,"_bound":12} start 370.8681 took 48.4586s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":1,"_bound":12}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":1,"_bound":12}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"_bound":13,"ExpansionArg_array_element_3_type":0} start 372.8657 took 46.7998s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"_bound":13,"ExpansionArg_array_element_3_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"_bound":13}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":3,"_bound":11,"ExpansionArg_array_element_1_string":"PureString"} start 409.2524 took 39.7361s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":3,"_bound":11,"ExpansionArg_array_element_1_string":"PureString"}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":3,"_bound":11}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":4,"ExpansionArg_array_element_0_bool":false,"_bound":12,"ExpansionArg_array_element_0_array_length":0} start 411.7716 took 40.629s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":4,"ExpansionArg_array_element_0_bool":false,"_bound":12,"ExpansionArg_array_element_0_array_length":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":1,"ExpansionArg_array_element_0_type":4,"ExpansionArg_array_element_0_bool":false,"_bound":12}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_bool":false,"_bound":13,"ExpansionArg_array_element_1_type":0} start 411.8756 took 41.409s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_bool":false,"_bound":13,"ExpansionArg_array_element_1_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_bool":false,"_bound":13}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"_bound":15,"ExpansionArg_array_element_3_type":0} start 413.5079 took 40.2339s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"_bound":15,"ExpansionArg_array_element_3_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"_bound":15}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":1,"_bound":13} start 415.8377 took 38.4321s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":1,"_bound":13}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":1,"_bound":13}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":1,"_bound":14} start 413.3997 took 41.4707s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":1,"_bound":14}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":1,"_bound":14}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":1,"_bound":14,"ExpansionArg_array_element_3_type":0} start 415.355 took 39.5157s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":1,"_bound":14,"ExpansionArg_array_element_3_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":1,"_bound":14}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":0,"_bound":12,"ExpansionArg_array_element_2_type":0} start 409.392 took 46.5138s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":0,"_bound":12,"ExpansionArg_array_element_2_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":0,"_bound":12}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":5,"ExpansionArg_array_element_1_string":"","_bound":13,"ExpansionArg_array_element_1_bool":false} start 416.669 took 40.9667s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":5,"ExpansionArg_array_element_1_string":"","_bound":13,"ExpansionArg_array_element_1_bool":false}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":5,"ExpansionArg_array_element_1_string":"","_bound":13}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":0,"_bound":14,"ExpansionArg_array_element_3_type":0} start 414.2173 took 43.8403s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":0,"_bound":14,"ExpansionArg_array_element_3_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":0,"_bound":14}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":0,"_bound":14,"ExpansionArg_array_element_2_type":0} start 416.0263 took 42.4535s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":0,"_bound":14,"ExpansionArg_array_element_2_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":0,"_bound":14}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":2,"_bound":13,"ExpansionArg_array_element_2_int":0} start 414.0799 took 45.0729s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":2,"_bound":13,"ExpansionArg_array_element_2_int":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":2,"_bound":13}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":2,"_bound":13,"ExpansionArg_array_element_2_int":0} start 415.2419 took 44.7072s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":2,"_bound":13,"ExpansionArg_array_element_2_int":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":2,"_bound":13}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":3,"_bound":13,"ExpansionArg_array_element_1_string":"PureString"} start 419.5368 took 41.1202s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":3,"_bound":13,"ExpansionArg_array_element_1_string":"PureString"}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":3,"_bound":13}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":2,"ExpansionArg_array_element_1_string":"","_bound":12,"ExpansionArg_array_element_1_int":0} start 416.5602 took 45.1007s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":2,"ExpansionArg_array_element_1_string":"","_bound":12,"ExpansionArg_array_element_1_int":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":2,"ExpansionArg_array_element_1_string":"","_bound":12}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":1,"_bound":14} start 419.9645 took 43.8668s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":1,"_bound":14}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":1,"_bound":14}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":5,"ExpansionArg_array_element_1_string":"","_bound":14,"ExpansionArg_array_element_1_bool":false} start 452.6022 took 40.6061s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":5,"ExpansionArg_array_element_1_string":"","_bound":14,"ExpansionArg_array_element_1_bool":false}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":5,"ExpansionArg_array_element_1_string":"","_bound":14}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":2,"ExpansionArg_array_element_1_string":"","_bound":13,"ExpansionArg_array_element_1_int":0} start 449.3159 took 44.7076s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":2,"ExpansionArg_array_element_1_string":"","_bound":13,"ExpansionArg_array_element_1_int":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":2,"ExpansionArg_array_element_1_string":"","_bound":13}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_bool":false,"ExpansionArg_array_element_1_type":6,"_bound":14,"ExpansionArg_array_element_1_bool":false} start 454.0692 took 42.2976s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_bool":false,"ExpansionArg_array_element_1_type":6,"_bound":14,"ExpansionArg_array_element_1_bool":false}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_bool":false,"ExpansionArg_array_element_1_type":6,"_bound":14}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_1_string":"","_bound":12} start 453.5734 took 43.2163s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_1_string":"","_bound":12}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_1_string":"","_bound":12}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":1,"_bound":16} start 455.7221 took 41.0678s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":1,"_bound":16}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":1,"_bound":16}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":5,"_bound":14,"ExpansionArg_array_element_1_bool":false} start 454.573 took 44.084s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":5,"_bound":14,"ExpansionArg_array_element_1_bool":false}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":5,"_bound":14}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":4,"ExpansionArg_array_element_1_bool":false,"_bound":14,"ExpansionArg_array_element_1_array_length":0} start 457.8652 took 41.267s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":4,"ExpansionArg_array_element_1_bool":false,"_bound":14,"ExpansionArg_array_element_1_array_length":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":4,"ExpansionArg_array_element_1_bool":false,"_bound":14}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":5,"_bound":15,"ExpansionArg_array_element_2_bool":false} start 455.2575 took 43.8748s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":5,"_bound":15,"ExpansionArg_array_element_2_bool":false}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":5,"_bound":15}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":1,"_bound":15} start 458.747 took 41.4871s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":1,"_bound":15}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":1,"_bound":15}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":2,"_bound":15,"ExpansionArg_array_element_3_int":0} start 458.3066 took 41.9346s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":2,"_bound":15,"ExpansionArg_array_element_3_int":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":2,"_bound":15}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":5,"ExpansionArg_array_element_2_int":0,"_bound":14,"ExpansionArg_array_element_2_bool":false} start 460.2416 took 39.9997s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":5,"ExpansionArg_array_element_2_int":0,"_bound":14,"ExpansionArg_array_element_2_bool":false}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":5,"ExpansionArg_array_element_2_int":0,"_bound":14}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":5,"ExpansionArg_array_element_2_int":0,"_bound":15,"ExpansionArg_array_element_2_bool":false} start 459.3947 took 42.1813s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":5,"ExpansionArg_array_element_2_int":0,"_bound":15,"ExpansionArg_array_element_2_bool":false}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":5,"ExpansionArg_array_element_2_int":0,"_bound":15}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":2,"ExpansionArg_array_element_1_string":"","_bound":14,"ExpansionArg_array_element_1_int":0} start 461.0207 took 42.2522s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":2,"ExpansionArg_array_element_1_string":"","_bound":14,"ExpansionArg_array_element_1_int":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":2,"ExpansionArg_array_element_1_string":"","_bound":14}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":1,"ExpansionArg_array_element_3_type":2,"_bound":15,"ExpansionArg_array_element_3_int":0} start 456.2211 took 48.6818s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":1,"ExpansionArg_array_element_3_type":2,"_bound":15,"ExpansionArg_array_element_3_int":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":1,"ExpansionArg_array_element_3_type":2,"_bound":15}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":1,"ExpansionArg_array_element_2_int":0,"_bound":14} start 464.0372 took 41.3892s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":1,"ExpansionArg_array_element_2_int":0,"_bound":14}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":1,"ExpansionArg_array_element_2_int":0,"_bound":14}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":5,"ExpansionArg_array_element_1_string":"","_bound":15,"ExpansionArg_array_element_1_bool":false} start 461.9298 took 47.6781s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":5,"ExpansionArg_array_element_1_string":"","_bound":15,"ExpansionArg_array_element_1_bool":false}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":5,"ExpansionArg_array_element_1_string":"","_bound":15}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":4,"ExpansionArg_array_element_1_bool":false,"_bound":15,"ExpansionArg_array_element_1_array_length":0} start 493.5062 took 44.0947s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":4,"ExpansionArg_array_element_1_bool":false,"_bound":15,"ExpansionArg_array_element_1_array_length":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":4,"ExpansionArg_array_element_1_bool":false,"_bound":15}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_bool":false,"ExpansionArg_array_element_1_type":2,"ExpansionArg_array_element_1_bool":false,"_bound":16,"ExpansionArg_array_element_1_int":0} start 497.4828 took 41.4254s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_bool":false,"ExpansionArg_array_element_1_type":2,"ExpansionArg_array_element_1_bool":false,"_bound":16,"ExpansionArg_array_element_1_int":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_bool":false,"ExpansionArg_array_element_1_type":2,"ExpansionArg_array_element_1_bool":false,"_bound":16}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":4,"ExpansionArg_array_element_2_bool":false,"_bound":16,"ExpansionArg_array_element_2_array_length":0} start 501.3458 took 40.4745s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":4,"ExpansionArg_array_element_2_bool":false,"_bound":16,"ExpansionArg_array_element_2_array_length":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":4,"ExpansionArg_array_element_2_bool":false,"_bound":16}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_bool":false,"ExpansionArg_array_element_1_type":3,"ExpansionArg_array_element_1_bool":false,"_bound":17,"ExpansionArg_array_element_1_string":"PureString"} start 497.0147 took 47.2024s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_bool":false,"ExpansionArg_array_element_1_type":3,"ExpansionArg_array_element_1_bool":false,"_bound":17,"ExpansionArg_array_element_1_string":"PureString"}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_bool":false,"ExpansionArg_array_element_1_type":3,"ExpansionArg_array_element_1_bool":false,"_bound":17}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":2,"ExpansionArg_array_element_1_bool":false,"_bound":15,"ExpansionArg_array_element_1_int":0} start 501.8066 took 42.8913s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":2,"ExpansionArg_array_element_1_bool":false,"_bound":15,"ExpansionArg_array_element_1_int":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":2,"ExpansionArg_array_element_1_bool":false,"_bound":15}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":2,"_bound":15,"ExpansionArg_array_element_3_int":0} start 494.3259 took 50.8918s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":2,"_bound":15,"ExpansionArg_array_element_3_int":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":2,"_bound":15}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":4,"ExpansionArg_array_element_1_bool":false,"_bound":17,"ExpansionArg_array_element_1_array_length":0} start 498.9292 took 46.9157s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":4,"ExpansionArg_array_element_1_bool":false,"_bound":17,"ExpansionArg_array_element_1_array_length":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":4,"ExpansionArg_array_element_1_bool":false,"_bound":17}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":2,"ExpansionArg_array_element_2_bool":false,"_bound":16,"ExpansionArg_array_element_2_int":0} start 505.2302 took 41.4593s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":2,"ExpansionArg_array_element_2_bool":false,"_bound":16,"ExpansionArg_array_element_2_int":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":2,"ExpansionArg_array_element_2_bool":false,"_bound":16}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":4,"ExpansionArg_array_element_2_bool":false,"_bound":17,"ExpansionArg_array_element_2_array_length":0} start 503.5336 took 44.2162s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":4,"ExpansionArg_array_element_2_bool":false,"_bound":17,"ExpansionArg_array_element_2_array_length":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":4,"ExpansionArg_array_element_2_bool":false,"_bound":17}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_bool":false,"ExpansionArg_array_element_1_type":4,"ExpansionArg_array_element_1_bool":false,"_bound":18,"ExpansionArg_array_element_1_array_length":0} start 496.6231 took 51.6677s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_bool":false,"ExpansionArg_array_element_1_type":4,"ExpansionArg_array_element_1_bool":false,"_bound":18,"ExpansionArg_array_element_1_array_length":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_bool":false,"ExpansionArg_array_element_1_type":4,"ExpansionArg_array_element_1_bool":false,"_bound":18}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":3,"ExpansionArg_array_element_2_bool":false,"_bound":17,"ExpansionArg_array_element_2_string":"PureString"} start 499.9897 took 48.7573s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":3,"ExpansionArg_array_element_2_bool":false,"_bound":17,"ExpansionArg_array_element_2_string":"PureString"}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":3,"ExpansionArg_array_element_2_bool":false,"_bound":17}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":3,"ExpansionArg_array_element_3_int":0,"_bound":17,"ExpansionArg_array_element_3_string":"PureString"} start 500.9732 took 48.2683s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":3,"ExpansionArg_array_element_3_int":0,"_bound":17,"ExpansionArg_array_element_3_string":"PureString"}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":3,"ExpansionArg_array_element_3_int":0,"_bound":17}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":3,"ExpansionArg_array_element_2_bool":false,"_bound":15,"ExpansionArg_array_element_2_string":"PureString"} start 505.7732 took 44.7076s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":3,"ExpansionArg_array_element_2_bool":false,"_bound":15,"ExpansionArg_array_element_2_string":"PureString"}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":3,"ExpansionArg_array_element_2_bool":false,"_bound":15}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":4,"ExpansionArg_array_element_2_bool":false,"_bound":18,"ExpansionArg_array_element_2_array_length":0} start 500.4862 took 50.469s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":4,"ExpansionArg_array_element_2_bool":false,"_bound":18,"ExpansionArg_array_element_2_array_length":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":4,"ExpansionArg_array_element_2_bool":false,"_bound":18}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":3,"ExpansionArg_array_element_1_bool":false,"_bound":16,"ExpansionArg_array_element_1_string":"PureString"} start 499.4173 took 52.0885s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":3,"ExpansionArg_array_element_1_bool":false,"_bound":16,"ExpansionArg_array_element_1_string":"PureString"}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":3,"ExpansionArg_array_element_1_bool":false,"_bound":16}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":4,"ExpansionArg_array_element_1_bool":false,"_bound":16,"ExpansionArg_array_element_1_array_length":0} start 509.9297 took 45.1567s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":4,"ExpansionArg_array_element_1_bool":false,"_bound":16,"ExpansionArg_array_element_1_array_length":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":4,"ExpansionArg_array_element_1_bool":false,"_bound":16}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":3,"ExpansionArg_array_element_2_bool":false,"_bound":16,"ExpansionArg_array_element_2_string":"PureString"} start 537.8451 took 42.3118s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":3,"ExpansionArg_array_element_2_bool":false,"_bound":16,"ExpansionArg_array_element_2_string":"PureString"}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":3,"ExpansionArg_array_element_2_bool":false,"_bound":16}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_bool":false,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_1_bool":false,"_bound":15} start 539.231 took 44.6272s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_bool":false,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_1_bool":false,"_bound":15}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":2,"ExpansionArg_array_element_0_type":5,"ExpansionArg_array_element_0_bool":false,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_1_bool":false,"_bound":15}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":3,"_bound":17,"ExpansionArg_array_element_3_string":"PureString"} start 544.9812 took 44.6792s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":3,"_bound":17,"ExpansionArg_array_element_3_string":"PureString"}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":2,"ExpansionArg_array_element_0_int":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":3,"_bound":17}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":2,"_bound":16,"ExpansionArg_array_element_2_int":0} start 542.1228 took 48.986s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":2,"_bound":16,"ExpansionArg_array_element_2_int":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":3,"ExpansionArg_array_element_0_string":"","ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":2,"_bound":16}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":2,"_bound":13,"ExpansionArg_array_element_2_int":0} start 548.5861 took 43.1106s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":2,"_bound":13,"ExpansionArg_array_element_2_int":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":1,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":2,"_bound":13}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":1,"ExpansionArg_array_element_3_type":1,"ExpansionArg_array_element_3_int":0,"_bound":16} start 545.574 took 46.1471s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":1,"ExpansionArg_array_element_3_type":1,"ExpansionArg_array_element_3_int":0,"_bound":16}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":1,"ExpansionArg_array_element_3_type":1,"ExpansionArg_array_element_3_int":0,"_bound":16}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":3,"ExpansionArg_array_element_1_string":"","_bound":14,"ExpansionArg_array_element_2_type":0} start 550.78 took 42.0025s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":3,"ExpansionArg_array_element_1_string":"","_bound":14,"ExpansionArg_array_element_2_type":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":3,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":3,"ExpansionArg_array_element_1_string":"","_bound":14}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":3,"ExpansionArg_array_element_3_int":0,"_bound":16,"ExpansionArg_array_element_3_string":"PureString"} start 547.0327 took 45.7564s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":3,"ExpansionArg_array_element_3_int":0,"_bound":16,"ExpansionArg_array_element_3_string":"PureString"}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":0,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":3,"ExpansionArg_array_element_3_int":0,"_bound":16}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":5,"ExpansionArg_array_element_3_string":"","_bound":18,"ExpansionArg_array_element_3_bool":false} start 549.5311 took 44.8234s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":4,"ExpansionArg_array_length":4,"ExpansionArg_array_element_0_type":0,"ExpansionArg_array_element_1_type":1,"ExpansionArg_array_element_2_type":0,"ExpansionArg_array_element_3_type":5,"ExpansionArg_array_element_3_string":"","_bound":18,"ExpansionArg_array_element_3_bool":false}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Licensed under the Apache License, Version 2.0 (the 'License'); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

'use strict';

var u = require('url');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var errs = require('errs');
var _ = require('underscore');
var follow = require('cloudant-follow');
var logger = require('./logger');

var nano;

module.exports = exports = nano = function dbScope(cfg) {
  var serverScope = {};
  var replications = {};

  if (typeof cfg === 'string') {
    cfg = {url: cfg};
  }

  assert.equal(typeof cfg, 'object',
    'You must specify the endpoint url when invoking this module');
  assert.ok(/^https?:/.test(cfg.url), 'url is not valid');

  cfg = _.clone(cfg);

  serverScope.config = cfg;
  cfg.requestDefaults = cfg.requestDefaults || {jar: false};

  var httpAgent = (typeof cfg.request === 'function') ? cfg.request :
    request.defaults(cfg.requestDefaults);
  var followAgent = (typeof cfg.follow === 'function') ? cfg.follow : follow;
  var log = typeof cfg.log === 'function' ? cfg.log : logger(cfg);
  var parseUrl = 'parseUrl' in cfg ? cfg.parseUrl : true;

  function maybeExtractDatabaseComponent() {
    if (!parseUrl) {
      return;
    }

    var path = u.parse(cfg.url);
    var pathArray = path.pathname.split('/').filter(function(e) { return e; });
    var db = pathArray.pop();
    var rootPath = path.pathname.replace(/\/?$/, '/..');

    if (db) {
      cfg.url = urlResolveFix(cfg.url, rootPath).replace(/\/?$/, '');
      return db;
    }
  }

  function scrub(str) {
    if (str) {
      str = str.replace(/\/\/(.*)@/,"//XXXXXX:XXXXXX@");
    }
    return str;
  }

  function relax(opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {path: ''};
    }

    if (typeof opts === 'string') {
      opts = {path: opts};
    }

    if (!opts) {
      opts = {path: ''};
      callback = null;
    }

    var qs = _.extend({}, opts.qs);

    var headers = {
      'content-type': 'application/json',
      accept: 'application/json'
    };

    var req = {
      method: (opts.method || 'GET'),
      headers: headers,
      uri: cfg.url
    };

    var parsed;
    var rh;

    // https://github.com/mikeal/request#requestjar
    var isJar = opts.jar || cfg.jar;

    if (isJar) {
      req.jar = isJar;
    }

    // http://wiki.apache.org/couchdb/HTTP_database_API#Naming_and_Addressing
    if (opts.db) {
      req.uri = urlResolveFix(req.uri, encodeURIComponent(opts.db));
    }

    if (opts.multipart) {
      req.multipart = opts.multipart;
    }

    req.headers = _.extend(req.headers, opts.headers, cfg.defaultHeaders);

    if (opts.path) {
      req.uri += '/' + opts.path;
    } else if (opts.doc) {
      if (!/^_design/.test(opts.doc)) {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Naming.2FAddressing
        req.uri += '/' + encodeURIComponent(opts.doc);
      } else {
        // http://wiki.apache.org/couchdb/HTTP_Document_API#Document_IDs
        req.uri += '/' + opts.doc;
      }

      // http://wiki.apache.org/couchdb/HTTP_Document_API#Attachments
      if (opts.att) {
        req.uri += '/' + opts.att;
      }
    }

    // prevent bugs where people set encoding when piping
    if (opts.encoding !== undefined && callback) {
      req.encoding = opts.encoding;
      delete req.headers['content-type'];
      delete req.headers.accept;
    }

    if (opts.contentType) {
      req.headers['content-type'] = opts.contentType;
      delete req.headers.accept;
    }

    // http://guide.couchdb.org/draft/security.html#cookies
    if (cfg.cookie) {
      req.headers['X-CouchDB-WWW-Authenticate'] = 'Cookie';
      req.headers.cookie = cfg.cookie;
    }

    // http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.qs === 'object' && !_.isEmpty(opts.qs)) {
      ['startkey', 'endkey', 'key', 'keys'].forEach(function(key) {
        if (key in opts.qs) {
          qs[key] = JSON.stringify(opts.qs[key]);
        }
      });
      req.qs = qs;
    }

    if (opts.body) {
      if (Buffer.isBuffer(opts.body) || opts.dontStringify) {
        req.body = opts.body;
      } else {
        req.body = JSON.stringify(opts.body, function(key, value) {
          // don't encode functions
          if (typeof(value) === 'function') {
            return value.toString();
          } else {
            return value;
          }
        });
      }
    }

    if (opts.form) {
      req.headers['content-type'] =
        'application/x-www-form-urlencoded; charset=utf-8';
      req.body = querystring.stringify(opts.form).toString('utf8');
    }

    log(req);

    if (!callback) {
      return httpAgent(req);
    }

    return httpAgent(req, function(e, h, b) {
      rh = h && h.headers || {};
      rh.statusCode = h && h.statusCode || 500;
      rh.uri = req.uri;
      if (e) {
        log({err: 'socket', body: b, headers: rh});
        return callback(errs.merge(e, {
          message: 'error happened in your connection',
          scope: 'socket',
          errid: 'request'
        }));
      }

      delete rh.server;
      delete rh['content-length'];

      if (opts.dontParse) {
        parsed = b;
      } else {
        try { parsed = JSON.parse(b); } catch (err) { parsed = b; }
      }

      if (rh.statusCode >= 200 && rh.statusCode < 400) {
        log({err: null, body: parsed, headers: rh});
        return callback(null, parsed, rh);
      }

      log({err: 'couch', body: parsed, headers: rh});

      // cloudant stacktrace
      if (typeof parsed === 'string') {
        parsed = {message: parsed};
      }

      if (!parsed.message && (parsed.reason || parsed.error)) {
        parsed.message = (parsed.reason || parsed.error);
      }

      // fix cloudant issues where they give an erlang stacktrace as js
      delete parsed.stack;

      // scrub credentials
      req.uri = scrub(req.uri);
      rh.uri = scrub(rh.uri);
      if (req.headers.cookie) {
        req.headers.cookie = "XXXXXXX";
      }

      callback(errs.merge({
        message: 'couch returned ' + rh.statusCode,
        scope: 'couch',
        statusCode: rh.statusCode,
        request: req,
        headers: rh,
        errid: 'non_200'
      }, errs.create(parsed)));
    });
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#cookie-authentication
  function auth(username, password, callback) {
    return relax({
      method: 'POST',
      db: '_session',
      form: {
        name: username,
        password: password
      }
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/authn.html#post--_session
  function session(callback) {
    return relax({db: '_session'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_db_updates
  function updates(qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({
      db: '_db_updates',
      qs: qs
    }, callback);
  }

  function followUpdates(qs, callback) {
    return followDb('_db_updates', qs, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#put--db
  function createDb(dbName, callback) {
    return relax({db: dbName, method: 'PUT'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#delete--db
  function destroyDb(dbName, callback) {
    return relax({db: dbName, method: 'DELETE'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/common.html#get--db
  function getDb(dbName, callback) {
    return relax({db: dbName}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#get--_all_dbs
  function listDbs(callback) {
    return relax({db: '_all_dbs'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/compact.html#post--db-_compact
  function compactDb(dbName, ddoc, callback) {
    if (typeof ddoc === 'function') {
      callback = ddoc;
      ddoc = null;
    }
    return relax({
      db: dbName,
      doc: '_compact',
      att: ddoc,
      method: 'POST'
    }, callback);
  }

  // http://docs.couchdb.org/en/latest/api/database/changes.html#get--db-_changes
  function changesDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }
    return relax({db: dbName, path: '_changes', qs: qs}, callback);
  }

  function followDb(dbName, qs, callback) {
    if (typeof qs === 'function') {
      callback = qs;
      qs = {};
    }

    qs = qs || {};
    qs.db = urlResolveFix(cfg.url, encodeURIComponent(dbName));

    if (typeof callback === 'function') {
      return followAgent(qs, callback);
    } else {
      return new followAgent.Feed(qs);
    }
  }

  function _serializeAsUrl(db) {
    if (typeof db === 'object' && db.config && db.config.url && db.config.db) {
      return urlResolveFix(db.config.url, encodeURIComponent(db.config.db));
    } else {
      return db;
    }
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#post--_replicate
  function replicateDb(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicate
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicate', body: opts, method: 'POST'}, callback);
  }

  // http://docs.couchdb.org/en/latest/api/server/common.html#uuids
  function uuids(count, callback) {
    if (typeof count === 'function') {
      callback = count;
      count = 1;
    }

    return relax({ method: 'GET', path: '_uuids', qs: {count: count}}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function enableReplication(source, target, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    // _replicator
    opts.source = _serializeAsUrl(source);
    opts.target = _serializeAsUrl(target);

    return relax({db: '_replicator', body: opts, method: 'POST'}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function queryReplication(id, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'GET', path: id}, callback);
  }

  // http://guide.couchdb.org/draft/replication.html
  function disableReplication(id, rev, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    return relax({db: '_replicator', method: 'DELETE', path: id, qs: {rev: rev}}, callback);
  }

  function docModule(dbName) {
    var docScope = {};
    dbName = decodeURIComponent(dbName);

    // http://docs.couchdb.org/en/latest/api/document/common.html#put--db-docid
    // http://docs.couchdb.org/en/latest/api/database/common.html#post--db
    function insertDoc(doc, qs, callback) {
      var opts = {db: dbName, body: doc, method: 'POST'};

      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      if (typeof qs === 'string') {
        qs = {docName: qs};
      }

      if (qs) {
        if (qs.docName) {
          opts.doc = qs.docName;
          opts.method = 'PUT';
          delete qs.docName;
        }
        opts.qs = qs;
      }

      return relax(opts, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#delete--db-docid
    function destroyDoc(docName, rev, callback) {
      if(!docName) {
        if(callback)
          callback("Invalid doc id", null);
      }
      else {
        return relax({
          db: dbName,
          doc: docName,
          method: 'DELETE',
          qs: {rev: rev}
        }, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#get--db-docid
    function getDoc(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, doc: docName, qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#head--db-docid
    function headDoc(docName, callback) {
      return relax({
        db: dbName,
        doc: docName,
        method: 'HEAD',
        qs: {}
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#copy--db-docid
    function copyDoc(docSrc, docDest, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var qs = {
        db: dbName,
        doc: docSrc,
        method: 'COPY',
        headers: {'Destination': docDest}
      };

      if (opts.overwrite) {
        return headDoc(docDest, function(e, b, h) {
          if (e && e.statusCode !== 404) {
            return callback(e);
          }
          if (h.etag) {
            qs.headers.Destination += '?rev=' +
              h.etag.substring(1, h.etag.length - 1);
          }
          return relax(qs, callback);
        });
      } else {
        return relax(qs, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#get--db-_all_docs
    function listDoc(qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({db: dbName, path: '_all_docs', qs: qs}, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs
    function fetchDocs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      qs = qs || {};
      qs['include_docs'] = true;

      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function fetchRevs(docNames, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      return relax({
        db: dbName,
        path: '_all_docs',
        method: 'POST',
        qs: qs,
        body: docNames
      }, callback);
    }

    function view(ddoc, viewName, meta, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      var viewPath = '_design/' + ddoc + '/_' + meta.type + '/'  + viewName;

      // Several search parameters must be JSON-encoded; but since this is an
      // object API, several parameters need JSON endoding.
      var paramsToEncode = ['counts', 'drilldown', 'group_sort', 'ranges', 'sort'];
      paramsToEncode.forEach(function(param) {
        if (param in qs) {
          if (typeof qs[param] !== 'string') {
            qs[param] = JSON.stringify(qs[param]);
          } else {
            // if the parameter is not already encoded, encode it
            try {
              JSON.parse(qs[param]);
            } catch(e) {
              qs[param] = JSON.stringify(qs[param]);
            }
          }
        }
      });

      if (qs && qs.keys) {
        var body = {keys: qs.keys};
        delete qs.keys;
        return relax({
          db: dbName,
          path: viewPath,
          method: 'POST',
          qs: qs,
          body: body
        }, callback);
      } else {
        var req = {
          db: dbName,
          method: meta.method || 'GET',
          path: viewPath,
          qs: qs
        };

        if (meta.body) {
          req.body = meta.body;
        }

        return relax(req, callback);
      }
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/views.html#post--db-_design-ddoc-_view-view
    function viewDocs(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'view'}, qs, callback);
    }

    // geocouch
    function viewSpatial(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'spatial'}, qs, callback);
    }

    // cloudant
    function viewSearch(ddoc, viewName, qs, callback) {
      return view(ddoc, viewName, {type: 'search'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#get--db-_design-ddoc-_show-func
    function showDoc(ddoc, viewName, docName, qs, callback) {
      return view(ddoc, viewName + '/' + docName, {type: 'show'}, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/ddoc/render.html#put--db-_design-ddoc-_update-func-docid
    function updateWithHandler(ddoc, viewName, docName, body, callback) {
      if (typeof body === 'function') {
          callback = body;
          body = undefined;
      }
      return view(ddoc, viewName + '/' + encodeURIComponent(docName), {
        type: 'update',
        method: 'PUT',
        body: body
      }, callback);
    }

    function viewWithList(ddoc, viewName, listName, qs, callback) {
      return view(ddoc, listName + '/' + viewName, {
        type: 'list'
      }, qs, callback);
    }

    // http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_bulksDoc
    function bulksDoc(docs, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        path: '_bulk_docs',
        body: docs,
        method: 'POST',
        qs: qs
      }, callback);
    }

    // http://docs.couchdb.org/en/latest/api/document/common.html#creating-multiple-attachments
    function insertMultipart(doc, attachments, qs, callback) {
      if (typeof qs === 'string') {
        qs = {docName: qs};
      }
      qs = qs || {};

      var docName = qs.docName;
      delete qs.docName;

      doc = _.extend({_attachments: {}}, doc);

      var multipart = [];

      attachments.forEach(function(att) {
        doc._attachments[att.name] = {
          follows: true,
          length: Buffer.isBuffer(att.data) ?
            att.data.length : Buffer.byteLength(att.data),
          /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
          'content_type': att.content_type
        };
        multipart.push({body: att.data});
      });

      multipart.unshift({
        'content-type': 'application/json',
        body: JSON.stringify(doc)
      });

      return relax({
        db: dbName,
        method: 'PUT',
        contentType: 'multipart/related',
        doc: docName,
        qs: qs,
        multipart: multipart
      }, callback);
    }

    function getMultipart(docName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }
      qs = qs || {};

      qs.attachments = true;

      return relax({
        db: dbName,
        doc: docName,
        encoding: null,
        contentType: 'multipart/related',
        qs: qs
      }, callback);
    }

    function insertAtt(docName, attName, att, contentType, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        method: 'PUT',
        contentType: contentType,
        doc: docName,
        qs: qs,
        body: att,
        dontStringify: true
      }, callback);
    }

    function getAtt(docName, attName, qs, callback) {
      if (typeof qs === 'function') {
        callback = qs;
        qs = {};
      }

      return relax({
        db: dbName,
        att: attName,
        doc: docName,
        qs: qs,
        encoding: null,
        dontParse: true
      }, callback);
    }

    function destroyAtt(docName, attName, qs, callback) {
      return relax({
        db: dbName,
        att: attName,
        method: 'DELETE',
        doc: docName,
        qs: qs
      }, callback);
    }

    // db level exports
    docScope = {
      info: function(cb) {
        return getDb(dbName, cb);
      },
      replicate: function(target, opts, cb) {
        return replicateDb(dbName, target, opts, cb);
      },
      compact: function(cb) {
        return compactDb(dbName, cb);
      },
      changes: function(qs, cb) {
        return changesDb(dbName, qs, cb);
      },
      follow: function(qs, cb) {
        return followDb(dbName, qs, cb);
      },
      auth: auth,
      session: session,
      insert: insertDoc,
      get: getDoc,
      head: headDoc,
      copy: copyDoc,
      destroy: destroyDoc,
      bulk: bulksDoc,
      list: listDoc,
      fetch: fetchDocs,
      fetchRevs: fetchRevs,
      config: {url: cfg.url, db: dbName},
      multipart: {
        insert: insertMultipart,
        get: getMultipart
      },
      attachment: {
        insert: insertAtt,
        get: getAtt,
        destroy: destroyAtt
      },
      show: showDoc,
      atomic: updateWithHandler,
      updateWithHandler: updateWithHandler,
      search: viewSearch,
      spatial: viewSpatial,
      view: viewDocs,
      viewWithList: viewWithList,
      server: serverScope,
      replication: {
        enable: function(target, opts, cb) {
          return enableReplication(dbName, target, opts, cb);
        },
        disable: function(id, revision, opts, cb) {
          return disableReplication(id, revision, opts, cb);
        },
        query: function(id, opts, cb) {
          return queryReplication(id, opts, cb);
        }
      }
    };

    docScope.view.compact = function(ddoc, cb) {
      return compactDb(dbName, ddoc, cb);
    };

    return docScope;
  }

  // server level exports
  serverScope = _.extend(serverScope, {
    db: {
      create: createDb,
      get: getDb,
      destroy: destroyDb,
      list: listDbs,
      use: docModule,
      scope: docModule,
      compact: compactDb,
      replicate: replicateDb,
      replication: {
        enable: enableReplication,
        disable: disableReplication,
        query: queryReplication
      },
      changes: changesDb,
      follow: followDb,
      followUpdates: followUpdates,
      updates: updates
    },
    use: docModule,
    scope: docModule,
    request: relax,
    relax: relax,
    dinosaur: relax,
    auth: auth,
    session: session,
    updates: updates,
    followUpdates: followUpdates,
    uuids: uuids
  });

  var db = maybeExtractDatabaseComponent();

  return db ? docModule(db) : serverScope;
};

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR! i'm a vegan!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */
nano.version = require('../package.json').version;
nano.path    = __dirname;

function urlResolveFix(couchUrl, dbName) {
  if (/[^\/]$/.test(couchUrl)) {
    couchUrl += '/';
  }
  return u.resolve(couchUrl, dbName);
}
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
