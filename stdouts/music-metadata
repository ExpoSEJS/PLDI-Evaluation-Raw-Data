/root/Targets/music-metadata
└─┬ music-metadata@0.8.6 
  ├── es6-promise@4.1.1 
  ├─┬ fs-extra@4.0.2 
  │ ├── graceful-fs@4.1.11 
  │ ├── jsonfile@4.0.0 
  │ └── universalify@0.1.1 
  ├─┬ strtok3@1.3.2 
  │ └── @types/es6-promise@0.0.33 
  ├── then-read-stream@1.0.4 
  └── token-types@0.9.1 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/music-metadata/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 22% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0316 took 4.4218s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (3:4) on program "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var assert = require("assert");
var Windows1292Decoder_1 = require("./Windows1292Decoder");
var ID3v1Parser_1 = require("../id3v1/ID3v1Parser");
var Common = /** @class */ (function () {
    function Common() {
    }
    /**
     *
     * @param buffer
     * @param start
     * @param end
     * @param encoding // ToDo: ts.enum
     * @return {number}
     */
    Common.findZero = function (buffer, start, end, encoding) {
        var i = start;
        if (encoding === 'utf16') {
            while (buffer[i] !== 0 || buffer[i + 1] !== 0) {
                if (i >= end)
                    return end;
                i += 2;
            }
            return i;
        }
        else {
            while (buffer[i] !== 0) {
                if (i >= end)
                    return end;
                i++;
            }
            return i;
        }
    };
    Common.sum = function (arr) {
        var s = 0;
        for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
            var v = arr_1[_i];
            s += v;
        }
        return s;
    };
    Common.swapBytes = function (buffer) {
        var l = buffer.length;
        assert.ok((l & 1) === 0, 'Buffer length must be even');
        for (var i = 0; i < l; i += 2) {
            var a = buffer[i];
            buffer[i] = buffer[i + 1];
            buffer[i + 1] = a;
        }
        return buffer;
    };
    Common.readUTF16String = function (buffer) {
        var offset = 0;
        if (buffer[0] === 0xFE && buffer[1] === 0xFF) {
            buffer = Common.swapBytes(buffer);
            offset = 2;
        }
        else if (buffer[0] === 0xFF && buffer[1] === 0xFE) {
            offset = 2;
        }
        return buffer.toString('ucs2', offset);
    };
    /**
     *
     * @param buffer Decoder input data
     * @param encoding 'utf16le' | 'utf16' | 'utf8' | 'iso-8859-1'
     * @return {string}
     */
    Common.decodeString = function (buffer, encoding) {
        // annoying workaround for a double BOM issue
        // https://github.com/leetreveil/musicmetadata/issues/84
        if (buffer[0] === 0xFF && buffer[1] === 0xFE && buffer[2] === 0xFE && buffer[3] === 0xFF) {
            buffer = buffer.slice(2);
        }
        if (encoding === 'utf16le' || encoding === 'utf16') {
            return Common.readUTF16String(buffer);
        }
        else if (encoding === 'utf8') {
            return buffer.toString('utf8');
        }
        else if (encoding === 'iso-8859-1') {
            return Windows1292Decoder_1.Windows1292Decoder.decode(buffer);
        }
        throw Error(encoding + ' encoding is not supported!');
    };
    Common.parseGenre = function (origVal) {
        // match everything inside parentheses
        var split = origVal.trim().split(/\((.*?)\)/g).filter(function (val) {
            return val !== '';
        });
        var array = [];
        for (var _i = 0, split_1 = split; _i < split_1.length; _i++) {
            var cur = split_1[_i];
            if (/^\d+$/.test(cur) && !isNaN(parseInt(cur, 10))) {
                cur = ID3v1Parser_1.Genres[cur];
            }
            array.push(cur);
        }
        return array
            .filter(function (val) {
            return val !== undefined;
        }).join('/');
    };
    Common.stripNulls = function (str) {
        str = str.replace(/^\x00+/g, '');
        str = str.replace(/\x00+$/g, '');
        return str;
    };
    /**
     * Read bit-aligned number start from buffer
     * Total offset in bits = byteOffset * 8 + bitOffset
     * @param buf Byte buffer
     * @param byteOffset Starting offset in bytes
     * @param bitOffset Starting offset in bits: 0 = lsb
     * @param len Length of number in bits
     * @return {number} decoded bit aligned number
     */
    Common.getBitAllignedNumber = function (buf, byteOffset, bitOffset, len) {
        var byteOff = byteOffset + ~~(bitOffset / 8);
        var bitOff = bitOffset % 8;
        var value = buf[byteOff];
        value &= 0xff >> bitOff;
        var bitsRead = 8 - bitOff;
        var bitsLeft = len - bitsRead;
        if (bitsLeft < 0) {
            value >>= (8 - bitOff - len);
        }
        else if (bitsLeft > 0) {
            value <<= bitsLeft;
            value |= Common.getBitAllignedNumber(buf, byteOffset, bitOffset + bitsRead, bitsLeft);
        }
        return value;
    };
    /**
     * Read bit-aligned number start from buffer
     * Total offset in bits = byteOffset * 8 + bitOffset
     * @param buf Byte buffer
     * @param byteOffset Starting offset in bytes
     * @param bitOffset Starting offset in bits: 0 = most significant bit, 7 is least significant bit
     * @return {number} decoded bit aligned number
     */
    Common.isBitSet = function (buf, byteOffset, bitOffset) {
        return Common.getBitAllignedNumber(buf, byteOffset, bitOffset, 1) === 1;
    };
    Common.strtokBITSET = {
        get: function (buf, off, bit) {
            return (buf[off] & (1 << bit)) !== 0;
        },
        len: 1
    };
    return Common;
}());
exports.default = Common;
 at SyntaxError: Unexpected token (3:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/music-metadata/node_modules/music-metadata/lib/index.js. Coverage (Term): 4% Coverage (LOC): 6%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
