/root/Targets/thinkjs
└─┬ thinkjs@3.2.1 
  ├── bluebird@3.3.5 
  ├─┬ cookies@0.7.1 
  │ ├── depd@1.1.1 
  │ └── keygrip@1.0.2 
  ├─┬ debug@2.6.9 
  │ └── ms@2.0.0 
  ├── destroy@1.0.4 
  ├─┬ koa@2.3.0 
  │ ├─┬ accepts@1.3.4 
  │ │ └── negotiator@0.6.1 
  │ ├── content-disposition@0.5.2 
  │ ├── content-type@1.0.4 
  │ ├── delegates@1.0.0 
  │ ├── error-inject@1.0.0 
  │ ├── escape-html@1.0.3 
  │ ├── fresh@0.5.2 
  │ ├─┬ http-assert@1.3.0 
  │ │ └── deep-equal@1.0.1 
  │ ├─┬ http-errors@1.6.2 
  │ │ ├── inherits@2.0.3 
  │ │ └── setprototypeof@1.0.3 
  │ ├── is-generator-function@1.0.6 
  │ ├── koa-compose@4.0.0 
  │ ├─┬ koa-convert@1.2.0 
  │ │ ├── co@4.6.0 
  │ │ └─┬ koa-compose@3.2.1 
  │ │   └── any-promise@1.3.0 
  │ ├── koa-is-json@1.0.0 
  │ ├─┬ mime-types@2.1.17 
  │ │ └── mime-db@1.30.0 
  │ ├── only@0.0.2 
  │ ├── parseurl@1.3.2 
  │ ├── statuses@1.3.1 
  │ ├─┬ type-is@1.6.15 
  │ │ └── media-typer@0.3.0 
  │ └── vary@1.1.2 
  ├─┬ on-finished@2.3.0 
  │ └── ee-first@1.1.1 
  ├─┬ think-cluster@1.4.2 
  │ └── string-hash@1.1.3 
  ├── think-config@1.0.4 
  ├── think-controller@1.0.3 
  ├─┬ think-crontab@1.0.4 
  │ └─┬ node-schedule@1.2.5 
  │   ├─┬ cron-parser@2.4.1 
  │   │ ├─┬ is-nan@1.2.1 
  │   │ │ └─┬ define-properties@1.1.2 
  │   │ │   ├── foreach@2.0.5 
  │   │ │   └── object-keys@1.0.11 
  │   │ └─┬ moment-timezone@0.5.13 
  │   │   └── moment@2.18.1 
  │   ├── long-timeout@0.1.1 
  │   └── sorted-array-functions@1.0.0 
  ├─┬ think-helper@1.0.22 
  │ ├── core-util-is@1.0.2 
  │ ├── ms@1.0.0 
  │ └── uuid@3.1.0 
  ├─┬ think-loader@1.1.0 
  │ └─┬ path-to-regexp@1.7.0 
  │   └── isarray@0.0.1 
  ├─┬ think-logger3@1.0.10 
  │ └─┬ log4js@1.1.1 
  │   ├── semver@5.4.1 
  │   └─┬ streamroller@0.4.1 
  │     ├── date-format@0.0.0 
  │     ├── debug@0.7.4 
  │     ├─┬ mkdirp@0.5.1 
  │     │ └── minimist@0.0.8 
  │     └─┬ readable-stream@1.1.14 
  │       └── string_decoder@0.10.31 
  ├── think-logic@1.0.0 
  ├── think-meta@1.0.3 
  ├── think-mock-http@1.0.5 
  ├─┬ think-payload@1.2.4 
  │ ├── formidable@1.1.1 
  │ ├── inflation@2.0.0 
  │ ├─┬ raw-body@2.3.2 
  │ │ ├── bytes@3.0.0 
  │ │ ├── iconv-lite@0.4.19 
  │ │ └── unpipe@1.0.0 
  │ └─┬ xml2js@0.4.19 
  │   ├── sax@1.2.4 
  │   └── xmlbuilder@9.0.4 
  ├── think-pm2@1.0.0 
  ├─┬ think-resource@1.0.3 
  │ ├─┬ koa-send@3.3.0 
  │ │ ├─┬ mz@2.7.0 
  │ │ │ ├── object-assign@4.1.1 
  │ │ │ └─┬ thenify-all@1.6.0 
  │ │ │   └── thenify@3.3.0 
  │ │ └─┬ resolve-path@1.3.3 
  │ │   ├─┬ http-errors@1.5.1 
  │ │   │ └── setprototypeof@1.0.2 
  │ │   └── path-is-absolute@1.0.1 
  │ └─┬ think-helper@1.0.22 
  │   └── ms@1.0.0 
  ├── think-router@1.2.0 
  ├─┬ think-trace@1.0.13 
  │ ├─┬ source-map-support@0.4.18 
  │ │ └── source-map@0.5.7 
  │ └── stack-trace@0.0.9 
  └─┬ think-validator@1.3.0 
    └── validator@7.2.0 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/thinkjs/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0668 took 2.3248s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (7:6) on program const path = require('path');
const cluster = require('cluster');
const helper = require('think-helper');
const thinkCluster = require('think-cluster');
const pm2 = require('think-pm2');
const http = require('http');
const assert = require('assert');
const mockHttp = require('think-mock-http');

const ThinkLoader = require('./loader.js');

/**
 * applition class
 */
module.exports = class Application {
  /**
   * constructor
   */
  constructor(options = {}) {
    assert(options.ROOT_PATH, 'options.ROOT_PATH must be set');
    if (!options.APP_PATH) {
      let appPath = path.join(options.ROOT_PATH, 'app');
      if (!options.transpiler && !helper.isDirectory(appPath)) {
        appPath = path.join(options.ROOT_PATH, 'src');
      }
      options.APP_PATH = appPath;
    }
    this.options = options;
  }
  /**
   * notify error
   */
  notifier(err) {
    if (!this.options.notifier) return;
    let notifier = this.options.notifier;
    if (!helper.isArray(notifier)) {
      notifier = [notifier];
    }
    notifier[0](Object.assign({
      title: 'ThinkJS Transpile Error',
      message: err.message
    }, notifier[1]));
  }
  /**
   * watcher callback
   */
  _watcherCallBack(fileInfo) {
    let transpiler = this.options.transpiler;
    if (transpiler) {
      if (!helper.isArray(transpiler)) {
        transpiler = [transpiler];
      }
      const ret = transpiler[0]({
        srcPath: fileInfo.path,
        outPath: this.options.APP_PATH,
        file: fileInfo.file,
        options: transpiler[1]
      });
      if (helper.isError(ret)) {
        console.error(ret.stack);
        this.notifier(ret);
        return false;
      }
      if (think.logger) {
        think.logger.info(`transpile file ${fileInfo.file} success`);
      }
    }
    // reload all workers
    if (this.masterInstance) {
      this.masterInstance.forceReloadWorkers();
    }
  }
  /**
   * start watcher
   */
  startWatcher() {
    const Watcher = this.options.watcher;
    if (!Watcher) return;
    const instance = new Watcher({
      srcPath: path.join(this.options.ROOT_PATH, 'src'),
      diffPath: this.options.APP_PATH
    }, fileInfo => this._watcherCallBack(fileInfo));
    instance.watch();
  }
  /**
   * parse argv
   */
  parseArgv() {
    const options = {};
    const argv2 = process.argv[2];
    const portRegExp = /^\d{2,5}$/;
    if (argv2) {
      if (!portRegExp.test(argv2)) {
        options.path = argv2;
      } else {
        options.port = argv2;
      }
    }
    return options;
  }
  /**
   * run in master
   */
  runInMaster(argv) {
    const port = argv.port || think.config('port');
    const host = think.config('host');
    const instance = new thinkCluster.Master({
      port,
      host,
      sticky: think.config('stickyCluster'),
      getRemoteAddress: socket => {
        return socket.remoteAddress || '';
      },
      workers: think.config('workers'),
      reloadSignal: think.config('reloadSignal')
    });
    instance.startServer().then(() => {
      think.app.emit('appReady');

      think.logger.info(`Server running at http://${host || '127.0.0.1'}:${port}`);
      think.logger.info(`ThinkJS version: ${think.version}`);
      think.logger.info(`Enviroment: ${think.app.env}`);
      think.logger.info(`Workers: ${instance.options.workers}`);
    });
    this.masterInstance = instance;
  }
  /**
   * run in worker
   * @param {Object} argv
   */
  runInWorker(argv) {
    const port = argv.port || think.config('port');
    const instance = new thinkCluster.Worker({
      port,
      host: think.config('host'),
      sticky: think.config('stickyCluster'),
      createServer() {
        const createServerFn = think.config('createServer');
        const callback = think.app.callback();
        if (createServerFn) {
          assert(helper.isFunction(createServerFn), 'config.createServer must be a function');
        }
        const server = createServerFn ? createServerFn(callback) : http.createServer(callback);
        think.app.server = server;
        return server;
      },
      logger: think.logger.error.bind(think.logger),
      processKillTimeout: think.config('processKillTimeout'),
      onUncaughtException: think.config('onUncaughtException'),
      onUnhandledRejection: think.config('onUnhandledRejection')
    });
    think.beforeStartServer().catch(err => {
      think.logger.error(err);
    }).then(() => {
      return instance.startServer();
    }).then(() => {
      think.app.emit('appReady');
    });
  }
  /**
   * command line invoke
   */
  runInCli(argv) {
    think.app.emit('appReady');
    mockHttp({
      url: argv.path,
      method: 'CLI',
      exitOnEnd: true
    }, think.app);
  }
  /**
   * run
   */
  run() {
    if (pm2.isClusterMode) {
      throw new Error('can not use pm2 cluster mode, please change exec_mode to fork');
    }
    // start file watcher
    if (cluster.isMaster) this.startWatcher();

    const instance = new ThinkLoader(this.options);
    const argv = this.parseArgv();
    try {
      if (process.env.THINK_UNIT_TEST) {
        instance.loadAll('worker', true);
      } else if (argv.path) {
        instance.loadAll('worker', true);
        return this.runInCli(argv);
      } else if (cluster.isMaster) {
        instance.loadAll('master');
        this.runInMaster(argv);
      } else {
        instance.loadAll('worker');
        this.runInWorker(argv);
      }
    } catch (e) {
      console.error(e);
    }
  }
};

/**
 * global think instance, mostly use in typescript
 */
module.exports.think = global.think;
 at SyntaxError: Unexpected token (7:6)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
