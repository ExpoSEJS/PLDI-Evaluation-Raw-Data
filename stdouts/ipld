/root/Targets/ipld
└─┬ ipld@0.6.0 
  ├─┬ babel-runtime@6.26.0 
  │ ├── core-js@2.5.1 
  │ └── regenerator-runtime@0.11.0 
  ├─┬ bs58@3.1.0 
  │ └── base-x@1.1.0 
  ├─┬ cbor@1.0.6 
  │ ├── bignumber.js@2.4.0 
  │ ├── commander@2.11.0 
  │ ├─┬ json-text-sequence@0.1.1 
  │ │ └── delimit-stream@0.1.0 
  │ └── nofilter@0.0.3 
  ├── lodash.clonedeep@4.5.0 
  ├── lodash.defaults@4.2.0 
  ├── lodash.includes@4.3.0 
  ├─┬ multiaddr@2.3.0 
  │ ├─┬ bs58@4.0.1 
  │ │ └─┬ base-x@3.0.2 
  │ │   └── safe-buffer@5.1.1 
  │ ├── ip@1.1.5 
  │ ├── lodash.filter@4.6.0 
  │ ├── lodash.map@4.6.0 
  │ ├── varint@5.0.0 
  │ └── xtend@4.0.1 
  ├── multihashes@0.2.2 
  ├─┬ multihashing@0.2.3 
  │ ├─┬ multihashes@0.3.3 
  │ │ └─┬ bs58@4.0.1 
  │ │   └── base-x@3.0.2 
  │ └─┬ webcrypto@0.1.0 
  │   └─┬ crypto-browserify@3.11.1 
  │     ├─┬ browserify-cipher@1.0.0 
  │     │ ├─┬ browserify-aes@1.0.8 
  │     │ │ └── buffer-xor@1.0.3 
  │     │ ├─┬ browserify-des@1.0.0 
  │     │ │ └── des.js@1.0.0 
  │     │ └─┬ evp_bytestokey@1.0.3 
  │     │   └─┬ md5.js@1.3.4 
  │     │     └── hash-base@3.0.4 
  │     ├─┬ browserify-sign@4.0.4 
  │     │ ├── bn.js@4.11.8 
  │     │ ├── browserify-rsa@4.0.1 
  │     │ ├─┬ elliptic@6.4.0 
  │     │ │ ├── brorand@1.1.0 
  │     │ │ ├── hash.js@1.1.3 
  │     │ │ ├── hmac-drbg@1.0.1 
  │     │ │ ├── minimalistic-assert@1.0.0 
  │     │ │ └── minimalistic-crypto-utils@1.0.1 
  │     │ └─┬ parse-asn1@5.1.0 
  │     │   └── asn1.js@4.9.1 
  │     ├── create-ecdh@4.0.0 
  │     ├─┬ create-hash@1.1.3 
  │     │ ├── cipher-base@1.0.4 
  │     │ ├─┬ ripemd160@2.0.1 
  │     │ │ └── hash-base@2.0.2 
  │     │ └── sha.js@2.4.8 
  │     ├── create-hmac@1.1.6 
  │     ├─┬ diffie-hellman@5.0.2 
  │     │ └── miller-rabin@4.0.0 
  │     ├── inherits@2.0.3 
  │     ├── pbkdf2@3.0.14 
  │     ├── public-encrypt@4.0.0 
  │     └── randombytes@2.0.5 
  └── nofilter@0.0.2 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/ipld/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 28.000000000000004% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","call"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0588 took 4.7619s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (8:9) on program // Generated by CoffeeScript 1.10.0
(function() {
  var Commented, Decoder, MT, NUMBYTES, NoFilter, SYMS, Simple, assert, bignumber, plural, ref, stream, util, utils,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  assert = require('assert');

  stream = require('stream');

  util = require('util');

  utils = require('./utils');

  Simple = require('./simple');

  Decoder = require('./decoder');

  ref = require('./constants'), MT = ref.MT, NUMBYTES = ref.NUMBYTES, SYMS = ref.SYMS;

  bignumber = require('bignumber.js');

  NoFilter = require('nofilter');

  plural = function(c) {
    if (c > 1) {
      return 's';
    } else {
      return '';
    }
  };

  module.exports = Commented = (function(superClass) {
    extend(Commented, superClass);

    function Commented(options) {
      var ref1;
      if (options == null) {
        options = {};
      }
      this._on_data = bind(this._on_data, this);
      this._on_value = bind(this._on_value, this);
      this._on_stop = bind(this._on_stop, this);
      this._on_start = bind(this._on_start, this);
      this._on_start_string = bind(this._on_start_string, this);
      this._on_more = bind(this._on_more, this);
      this._on_read = bind(this._on_read, this);
      this._on_error = bind(this._on_error, this);
      options.readableObjectMode = false;
      options.writableObjectMode = false;
      this.max_depth = (ref1 = options.max_depth) != null ? ref1 : 10;
      delete options.max_depth;
      Commented.__super__.constructor.call(this, options);
      this.depth = 1;
      this.all = new NoFilter;
      this.parser = new Decoder(options);
      this.parser.on('value', this._on_value);
      this.parser.on('start', this._on_start);
      this.parser.on('start-string', this._on_start_string);
      this.parser.on('stop', this._on_stop);
      this.parser.on('more-bytes', this._on_more);
      this.parser.on('error', this._on_error);
      this.parser.on('data', this._on_data);
      this.parser.bs.on('read', this._on_read);
    }

    Commented.prototype._transform = function(fresh, encoding, cb) {
      return this.parser.write(fresh, encoding, function(er) {
        return cb(er);
      });
    };

    Commented.prototype._flush = function(cb) {
      return this.parser._flush(cb);
    };

    Commented.comment = function(input, options, cb) {
      var bs, d, encoding, max_depth, p, ref1, ref2;
      if (input == null) {
        throw new Error('input required');
      }
      encoding = typeof input === 'string' ? 'hex' : void 0;
      max_depth = 10;
      switch (typeof options) {
        case 'function':
          cb = options;
          break;
        case 'string':
          encoding = options;
          break;
        case 'number':
          max_depth = options;
          break;
        case 'object':
          encoding = (ref1 = options.encoding) != null ? ref1 : encoding;
          max_depth = (ref2 = options.max_depth) != null ? ref2 : max_depth;
      }
      bs = new NoFilter;
      d = new Commented({
        max_depth: max_depth
      });
      p = null;
      if (typeof cb === 'function') {
        d.on('end', function() {
          return cb(null, bs.toString('utf8'));
        });
        d.on('error', cb);
      } else {
        p = new Promise(function(resolve, reject) {
          d.on('end', function() {
            return resolve(bs.toString('utf8'));
          });
          return d.on('error', reject);
        });
      }
      d.pipe(bs);
      d.end(input, encoding);
      return p;
    };

    Commented.prototype._on_error = function(er) {
      this.push('ERROR: ');
      this.push(er.toString());
      return this.push('\n');
    };

    Commented.prototype._on_read = function(buf) {
      var hex, ind;
      this.all.write(buf);
      hex = buf.toString('hex');
      this.push(new Array(this.depth + 1).join('  '));
      this.push(hex);
      ind = (this.max_depth - this.depth) * 2;
      ind -= hex.length;
      if (ind < 1) {
        ind = 1;
      }
      this.push(new Array(ind + 1).join(' '));
      return this.push('-- ');
    };

    Commented.prototype._on_more = function(mt, len, parent_mt, pos) {
      this.depth++;
      this.push((function() {
        switch (mt) {
          case MT.POS_INT:
            return 'Positive number,';
          case MT.NEG_INT:
            return 'Negative number,';
          case MT.ARRAY:
            return 'Array, length';
          case MT.MAP:
            return 'Map, count';
          case MT.BYTE_STRING:
            return 'Bytes, length';
          case MT.UTF8_STRING:
            return 'String, length';
          case MT.SIMPLE_FLOAT:
            if (len === 1) {
              return 'Simple value,';
            } else {
              return 'Float,';
            }
        }
      })());
      return this.push(" next " + len + " byte" + (plural(len)) + "\n");
    };

    Commented.prototype._on_start_string = function(mt, tag, parent_mt, pos) {
      this.depth++;
      this.push((function() {
        switch (mt) {
          case MT.BYTE_STRING:
            return "Bytes, length: " + tag;
          case MT.UTF8_STRING:
            return "String, length: " + (tag.toString());
        }
      })());
      return this.push('\n');
    };

    Commented.prototype._on_start = function(mt, tag, parent_mt, pos) {
      this.depth++;
      if (tag !== SYMS.BREAK) {
        this.push((function() {
          switch (parent_mt) {
            case MT.ARRAY:
              return "[" + pos + "], ";
            case MT.MAP:
              if (pos % 2) {
                return "{Val:" + (Math.floor(pos / 2)) + "}, ";
              } else {
                return "{Key:" + (Math.floor(pos / 2)) + "}, ";
              }
          }
        })());
      }
      this.push((function() {
        switch (mt) {
          case MT.TAG:
            return "Tag #" + tag;
          case MT.ARRAY:
            if (tag === SYMS.STREAM) {
              return 'Array (streaming)';
            } else {
              return "Array, " + tag + " item" + (plural(tag));
            }
            break;
          case MT.MAP:
            if (tag === SYMS.STREAM) {
              return 'Map (streaming)';
            } else {
              return "Map, " + tag + " pair" + (plural(tag));
            }
            break;
          case MT.BYTE_STRING:
            return 'Bytes (streaming)';
          case MT.UTF8_STRING:
            return 'String (streaming)';
        }
      })());
      return this.push('\n');
    };

    Commented.prototype._on_stop = function(mt) {
      return this.depth--;
    };

    Commented.prototype._on_value = function(val, parent_mt, pos, ai) {
      if (val !== SYMS.BREAK) {
        this.push((function() {
          switch (parent_mt) {
            case MT.ARRAY:
              return "[" + pos + "], ";
            case MT.MAP:
              if (pos % 2) {
                return "{Val:" + (Math.floor(pos / 2)) + "}, ";
              } else {
                return "{Key:" + (Math.floor(pos / 2)) + "}, ";
              }
          }
        })());
      }
      this.push((function() {
        switch (false) {
          case val !== SYMS.BREAK:
            return 'BREAK';
          case val !== SYMS.NULL:
            return 'null';
          case val !== SYMS.UNDEFINED:
            return 'undefined';
          case typeof val !== 'string':
            this.depth--;
            return JSON.stringify(val);
          case !Buffer.isBuffer(val):
            this.depth--;
            return val.toString('hex');
          case !(val instanceof bignumber):
            return val.toString();
          default:
            return util.inspect(val);
        }
      }).call(this));
      switch (ai) {
        case NUMBYTES.ONE:
        case NUMBYTES.TWO:
        case NUMBYTES.FOUR:
        case NUMBYTES.EIGHT:
          this.depth--;
      }
      return this.push('\n');
    };

    Commented.prototype._on_data = function() {
      this.push('0x');
      this.push(this.all.read().toString('hex'));
      return this.push('\n');
    };

    return Commented;

  })(stream.Transform);

}).call(this);

//# sourceMappingURL=commented.js.map
 at SyntaxError: Unexpected token (8:9)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$3.parseExprAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1822:12)
    at Parser.parseExprAtom (/root/ExpoSE/lib/Tropigate/bin/Expression.js:28:30)
    at Parser.pp$3.parseExprSubscripts (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1715:21)
    at Parser.parseMaybeUnary (/root/ExpoSE/lib/Tropigate/bin/Unary.js:34:29)
    at Parser.pp$3.parseExprOps (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1637:21)
    at Parser.pp$3.parseMaybeConditional (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1620:21)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1597:21)
    at Parser.pp$3.parseExpression (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1573:21)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/ipld/node_modules/ipld/lib/index.js. Coverage (Term): 34% Coverage (LOC): 45%
*- File /root/Targets/ipld/node_modules/ipld/lib/cbor.js. Coverage (Term): 10% Coverage (LOC): 11%
*- File /root/Targets/ipld/node_modules/cbor/lib/cbor.js. Coverage (Term): 21% Coverage (LOC): 26%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
