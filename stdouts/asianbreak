/root/Targets/asianbreak
└─┬ asianbreak@1.2.2 
  ├── core-js@2.5.1 
  └── eastasianwidth@0.1.1 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/asianbreak/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0624 took 2.6428s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (7:9) on program (function(){
  var eastAsianWidth, extend, codePointAt, fromCodePoint, assert, firstChar, lastChar, isHangul, isntHangul, toString$ = {}.toString;
  eastAsianWidth = require('eastasianwidth').eastAsianWidth;
  extend = require('core-js/library/fn/object/assign');
  codePointAt = require('core-js/library/fn/string/code-point-at');
  fromCodePoint = require('core-js/library/fn/string/from-code-point');
  assert = require('assert');
  firstChar = function(string){
    var codePoint;
    codePoint = codePointAt(string, 0);
    return isNaN(
    codePoint)
      ? undefined
      : fromCodePoint(
      codePoint);
  };
  lastChar = function(string){
    var codePoint;
    if (string.length === 0) {
      return undefined;
    }
    if (string.length === 1) {
      return string[0];
    }
    codePoint = codePointAt(string, string.length - 2);
    return isNaN(
    codePoint)
      ? undefined
      : codePoint >= 0x10000
        ? string.slice(-2)
        : string.slice(-1);
  };
  isHangul = function(char){
    var codePoint;
    codePoint = codePointAt(char, 0);
    return (0x1100 <= codePoint && codePoint <= 0x11FF) || (0x3130 <= codePoint && codePoint <= 0x318F) || (0xA960 <= codePoint && codePoint <= 0xA97F) || (0xAC00 <= codePoint && codePoint <= 0xD7A3) || (0xD7B0 <= codePoint && codePoint <= 0xD7FF) || (0xFFA0 <= codePoint && codePoint <= 0xFFDF);
  };
  isntHangul = compose$(isHangul, not$);
  module.exports = function(texts, options){
    var defaultOptions, segments, headingWhiteSpaceSegments, newSegments, pushedDownRemainings, i$, len$, segmentIndex, segment, headingWhiteSpace, tailingWhiteSpaceSegments, tailingWhiteSpace, prevCharBeforeSegment, j$, index, nextCharAfterSegment, to$, spans, len1$, spanIndex, span, isMonolineSpace, prevSpan, nextSpan, prevChar, ref$, nextChar, prevWidth, nextWidth, newSegment, char, padLeftSegments, padRightSegments;
    options == null && (options = {});
    defaultOptions = {
      collapseHead: false,
      collapseTail: false,
      collapseInlineWhiteSpace: false,
      collapseAllBreak: false,
      removeZwsp: false
    };
    options = extend({}, defaultOptions, options);
    switch (toString$.call(texts).slice(8, -1)) {
    case 'String':
      segments = [texts];
      break;
    case 'Array':
      segments = texts;
      break;
    default:
      throw new Error('Unsupported text type');
    }
    headingWhiteSpaceSegments = [];
    newSegments = [];
    pushedDownRemainings = false;
    for (i$ = 0, len$ = segments.length; i$ < len$; ++i$) {
      segmentIndex = i$;
      segment = segments[i$];
      if (!segment.match(/[^ \t\r\n]/)) {
        headingWhiteSpaceSegments.push(segment);
      } else {
        headingWhiteSpace = segment.match(/^([ \t\r\n]*)/)[1];
        headingWhiteSpaceSegments.push(headingWhiteSpace);
        newSegments.push(segment.slice(headingWhiteSpace.length));
        Array.prototype.push.apply(newSegments, segments.slice(segmentIndex + 1));
        pushedDownRemainings = true;
        break;
      }
    }
    if (!pushedDownRemainings) {
      newSegments.push('');
    }
    segments = newSegments;
    tailingWhiteSpaceSegments = [];
    newSegments = [];
    pushedDownRemainings = false;
    for (i$ = segments.length - 1; i$ >= 0; --i$) {
      segmentIndex = i$;
      segment = segments[i$];
      if (!segment.match(/[^ \t\r\n]/)) {
        tailingWhiteSpaceSegments.unshift(segment);
      } else {
        tailingWhiteSpace = segment.match(/([ \t\r\n]*)$/)[1];
        tailingWhiteSpaceSegments.unshift(tailingWhiteSpace);
        if (tailingWhiteSpace.length === 0) {
          newSegments.unshift(segment);
        } else {
          newSegments.unshift(segment.slice(0, -tailingWhiteSpace.length));
        }
        Array.prototype.unshift.apply(newSegments, segments.slice(0, segmentIndex));
        pushedDownRemainings = true;
        break;
      }
    }
    if (!pushedDownRemainings) {
      newSegments.unshift('');
    }
    segments = newSegments;
    newSegments = [];
    for (i$ = 0, len$ = segments.length; i$ < len$; ++i$) {
      segmentIndex = i$;
      segment = segments[i$];
      prevCharBeforeSegment = null;
      for (j$ = segmentIndex - 1; j$ >= 0; --j$) {
        index = j$;
        if (lastChar(
        segments[index])) {
          prevCharBeforeSegment = lastChar(
          segments[index]);
          break;
        }
      }
      nextCharAfterSegment = null;
      for (j$ = segmentIndex + 1, to$ = segments.length; j$ < to$; ++j$) {
        index = j$;
        if (firstChar(
        segments[index])) {
          nextCharAfterSegment = firstChar(
          segments[index]);
          break;
        }
      }
      /*
        Split segment by series of white spaces
      
        From spec:
          document white space characters: spaces (U+0020), tabs (U+0009), and segment breaks
          segment break: CRLF sequence (U+000D U+000A), carriage return (U+000D), and line feed (U+000A)
        https://drafts.csswg.org/css-text-3/#white-space-processing
       */
      spans = segment.split(/([ \t\r\n]+)/);
      for (j$ = 0, len1$ = spans.length; j$ < len1$; ++j$) {
        spanIndex = j$;
        span = spans[j$];
        if (spanIndex % 2 === 1) {
          isMonolineSpace = !span.match(/[\r\n]/);
          if (!options.collapseInlineWhiteSpace && isMonolineSpace) {
            continue;
          }
          prevSpan = spans[spanIndex - 1];
          nextSpan = spans[spanIndex + 1];
          prevChar = prevSpan.length !== 0
            ? (ref$ = lastChar(
            prevSpan)) != null ? ref$ : null
            : prevCharBeforeSegment != null ? prevCharBeforeSegment : null;
          nextChar = nextSpan.length !== 0
            ? (ref$ = firstChar(
            nextSpan)) != null ? ref$ : null
            : nextCharAfterSegment != null ? nextCharAfterSegment : null;
          if (prevChar != null) {
            prevWidth = eastAsianWidth(prevChar);
          }
          if (nextChar != null) {
            nextWidth = eastAsianWidth(nextChar);
          }
          if (isMonolineSpace) {
            assert(options.collapseInlineWhiteSpace === true);
            assert(span.match(/^[ \t]+$/));
            if (prevChar === ' ' || prevChar === '\t' || prevChar === '\n' || prevChar === '\r') {
              spans[spanIndex] = '';
            } else {
              spans[spanIndex] = ' ';
            }
          } else {
            if ('\u200B' === prevChar || '\u200B' === nextChar) {
              if (!options.removeZwsp) {
                spans[spanIndex] = '';
              } else {
                throw Error('unimplemented');
              }
            } else if ((prevWidth === 'F' || prevWidth === 'W' || prevWidth === 'H') && (nextWidth === 'F' || nextWidth === 'W' || nextWidth === 'H') && isntHangul(
            prevChar) && isntHangul(
            nextChar)) {
              spans[spanIndex] = '';
            } else if (options.collapseAllBreak) {
              spans[spanIndex] = ' ';
            } else {}
          }
        }
      }
      newSegments.push(spans.join(''));
    }
    if (options.collapseInlineWhiteSpace) {
      for (i$ = 0, len$ = newSegments.length; i$ < len$; ++i$) {
        segmentIndex = i$;
        segment = newSegments[i$];
        prevCharBeforeSegment = null;
        for (j$ = segmentIndex - 1; j$ >= 0; --j$) {
          index = j$;
          if (lastChar(
          newSegments[index])) {
            prevCharBeforeSegment = lastChar(
            newSegments[index]);
            break;
          }
        }
        newSegment = '';
        for (j$ = 0, len1$ = segment.length; j$ < len1$; ++j$) {
          char = segment[j$];
          if (char === ' ') {
            prevChar = (ref$ = newSegment[newSegment.length - 1]) != null ? ref$ : prevCharBeforeSegment;
            if (prevChar !== ' ') {
              newSegment += char;
            }
          } else {
            newSegment += char;
          }
        }
        newSegments[segmentIndex] = newSegment;
      }
    }
    if (!(options.collapseHead || (options.collapseTail && newSegments.length === 1 && newSegments[0] === ''))) {
      headingWhiteSpaceSegments[headingWhiteSpaceSegments.length - 1] += newSegments.shift();
      newSegments = headingWhiteSpaceSegments.concat(newSegments);
    } else {
      padLeftSegments = repeatArray$([''], headingWhiteSpaceSegments.length - 1);
      newSegments = padLeftSegments.concat(newSegments);
    }
    if (!options.collapseTail) {
      newSegments[newSegments.length - 1] += tailingWhiteSpaceSegments.shift();
      newSegments = newSegments.concat(tailingWhiteSpaceSegments);
    } else {
      padRightSegments = repeatArray$([''], tailingWhiteSpaceSegments.length - 1);
      newSegments = newSegments.concat(padRightSegments);
    }
    if (toString$.call(texts).slice(8, -1) === 'String') {
      return newSegments[0];
    } else {
      return newSegments;
    }
  };
  function compose$() {
    var functions = arguments;
    return function() {
      var i, result;
      result = functions[0].apply(this, arguments);
      for (i = 1; i < functions.length; ++i) {
        result = functions[i](result);
      }
      return result;
    };
  }
  function not$(x){ return !x; }
  function repeatArray$(arr, n){
    for (var r = []; n > 0; (n >>= 1) && (arr = arr.concat(arr)))
      if (n & 1) r.push.apply(r, arr);
    return r;
  }
}).call(this);

//# sourceMappingURL=index.js.map
 at SyntaxError: Unexpected token (7:9)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$3.parseExprAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1822:12)
    at Parser.parseExprAtom (/root/ExpoSE/lib/Tropigate/bin/Expression.js:28:30)
    at Parser.pp$3.parseExprSubscripts (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1715:21)
    at Parser.parseMaybeUnary (/root/ExpoSE/lib/Tropigate/bin/Unary.js:34:29)
    at Parser.pp$3.parseExprOps (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1637:21)
    at Parser.pp$3.parseMaybeConditional (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1620:21)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1597:21)
    at Parser.pp$3.parseExpression (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1573:21)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
