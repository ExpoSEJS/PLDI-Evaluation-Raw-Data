/root/Targets/strong-docs
└─┬ strong-docs@1.5.1 
  ├─┬ debug@2.6.9 
  │ └── ms@2.0.0 
  ├─┬ dox@0.8.0 
  │ ├─┬ commander@2.8.1 
  │ │ └── graceful-readlink@1.0.1 
  │ ├─┬ jsdoctypeparser@1.2.0 
  │ │ └── lodash@3.10.1 
  │ └── marked@0.3.6 
  ├── ejs@2.5.7 
  ├─┬ express@4.15.5 
  │ ├─┬ accepts@1.3.4 
  │ │ ├─┬ mime-types@2.1.17 
  │ │ │ └── mime-db@1.30.0 
  │ │ └── negotiator@0.6.1 
  │ ├── array-flatten@1.1.1 
  │ ├── content-disposition@0.5.2 
  │ ├── content-type@1.0.4 
  │ ├── cookie@0.3.1 
  │ ├── cookie-signature@1.0.6 
  │ ├── depd@1.1.1 
  │ ├── encodeurl@1.0.1 
  │ ├── escape-html@1.0.3 
  │ ├── etag@1.8.1 
  │ ├─┬ finalhandler@1.0.6 
  │ │ └── unpipe@1.0.0 
  │ ├── fresh@0.5.2 
  │ ├── merge-descriptors@1.0.1 
  │ ├── methods@1.1.2 
  │ ├─┬ on-finished@2.3.0 
  │ │ └── ee-first@1.1.1 
  │ ├── parseurl@1.3.2 
  │ ├── path-to-regexp@0.1.7 
  │ ├─┬ proxy-addr@1.1.5 
  │ │ ├── forwarded@0.1.2 
  │ │ └── ipaddr.js@1.4.0 
  │ ├── qs@6.5.0 
  │ ├── range-parser@1.2.0 
  │ ├─┬ send@0.15.6 
  │ │ ├── destroy@1.0.4 
  │ │ ├── http-errors@1.6.2 
  │ │ └── mime@1.3.4 
  │ ├── serve-static@1.12.6 
  │ ├── setprototypeof@1.0.3 
  │ ├── statuses@1.3.1 
  │ ├─┬ type-is@1.6.15 
  │ │ └── media-typer@0.3.0 
  │ ├── utils-merge@1.0.0 
  │ └── vary@1.1.2 
  ├─┬ fs-extra@4.0.2 
  │ ├── graceful-fs@4.1.11 
  │ ├── jsonfile@4.0.0 
  │ └── universalify@0.1.1 
  ├─┬ glob@7.1.2 
  │ ├── fs.realpath@1.0.0 
  │ ├─┬ inflight@1.0.6 
  │ │ └── wrappy@1.0.2 
  │ ├── inherits@2.0.3 
  │ ├─┬ minimatch@3.0.4 
  │ │ └─┬ brace-expansion@1.1.8 
  │ │   ├── balanced-match@1.0.0 
  │ │   └── concat-map@0.0.1 
  │ ├── once@1.4.0 
  │ └── path-is-absolute@1.0.1 
  ├── highlight.js@7.3.0 
  ├─┬ markdown@0.5.0 
  │ └─┬ nopt@2.1.2 
  │   └── abbrev@1.1.0 
  ├── marked@0.2.10 
  ├─┬ optimist@0.6.1 
  │ ├── minimist@0.0.10 
  │ └── wordwrap@0.0.3 
  ├─┬ strong-task-emitter@0.0.7 
  │ └── debug@0.7.4 
  ├─┬ typedoc@0.7.1 
  │ ├─┬ @types/fs-extra@3.0.3 
  │ │ └── @types/node@8.0.31 
  │ ├── @types/handlebars@4.0.36 
  │ ├── @types/highlight.js@9.1.10 
  │ ├── @types/lodash@4.14.76 
  │ ├── @types/marked@0.0.28 
  │ ├── @types/minimatch@2.0.29 
  │ ├─┬ @types/shelljs@0.7.4 
  │ │ └── @types/glob@5.0.32 
  │ ├─┬ fs-extra@3.0.1 
  │ │ └── jsonfile@3.0.1 
  │ ├─┬ handlebars@4.0.10 
  │ │ ├── async@1.5.2 
  │ │ ├─┬ source-map@0.4.4 
  │ │ │ └── amdefine@1.0.1 
  │ │ └─┬ uglify-js@2.8.29 
  │ │   ├── source-map@0.5.7 
  │ │   ├── uglify-to-browserify@1.0.2 
  │ │   └─┬ yargs@3.10.0 
  │ │     ├── camelcase@1.2.1 
  │ │     ├─┬ cliui@2.1.0 
  │ │     │ ├─┬ center-align@0.1.3 
  │ │     │ │ ├─┬ align-text@0.1.4 
  │ │     │ │ │ ├─┬ kind-of@3.2.2 
  │ │     │ │ │ │ └── is-buffer@1.1.5 
  │ │     │ │ │ ├── longest@1.0.1 
  │ │     │ │ │ └── repeat-string@1.6.1 
  │ │     │ │ └── lazy-cache@1.0.4 
  │ │     │ ├── right-align@0.1.3 
  │ │     │ └── wordwrap@0.0.2 
  │ │     ├── decamelize@1.2.0 
  │ │     └── window-size@0.1.0 
  │ ├── highlight.js@9.12.0 
  │ ├── lodash@4.17.4 
  │ ├── marked@0.3.6 
  │ ├── progress@2.0.0 
  │ ├─┬ shelljs@0.7.8 
  │ │ ├── interpret@1.0.4 
  │ │ └─┬ rechoir@0.6.2 
  │ │   └─┬ resolve@1.4.0 
  │ │     └── path-parse@1.0.5 
  │ ├── typedoc-default-themes@0.5.0 
  │ └── typescript@2.3.2 
  └─┬ underscore.string@3.3.4 
    ├── sprintf-js@1.1.1 
    └── util-deprecate@1.0.2 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/strong-docs/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0762 took 1.9682s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (18:4) on program /*!
 * Expose `Docs`.
 */

module.exports = Docs;

/*!
 * Module dependencies.
 */

var debug = require('debug')('docs')
  , Doc = require('./doc')
  , path = require('path')
  , fs = require('fs')
  , exec = require('child_process').exec
  , ejs = require('ejs')
  , TaskEmitter = require('strong-task-emitter')
  , assert = require('assert')
  , string = require('underscore.string')
  , COMMENT_TEMPLATE = path.join(__dirname, '..', 'templates', 'annotation.ejs')
  , TSParser = require('./tsParser');

/*!
 * Create a new set of `Docs` with the given `config`.
 *
 * @param {Object} config
 * @return {Docs}
 */

function Docs(config) {
  this.content = [];
  this.sections = [];
  this.renderedClasses = [];

  // defaults
  config = config || {};
  config.content = config.content || ['*.md'];
  config.extensions = config.extensions || ['.markdown', '.md', '.js', '.ts'];
  if(config.fileSections !== false) {
    config.fileSections = true;
  }
  if(!Array.isArray(config.content)) {
    config.content = [config.content]
  }
  var root = this.root = config.root || process.cwd();
  this.config = config;

  if(this.config.order) {
    // resolve order paths
    this.config.order = this.config.order.map(function (p) {
      return path.resolve(root, p);
    });
  }

  this.commentTemplate = fs.readFileSync(config.commentTemplate || COMMENT_TEMPLATE, 'utf8');
}

/**
 * Parse all content in the given [config](#config) and callback with a `Docs`
 * object.
 *
 * @options  {Object} config
 * @property {String} [title] The title of your documentation site
 * @property {String} [version] The version of the project you are documenting
 * @property {Array}  content Specify your [documentation source files](#documentation-source-files)
 * @property {Number} [codeSectionDepth=4] Specify the depth of [JavaScript sections](#section-depth)
 * @property {String} [assets] Path to your assets directory
 * @end
 * @callback {Function} callback
 * @param {Error} err
 * @param {Docs} docs The `Docs` object
 */

Docs.parse = function (config, fn) {
  var docs = new Docs(config);
  docs.parse(function (err) {
    fn(err, err ? null : docs);
  });
}

Docs.readJSON = function(file, fn) {
  fs.readFile(file, 'utf8', function(err, str) {
    var isEmptyFile = (err && err.code === 'ENOENT') || str.replace(/\s/g, '') === '';
    var seriousError = err && !isEmptyFile;

    if(seriousError) {
      fn(err);
    } else if(isEmptyFile) {
      fn();
    } else {
      try {
        var object = JSON.parse(str);
      } catch(e) {
        return fn(e);
      }

      fn(null, object);
    }
  });
}

/**
 * Read the config and package at paths in the given options.
 *
 * @options {Object} options
 * @prop {String} [configPath] The path (relative to cwd) to docs.json
 * @prop {String} [packagePath] The path (relative to cwd) to package.json
 * @end
 * @callback {Function} callback
 * @param {Error} err An error if one occurred loading either the docs.json or package.json
 * @param {Object} config The config object loaded from `options.configPath`
 */

Docs.readConfig = function(options, fn) {
  options = options || {};
  var configPath = options.configPath || 'docs.json';
  var packagePath = options.packagePath || 'package.json';

  Docs.readJSON(configPath, function(err, config) {
    if(err) {
      err.message = 'Could not load config data: ' + err.message;
      fn(err);
    } else {
      // default config
      config = config || {};
      Docs.readJSON(packagePath, function(err, package) {
        if(err) {
          err.message = 'Could not load package data: ' + err.message;
          fn(err);
        } else {
          package = package || undefined;
          config.package = package;
          fn(null, config);
        }
      });
    }
  });
}

var glob = require("glob").sync;

function findFiles(root, f) {
  var files = glob(f, {cwd: root, nonull: false});
  return files;
}

Docs.prototype.parse = function (fn) {
  var self = this;
  var content = this.config.content;
  var init = this.config.init;
  var root = this.root;
  var cwd = process.cwd();
  var te = new TaskEmitter();
  var files = {};
  var matchedFiles = [];
  var tsFiles = [];
  // reference to individual classes
  this.classes = {};
  te.on('error', fn);
  te.on('done', function () {
    matchedFiles.forEach(function (f) {
      var contents;

      if(typeof f === 'object') {
        contents = fauxSectionToMarkdown(f);
        var fauxdoc = new Doc('faux-section.md', contents, false, this);
        this.content.push(fauxdoc);
      } else {
          if (path.extname(f) === '.ts') {
            // Filter out ts files, and process them as a bunch
            tsFiles.push(f);
            return;
          }
        f = path.resolve(root, f);
        contents = files[f];
        if(this.hasExt(f)) { 
          var doc = new Doc(f, contents, path.extname(f) === '.js', self);
          doc.classes.forEach(function (c) {
            if (!(c.classDesc in self.classes)) {
              self.classes[c.classDesc] = doc;
            }
          });
          self.content.push(doc);
        }
      }
    }.bind(this));
    // Process ts files
    if(tsFiles.length > 0) {
      var tsParser = new TSParser(tsFiles);
      var parsedData = tsParser.parse();
      var doc = {
        classes: parsedData.constructs,
        sections: parsedData.sections,
        html: ''
      }
      doc.classes.forEach(function(tsConstruct) {
        doc.html += tsConstruct.render();
      });
      self.content.push(doc);
    }
    this.buildSections();
    fn();
  }.bind(this));

  te.on('readdir', function (f, dir) {
    dir.forEach(function (df) {
      te.task(fs, 'stat', path.join(f, df));
    });
  });

  te.on('stat', function (f, stat) {
    if(stat.isDirectory()) {
      te.task(fs, 'readdir', f);
    } else {
      te.task(fs, 'readFile', f, 'utf8');
    }
  });

  te.on('readFile', function (f, enc, contents) {
    files[f] = contents;
  });

  te.on('init', function iterateFiles() {
    content.forEach(function (p) {
      if (typeof p === 'string') {
        var matched = findFiles(root || cwd, p);
        matched.forEach(function (f) {
          if (matchedFiles.indexOf(f) === -1) {
            matchedFiles.push(f);
          }
        });
      } else {
        matchedFiles.push(p);
      }
    });

    matchedFiles.forEach(function (p) {
      if(typeof p === 'string') {
        var f = path.join(root || cwd, p);
        if(self.hasExt(f)) {
          te.task(fs, 'readFile', f, 'utf8');
        } else {
          te.task(fs, 'stat', f);
        }
      }
    }.bind(this));
    if (!te.remaining()) {
      te.emit('error', new Error('no matching files were found'));
    }
  });

  if (init) {
    te.task('init', function execInit(cb) {
      var opts = {
        cwd: root || process.cwd(),
        timeout: 2000 /* milliseconds */
      };
      exec(init, opts, cb);
    });
  } else {
    te.emit('init');
  }
}

Docs.prototype.hasExt = function (f) {
  return ~this.config.extensions.indexOf(path.extname(f));
}

Docs.prototype.buildSections = function () {
  var sections = this.sections;
  var order = this.config.order;
  var files = this.content;
  var content = this.content;
  var root = this.root;

  // order content using index
  if(Array.isArray(order)) {
    files = content.sort(function (a, b) {
      var pathA = path.resolve(root, a.file);
      var pathB = path.resolve(root, b.file);
      var indexA = order.indexOf(pathA);
      var indexB = order.indexOf(pathB);

      if(indexA === indexB) return 0;
      return indexA > indexB ? 1 : -1;
    });
  }

  for(var i = 0; i < files.length; i++) {
    var f = files[i];
    f.sections.forEach(function (s) {
      sections.push(s);
    });
  }
}

Docs.prototype.getUrlSafeAnchor = function(title) {
  return string.slugify(title.toLowerCase().replace(/\./g, '-'));
};

Docs.prototype.getUniqueAnchor = function (title) {
  var anchors = this.anchors = this.anchors || {};
  var anchor;
  var urlSafe = this.getUrlSafeAnchor(title);
  var isUsed = anchors[urlSafe];

  if(!urlSafe) {
    return;
  }

  if(isUsed) {
    var split = urlSafe.split('');
    var lastCharIndex = split.length - 1;
    var lastChar = split[lastCharIndex];
    var num = parseInt(lastChar);
    var isNum = num == lastChar;

    if(isNum) {
      split[lastCharIndex] = num + 1;
    } else {
      split.push('-1');
    }
    anchor = this.getUniqueAnchor(split.join(''));
  } else {
    anchor = urlSafe;
  }

  // index anchor
  anchors[anchor] = true;

  return anchor;
}

/**
 * Render the given [config](#config) as html.
 *
 * @param {Object} config
 * @param {Function} callback
 */

Docs.toHtml = function (config, fn) {
  var template = config.template || path.join(__dirname, '..', 'templates', 'docs.ejs');

  Docs.parse(config, function (err, docs) {
    if(err) {
      return fn(err);
    }

    ejs.renderFile(template, {docs: docs}, function (err, html) {
      if (err) {
        fn(err);
      } else {
        docs.postProcessHtml(html, fn);
      }
    });
  });
}

function fauxSectionToMarkdown(section) {
  var md = '';
  var n = section.depth

  for (var i=0; i < n; i++) {
    md += '#';
  };

  md += ' ' + section.title;

  return md;
}

/**
 * A hook to do any post-processing of the HTML before `toHtml` signals its
 * completion.
 *
 * @param  {String}   html     The fleshed-out HTML.
 * @param  {Function} callback A Node-style callback.
 * @return {Docs}              The Docs instance, for cascading.
 */
Docs.prototype.postProcessHtml = function(html, callback) {
  var self = this;
  var package = self.config.package;
  var version = package && package.version;

  if(version) {
    callback(null, addVersion(html));
  } else {
    callback(null, html);
  }

  return self;

  // We want to add and de-emphasize the version number within the content's
  // main title.
  function addVersion(html) {
    // This is the poor man's version of $('h1').get(0).html(...)
    // TODO(schoon) - Add DOM-aware post-processing capabilities, i.e. jsdom.
    return html.replace('</h1>', ' <small>v' + version +
      '</small></h1>');
  }
};

Docs.prototype.getAllMarkdown = function() {
  return this.content
    .filter(function(doc) {
      return !doc.isJS;
    })
    .sort(alpha);
}

Docs.prototype.getMarkdownSections = function() {
  var sections = [];
  this.getAllMarkdown().forEach(function(doc) {
    sections = sections.concat(doc.sections);
  });
  return sections;
}

Docs.prototype.getAllModules = function() {
  return this
    .content.filter(function(doc) {
      return doc.isJS;
    })
    .sort(alpha);
}

function alpha(a, b) {
  a = a.file;
  b = b.file;
  return a.localeCompare(b);
}
 at SyntaxError: Unexpected token (18:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/strong-docs/node_modules/strong-docs/index.js. Coverage (Term): 80% Coverage (LOC): 100%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
