/root/Targets/react-fuzzy-search
└─┬ react-fuzzy-search@0.4.0 
  ├── classnames@1.2.2 
  ├── priorityqueuejs@1.0.0 
  └─┬ react@0.13.3 
    └─┬ envify@3.4.1 
      ├─┬ jstransform@11.0.3 
      │ ├── base62@1.2.0 
      │ ├─┬ commoner@0.10.8 
      │ │ ├── commander@2.11.0 
      │ │ ├─┬ detective@4.5.0 
      │ │ │ ├── acorn@4.0.13 
      │ │ │ └── defined@1.0.0 
      │ │ ├─┬ glob@5.0.15 
      │ │ │ ├─┬ inflight@1.0.6 
      │ │ │ │ └── wrappy@1.0.2 
      │ │ │ ├── inherits@2.0.3 
      │ │ │ ├─┬ minimatch@3.0.4 
      │ │ │ │ └─┬ brace-expansion@1.1.8 
      │ │ │ │   ├── balanced-match@1.0.0 
      │ │ │ │   └── concat-map@0.0.1 
      │ │ │ ├── once@1.4.0 
      │ │ │ └── path-is-absolute@1.0.1 
      │ │ ├── graceful-fs@4.1.11 
      │ │ ├── iconv-lite@0.4.19 
      │ │ ├─┬ mkdirp@0.5.1 
      │ │ │ └── minimist@0.0.8 
      │ │ ├── private@0.1.7 
      │ │ ├── q@1.5.0 
      │ │ └─┬ recast@0.11.23 
      │ │   ├── ast-types@0.9.6 
      │ │   ├── esprima@3.1.3 
      │ │   └── source-map@0.5.7 
      │ ├── esprima-fb@15001.1.0-dev-harmony-fb 
      │ ├── object-assign@2.1.1 
      │ └─┬ source-map@0.4.4 
      │   └── amdefine@1.0.1 
      └── through@2.3.8 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/react-fuzzy-search/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0597 took 6.5412s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (85:3) on program var React = require("react");
var PriorityQueue = require('priorityqueuejs');
var cx = require("classnames")
var containsNode = require("../utils/containsNode")
var JaroWinkler = require("../utils/JaroWinkler")

var SearchWorker = require("../worker/worker")

// temporarily disabling IE10
var _canUseWorkers = !!window.Worker && !/MSIE/i.test(navigator.userAgent);

var punctuationRE = /[^\w ]/g

function extend(dest, src){
	for(var p in src)
		dest[p] = src[p];
	return dest;
}

function computeSearchValues(items, opts){
	var { field, searchField, delim, immutable, removePunctuation, useWebWorkers, searchLowerCase, threadCount } = opts;

	searchField = searchField || field;

	var _searchItems = [],
		slices = [];

	items = typeof items.toArray  == "function" ?
		items.toArray() :
		items;

	items.forEach(function(item){
		var _searchValues = [],
			added = {};
		_searchItems.push({ _originalItem: item, _searchValues })

		var curSearchField = Object.prototype.toString.call(searchField) === '[object Array]' ?
			searchField.reduce((acc, f) => acc + item[f] + " ", "") : 
			item[searchField]

		if(removePunctuation)
			curSearchField = curSearchField.replace(punctuationRE, "")

		curSearchField.split(delim).forEach(function(term){
			var _term = searchLowerCase ? term.toLowerCase() : term

			/**
				Track if the field has multiples of the same word and ignore them if so
			*/
			if(!added[_term]){
				_searchValues.push(_term)
				added[_term] = true
			}
		})
	})

	/**
		If we're using web workers split them computed search data into equal chunks per thread
	*/
	if(useWebWorkers && immutable){
		for(var i = 0; i < threadCount; i++){
			var start = Math.floor(i * (_searchItems.length / threadCount)),
				end = Math.floor((i + 1) * (_searchItems.length / threadCount))
			if(i < 3)
				slices.push(_searchItems.slice(start, end))
			else
				slices.push(_searchItems.slice(start))
		}
	}

	return {
		computing: false,
		items: _searchItems,
		slices: slices
	}
}

var FuzzySearchResult = React.createClass({
	render: function(){
		var classes = cx("fuzzy-search-result", {
			"fuzzy-search-result-highlighted": this.props.highlighted
		})

		return (
			<li className={classes} onClick={this.props.selectItem && this.select} style={this.props.style}>
				<div className="inline-top" style={{ paddingLeft: 4, marginTop:2 }}>
					<div>
						{ this.props.item[this.props.nameField] + (this.props.showScore ? this.props.score : '' ) }
					</div>
				</div>
			</li>
		);
	},

	select: function (e) {
		this.props.selectItem(this.props.item)

		e.stopPropagation();
	}
});

var FuzzySearch = React.createClass({
	getInitialState: function(){
		return {
			active: false,
			computing: true,
			results: [],
			searchTerm: "",
			highlightedIdx: -1,
			threadID: 0,
			threadResults: {}
		}
	},

	componentDidMount: function(){
		this._computeData()

		if(this.props.initialSelectedID){
			var selectedItem = this.props.items.filter(function (item) { return item[this.props.idField] == this.props.initialSelectedID}.bind(this))
			if(selectedItem.length === 1)
				this.setState({ selectedItem: selectedItem[0] });
		}
	},

	getDefaultProps: function(){
		return {
			containerClassName: "",
			delim: " ",
			immutable: true,
			maxItems: 25,
			minScore: .7,
			resultsComponent: FuzzySearchResult,
			resultsComponentProps: {},
			searchLowerCase: true,
			threadCount: 2,
			useWebWorkers: !!window.Worker
		}
	},

	componentDidUpdate: function(prevProps, prevState){
		if(this.props.items != prevProps.items){
			this.setState({
				computing: true
			}, this._computeData)
		}
		else{
			if(this.state.active != prevState.active){
				if(this.state.active){
					document.addEventListener("click", this._checkForClose, false)
					this.refs.input.getDOMNode().focus();
				}
				else
					document.removeEventListener("click", this._checkForClose)
			}

			if(this.state.searchingAsync && this._asyncSearchComplete()){
				/*
					Minimum score is a value [0,1] multiplied by the number of search terms. If 
					there are 3 search terms and the minScore is .7 a result's score would need
					to be at least 2.1
				*/
				var minScore = this.props.minScore * this.getSearchTerms().length;
				
				var results = this.state.threadResults[this.state.threadID]
									.reduce(function(acc, res) { return acc.concat(res) }, [])
									.filter(function(res) { return res._score > minScore })
									.sort(function(a,b) { return b._score - a._score })

				this.setState({
					results: results.slice(0, this.props.maxItems),
					searchingAsync: false
				})
			}
		}
	},

	componentWillUnmount: function(){
		this._closeWorkers();
		document.removeEventListener("click", this._checkForClose)
	},

	_checkForClose: function (e) {
		if(!containsNode(this.getDOMNode(), e.target))
			this.setInactive();
	},

	_asyncSearchComplete: function(){
		// check if all threads have returned a result
		return this.state.threadResults[this.state.threadID].length == this.props.threadCount
	},

	_computeData: function(){
		this.setState(computeSearchValues(this.props.items, this.props), this._createWorkers)
	},

	_createWorkers: function(){
		if(this.props.useWebWorkers && _canUseWorkers){
			this._closeWorkers();
			this._threads = [];
			
			var workerBlob;
			try{
				workerBlob = new Blob(['(' + SearchWorker.toString() + ')();'], {type: "text/javascript"});
			}
			catch(e){
				var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
				blob = new BlobBuilder();
				blob.append(SearchWorker.toString());
				workerBlob = blob.getBlob();
			}
			
			var workerBlobURL = window.URL.createObjectURL(workerBlob);

			for(var i = 0; i < this.props.threadCount; i++){
				var worker;
				try{
					worker = new Worker(workerBlobURL);

					worker.onmessage = this.onWorkerMessage;

					worker.postMessage({
						cmd: "setData",
						items: this.state.slices[i]
					})

					this._threads.push({ worker })
				}
				catch(e){
					// if(e.code == 18){
						// TODO: handle IE10 security error
					// }
				}
			}

			window.URL.revokeObjectURL(workerBlob);
		}

		if(this.state.searchTerm.length) 
			this.search({ target: { value: this.state.searchTerm }}) //hacky I know
	},

	_closeWorkers: function(){
		if(this.props.useWebWorkers && this._threads){
			this._threads.forEach(function(thread){
				if(thread.worker && thread.worker.terminate)
					thread.worker.terminate();
			})
		}
	},

	_updateScrollTop () {
		if(this.refs.cont)
        	this.refs.cont.getDOMNode().scrollTop = Math.max(0, this.state.highlightedIdx - 5) * 28
    },

	render: function () {
		var items = this.getItems(),
			inactive = this.state.selectedItem && !this.state.active,
			inpClasses = cx({
				"fuzzy-inp": true,
				"fuzzy-inp-inactive": inactive
			})

		return (
			<span className={"fuzzy-search " + this.props.containerClassName}>
				<input
					{...this.props}
					className={inpClasses}
					disabled={this.state.computing}
					onChange={this.search}
					onFocus={this.setActive}
					onKeyDown={this.handleSpecialKeys}
					ref="input"
					type="text"
					value={inactive ?
						this.state.selectedItem[this.props.nameField] :
						this.state.searchTerm
					}
				/>
				
				{ this.state.active &&
					<ul className="fuzzy-results-cont" ref="cont">
						{ items.map(function(result, idx) {
							return (
								React.createElement(this.props.resultsComponent, 
									extend(
										{
											key: result._originalItem[this.props.idField],
											highlighted: idx == this.state.highlightedIdx,
											nameField: this.props.nameField,
											item: result._originalItem,
											score: result._score,
											selected: result._originalItem == this.state.selectedItem,
											selectItem: this.selectItem,
											showScore: this.props.showScore
										},
										this.props.resultsComponentProps
									)
								)
							)
						}, this)}
					</ul>
				}
			</span>
		);
	},
	
	getItems: function(){
		if(this.state.searchTerm.length){
			return this.state.results
		}
		else{
			if(this.state.items){
				if(this.props.maxUnfilteredItems)
					return this.state.items.slice(0, this.props.maxUnfilteredItems)
				else
					return this.state.items;
			}

		}
		
		return [];
	},

	getSearchTerms: function(){
		return this.state.searchTerm
				.split(" ")
				.filter(function(term) { return term.length > 0 })
				.map(function(term) { return term.toLowerCase() });
	},

	handleSpecialKeys (e) {
		if(e.keyCode == 13){
            if(this.state.highlightedIdx >= 0){
    			var items = this.getItems(),
    				selectedItem = items[this.state.highlightedIdx];

    			if(selectedItem)
    				this.selectItem(selectedItem._originalItem)

    			this.refs.input.getDOMNode().blur()

    			e.stopPropagation();
                e.preventDefault();
            }
		}
		else if(e.keyCode == 40 || e.keyCode == 38){
			var highlightedIdx = (
                Math.min(
                    this.getItems().length - 1,
                    Math.max(
                        0,
                        this.state.highlightedIdx + (e.keyCode == 40 ? 1 : -1)
                    )
                )
            )

			this.setState({ highlightedIdx }, this._updateScrollTop);
			e.stopPropagation();
            e.preventDefault();
		}
	},

	runSearch: function(searchTerms){
		var queue = new PriorityQueue(function(a,b) { return b.dist - a.dist }),
			results = [],
			minDist = 0,
			cache = {};

		for(var i = 0; i < this.state.items.length; i++){
			var item = this.state.items[i],
				totalDist = 0,
				flagged = {};

			for(var j = 0; j < searchTerms.length; j++){
				var searchTerm = searchTerms[j],
					maxDist = 0,
					flagPos;

				cache[searchTerm] = cache[searchTerm] || {}

				for(var k = 0; k < item._searchValues.length; k++){
					var searchValue = item._searchValues[k],	
						curDist;

					if(searchTerm == searchValue){
						if(!flagged[j]){
							flagPos = j;
							maxDist = 1.1
							break;
						}
					}
					else if(cache[searchTerm][searchValue])
						curDist = cache[searchTerm][searchValue]
					else
						curDist = cache[searchTerm][searchValue] = JaroWinkler.get(searchTerm, searchValue)

					if(curDist > maxDist && (!flagged[j] || curDist > flagged[j])){
						flagPos = j;
						maxDist = curDist;
					}
				}
				
				/*
					Worth noting that flagging is crude and only works in one direction. A search term can be a top match
					for a search value and then supplanted by a later search term but its maxDist will not be recalculated.
				*/
				flagged[flagPos] = maxDist;
				totalDist += maxDist;
			}

			if(queue.size() < this.props.maxItems){
				if(totalDist < minDist)
					minDist = totalDist;
				queue.enq({ item: item, dist: totalDist })
			}
			else if(totalDist > minDist){
				queue.deq()
				minDist = queue.peek().dist;
				queue.enq({ item: item, dist: totalDist })
			}
		}

		var minScore = this.props.minScore * searchTerms.length;

		while(queue.size()){
			var _res = queue.deq();
			if(_res.dist > minScore){
				_res.item._score = _res.dist;
				results.unshift(_res.item)
			}
		}

		this.setState({
			results
		})
	},

	search: function(e){
		var threadID = this.state.threadID + 1,
			threadResults = {};

		threadResults[threadID] = []

		this.setState({
			searching: true,
			searchTerm: e.target.value,
			threadID,
			threadResults
		}, this.startSearch)
	},

	selectItem: function (selectedItem) {
		this.setState({ active: false, selectedItem });

		if(this.props.onChange)
			this.props.onChange(selectedItem);
	},

	setActive: function (e) {
		this.setState({
			active: true,
			highlightedIdx: 0
		});

		if(this.props.onFocus)
			this.props.onFocus(e)
		else if(e && e.stopPropagation)
			e.stopPropagation();
	},

	setInactive: function (e) {
		this.setState({
			active: false,
			highlightedIdx: -1
		});

		if(this.props.onBlur)
			this.props.onBlur(e)
		else if(e && e.stopPropagation)
			e.stopPropagation();
	},

	startSearch: function(){
		var searchTerms = this.getSearchTerms();

		if(this.props.useWebWorkers && _canUseWorkers){
			/*
				Each new state.searchTerm gets a threadID by which the web workers results will be tracked. 
			*/
			for(var i = 0; i < this.props.threadCount; i++){
				var worker = this._threads[i].worker,
					slice = this.state.slices[i]

				worker.postMessage({
					cmd: "search",
					opts: {
						maxItems: this.props.maxItems
					},
					searchTerms,
					threadID: this.state.threadID
				})
			}

			this.setState({
				searchingAsync: true
			})
		}
		else if(!this.props.immutable){
			this.setState(computeSearchValues(this.props.items, this.props), function(){
				this.runSearch(searchTerms);
			})
		}
		else{
			this.runSearch(searchTerms);
		}
	},

	onWorkerMessage: function(e){
		if(e.data && e.data.results){
			var threadResults = this.state.threadResults,
				threadResultsForID = threadResults[e.data.threadID]

			if(threadResultsForID){
				threadResultsForID.push(e.data.results)
				this.state.threadResults[e.data.threadID] = threadResultsForID;

				this.setState({ threadResults })
			}
		}	
	}
})


module.exports = FuzzySearch;
 at SyntaxError: Unexpected token (85:3)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$3.parseExprAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1822:12)
    at Parser.parseExprAtom (/root/ExpoSE/lib/Tropigate/bin/Expression.js:28:30)
    at Parser.pp$3.parseExprSubscripts (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1715:21)
    at Parser.parseMaybeUnary (/root/ExpoSE/lib/Tropigate/bin/Unary.js:34:29)
    at Parser.pp$3.parseExprOps (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1637:21)
    at Parser.pp$3.parseMaybeConditional (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1620:21)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1597:21)
    at Parser.pp$3.parseParenAndDistinguishExpression (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1861:32)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/react-fuzzy-search/node_modules/react-fuzzy-search/src/index.js. Coverage (Term): 80% Coverage (LOC): 100%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
