/root/Targets/integra
└─┬ integra@0.1.8 
  ├─┬ escodegen@1.1.0 
  │ ├── estraverse@1.5.1 
  │ ├── esutils@1.0.0 
  │ └─┬ source-map@0.1.43 
  │   └── amdefine@1.0.1 
  ├── esprima@1.0.4 
  ├─┬ handlebars@2.0.0-alpha.1 
  │ ├─┬ optimist@0.3.7 
  │ │ └── wordwrap@0.0.3 
  │ └─┬ uglify-js@2.3.6 
  │   └── async@0.2.10 
  ├─┬ mkdirp@0.5.1 
  │ └── minimist@0.0.8 
  └── rimraf@2.2.6 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/integra/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 24% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0627 took 14.2227s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (3:3) on program var debug = require('../utils').debug
	, f = require('util').format
	, assert = require('../assert/assert')
	, utils = require('../utils')
	, Formatter = require('./formatter');

var TestRunnerResults = function() {
	var errors = [];
	var results = [];

	utils.readOnlyEnumerableProperty(this, "errors", errors);
	utils.readOnlyEnumerableProperty(this, "results", results);

	this.add = function(result) {
		results.push(result);
	}

	this.addErr = function(test) {
		errors.push(test);
	}
}

var TestResult = function(test) {
	var err = null;
	var callback = null;
	var number_of_assertions = 0;
	var number_of_successful_assertions = 0;
	var number_of_failed_assertions = 0;

	utils.readOnlyEnumerableProperty(this, "assertions", number_of_assertions);
	utils.readOnlyEnumerableProperty(this, "successfulAssertions", number_of_successful_assertions);
	utils.readOnlyEnumerableProperty(this, "failedAssertions", number_of_failed_assertions);

	this.addErr = function(_err) {
		err = _err;
	}

	this.done = function() {
		if(typeof callback == 'function') callback(test);
	}

	this.onDone = function(_callback) {
		callback = _callback;
	}

  this.ok = function(value, description) {
    number_of_assertions++;

    try {
      assert.ok(value, description);    
      number_of_successful_assertions++;
    } catch(err) {
      number_of_failed_assertions++;
      throw err;
    }
  }

  this.equal = function(expected, value, description) {
    number_of_assertions++;

    try {
      assert.equal(value, expected, description);
      number_of_successful_assertions++;
    } catch(_err) {
      number_of_failed_assertions++;
      throw _err;
    }
  }	

  this.notEqual = function(expected, value, description) {
    number_of_assertions++;

    try {
      assert.notEqual(value, expected, description);
      number_of_successful_assertions++;
    } catch(err) {
      number_of_failed_assertions++;
      throw err;
    }
  } 

  this.deepEqual = function(expected, value, description) {
  	number_of_assertions++;

		try {
			assert.deepEqual(value, expected, description);
			number_of_successful_assertions++;
		} catch(err) {
			number_of_failed_assertions++;
			throw err;
		}
  }

  this.throws = function(block, error, message) {
    number_of_assertions++;

    try {
      assert.throws(block, error, message);
      number_of_successful_assertions++;
    } catch(err) {
      number_of_failed_assertions++;
      throw err;
    }
  }

  this.strictEqual = function(expected, value, description) {
    number_of_assertions++;

    try {
      assert.strictEqual(value, expected, description);
      number_of_successful_assertions++;
    } catch(err) {
      number_of_failed_assertions++;
      throw err;
    }
  }

  this.uncaughtException = function(handler) {
    // Save state of the current uncaughtException listeners
    var state = process._events['uncaughtException'];
    process._events['uncaughtException'] = [];
    // Add our own handler
    process.on('uncaughtException', function(err) {
      process._events['uncaughtException'] = state;
      handler(err);
    });
  }
}

var TestRunner = function(context, options, plugins, testFiles) {
	var tests = [];
	var logger = debug('LocalScheduler');
	var results = new TestRunnerResults();
	var formatter = new Formatter();
	options = options || {};
	// Fail test process on first failure
	var failFast = typeof options.failFast == 'boolean' ? options.failFast : true;

	this.add = function(test) {
		tests.push(test);
	}

	this.run = function(callback) {
		if(tests.length == 0) callback(null, null);
		runTests(context, tests, 0, function() {
			callback(null, results);
		})
	}

	var runTests = function(context, tests, index, callback) {
		if(index >= tests.length) return callback();
		// Get the test
		var test = tests[index];
		// Create a test result instance
		var testResult = new TestResult(test);
		results.add(testResult);
		// Assume fail until passed in case of an uncaught exception
		test.status = "fail";
		
		// Add onDone
		testResult.onDone(function(test) {
			console.log(formatter.ok('✔ ' + test.name));
			test.status = "pass";

      // Execute the before tests
      testFiles[test.file].afterTests(context, test, function() {
  			// All plugins that need to run after a test finished
  			utils.executeAllPlugins(plugins, "afterTest", test, function() {
  				context.teardown(function() {
  					runTests(context, tests, index + 1, callback);
  				});
  			});			
      });
		});

		// All plugins that need to run before a test starts
		utils.executeAllPlugins(plugins, "beforeTest", test, function() {
			// We need to run the context setup
			context.setup(function() {
        
        // Execute the before tests
        testFiles[test.file].beforeTests(context, test, function() {
          // Get the test Function
          var testFunction = typeof test.test == 'function' ? test.test : test.test.test;
          
          // Execute the test
          try {
            logger(options.logLevel, 'info', f("started test [%s]", test.name));
            testFunction.apply(test.module, [context, testResult]);
          } catch(err) {
            console.log(formatter.error('✖ ' + test.name));
            console.log(formatter.bold(JSON.stringify(err)));
            // Add error to test results
            testResult.addErr(err);
            
            // If we decided to fail fast, due so now
            if(!failFast) {
              // All plugins that need to run after a test finished
              return utils.executeAllPlugins(plugins, "afterTest", test, function() {
                process.nextTick(function() {
                  runTests(context, tests, index + 1, callback);
                });
              });
            }

            // Throw an error
            throw err;
          }                    
        })
			});
		});
	}
}

module.exports = TestRunner;
 at SyntaxError: Unexpected token (3:3)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/integra/node_modules/integra/index.js. Coverage (Term): 31% Coverage (LOC): 50%
*- File /root/Targets/integra/node_modules/integra/lib/runner.js. Coverage (Term): 8% Coverage (LOC): 4%
*- File /root/Targets/integra/node_modules/integra/lib/utils.js. Coverage (Term): 17% Coverage (LOC): 33%
*- File /root/Targets/integra/node_modules/integra/lib/schedulers/local_scheduler.js. Coverage (Term): 12% Coverage (LOC): 9%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
