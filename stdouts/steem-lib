/root/Targets/steem-lib
└─┬ steem-lib@1.0.3 
  ├── async@0.9.2 
  ├── bigi@1.4.2 
  ├─┬ bs58@3.1.0 
  │ └── base-x@1.1.0 
  ├─┬ bytebuffer@5.0.1 
  │ └── long@3.2.0 
  ├── crypto-js@3.1.8 
  ├── ecurve@1.0.5 
  ├── secure-random@1.1.1 
  └─┬ ws@2.3.1 
    ├── safe-buffer@5.0.1 
    └── ultron@1.1.0 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/steem-lib/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 15% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0333 took 11.6977s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (6:4) on program var ecurve = require('ecurve');
var Point = ecurve.Point;
var secp256k1 = ecurve.getCurveByName('secp256k1');
var BigInteger = require('bigi');
var base58 = require('bs58');
var assert = require('assert');
var hash = require('./hash');
var PublicKey = require('./publicKey');
var Signature = require('./signature');

var G = secp256k1.G
var n = secp256k1.n

var PrivateKey = function(d) {
    this.d = d;
}    

PrivateKey.fromBuffer = function(buf) {
    if (!Buffer.isBuffer(buf)) {
        throw new Error("Expecting paramter to be a Buffer type");
    }
    if (32 !== buf.length) {
        console.log('WARN: Expecting 32 bytes, instead got ' + buf.length + ', stack trace:', new Error().stack);
    }
    if (buf.length === 0) {
        throw new Error("Empty buffer");
    }
    return new PrivateKey(BigInteger.fromBuffer(buf));
}

/** @arg {string} seed - any length string.  This is private, the same seed produces the same private key every time.  */
PrivateKey.fromSeed = function(seed) { // generate_private_key
    if (!(typeof seed === 'string')) {
        throw new Error('seed must be of type string');
    }
    return PrivateKey.fromBuffer(hash.sha256(seed));
}

PrivateKey.isWif = function(text) {
    try {
        this.fromWif(text)
        return true
    } catch(e) {
        return false
    }
}

/**
    @throws {AssertError|Error} parsing key
    @return {string} Walvar Import Format (still a secret, Not encrypted)
*/
PrivateKey.fromWif = function(_private_wif) {
    var private_wif = new Buffer(base58.decode(_private_wif));
    var version = private_wif.readUInt8(0);
    assert.equal(0x80, version, 'Expected version ' + 0x80 + ', instead got ' + version);
    // checksum includes the version
    var private_key = private_wif.slice(0, -4);
    var checksum = private_wif.slice(-4);
    var new_checksum = hash.sha256(private_key);
    new_checksum = hash.sha256(new_checksum);
    new_checksum = new_checksum.slice(0, 4);
    if (checksum.toString() !== new_checksum.toString())
        throw new Error('Invalid WIF key (checksum miss-match)')

    private_key = private_key.slice(1);
    return PrivateKey.fromBuffer(private_key);
}

PrivateKey.prototype.toWif = function() {
    var private_key = this.toBuffer();
    // checksum includes the version
    private_key = Buffer.concat([new Buffer([0x80]), private_key]);
    var checksum = hash.sha256(private_key);
    checksum = hash.sha256(checksum);
    checksum = checksum.slice(0, 4);
    var private_wif = Buffer.concat([private_key, checksum]);
    return base58.encode(private_wif);
}

/** Alias for {@link toWif} */
PrivateKey.prototype.toString = function() {
    return this.toWif();
}


PrivateKey.prototype.sign = function (string) {
    return Signature.sign(string, this);
}

PrivateKey.prototype.signBuffer = function (buf) {
    return Signature.signBuffer(buf, this);
}


/**
    @return {Point}
*/
PrivateKey.prototype.toPublicKeyPoint = function() {
    var Q;
    return Q = secp256k1.G.multiply(this.d);
}

PrivateKey.prototype.toPublic = function() {
    if (this.public_key) { return this.public_key; }
    return this.public_key = PublicKey.fromPoint(this.toPublicKeyPoint());
}

PrivateKey.prototype.toBuffer = function() {
    return this.d.toBuffer(32);
}

/** ECIES */
PrivateKey.prototype.get_shared_secret = function(public_key) {
    public_key = toPublic(public_key)
    var KB = public_key.toUncompressed().toBuffer()
    var KBP = Point.fromAffine(
        secp256k1,
        BigInteger.fromBuffer( KB.slice( 1,33 )), // x
        BigInteger.fromBuffer( KB.slice( 33,65 )) // y
    )
    var r = this.toBuffer()
    var P = KBP.multiply(BigInteger.fromBuffer(r))
    var S = P.affineX.toBuffer({size: 32})
    // SHA512 used in ECIES
    return hash.sha512(S)
}

// /** ECIES (does not always match the Point.fromAffine version above) */
// get_shared_secret(public_key){
//     public_key = toPublic(public_key)
//     var P = public_key.Q.multiply( this.d );
//     var S = P.affineX.toBuffer({size: 32});
//     // ECIES, adds an extra sha512
//     return hash.sha512(S);
// }

/** @throws {Error} - overflow of the key could not be derived */
PrivateKey.prototype.child = function( offset ) {
    offset = Buffer.concat([ this.toPublicKey().toBuffer(), offset ])
    offset = hash.sha256( offset )
    var c = BigInteger.fromBuffer(offset)

    if (c.compareTo(n) >= 0)
        throw new Error("Child offset went out of bounds, try again")

    var derived = this.d.add(c)//.mod(n)

    if( derived.signum() === 0 )
        throw new Error("Child offset derived to an invalid key, try again")

    return new PrivateKey( derived )
}

/* <helper_functions> */

PrivateKey.prototype.toByteBuffer = function() {
    var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
    this.appendByteBuffer(b);
    return b.copy(0, b.offset);
}

PrivateKey.fromHex = function(hex) {
    return PrivateKey.fromBuffer(new Buffer(hex, 'hex'));
}

PrivateKey.prototype.toHex = function() {
    return this.toBuffer().toString('hex');
}

PrivateKey.prototype.toPublicKey = function() {
    return this.toPublic()
}


module.exports = PrivateKey;

var toPublic = function (data) {
    return data == null ? data :
    data.Q ? data : PublicKey.fromStringOrThrow(data)
}     at SyntaxError: Unexpected token (6:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/steem-lib/node_modules/steem-lib/src/index.js. Coverage (Term): 12% Coverage (LOC): 19%
*- File /root/Targets/steem-lib/node_modules/steem-lib/src/remote.js. Coverage (Term): 3% Coverage (LOC): 3%
*- File /root/Targets/steem-lib/node_modules/steem-lib/src/server.js. Coverage (Term): 10% Coverage (LOC): 20%
*- File /root/Targets/steem-lib/node_modules/steem-lib/src/request.js. Coverage (Term): 10% Coverage (LOC): 12%
*- File /root/Targets/steem-lib/node_modules/async/lib/async.js. Coverage (Term): 10% Coverage (LOC): 14%
*- File /root/Targets/steem-lib/node_modules/steem-lib/src/auth.js. Coverage (Term): 6% Coverage (LOC): 9%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
