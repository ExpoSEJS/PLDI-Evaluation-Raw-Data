/root/Targets/rescode
└── rescode@0.1.10 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/rescode/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 13% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0475 took 30.7945s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Octal literal in strict mode (288:10) on program // file: lib/canvas.js
//
// Copyright (c) 2011-2013 Mark Warren
//
// See the COPYRIGHT file in the bwip.js root directory
// for the extended copyright notice.

// With embedding in the browser, we load the symbols externally


// Encapsulate the bitmap interface

// bwip-js bitmap interface

function Bitmap() {
	var _clr  = 0;					// currently active color
	var _clrs = {};					// color map
	var _nclr = 0;					// color count
	var _bits = [];					// the x,y,c bits
	var _minx = Infinity;
	var _miny = Infinity;
	var _maxx = 0;
	var _maxy = 0;

	this.color = function(r,g,b) {
		var rgb = (r<<16) | (g<<8) | b;
		if (!_clrs[rgb])
			_clrs[rgb] = { n:_nclr++ };
		_clr = rgb;
	};

	this.set = function(x, y, b) {
		// postscript graphics work with floating-pt numbers
		x = Math.floor(x);
		y = Math.floor(y);

		if (_minx > x) _minx = x;
		if (_maxx < x) _maxx = x;
		if (_miny > y) _miny = y;
		if (_maxy < y) _maxy = y;

		_bits.push([x,y,_clr]);
	};

	this.create = function(rot) {
		
		var h, w;
		// determine image width and height
		if (rot == 'R' || rot == 'L') {
			h = _maxx-_minx+1;
			w = _maxy-_miny+1;
		} else {
			w = _maxx-_minx+1;
			h = _maxy-_miny+1;
		}

		var png = new PNGlib(w, h, 256);

		// make sure the default color (index 0) is white
		png.color(255,255,255,255);

		// map the colors
		var cmap = [];
		for (rgb in _clrs)
			cmap[rgb] = png.color(rgb>>16, (rgb>>8)&0xff, (rgb&0xff), 255);

		for (var i = 0; i < _bits.length; i++) {
			// PostScript builds bottom-up, we build top-down.
			var x = _bits[i][0] - _minx;
			var y = _bits[i][1] - _miny;
			var c = cmap[_bits[i][2]];
			
			if (rot == 'N') {
				y = h - y - 1; 	// Invert y
			} else if (rot == 'I') {
				x = w - x - 1;	// Invert x
			} else {
				y = w - y; 		// Invert y
				if (rot == 'L') {
					var t = y;
					y = h - x - 1;
					x = t - 1;
				} else {
					var t = x;
					x = w - y;
					y = t;
				}
			}

			png.set(x, y, c);
		}

		return new Buffer( png.render(), "binary" );
	};
}

module.exports = Bitmap;

/**
* pnglib.js
* @version 1.0
* @author Robert Eisele <robert@xarg.org>
* @copyright Copyright (c) 2010, Robert Eisele
* @link http://www.xarg.org/2010/03/generate-client-side-png-files-using-javascript/
* @license http://www.opensource.org/licenses/bsd-license.php BSD License
*/

// Modified by MRW for use with bwip-js.
function PNGlib(width,height,depth) {

	// helper functions for that ctx
	function write(buffer, offs) {
		for (var i = 2; i < arguments.length; i++) {
			for (var j = 0; j < arguments[i].length; j++) {
				buffer[offs++] = arguments[i].charAt(j);
			}
		}
	}

	function byte2(w) {
		return String.fromCharCode((w >> 8) & 255, w & 255);
	}

	function byte4(w) {
		return String.fromCharCode((w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w & 255);
	}

	function byte2lsb(w) {
		return String.fromCharCode(w & 255, (w >> 8) & 255);
	}

	this.width   = width;
	this.height  = height;
	this.depth   = depth;

	// pixel data and row filter identifier size
	this.pix_size = height * (width + 1);

	// deflate header, pix_size, block headers, adler32 checksum
	this.data_size = 2 + this.pix_size +
					5 * Math.floor((0xfffe + this.pix_size) / 0xffff) + 4;

	// offsets and sizes of Png chunks
	this.ihdr_offs = 0;
	this.ihdr_size = 4 + 4 + 13 + 4;
	this.plte_offs = this.ihdr_offs + this.ihdr_size;
	this.plte_size = 4 + 4 + 3 * depth + 4;
	this.trns_offs = this.plte_offs + this.plte_size;
	this.trns_size = 4 + 4 + depth + 4;
	this.idat_offs = this.trns_offs + this.trns_size;
	this.idat_size = 4 + 4 + this.data_size + 4;
	this.iend_offs = this.idat_offs + this.idat_size;
	this.iend_size = 4 + 4 + 4;
	this.buffer_size  = this.iend_offs + this.iend_size;

	this.buffer  = new Array();
	this.palette = new Object();
	this.pindex  = 0;

	var _crc32 = new Array();

	// initialize buffer with zero bytes
	for (var i = 0; i < this.buffer_size; i++) {
		this.buffer[i] = "\x00";
	}

	// initialize non-zero elements
	write(this.buffer, this.ihdr_offs, byte4(this.ihdr_size - 12), 'IHDR',
					byte4(width), byte4(height), "\x08\x03");
	write(this.buffer, this.plte_offs, byte4(this.plte_size - 12), 'PLTE');
	write(this.buffer, this.trns_offs, byte4(this.trns_size - 12), 'tRNS');
	write(this.buffer, this.idat_offs, byte4(this.idat_size - 12), 'IDAT');
	write(this.buffer, this.iend_offs, byte4(this.iend_size - 12), 'IEND');

	// initialize deflate header
	var header = ((8 + (7 << 4)) << 8) | (3 << 6);
	header+= 31 - (header % 31);

	write(this.buffer, this.idat_offs + 8, byte2(header));

	// initialize deflate block headers
	for (var i = 0; (i << 16) - 1 < this.pix_size; i++) {
		var size, bits;
		if (i + 0xffff < this.pix_size) {
			size = 0xffff;
			bits = "\x00";
		} else {
			size = this.pix_size - (i << 16) - i;
			bits = "\x01";
		}
		write(this.buffer, this.idat_offs + 8 + 2 + (i << 16) + (i << 2),
					bits, byte2lsb(size), byte2lsb(~size));
	}

	/* Create crc32 lookup table */
	for (var i = 0; i < 256; i++) {
		var c = i;
		for (var j = 0; j < 8; j++) {
			if (c & 1) {
				c = -306674912 ^ ((c >> 1) & 0x7fffffff);
			} else {
				c = (c >> 1) & 0x7fffffff;
			}
		}
		_crc32[i] = c;
	}

	// used internally
	this.index = function(x,y) {
		var i = y * (this.width + 1) + x + 1;
		var j = this.idat_offs + 8+2+5 * Math.floor((i / 0xffff) + 1)+i;
		return j;
	}

	// set a pixel to the given color
	this.set = function(x,y,c) {
		var i = y * (this.width + 1) + x + 1;
		var j = this.idat_offs + 8+2+5 * Math.floor((i / 0xffff) + 1)+i;
		this.buffer[j] = c;
	}

	// convert a color and build up the palette
	this.color = function(red, green, blue, alpha) {

		alpha = alpha >= 0 ? alpha : 255;
		var color = (((((alpha << 8) | red) << 8) | green) << 8) | blue;

		if (typeof this.palette[color] == "undefined") {
			if (this.pindex == this.depth) return "\x00";

			var ndx = this.plte_offs + 8 + 3 * this.pindex;

			this.buffer[ndx + 0] = String.fromCharCode(red);
			this.buffer[ndx + 1] = String.fromCharCode(green);
			this.buffer[ndx + 2] = String.fromCharCode(blue);
			this.buffer[this.trns_offs+8+this.pindex] =
											String.fromCharCode(alpha);

			this.palette[color] = String.fromCharCode(this.pindex++);
		}
		return this.palette[color];
	}

	// output a PNG string
	this.render = function() {

		// compute adler32 of output pixels + row filter bytes
		// NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <=
		// 2^32-1.
		var BASE = 65521; /* largest prime smaller than 65536 */
		var NMAX = 5552; 
		var s1 = 1;
		var s2 = 0;
		var n = NMAX;

		for (var y = 0; y < this.height; y++) {
			for (var x = -1; x < this.width; x++) {
				s1+= this.buffer[this.index(x, y)].charCodeAt(0);
				s2+= s1;
				if ((n-= 1) == 0) {
					s1%= BASE;
					s2%= BASE;
					n = NMAX;
				}
			}
		}
		s1%= BASE;
		s2%= BASE;
		write(this.buffer, this.idat_offs + this.idat_size - 8,
				byte4((s2 << 16) | s1));

		// compute crc32 of the PNG chunks
		function crc32(png, offs, size) {
			var crc = -1;
			for (var i = 4; i < size-4; i += 1) {
				crc = _crc32[(crc ^ png[offs+i].charCodeAt(0)) & 0xff] ^ ((crc >> 8) & 0x00ffffff);
			}
			write(png, offs+size-4, byte4(crc ^ -1));
		}

		crc32(this.buffer, this.ihdr_offs, this.ihdr_size);
		crc32(this.buffer, this.plte_offs, this.plte_size);
		crc32(this.buffer, this.trns_offs, this.trns_size);
		crc32(this.buffer, this.idat_offs, this.idat_size);
		crc32(this.buffer, this.iend_offs, this.iend_size);

		// convert PNG to string
		return "\211PNG\r\n\032\n"+this.buffer.join('');
	};
}






 at SyntaxError: Octal literal in strict mode (288:10)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$7.readEscapedChar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:3023:16)
    at Parser.pp$7.readString (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2935:23)
    at Parser.pp$7.getTokenFromCode (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2724:19)
    at Parser.pp$7.readToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2477:17)
    at Parser.readToken (/root/ExpoSE/lib/Tropigate/bin/Tokens.js:124:26)
    at Parser.pp$7.nextToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2468:15)
    at Parser.pp$7.next (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2413:10)
    at Parser.pp$1.parseReturnStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:832:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:699:34)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/rescode/node_modules/rescode/index.js. Coverage (Term): 80% Coverage (LOC): 100%
*- File /root/Targets/rescode/node_modules/rescode/lib/codes.js. Coverage (Term): 17% Coverage (LOC): 19%
*- File /root/Targets/rescode/node_modules/rescode/lib/bwip.js. Coverage (Term): 6% Coverage (LOC): 15%
*- File /root/Targets/rescode/node_modules/rescode/lib/bwipp/index.js. Coverage (Term): 96% Coverage (LOC): 100%
*- File /root/Targets/rescode/node_modules/rescode/lib/bwipp/renlinear.js. Coverage (Term): 0% Coverage (LOC): 0%
*- File /root/Targets/rescode/node_modules/rescode/lib/bwipp/renmatrix.js. Coverage (Term): 0% Coverage (LOC): 1%
*- File /root/Targets/rescode/node_modules/rescode/lib/bwipp/renmaximatrix.js. Coverage (Term): 1% Coverage (LOC): 2%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
