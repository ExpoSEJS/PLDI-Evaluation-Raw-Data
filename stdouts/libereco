
> ws@0.4.32 install /root/Targets/libereco/node_modules/ws
> (node-gyp rebuild 2> builderror.log) || (exit 0)

make: Entering directory '/root/Targets/libereco/node_modules/ws/build'
  CXX(target) Release/obj.target/bufferutil/src/bufferutil.o
bufferutil.target.mk:96: recipe for target 'Release/obj.target/bufferutil/src/bufferutil.o' failed
make: Leaving directory '/root/Targets/libereco/node_modules/ws/build'
/root/Targets/libereco
└─┬ libereco@0.0.6 
  ├── async@0.2.10 
  ├─┬ form-data@0.0.10 
  │ ├─┬ combined-stream@0.0.7 
  │ │ └── delayed-stream@0.0.5 
  │ └── mime@1.2.11 
  ├── oauth@0.9.15 
  ├─┬ request@2.21.0 
  │ ├── aws-sign@0.3.0 
  │ ├── cookie-jar@0.3.0 
  │ ├── forever-agent@0.5.2 
  │ ├── form-data@0.0.8 
  │ ├─┬ hawk@0.13.1 
  │ │ ├─┬ boom@0.4.2 
  │ │ │ └── hoek@0.9.1 
  │ │ ├── cryptiles@0.2.2 
  │ │ ├── hoek@0.8.5 
  │ │ └─┬ sntp@0.2.4 
  │ │   └── hoek@0.9.1 
  │ ├─┬ http-signature@0.9.11 
  │ │ ├── asn1@0.1.11 
  │ │ ├── assert-plus@0.1.2 
  │ │ └── ctype@0.5.2 
  │ ├── json-stringify-safe@4.0.0 
  │ ├── node-uuid@1.4.8 
  │ ├── oauth-sign@0.3.0 
  │ ├── qs@0.6.6 
  │ └── tunnel-agent@0.3.0 
  ├─┬ socket.io@0.9.19 
  │ ├── base64id@0.1.0 
  │ ├── policyfile@0.0.4 
  │ ├── redis@0.7.3 
  │ └─┬ socket.io-client@0.9.16 
  │   ├─┬ active-x-obfuscator@0.0.1 
  │   │ └── zeparser@0.0.5 
  │   ├── uglify-js@1.2.5 
  │   ├─┬ ws@0.4.32 
  │   │ ├── commander@2.1.0 
  │   │ ├── nan@1.0.0 
  │   │ ├── options@0.0.6 
  │   │ └── tinycolor@0.0.1 
  │   └── xmlhttprequest@1.4.2 
  ├─┬ tako@0.3.0 
  │ ├── filed@0.1.0 
  │ └── mapleTree@0.5.1 
  └── valentine@1.6.1 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/libereco/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0289 took 4.2495s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected character '#' (1:78) on program #!/usr/bin/env node

var path           = require('path')
  , util           = require('util')

  , async          = require('async')
  , app            = require('tako')() // it uses socket.io internaly

  // apis
  , APIs           =
    {
      '500px'      : require('./lib/api_500px'),
      'flickr'     : require('./lib/api_flickr')
    }

  // globals
  , activeClients  = 0
  , oauthPool      = {}

  // settings
  , Config         =
    {
      port         : 8000,
      path         : 'static',
      index        : 'index.html',
      oauthCallback: '/oauth/callback'
    }
  ;

// {{{ prepare environment

// process config settings
Config.host = getConfigVar('host');

Config.port = getConfigVar('port') || Config.port;

Config.path = getConfigVar('path') || Config.path;
if (Config.path[0] != '/') Config.path = path.join(__dirname, Config.path);

Config.index = getConfigVar('index') || Config.index;
if (Config.index[0] != '/') Config.index = path.join(Config.path, Config.index);

Config.oauthCallback = getConfigVar('oauth_callback') || Config.oauthCallback;

// check APIs
for (var service in APIs)
{
  if (!APIs.hasOwnProperty(service)) continue;

  // check that we have both api key and secret for each service
  if (getConfigVar('api_'+service+'_key') && getConfigVar('api_'+service+'_secret'))
  {
    APIs[service].oauth(
    {
      key      : getConfigVar('api_'+service+'_key'),
      secret   : getConfigVar('api_'+service+'_secret'),
      callback : Config.oauthCallback
    });
  }
  else
  {
    delete APIs[service];
  }
}

// it makes sense to work with at least two services
if (Object.keys(APIs).length < 2)
{
  console.error('Error: Please enable at least two api services.');
  process.exit(0);
}

// socket.io settings
app.socketioManager.set('log level', 1);
app.socketioManager.set('transports', ['websocket']);
app.socketioManager.set('heartbeat interval', 20);
app.socketioManager.set('heartbeat timeout', 60);

// }}}

// {{{ define routing

// oauth callback
app.route(Config.oauthCallback, function appRouteOauthCallback(req, res)
{
  var token    = req.qs.oauth_token
    , verifier = req.qs.oauth_verifier;

  if (typeof oauthPool[token] == 'function')
  {
    oauthPool[token](verifier);
  }

  res.end('<script>window.close();</script>');
});

// static files + landing page
app.route('/').files(Config.index);
app.route('*').files(Config.path);

// sockets
app.sockets.on('connection', function socketsConnection(socket)
{
  // let's party
  socket.emit('ready');

  activeClients++;

  var browser = (socket.manager.handshaken[socket.id].headers['user-agent'].match(/(Chrome|Safari|Firefox|MSIE)(\/| )[0-9]+(\.[0-9]+)?/) || [socket.manager.handshaken[socket.id].headers['user-agent']])[0];

  console.log(['connected', browser, socket.id, activeClients]);

  socket.browser = browser;

  // {{{ disconnect
  socket.on('disconnect', function()
  {
    activeClients--;
    console.log(['left', browser, socket.id, activeClients]);
  });
  // }}}

  // {{{ service auth
  // TODO: Maybe make it as handler for situations when access token is missing
  socket.on('auth:request', function socketAuthRequestHandler(service, callback)
  {
    if (!(service in APIs)) return callback({status: 'error', message: 'Requested service ['+service+'] is not enabled.'});

    // create api instance
    var api = new APIs[service]();

    // set current host
    // TODO: Make it sane
    api.set({callbackHost: socket.manager.handshaken[socket.id].headers.host });

    // and store it in the socket
    socket.set('api_'+service, api, function socketStoreApi()
    {
      // request auth token
      api.authRequest(function apiAuthRequest(err, token, secret, results)
      {
        if (err) return callback({status: 'error', message: 'Unable to authenticate with the requested service ['+service+']'});

        // wait for the callback
        createOAuthVerifier(socket, service, token, secret);

        callback({ status: 'ok', data: {token: token, secret: secret, results: results} });
      });

    });

  });
  // }}}

  // {{{ fetch photos
  socket.on('photos:fetch', function socketPhotosFetchHandler(service, page)
  {
    socket.get('api_'+service, function(err, api)
    {
      if (err) return console.error(['Unable to find API ['+service+'] data', err]);

      // fetch photos
      api.fetchPhotos(page, function(err, data)
      {
        if (err) return console.error(['Cant get photos from '+service, err]);

        // return list of photos
        socket.emit('photos:add', service, {page: page, photos: data});
      });
    });

  });
  // }}}

  // {{{ upload photo
  socket.on('upload:photo', function socketUploadPhotoHandler(data, callback)
  {

    // get two (from & to) apis
    async.parallel(
    {
      from: function socketUploadPhotoGetApiFrom(cb)
      {
        socket.get('api_'+data.from, cb);
      },
      to: function socketUploadPhotoGetApiTo(cb)
      {
        socket.get('api_'+data.to, cb);
      }
    },
    function socketUploadPhotoGetApiResult(err, apis)
    {
      // get photo info to upload
      apis.from.getPhotoInfo(data.photo.id, function(err, photo)
      {
        if (err) return callback({status: 'error', message: err});

        // upload photo to the destination api
        // TODO: Streams would play here better,
        // but wait for them to be stable
        apis.to.uploadPhoto(photo, function(err, result)
        {
          if (err) return callback({status: 'error', message: err});

          callback({status: 'ok', data: result});
        });
      });

    });

  });
  // }}}

});

// }}}

// {{{ start server

app.httpServer.listen(Config.port, Config.host);

console.log('Listening on '+Config.host+':'+Config.port);

// }}}

/*
 * subroutines
 */

// creates oauth verification handler,
// upon receiving callback from the api
// requests access token
function createOAuthVerifier(socket, service, token, secret)
{
  oauthPool[token] = function oauthVerificationCallbackHandler(verifier)
  {
    socket.get('api_'+service, function(err, api)
    {
      if (err || !api) return console.error(['Cannot store access data ['+service+'] in the socket', (err ? err : 'api is null'), api]);

      // get Access Token from the API
      api.getAccessToken(token, secret, verifier, function oauthAccessTokenHandler(err, access_token, access_secret, results)
      {
        if (err) return console.error(['Cannot get access token for '+service, err]);

        api.fetchUser(function(err, user)
        {
          if (err) return console.error(['Cannot get user data for '+service, err]);

          socket.emit('auth:user', {service: service, user: api.Data.user});
        });
      });

    });

    // we done here, clean up
    delete oauthPool[token];
  };
}

// fetches variable from environment or npm config
// TODO: Should we account for 0?
function getConfigVar(key)
{
  return process.env[key] || process.env['npm_package_config_'+key] || null;
}
 at SyntaxError: Unexpected character '#' (1:78)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$7.getTokenFromCode (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2756:10)
    at Parser.pp$7.readToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2477:17)
    at Parser.readToken (/root/ExpoSE/lib/Tropigate/bin/Tokens.js:124:26)
    at Parser.pp$7.nextToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2468:15)
    at Parser.pp$7.next (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2413:10)
    at Parser.pp.eat (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:536:12)
    at Parser.pp.semicolon (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:581:15)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:918:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
