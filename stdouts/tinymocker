/root/Targets/tinymocker
└─┬ tinymocker@1.0.5 
  ├─┬ body-parser@1.18.2 
  │ ├── bytes@3.0.0 
  │ ├── content-type@1.0.4 
  │ ├─┬ debug@2.6.9 
  │ │ └── ms@2.0.0 
  │ ├── depd@1.1.1 
  │ ├─┬ http-errors@1.6.2 
  │ │ ├── inherits@2.0.3 
  │ │ └── setprototypeof@1.0.3 
  │ ├── iconv-lite@0.4.19 
  │ ├─┬ on-finished@2.3.0 
  │ │ └── ee-first@1.1.1 
  │ ├── qs@6.5.1 
  │ ├─┬ raw-body@2.3.2 
  │ │ └── unpipe@1.0.0 
  │ └─┬ type-is@1.6.15 
  │   └── media-typer@0.3.0 
  ├── commander@2.11.0 
  ├─┬ express@4.16.1 
  │ ├─┬ accepts@1.3.4 
  │ │ └── negotiator@0.6.1 
  │ ├── array-flatten@1.1.1 
  │ ├── content-disposition@0.5.2 
  │ ├── cookie@0.3.1 
  │ ├── cookie-signature@1.0.6 
  │ ├── encodeurl@1.0.1 
  │ ├── escape-html@1.0.3 
  │ ├── etag@1.8.1 
  │ ├── finalhandler@1.1.0 
  │ ├── fresh@0.5.2 
  │ ├── merge-descriptors@1.0.1 
  │ ├── methods@1.1.2 
  │ ├── parseurl@1.3.2 
  │ ├── path-to-regexp@0.1.7 
  │ ├─┬ proxy-addr@2.0.2 
  │ │ ├── forwarded@0.1.2 
  │ │ └── ipaddr.js@1.5.2 
  │ ├── range-parser@1.2.0 
  │ ├── safe-buffer@5.1.1 
  │ ├─┬ send@0.16.1 
  │ │ ├── destroy@1.0.4 
  │ │ └── mime@1.4.1 
  │ ├── serve-static@1.13.1 
  │ ├── setprototypeof@1.1.0 
  │ ├── statuses@1.3.1 
  │ ├── utils-merge@1.0.1 
  │ └── vary@1.1.2 
  ├─┬ jsonfile@2.4.0 
  │ └── graceful-fs@4.1.11 
  ├─┬ morgan@1.9.0 
  │ ├── basic-auth@2.0.0 
  │ └── on-headers@1.0.1 
  ├── open@0.0.5 
  ├─┬ request@2.83.0 
  │ ├── aws-sign2@0.7.0 
  │ ├── aws4@1.6.0 
  │ ├── caseless@0.12.0 
  │ ├─┬ combined-stream@1.0.5 
  │ │ └── delayed-stream@1.0.0 
  │ ├── extend@3.0.1 
  │ ├── forever-agent@0.6.1 
  │ ├─┬ form-data@2.3.1 
  │ │ └── asynckit@0.4.0 
  │ ├─┬ har-validator@5.0.3 
  │ │ ├─┬ ajv@5.2.3 
  │ │ │ ├── co@4.6.0 
  │ │ │ ├── fast-deep-equal@1.0.0 
  │ │ │ ├── json-schema-traverse@0.3.1 
  │ │ │ └─┬ json-stable-stringify@1.0.1 
  │ │ │   └── jsonify@0.0.0 
  │ │ └── har-schema@2.0.0 
  │ ├─┬ hawk@6.0.2 
  │ │ ├── boom@4.3.1 
  │ │ ├─┬ cryptiles@3.1.2 
  │ │ │ └── boom@5.2.0 
  │ │ ├── hoek@4.2.0 
  │ │ └── sntp@2.0.2 
  │ ├─┬ http-signature@1.2.0 
  │ │ ├── assert-plus@1.0.0 
  │ │ ├─┬ jsprim@1.4.1 
  │ │ │ ├── extsprintf@1.3.0 
  │ │ │ ├── json-schema@0.2.3 
  │ │ │ └─┬ verror@1.10.0 
  │ │ │   └── core-util-is@1.0.2 
  │ │ └─┬ sshpk@1.13.1 
  │ │   ├── asn1@0.2.3 
  │ │   ├── bcrypt-pbkdf@1.0.1 
  │ │   ├── dashdash@1.14.1 
  │ │   ├── ecc-jsbn@0.1.1 
  │ │   ├── getpass@0.1.7 
  │ │   ├── jsbn@0.1.1 
  │ │   └── tweetnacl@0.14.5 
  │ ├── is-typedarray@1.0.0 
  │ ├── isstream@0.1.2 
  │ ├── json-stringify-safe@5.0.1 
  │ ├─┬ mime-types@2.1.17 
  │ │ └── mime-db@1.30.0 
  │ ├── oauth-sign@0.8.2 
  │ ├── performance-now@2.1.0 
  │ ├── stringstream@0.0.5 
  │ ├─┬ tough-cookie@2.3.3 
  │ │ └── punycode@1.4.1 
  │ ├── tunnel-agent@0.6.0 
  │ └── uuid@3.1.0 
  └─┬ tinyproxy@0.1.9 
    ├─┬ socks5-client@1.2.5 
    │ └─┬ ip-address@5.8.8 
    │   ├── jsbn@0.1.0 
    │   ├── lodash.find@4.6.0 
    │   ├── lodash.max@4.0.1 
    │   ├── lodash.merge@4.6.0 
    │   ├── lodash.padstart@4.6.1 
    │   ├── lodash.repeat@4.1.0 
    │   ├── sprintf-js@1.1.1 
    │   └── util-deprecate@1.0.2 
    ├─┬ socks5-http-client@1.0.2 
    │ └─┬ socks5-client@1.1.2 
    │   └─┬ ip-address@4.2.0 
    │     ├─┬ cli@0.6.6 
    │     │ ├── exit@0.1.2 
    │     │ └─┬ glob@3.2.11 
    │     │   └─┬ minimatch@0.3.0 
    │     │     ├── lru-cache@2.7.3 
    │     │     └── sigmund@1.0.1 
    │     ├─┬ cliff@0.1.10 
    │     │ ├── colors@1.0.3 
    │     │ ├── eyes@0.1.8 
    │     │ └─┬ winston@0.8.3 
    │     │   ├── async@0.2.10 
    │     │   ├── colors@0.6.2 
    │     │   ├── cycle@1.0.3 
    │     │   ├── pkginfo@0.3.1 
    │     │   └── stack-trace@0.0.10 
    │     ├── jsbn@0.0.0 
    │     ├─┬ lodash.find@3.2.1 
    │     │ ├─┬ lodash._basecallback@3.3.1 
    │     │ │ ├── lodash._baseisequal@3.0.7 
    │     │ │ ├── lodash._bindcallback@3.0.1 
    │     │ │ └── lodash.pairs@3.0.1 
    │     │ ├── lodash._baseeach@3.0.4 
    │     │ ├── lodash._basefind@3.0.0 
    │     │ ├── lodash._basefindindex@3.6.0 
    │     │ ├── lodash.isarray@3.0.4 
    │     │ └── lodash.keys@3.1.2 
    │     ├─┬ lodash.merge@3.3.2 
    │     │ ├── lodash._arraycopy@3.0.0 
    │     │ ├── lodash._arrayeach@3.0.0 
    │     │ ├─┬ lodash._createassigner@3.1.1 
    │     │ │ ├── lodash._isiterateecall@3.0.9 
    │     │ │ └── lodash.restparam@3.6.1 
    │     │ ├── lodash._getnative@3.9.1 
    │     │ ├── lodash.isarguments@3.1.0 
    │     │ ├─┬ lodash.isplainobject@3.2.0 
    │     │ │ └── lodash._basefor@3.0.3 
    │     │ ├── lodash.istypedarray@3.0.6 
    │     │ ├── lodash.keysin@3.0.8 
    │     │ └─┬ lodash.toplainobject@3.0.0 
    │     │   └── lodash._basecopy@3.0.1 
    │     └── sprintf@0.1.5 
    └── socks5-https-client@1.2.1 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/tinymocker/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0436 took 5.1819s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected character '#' (1:78) on program #!/usr/bin/env node
'use strict';
const cluster = require('cluster');
const jsonfile = require('jsonfile');
const path = require('path');
const mockDataFile = path.resolve(__dirname, 'mockData.json');
const program = require('commander');

program
    .option('-u, --uiport <uiport>', 'set port of control panel')
    .option('-p, --proxyport <proxyport>', 'set port of proxy server')
    .parse(process.argv);

let uiPort = program.uiport || 9998;
let proxyPort = program.proxyport || 9999;

if(cluster.isMaster) {

    let proxy = cluster.fork();

    cluster.on('exit', (worker, code, signal) => {
        if(signal == 'SIGKILL') {
            console.log(`EXITED. SIGNAL: ${signal}`);
        }else{
            console.log(`EXITED. SIGNAL: ${signal}; CODE: ${code}`);
            proxy = cluster.fork();
        }
    });

    const express = require('express');
    const app = express();
    const logger = require('morgan');
    const bodyParser = require('body-parser');
    const open = require('open');

    app.use(express.static(__dirname + '/views/dist'));
    app.use(logger('dev'));
    app.use(bodyParser.json()); 
    app.use(bodyParser.urlencoded({ extended: true }));

    app.get('/', (req, res) => {
        res.sendFile(__dirname + '/pages/index.html');
    });

    app.get('/mockData', (req, res) => {
        res.json(jsonfile.readFileSync(mockDataFile));
    });

    app.post('/addMockData', (req, res) => {
        let tempNewMock = req.body;
        delete tempNewMock.headersStr;
        let tempMockData = jsonfile.readFileSync(mockDataFile);
        tempMockData.unshift(tempNewMock);
        jsonfile.writeFileSync(mockDataFile, tempMockData, {spaces: 4});
        try {
            res.json({
                result: 1,
                mockData: tempMockData
            });
            setTimeout(() => {
                proxy.process.kill('SIGKILL');
                proxy = cluster.fork();
            },300);
        }catch(e) {
            res.json({
                result: 0,
                error: e
            });
        }
    });

    app.post('/editMockData', (req, res) => {
        let tempNewMock = req.body;
        delete tempNewMock.headersStr;
        let tempMockData = jsonfile.readFileSync(mockDataFile);
        let target = tempMockData.findIndex((e) => {
            return e.urlReg == tempNewMock.urlReg;
        });
        if(target != -1) {
            tempMockData.splice(target, 1, tempNewMock);
            jsonfile.writeFileSync(mockDataFile, tempMockData, {spaces: 4});

            res.json({
                result: 1,
                mockData: tempMockData
            });
            setTimeout(() => {
                proxy.process.kill('SIGKILL');
                proxy = cluster.fork();
            },300);
        }else {
            res.json({
                result: 0,
                error: '无匹配项'
            });
        }
    });

    app.post('/delMockData', (req, res) => {
        let tempUrlReg = req.body.urlReg;
        let tempMockData = jsonfile.readFileSync(mockDataFile);
        let target = tempMockData.findIndex((e) => {
            return e.urlReg == tempUrlReg;
        });
        if(target != -1) {
            tempMockData.splice(target, 1);
            jsonfile.writeFileSync(mockDataFile, tempMockData, {spaces: 4});

            res.json({
                result: 1,
                mockData: tempMockData
            });
            setTimeout(() => {
                proxy.process.kill('SIGKILL');
                proxy = cluster.fork();
            },300);
        }else {
            res.json({
                result: 0,
                error: '无匹配项'
            });
        }
    });

    app.post('/enableMockData', (req, res) => {
        let tempUrlReg = req.body.urlReg;
        let tempMockData = jsonfile.readFileSync(mockDataFile);
        let target = tempMockData.findIndex((e) => {
            return e.urlReg == tempUrlReg;
        });
        if(target != -1) {
            tempMockData[target].enabled = true;
            jsonfile.writeFileSync(mockDataFile, tempMockData, {spaces: 4});

            res.json({
                result: 1,
                mockData: tempMockData
            });
            setTimeout(() => {
                proxy.process.kill('SIGKILL');
                proxy = cluster.fork();
            },300);
        }else {
            res.json({
                result: 0,
                error: '无匹配项'
            });
        }
    });

    app.post('/disableMockData', (req, res) => {
        let tempUrlReg = req.body.urlReg;
        let tempMockData = jsonfile.readFileSync(mockDataFile);
        let target = tempMockData.findIndex((e) => {
            return e.urlReg == tempUrlReg;
        });
        if(target != -1) {
            tempMockData[target].enabled = false;
            jsonfile.writeFileSync(mockDataFile, tempMockData, {spaces: 4});

            res.json({
                result: 1,
                mockData: tempMockData
            });
            setTimeout(() => {
                proxy.process.kill('SIGKILL');
                proxy = cluster.fork();
            },300);
        }else {
            res.json({
                result: 0,
                error: '无匹配项'
            });
        }
    });

    app.listen(uiPort, () => {
        console.log(`配置平台运行于 localhost:${uiPort}。`);
    });
    open(`http://localhost:${uiPort}`);

}else {

    const tinyProxy = require('tinyproxy');
    const request = require('request');
    const url = require('url');
    let mockData = jsonfile.readFileSync(mockDataFile);

    let mock = (req, res, requestOptions) => {
        let localhostReg = new RegExp(`(localhost|127\.0\.0\.1):${uiPort}`);
        let result = {};
        let flag = mockData.some((e) => {
            let urlReg = new RegExp(e.urlReg);
            if(e.enabled && urlReg.test(req.url) && !localhostReg.test(req.url)) {
                result.headers = e.headers;
                result.statusCode = e.statusCode;
                if(e.jsonp) {
                    let parsedUrl,callbackStr;
                    try {
                        parsedUrl = url.parse(req.url, true);
                        callbackStr = parsedUrl.query.callback;
                        result.body = `${callbackStr}(${e.body})`;
                    }catch(error) {
                        console.log('jsonpReg Error: ' + error);
                        result.body = e.body;
                    }
                }else {
                    result.body = e.body;
                }
            }
            return e.enabled && urlReg.test(req.url) && !localhostReg.test(req.url);
        });
        if(flag) {
            console.log(`MOCK ${req.method}: ${req.url}`);
            res.writeHead(result.statusCode, '', result.headers);
            res.end(result.body);
        }else {
            request(requestOptions, (error, response, body) => {
                try {
                    res.writeHead(response.statusCode, '', response.headers);
                    res.end(body);
                }catch(e) {
                    console.log(e);
                }
            });
        }
    };

    let proxy = new tinyProxy({
        port: proxyPort,
        agent: 'http',
        mock: mock
    });
    proxy.start();
    console.log(`MOCK服务器运行于 localhost:${proxyPort}。`);
} at SyntaxError: Unexpected character '#' (1:78)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$7.getTokenFromCode (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2756:10)
    at Parser.pp$7.readToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2477:17)
    at Parser.readToken (/root/ExpoSE/lib/Tropigate/bin/Tokens.js:124:26)
    at Parser.pp$7.nextToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2468:15)
    at Parser.pp$7.next (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2413:10)
    at Parser.pp.eat (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:536:12)
    at Parser.pp.semicolon (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:581:15)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:918:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
