
> dbus@0.2.23 install /root/Targets/upnpserver/node_modules/dbus
> node-gyp configure build

/root/Targets/upnpserver
└─┬ upnpserver@3.0.2 
  ├─┬ async@2.5.0 
  │ └── lodash@4.17.4 
  ├─┬ debug@3.1.0 
  │ └── ms@2.0.0 
  ├─┬ exif@0.6.0 
  │ └── debug@2.6.9 
  ├─┬ follow-redirects@0.0.3 
  │ └── underscore@1.8.3 
  ├─┬ gm@1.23.0 
  │ ├── array-parallel@0.1.3 
  │ ├── array-series@0.1.5 
  │ ├─┬ cross-spawn@4.0.2 
  │ │ ├─┬ lru-cache@4.1.1 
  │ │ │ ├── pseudomap@1.0.2 
  │ │ │ └── yallist@2.1.2 
  │ │ └─┬ which@1.3.0 
  │ │   └── isexe@2.0.0 
  │ └─┬ debug@2.2.0 
  │   └── ms@0.7.1 
  ├── ip@0.3.3 
  ├── jstoxml@0.2.4 
  ├─┬ matroska@2.2.2 
  │ ├── async@1.0.0 
  │ ├── crc@3.2.1 
  │ ├─┬ dateformat@1.0.11 
  │ │ ├── get-stdin@5.0.1 
  │ │ └─┬ meow@3.7.0 
  │ │   ├─┬ camelcase-keys@2.1.0 
  │ │   │ └── camelcase@2.1.1 
  │ │   ├── decamelize@1.2.0 
  │ │   ├─┬ loud-rejection@1.6.0 
  │ │   │ ├─┬ currently-unhandled@0.4.1 
  │ │   │ │ └── array-find-index@1.0.2 
  │ │   │ └── signal-exit@3.0.2 
  │ │   ├── map-obj@1.0.1 
  │ │   ├── minimist@1.2.0 
  │ │   ├─┬ normalize-package-data@2.4.0 
  │ │   │ ├── hosted-git-info@2.5.0 
  │ │   │ ├─┬ is-builtin-module@1.0.0 
  │ │   │ │ └── builtin-modules@1.1.1 
  │ │   │ └─┬ validate-npm-package-license@3.0.1 
  │ │   │   ├─┬ spdx-correct@1.0.2 
  │ │   │   │ └── spdx-license-ids@1.2.2 
  │ │   │   └── spdx-expression-parse@1.0.4 
  │ │   ├── object-assign@4.1.1 
  │ │   ├─┬ read-pkg-up@1.0.1 
  │ │   │ ├─┬ find-up@1.1.2 
  │ │   │ │ ├── path-exists@2.1.0 
  │ │   │ │ └─┬ pinkie-promise@2.0.1 
  │ │   │ │   └── pinkie@2.0.4 
  │ │   │ └─┬ read-pkg@1.1.0 
  │ │   │   ├─┬ load-json-file@1.1.0 
  │ │   │   │ ├── graceful-fs@4.1.11 
  │ │   │   │ ├─┬ parse-json@2.2.0 
  │ │   │   │ │ └─┬ error-ex@1.3.1 
  │ │   │   │ │   └── is-arrayish@0.2.1 
  │ │   │   │ ├── pify@2.3.0 
  │ │   │   │ └─┬ strip-bom@2.0.0 
  │ │   │   │   └── is-utf8@0.2.1 
  │ │   │   └── path-type@1.1.0 
  │ │   ├─┬ redent@1.0.0 
  │ │   │ ├─┬ indent-string@2.1.0 
  │ │   │ │ └─┬ repeating@2.0.1 
  │ │   │ │   └─┬ is-finite@1.0.2 
  │ │   │ │     └── number-is-nan@1.0.1 
  │ │   │ └─┬ strip-indent@1.0.1 
  │ │   │   └── get-stdin@4.0.1 
  │ │   └── trim-newlines@1.0.0 
  │ ├── debug@0.7.4 
  │ └── mime@1.3.6 
  ├── mime@1.2.11 
  ├─┬ mkdirp@0.5.1 
  │ └── minimist@0.0.8 
  ├─┬ mongodb@2.2.31 
  │ ├── es6-promise@3.2.1 
  │ ├─┬ mongodb-core@2.1.15 
  │ │ ├── bson@1.0.4 
  │ │ └─┬ require_optional@1.0.1 
  │ │   ├── resolve-from@2.0.0 
  │ │   └── semver@5.4.1 
  │ └─┬ readable-stream@2.2.7 
  │   ├── buffer-shims@1.0.0 
  │   ├── core-util-is@1.0.2 
  │   ├── inherits@2.0.3 
  │   ├── isarray@1.0.0 
  │   ├── process-nextick-args@1.0.7 
  │   ├── string_decoder@1.0.3 
  │   └── util-deprecate@1.0.2 
  ├─┬ moviedb@0.2.10 
  │ └─┬ superagent@2.3.0 
  │   ├── component-emitter@1.2.1 
  │   ├── cookiejar@2.1.1 
  │   ├── debug@2.6.9 
  │   ├─┬ form-data@1.0.0-rc4 
  │   │ └── async@1.5.2 
  │   ├── formidable@1.1.1 
  │   ├── methods@1.1.2 
  │   └── mime@1.4.1 
  ├─┬ musicmetadata@2.0.5 
  │ ├── deep-equal@0.2.1 
  │ ├─┬ filereader-stream@0.2.0 
  │ │ └── inherits@1.0.0 
  │ ├── is-stream@1.1.0 
  │ ├── strtok2@1.0.4 
  │ └── through@2.3.8 
  ├─┬ nedb@1.8.0 
  │ ├── async@0.2.10 
  │ ├─┬ binary-search-tree@0.2.5 
  │ │ └── underscore@1.4.4 
  │ ├─┬ localforage@1.5.0 
  │ │ └─┬ lie@3.0.2 
  │ │   ├─┬ es3ify@0.1.4 
  │ │   │ ├── esprima-fb@3001.1.0-dev-harmony-fb 
  │ │   │ └─┬ jstransform@3.0.0 
  │ │   │   ├── base62@0.1.1 
  │ │   │   └─┬ source-map@0.1.31 
  │ │   │     └── amdefine@1.0.1 
  │ │   ├── immediate@3.0.6 
  │ │   ├─┬ inline-process-browser@1.0.0 
  │ │   │ ├─┬ falafel@1.2.0 
  │ │   │ │ ├── acorn@1.2.2 
  │ │   │ │ ├── foreach@2.0.5 
  │ │   │ │ ├── isarray@0.0.1 
  │ │   │ │ └── object-keys@1.0.11 
  │ │   │ └─┬ through2@0.6.5 
  │ │   │   ├─┬ readable-stream@1.0.34 
  │ │   │   │ ├── isarray@0.0.1 
  │ │   │   │ └── string_decoder@0.10.31 
  │ │   │   └── xtend@4.0.1 
  │ │   └─┬ unreachable-branch-transform@0.3.0 
  │ │     ├── esmangle-evaluator@1.0.1 
  │ │     └─┬ recast@0.10.43 
  │ │       ├── ast-types@0.8.15 
  │ │       ├── esprima-fb@15001.1001.0-dev-harmony-fb 
  │ │       ├── private@0.1.7 
  │ │       └── source-map@0.5.7 
  │ └── underscore@1.4.4 
  ├─┬ node-ssdp@2.9.1 
  │ ├── debug@2.6.9 
  │ └── ip@1.1.5 
  ├─┬ omdb-client@1.0.6 
  │ └── json-http@1.0.2 
  ├── range-parser@1.2.0 
  ├─┬ request@2.83.0 
  │ ├── aws-sign2@0.7.0 
  │ ├── aws4@1.6.0 
  │ ├── caseless@0.12.0 
  │ ├─┬ combined-stream@1.0.5 
  │ │ └── delayed-stream@1.0.0 
  │ ├── extend@3.0.1 
  │ ├── forever-agent@0.6.1 
  │ ├─┬ form-data@2.3.1 
  │ │ └── asynckit@0.4.0 
  │ ├─┬ har-validator@5.0.3 
  │ │ ├─┬ ajv@5.2.3 
  │ │ │ ├── co@4.6.0 
  │ │ │ ├── fast-deep-equal@1.0.0 
  │ │ │ ├── json-schema-traverse@0.3.1 
  │ │ │ └─┬ json-stable-stringify@1.0.1 
  │ │ │   └── jsonify@0.0.0 
  │ │ └── har-schema@2.0.0 
  │ ├─┬ hawk@6.0.2 
  │ │ ├── boom@4.3.1 
  │ │ ├─┬ cryptiles@3.1.2 
  │ │ │ └── boom@5.2.0 
  │ │ ├── hoek@4.2.0 
  │ │ └── sntp@2.0.2 
  │ ├─┬ http-signature@1.2.0 
  │ │ ├── assert-plus@1.0.0 
  │ │ ├─┬ jsprim@1.4.1 
  │ │ │ ├── extsprintf@1.3.0 
  │ │ │ ├── json-schema@0.2.3 
  │ │ │ └── verror@1.10.0 
  │ │ └─┬ sshpk@1.13.1 
  │ │   ├── asn1@0.2.3 
  │ │   ├── bcrypt-pbkdf@1.0.1 
  │ │   ├── dashdash@1.14.1 
  │ │   ├── ecc-jsbn@0.1.1 
  │ │   ├── getpass@0.1.7 
  │ │   ├── jsbn@0.1.1 
  │ │   └── tweetnacl@0.14.5 
  │ ├── is-typedarray@1.0.0 
  │ ├── isstream@0.1.2 
  │ ├── json-stringify-safe@5.0.1 
  │ ├─┬ mime-types@2.1.17 
  │ │ └── mime-db@1.30.0 
  │ ├── oauth-sign@0.8.2 
  │ ├── performance-now@2.1.0 
  │ ├── qs@6.5.1 
  │ ├── safe-buffer@5.1.1 
  │ ├── stringstream@0.0.5 
  │ ├─┬ tough-cookie@2.3.3 
  │ │ └── punycode@1.4.1 
  │ └── tunnel-agent@0.6.0 
  ├── sax@0.4.2 
  ├─┬ send@0.13.2 
  │ ├── debug@2.2.0 
  │ ├── depd@1.1.1 
  │ ├── destroy@1.0.4 
  │ ├── escape-html@1.0.3 
  │ ├── etag@1.7.0 
  │ ├── fresh@0.3.0 
  │ ├── http-errors@1.3.1 
  │ ├── mime@1.3.4 
  │ ├── ms@0.7.1 
  │ ├─┬ on-finished@2.3.0 
  │ │ └── ee-first@1.1.1 
  │ ├── range-parser@1.0.3 
  │ └── statuses@1.2.1 
  ├─┬ status@0.0.13 
  │ ├─┬ argus@0.0.3 
  │ │ └── pegjs@0.7.0 
  │ ├── async@0.9.2 
  │ ├── coffee-script@1.12.7 
  │ ├─┬ commander@1.3.2 
  │ │ └── keypress@0.1.0 
  │ ├─┬ fractal@0.0.3 
  │ │ └─┬ xemplar@0.0.8 
  │ │   └── BetterRegExp@0.0.2 
  │ ├─┬ loggo@0.0.4 
  │ │ └── colors@1.1.2 
  │ └── semver@4.3.6 
  └── uuid@3.1.0 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/upnpserver/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0641 took 3.9876s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (4:6) on program /*jslint node: true, nomen: true, esversion: 6 */
"use strict";

const assert = require('assert');
const events = require('events');
const http = require('http');
const ip = require('ip');
const SSDP = require('node-ssdp');
const url = require('url');
const util = require('util');

const debug = require('debug')('upnpserver:api');
const logger = require('./lib/logger');

const UPNPServer = require('./lib/upnpServer');
const Repository = require('./lib/repositories/repository');

class API extends events.EventEmitter {

	/**
	 * upnpserver API.
	 *
	 * @param {object}
	 *          configuration
	 * @param {array}
	 *          paths
	 *
	 * @constructor
	 */
	constructor(configuration, paths) {
		super();

		this.configuration = Object.assign({}, this.defaultConfiguration, configuration);
		this.repositories = [];
		this._upnpClasses = {};
		this._contentHandlers = [];
		this._contentProviders = {};
		this._contentHandlersKey = 0;

		if (typeof (paths) === "string") {
			this.addDirectory("/", paths);

		} else if (util.isArray(paths)) {
			paths.forEach((path) => this.initPaths(path));
		}

		if (this.configuration.noDefaultConfig !== true) {
			this.loadConfiguration("./default-config.json");
		}

		var cf = this.configuration.configurationFiles;
		if (typeof (cf) === "string") {
			var toks = cf.split(',');
			toks.forEach((tok) => this.loadConfiguration(tok));

		} else if (util.isArray(cf)) {
			cf.forEach((c) => this.loadConfiguration(c));
		}
	}

	/**
	 * Default server configuration.
	 *
	 * @type {object}
	 */
	get defaultConfiguration() {
		return {
			"dlnaSupport": true,
			"httpPort": 10293,
			"name": "Node Server",
			"version": require("./package.json").version
		};
	}

	/**
	 * Initialize paths.
	 *
	 * @param {string|object}
	 *          path
	 * @returns {Repository} the created repository
	 */
	initPaths(path) {
		if (typeof (path) === "string") {
			return this.addDirectory("/", path);
		}
		if (typeof(path) === "object") {
			if (path.type === "video") {
				path.type = "movie";
			}

			return this.declareRepository(path);
		}

		throw new Error("Invalid path '" + util.inspect(path) + "'");
	}

	/**
	 * Declare a repository
	 *
	 * @param {object}
	 *          the configuration
	 * @returns {Repository} the new repository
	 */
	declareRepository(configuration) {
		var config = Object.assign({}, configuration);

		var mountPath = config.mountPoint || config.mountPath || "/";

		var type = config.type;
		if (!type) {
			logger.error("Type is not specified, assume it is a 'directory' type");
			type = "directory";
		}

		var requirePath = configuration.require;
		if (!requirePath) {
			requirePath = "./lib/repositories/" + type;
		}

		debug("declareRepository", "requirePath=", requirePath, "mountPath=", mountPath, "config=", config);

		var clazz = require(requirePath);
		if (!clazz) {
			logger.error("Class of repository must be specified");
			return;
		}

		var repository = new clazz(mountPath, config);

		return this.addRepository(repository);
	}

	/**
	 * Add a repository.
	 *
	 * @param {Repository}
	 *          repository
	 *
	 * @returns {Repository} a Repository object
	 */
	addRepository(repository) {
		assert(repository instanceof Repository, "Invalid repository parameter '" + repository + "'");

		this.repositories.push(repository);

		return repository;
	}

	/**
	 * Add simple directory.
	 *
	 * @param {string}
	 *          mountPath
	 * @param {string}
	 *          path
	 *
	 * @returns {Repository} a Repository object
	 */
	addDirectory(mountPath, path, configuration) {
		assert.equal(typeof (mountPath), "string", "Invalid mountPoint parameter '" +
			mountPath + "'");

		assert.equal(typeof (path), "string", "Invalid path parameter '" + path + "'");

		configuration = Object.assign({}, configuration, {mountPath, path, type: "directory"});

		return this.declareRepository(configuration);
	}

	/**
	 * Add music directory.
	 *
	 * @param {string}
	 *          mountPath
	 * @param {string}
	 *          path
	 *
	 * @returns {Repository} a Repository object
	 */
	addMusicDirectory(mountPath, path, configuration) {
		assert.equal(typeof mountPath, "string", "Invalid mountPath parameter '" +
			mountPath + "'");
		assert.equal(typeof path, "string", "Invalid path parameter '" + mountPath + "'");

		configuration = Object.assign({}, configuration, {mountPath, path, type: "music"});

		return this.declareRepository(configuration);
	}

	/**
	 * Add video directory.
	 *
	 * @param {string}
	 *          mountPath
	 * @param {string}
	 *          path
	 *
	 * @returns {Repository} a Repository object
	 */
	addVideoDirectory(mountPath, path, configuration) {
		assert.equal(typeof mountPath, "string", "Invalid mountPoint parameter '" + mountPath + "'");
		assert.equal(typeof path, "string", "Invalid path parameter '" + path + "'");

		configuration = Object.assign({}, configuration, {mountPath, path, type: "movie"});

		return this.declareRepository(configuration);
	}

	/**
	 * Add history directory.
	 *
	 * @param {string}
	 *          mountPath
	 *
	 * @returns {Repository} a Repository object
	 */
	addHistoryDirectory(mountPath, configuration) {
		assert.equal(typeof mountPath, "string", "Invalid mountPoint parameter '" + mountPath + "'");

		configuration = Object.assign({}, configuration, {mountPath, type: "history"});

		return this.declareRepository(configuration);
	}

	/**
	 * Add iceCast.
	 *
	 * @param {string}
	 *          mountPath
	 * @param {object}
	 *          configuration
	 *
	 * @returns {Repository} a Repository object
	 */
	addIceCast(mountPath, configuration) {
		assert.equal(typeof mountPath, "string", "Invalid mountPoint parameter '" +
			mountPath + "'");

		configuration = Object.assign({}, configuration, {mountPath, type: "iceCast"});

		return this.declareRepository(configuration);
	}

	/**
	 * Load a JSON configuration
	 *
	 * @param {string}
	 *          path - The path of the JSON file
	 */
	loadConfiguration(path) {
		var config = require(path);

		var upnpClasses = config.upnpClasses;
		if (upnpClasses) {
			for (var upnpClassName in upnpClasses) {
				var p = upnpClasses[upnpClassName];

				var clazz = require(p);

				this._upnpClasses[upnpClassName] = new clazz();
			}
		}

		var contentHandlers = config.contentHandlers;
		if (contentHandlers instanceof Array) {
			contentHandlers.forEach((contentHandler) => {

				var mimeTypes = contentHandler.mimeTypes || [];

				if (contentHandler.mimeType) {
					mimeTypes = mimeTypes.slice(0);
					mimeTypes.push(contentHandler.mimeType);
				}

				var requirePath = contentHandler.require;
				if (!requirePath) {
					requirePath = "./lib/contentHandlers/" + contentHandler.type;
				}
				if (!requirePath) {
					logger.error("Require path is not defined !");
					return;
				}

				var clazz = require(requirePath);
				if (!clazz) {
					logger.error("Class of contentHandler must be specified");
					return;
				}

				var configuration = contentHandler.configuration || {};

				var ch = new clazz(configuration, mimeTypes);
				ch.priority = contentHandler.priority || 0;
				ch.mimeTypes = mimeTypes;

				this._contentHandlers.push(ch);
			});
		}

		var contentProviders = config.contentProviders;
		if (contentProviders instanceof Array) {
			contentProviders.forEach((contentProvider) => {
				var protocol = contentProvider.protocol;
				if (!protocol) {
					logger.error("Protocol property must be defined for contentProvider " + contentProvider.id + "'.");
					return;
				}
				if (protocol in this._contentProviders) {
					logger.error("Protocol '" + protocol + "' is already known");
					return;
				}

				var name = contentProvider.name || protocol;

				var requirePath = contentProvider.require;
				if (!requirePath) {
					var type = contentProvider.type || protocol;

					requirePath = "./lib/contentProviders/" + type;
				}
				if (!requirePath) {
					logger.error("Require path is not defined !");
					return;
				}

				var clazz = require(requirePath);
				if (!clazz) {
					logger.error("Class of contentHandler must be specified");
					return;
				}

				var configuration = Object.assign({}, contentProvider);

				var ch = new clazz(configuration, protocol);
				ch.protocol = protocol;
				ch.name = name;

				this._contentProviders[protocol] = ch;
			});
		}

		var repositories = config.repositories;
		if (repositories) {
			repositories.forEach((configuration) => this.declareRepository(configuration));
		}
	}

	/**
	 * Start server.
	 */
	start() {
		this.stop(() => {
			this.startServer();
		});
	}

	/**
	 * Start server callback.
	 *
	 * @return {UPNPServer}
	 */
	startServer(callback) {
		callback = callback || (() => {
			});

		debug("startServer", "Start the server");

		if (!this.repositories.length) {
			return callback(new Error("No directories defined !"));
		}

		var configuration = this.configuration;
		configuration.repositories = this.repositories;
		configuration.upnpClasses = this._upnpClasses;
		configuration.contentHandlers = this._contentHandlers;
		configuration.contentProviders = this._contentProviders;

		if (!callback) {
			callback = (error) => {
				if (error) {
					logger.error(error);
				}
			};
		}

		var upnpServer = new UPNPServer(configuration.httpPort, configuration, (error, upnpServer) => {
			if (error) {
				logger.error("Can not start UPNPServer", error);

				return callback(error);
			}

			debug("startServer", "Server started ...");

			this._upnpServerStarted(upnpServer, callback);
		});

		return upnpServer;
	}

	/**
	 * After the server start.
	 *
	 * @param {object}
	 *          upnpServer
	 */
	_upnpServerStarted(upnpServer, callback) {

		this.emit("starting");

		this.upnpServer = upnpServer;

		var locationURL = 'http://' + ip.address() + ':' + this.configuration.httpPort + "/description.xml";

		var config = {
			udn: this.upnpServer.uuid,
			description: "/description.xml",
			location: locationURL,
			ssdpSig: "Node/" + process.versions.node + " UPnP/1.0 " + "UPnPServer/" +
			require("./package.json").version
		};

		debug("_upnpServerStarted", "New SSDP server config=", config);

		var ssdpServer = new SSDP.Server(config);
		this.ssdpServer = ssdpServer;

		ssdpServer.addUSN('upnp:rootdevice');
		ssdpServer.addUSN(upnpServer.type);

		var services = upnpServer.services;
		if (services) {
			for (var route in services) {
				ssdpServer.addUSN(services[route].type);
			}
		}

		debug("_upnpServerStarted", "New Http server port=", upnpServer.port);

		var httpServer = http.createServer();
		this.httpServer = httpServer;

		httpServer.on('request', this._processRequest.bind(this));

		httpServer.listen(upnpServer.port, (error) => {
			if (error) {
				return callback(error);
			}

			this.ssdpServer.start();

			this.emit("waiting");

			var address = httpServer.address();

			debug("_upnpServerStarted", "Http server is listening on address=", address);

			var hostname = address.address;
			if (address.family === 'IPv6') {
				hostname = '[' + hostname + ']';
			}

			console.log('Ready http://' + hostname + ':' + address.port);

			callback();
		});
	}

	/**
	 * Process request
	 *
	 * @param {object}
	 *          request
	 * @param {object}
	 *          response
	 */
	_processRequest(request, response) {

		var path = url.parse(request.url).pathname;

		// logger.debug("Uri=" + request.url);

		var now = Date.now();
		try {
			this.upnpServer.processRequest(request, response, path, (error, processed) => {

				var stats = {
					request: request,
					response: response,
					path: path,
					processTime: Date.now() - now,
				};

				if (error) {
					response.writeHead(500, 'Server error: ' + error);
					response.end();

					this.emit("code:500", error, stats);
					return;
				}

				if (!processed) {
					response.writeHead(404, 'Resource not found: ' + path);
					response.end();

					this.emit("code:404", stats);
					return;
				}

				this.emit("code:200", stats);
			});

		} catch (error) {
			logger.error("Process request exception", error);
			this.emit("error", error);
		}
	}

	/**
	 * Stop server.
	 *
	 * @param {function|undefined}
	 *          callback
	 */
	stop(callback) {
		debug("stop", "Stopping ...");

		callback = callback || (() => {
				return false;
			});

		var httpServer = this.httpServer;
		var ssdpServer = this.ssdpServer;
		var stopped = false;

		if (this.ssdpServer) {
			this.ssdpServer = undefined;
			stopped = true;

			try {
				debug("stop", "Stop ssdp server ...");

				ssdpServer.stop();

			} catch (error) {
				logger.error(error);
			}
		}

		if (httpServer) {
			this.httpServer = undefined;
			stopped = true;

			try {
				debug("stop", "Stop http server ...");

				httpServer.close();

			} catch (error) {
				logger.error(error);
			}
		}

		debug("stop", "Stopped");

		if (stopped) {
			this.emit("stopped");
		}

		callback(null, stopped);
	}
}

module.exports = API;
 at SyntaxError: Unexpected token (4:6)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
