/root/Targets/textlint-plugin-review
└─┬ textlint-plugin-review@0.3.3 
  ├── textlint-ast-test@1.1.4 
  └── txt-ast-traverse@1.2.1 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/textlint-plugin-review/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 32% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","defineProperties"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0076 took 1.1297s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (15:4) on program // LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.isTxtAST = isTxtAST;
exports.test = test;

var _unistTest = require("./unist-test");

var assert = require("assert");
function isTxtAST(node) {
    try {
        test(node);
    } catch (error) {
        return false;
    }
    return true;
}
function test(node) {
    // test unist that is weak.
    (0, _unistTest.test)(node);
    assert.equal(typeof node === "undefined" ? "undefined" : _typeof(node), 'object');
    assert.equal(_typeof(node.type), 'string');
    assert.ok(node.type.length >= 1);

    assert.doesNotThrow(function () {
        JSON.parse(JSON.stringify(node));
    });

    // children
    if (node.children !== null && node.children !== undefined) {
        assert.ok(Array.isArray(node.children));
        node.children.forEach(test);
    }

    // value
    if (node.value !== null && node.value !== undefined) {
        assert.equal(_typeof(node.value), 'string');
    }
    // raw
    assert(node.raw !== null && node.raw !== undefined);
    assert.equal(_typeof(node.raw), 'string');
    // loc
    var loc = node.loc;
    assert(loc !== null && loc !== undefined);
    assert.equal(typeof loc === "undefined" ? "undefined" : _typeof(loc), 'object');
    var start = loc.start;
    var end = loc.end;
    if (start !== null && start !== undefined) {
        assert.equal(typeof start === "undefined" ? "undefined" : _typeof(start), 'object');

        if (start.line !== null && start.line !== undefined) {
            assert.equal(_typeof(start.line), 'number');
            assert.ok(start.line >= 0); // allow `0` for `null`.
        }

        if (start.column !== null && start.column !== undefined) {
            assert.equal(_typeof(start.column), 'number');
            assert.ok(start.column >= 0); // allow `0` for `null`.
        }

        if (start.offset !== null && start.offset !== undefined) {
            assert.equal(_typeof(start.offset), 'number');
            assert.ok(start.offset >= 0);
        }
    }

    if (end !== null && end !== undefined) {
        assert.equal(typeof end === "undefined" ? "undefined" : _typeof(end), 'object');

        if (end.line !== null && end.line !== undefined) {
            assert.equal(_typeof(end.line), 'number');
            assert.ok(end.line >= 0); // allow `0` for `null`.
        }

        if (end.column !== null && end.column !== undefined) {
            assert.equal(_typeof(end.column), 'number');
            assert.ok(end.column >= 0); // allow `0` for `null`.
        }

        if (end.offset !== null && end.offset !== undefined) {
            assert.equal(_typeof(end.offset), 'number');
            assert.ok(end.offset >= 0);
        }
    }
    // range
    var range = node.range;
    assert(range !== null && range !== undefined);
    assert.ok(Array.isArray(range));
    range.forEach(function (index) {
        assert.equal(typeof index === "undefined" ? "undefined" : _typeof(index), 'number');
        assert.ok(index >= 0);
    });
    assert(range[0] <= range[1]);
}
//# sourceMappingURL=textlint-ast-test.js.map at SyntaxError: Unexpected token (15:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/textlint-plugin-review/node_modules/textlint-plugin-review/lib/index.js. Coverage (Term): 43% Coverage (LOC): 70%
*- File /root/Targets/textlint-plugin-review/node_modules/textlint-plugin-review/lib/ReVIEWProcessor.js. Coverage (Term): 17% Coverage (LOC): 21%
*- File /root/Targets/textlint-plugin-review/node_modules/textlint-plugin-review/lib/review-to-ast.js. Coverage (Term): 19% Coverage (LOC): 21%
*- File /root/Targets/textlint-plugin-review/node_modules/txt-ast-traverse/lib/txt-ast-traverse.js. Coverage (Term): 21% Coverage (LOC): 38%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
