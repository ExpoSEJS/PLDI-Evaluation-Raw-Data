
> picture-wall@1.0.5 install /root/Targets/picture-wall/node_modules/picture-wall
> mkdir -p upload/picture/resized

/root/Targets/picture-wall
├── UNMET PEER DEPENDENCY images@^3.0.0
├── UNMET PEER DEPENDENCY lwip@0.0.9
├─┬ picture-wall@1.0.5 
│ ├── basic-auth@1.1.0 
│ ├─┬ body-parser@1.18.2 
│ │ ├── bytes@3.0.0 
│ │ ├── content-type@1.0.4 
│ │ ├─┬ debug@2.6.9 
│ │ │ └── ms@2.0.0 
│ │ ├── depd@1.1.1 
│ │ ├─┬ http-errors@1.6.2 
│ │ │ ├── inherits@2.0.3 
│ │ │ └── setprototypeof@1.0.3 
│ │ ├── iconv-lite@0.4.19 
│ │ ├─┬ on-finished@2.3.0 
│ │ │ └── ee-first@1.1.1 
│ │ ├── qs@6.5.1 
│ │ ├─┬ raw-body@2.3.2 
│ │ │ └── unpipe@1.0.0 
│ │ └─┬ type-is@1.6.15 
│ │   ├── media-typer@0.3.0 
│ │   └─┬ mime-types@2.1.17 
│ │     └── mime-db@1.30.0 
│ ├─┬ express@4.16.1 
│ │ ├─┬ accepts@1.3.4 
│ │ │ └── negotiator@0.6.1 
│ │ ├── array-flatten@1.1.1 
│ │ ├── content-disposition@0.5.2 
│ │ ├── cookie@0.3.1 
│ │ ├── cookie-signature@1.0.6 
│ │ ├── encodeurl@1.0.1 
│ │ ├── escape-html@1.0.3 
│ │ ├── etag@1.8.1 
│ │ ├── finalhandler@1.1.0 
│ │ ├── fresh@0.5.2 
│ │ ├── merge-descriptors@1.0.1 
│ │ ├── methods@1.1.2 
│ │ ├── parseurl@1.3.2 
│ │ ├── path-to-regexp@0.1.7 
│ │ ├─┬ proxy-addr@2.0.2 
│ │ │ ├── forwarded@0.1.2 
│ │ │ └── ipaddr.js@1.5.2 
│ │ ├── range-parser@1.2.0 
│ │ ├── safe-buffer@5.1.1 
│ │ ├─┬ send@0.16.1 
│ │ │ ├── destroy@1.0.4 
│ │ │ └── mime@1.4.1 
│ │ ├── serve-static@1.13.1 
│ │ ├── setprototypeof@1.1.0 
│ │ ├── statuses@1.3.1 
│ │ ├── utils-merge@1.0.1 
│ │ └── vary@1.1.2 
│ └─┬ multer@1.3.0 
│   ├── append-field@0.1.0 
│   ├─┬ busboy@0.2.14 
│   │ ├─┬ dicer@0.2.5 
│   │ │ └── streamsearch@0.1.2 
│   │ └─┬ readable-stream@1.1.14 
│   │   ├── core-util-is@1.0.2 
│   │   ├── isarray@0.0.1 
│   │   └── string_decoder@0.10.31 
│   ├─┬ concat-stream@1.6.0 
│   │ ├─┬ readable-stream@2.3.3 
│   │ │ ├── isarray@1.0.0 
│   │ │ ├── process-nextick-args@1.0.7 
│   │ │ ├── string_decoder@1.0.3 
│   │ │ └── util-deprecate@1.0.2 
│   │ └── typedarray@0.0.6 
│   ├─┬ mkdirp@0.5.1 
│   │ └── minimist@0.0.8 
│   ├── object-assign@3.0.0 
│   └── xtend@4.0.1 
└── UNMET PEER DEPENDENCY sharp@^0.16.0

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/picture-wall/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0546 took 4.1085s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (26:19) on program 
const express = require('express');
const bodyParser = require('body-parser');
const basicAuth = require('basic-auth');
const fs = require('fs');
const crypto = require('crypto');
const multer = require('multer');

const publicPath = __dirname + '/public';
const distPath = __dirname + '/dist';
const uploadPath = __dirname + '/upload';

const configPath = process.argv[2] === '--config' ? process.argv[3] : __dirname + '/config.json';
const config = require(configPath);

const DataDriver = require(config.dataDriver.module);
const FileDriver = require(config.fileDriver.module);
const ImageResizeDriver = require(config.imageResizeDriver.module);

const dataDriver = new DataDriver(...config.dataDriver.args);
const fileDriver = new FileDriver(...config.fileDriver.args);
const imageResizeDriver = new ImageResizeDriver(...config.imageResizeDriver.args);

const app = express();

const auth = async function (req, res, next) {
	function unauthorized(res) {
		res.set('WWW-Authenticate', 'Basic realm=Authorization Required');
		return res.send(401);
	};

	const credentials = basicAuth(req);

	if (!credentials || !credentials.name || !credentials.pass) {
		return unauthorized(res);
	};

	const users = await dataDriver.getData('users');
	const authenticated = users.filter((user) => {
		return credentials.name === user.username && credentials.pass === user.password
	}).length > 0;

	if (authenticated) {
		res.cookie(
			'Authorization',
			req.headers['authorization'].substring('Basic '.length),
			{ maxAge: 60 * 60 * 1E3, httpOnly: false, domain: '' }
		);
		return next();
	} else {
		return unauthorized(res);
	};
};

function computeFileHash(fileData) {
	const md5sum = crypto.createHash('md5');
	md5sum.update(fileData);
	return md5sum.digest('hex');
}

function getExtension(fileName) {
	const lastIndexOfDot = fileName.lastIndexOf('.');
	return lastIndexOfDot !== -1 ? fileName.substring(lastIndexOfDot) : '';
}

const upload = multer({ dest: __dirname + '/tmp' });

app.use(bodyParser.json());
app.use(express.static(publicPath));
app.use(express.static(distPath));
app.use(express.static(uploadPath));
app.use('/admin', auth);
app.use('/admin', auth, express.static(publicPath));
app.use('/admin', auth, express.static(distPath));
app.use('/admin', auth, express.static(uploadPath));

app.get('/positions', async function (req, res) {
	res.send(await dataDriver.getData('positions'));
});
app.post('/admin/positions', auth, async function (req, res) {
	const positions = req.body;
	await dataDriver.saveData('positions', positions);
	res.send({
		status: "ok"
	});
});
app.get('/persons', async function (req, res) {
	res.send(await dataDriver.getData('persons'));
});
app.post('/admin/person/:personId', auth, async function (req, res) {
	const newPerson = req.body;
	const currentPersons = await dataDriver.getData('persons');
	const persons = currentPersons.filter((person) => person.id !== newPerson.id);
	persons.push(newPerson);
	await dataDriver.saveData('persons', persons);
	res.send({
		status: "ok"
	});
});
app.delete('/admin/person/:personId', auth, async function (req, res) {
	const personId = parseInt(req.params.personId);
	const currentPositions = await dataDriver.getData('positions');
	const positions = currentPositions.filter((position) => position.personId !== personId);
	await dataDriver.saveData('positions', positions);
	const currentPersons = await dataDriver.getData('persons');
	const persons = currentPersons.filter((person) => person.id !== personId);
	await dataDriver.saveData('persons', persons);
	res.send({
		status: "ok"
	});
});
app.post('/admin/picture', auth, upload.single('file'), (req, res) => {
	const file = req.file;
	fs.readFile(file.path, async function (error, data) {
		if (error) {
			throw error;
		}
		const extension = getExtension(file.originalname);
		const fileHash = computeFileHash(data);
		const uploadFileName = fileHash + extension;
		const uploadFilePath = '/picture/' + uploadFileName;
		await fileDriver.saveFile(uploadFilePath, data)
		res.send({
			fileName: uploadFileName
		});
	});
});
app.get(/\/picture\/resized\/(\d+)x(\d+)_(.+)/, async function (req, res) {
	const width = parseInt(req.params[0]);
	const height = parseInt(req.params[1]);
	const fileName = req.params[2];
	const extension = getExtension(fileName);
	const sourceFilePath = '/picture/' + fileName;
	const resizedFilePath = '/picture/resized/' + width + 'x' + height + '_' + fileName;
	res.header('Content-Type', 'image/' + extension.substring(1));
	try {
		const resizedImageData = await fileDriver.getFile(resizedFilePath);
		fs.writeFileSync(uploadPath + resizedFilePath, resizedImageData); // Do cache on local FS
		res.send(resizedImageData);
	} catch (error) {
		const sourceImageData = await fileDriver.getFile(sourceFilePath);
		fs.writeFileSync(uploadPath + sourceFilePath, sourceImageData); // Do cache on local FS
		try {
			await imageResizeDriver.resize(uploadPath + sourceFilePath, uploadPath + resizedFilePath, { width, height });
			const resizedImageData = fs.readFileSync(uploadPath + resizedFilePath);
			await fileDriver.saveFile(resizedFilePath, resizedImageData);
			res.send(resizedImageData);
		} catch (error) {
			res.status(500).send(sourceImageData);
		}
	}
});
app.get('/settings', async function (req, res) {
	res.send(await dataDriver.getData('settings', {}));
});
app.post('/admin/settings', auth, async function (req, res) {
	const settings = req.body;
	await dataDriver.saveData('settings', settings);
	res.send({
		status: "ok"
	});
});

const port = process.env.PORT || 8083;
app.listen(port, () => {
	console.log('Server listen on port ' + port);
});
 at SyntaxError: Unexpected token (26:19)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp.semicolon (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:581:61)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:918:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
    at Parser.parse (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:516:17)
    at Object.parse (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:3098:39)
    at convert (/root/ExpoSE/lib/Tropigate/bin/main.js:50:18)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
