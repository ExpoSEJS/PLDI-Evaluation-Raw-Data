/root/Targets/simple-pool
└─┬ simple-pool@0.1.1 
  └── random-tools@0.0.5 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/simple-pool/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 30% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0958 took 6.7016s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: 'with' in strict mode (41:2) on program var noop = function(){};

/**
 *
 * getUniform
 * get function returning [0, 1) uniform distribution
 *
 * @param (function) fn: random function generating 0 to 1 at random, optional.
 *                       default: Math.random
 *        (string)   fn: random function name, you can use one of ["xorshift"]
 *
 * @return fn
 *
 */
function getUniform(fn) {
  var type = typeof fn;
  return (type == 'function')
       ? fn
       : (type == "string" && fn == "xorshift")
         ? xorshift
         : Math.random;
}


/**
 * normalRandom
 *
 * get random value from a normal distribution
 * @param (number) mean
 * @param (number) dev : standard deviation
 * @param (function) fn: random function generating 0 to 1 at random, optional.
 *                       default: Math.random
 *        (string)   fn: random function name, you can use one of ["xorshift"]
 *                       
 * @return number
 *
 */
function normalRandom(mean, dev, fn) {
  fn = getUniform(fn);
  var a = fn(), b = fn();
  with (Math) {
    return dev * sqrt(-2 * log(a)) * sin(2 * PI * b) + mean;
  }
}

/**
 * onoff
 *
 * get true or false
 *
 */
function onoff(rate, fn) {
  fn = getUniform(fn);
  if (rate == undefined) rate = 0.5;
  return ( fn() >= 1- rate);
}



/**
 * randomInt
 *
 * get random integer range from min to max
 * @param (number) max : default 1
 * @param (number) min : default 0
 * @param (function) fn: random function generating 0 to 1 at random, optional.
 *                       default: Math.random
 *        (string)   fn: random function name, you can use one of ["xorshift"]
 *                       
 * @return number
 *
 */
function randomInt(max, min, fn) {
  max = (typeof max != "number") ? 1 : parseInt(max);
  min = (typeof min != "number") ? 0 : parseInt(min);
  fn = getUniform(fn);
  if (max < min) throw new Error("max " + max + " must be larger or equal to min " + min);
  //console.assert(max > min);
  var range = max - min + 1;
  return Math.floor(fn() * range) + min;
}


/**
 * combination 
 *
 * get random combination (M from N)
 * @param (number) val : array or N (total number)
 * @param (number) M   : number to select
 * @param (function) fn: random function generating 0 to 1 at random, optional.
 *                       default: Math.random
 *        (string)   fn: random function name, you can use one of ["xorshift"]
 *                       
 * @return number
 *
 */
function combination(val, M, fn) {
  var valIsArray = Array.isArray(val);
  var N = (valIsArray) ? val.length : parseInt(val);
  M = parseInt(M);
  if (isNaN(N)) throw new Error("first argument must be a number");
  if (isNaN(M)) throw new Error("second argument must be a number");
  if (N < M) throw new Error("N must be larger than (or equal to) M");

  var T, J;

  var resultHash = {};

  for (J=N-M+1; J<=N; J++) {
    T = randomInt(J, 1, fn);
    resultHash[resultHash[T] ? J : T] = true;
  }

  if (valIsArray) {
    return val.filter(function(v, k) {
      return resultHash[k+1];
    });
  }
  else {
    return Object.keys(resultHash);
  }
}


/**
 * WeightedSelection
 *
 * author : shinout <shinout310@gmail.com>
 * description : choose one of the given values at random, but weighted.
 *
 * example: 
 *
 *  var WeightedSelection = require("weightedselection");
 *
 *  // set hash table of choices
 *  var sel = new WeightedSelection({
 *    "hoge" : 1,
 *    "fuga" : 5,
 *    "piyo" : 2
 *  });
 *
 *  // get one of the given keys
 *  var a = sel.random(); // one of "hoge", "fuga", "piyo".
 *
 *  the probability to get "hoge" = 1 / (1 + 5 + 2) = 1/8
 *                         "fuga" = 5 / (1 + 5 + 2) = 5/8
 *                         "piyo" = 2 / (1 + 5 + 2) = 2/8
 *
 **/
function WeightedSelection(table, fn) {
  // TODO validate first.
	
  this.names = Object.keys(table).filter(function(name) {
		return (table[name] > 0);
	});

  this.hists = this.names.map((function() {
    var total = 0;
    return function(v) {
      total += Number(table[v]);
      return total;
    };
  })());
  this.hists.unshift(0);

  this.fn = getUniform(fn);
}


/**
 * get total number of cases
 **/
Object.defineProperty(WeightedSelection.prototype, "total", {
  get: function() {
    return this.hists[this.hists.length -1];
  },
  set: noop
});

/**
 * length: get the number of valid keys
 **/
Object.defineProperty(WeightedSelection.prototype, "length", {
  get: function() {
    return this.names.length;
  },
  set: noop
});

/**
 * get a random value
 **/
WeightedSelection.prototype.random = function(val) {
  var stpos  = 0;
  var endpos = this.hists.length -1;

  // TODO filter NaN, over max
  var val = (val != null) ? Number(val) : Math.floor(this.fn() * this.hists[endpos]);

  // binary search
  var cenpos, cenval, sub;
  while ( endpos - stpos > 1) {
    cenpos = Math.floor((stpos + endpos) / 2);
    cenval = this.hists[cenpos];
    sub = val - cenval;
    if (sub > 0) {
      stpos = cenpos;
    }
    else if (sub < 0) {
      endpos = cenpos;
    }
    // exact match
    else {
      return this.names[cenpos];
    }
  }
  return this.names[stpos];
};


/**
 * internal random generator
 **/
WeightedSelection.prototype.fn = Math.random;


/**
 * XORShift
 *
 * random number generator generator
 * @param (Number) seed
 * @param (boolean) normalize : if true, range becomes 0 to 1 
 * @return function : random number generator
 *
 */
function XORShift(seed, normalize) {
  /* prepare seed */
  seed = (typeof seed == Number) ? seed : Math.floor(Math.random() * 10000000);
  var sq = Math.sqrt(Math.random() + seed);
  var num = sq.toString().replace('.', '').replace(/^0*/, '');
  var len = num.length;
  num = Number(num);

  var w = (num + new Date().getTime() >>> ((seed + len) % 8)) >>> 0,
      x = 123456789,
      y = 362436069,
      z = 521288629;

  /**
   * random number generator
   * @return if normalize is false, integer ( 0 to 0x100000000 )
   *         if normalize is true , float ( 0 to 1 )
   */
  return function() {
    var t = x ^ (x << 11);
    x = y; y = z; z = w;
    w = ((w ^ (w >>> 19)) ^ (t ^ (t>>>8))) >>> 0;
    return (normalize) ? w/0x100000000 : w;
  }
}

var xorshift = XORShift(new Date().getTime(), true);


function shuffle(arr, copy) {
  if (copy) arr = arr.slice();
  var i = arr.length;
  while (i) {
    var j = Math.floor(Math.random()*i);
    var t = arr[--i];
    arr[i] = arr[j];
    arr[j] = t;
  }
  return arr;
}


module.exports = {
  getUniform        : getUniform,
  normalRandom      : normalRandom,
  XORShift          : XORShift,
  xorshift          : xorshift,
  randomInt         : randomInt,
  onoff             : onoff,
  combination       : combination,
  WeightedSelection : WeightedSelection,
  shuffle           : shuffle
};
 at SyntaxError: 'with' in strict mode (41:2)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$1.parseWithStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:932:27)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:708:32)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseBlock (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:981:25)
    at Parser.pp$3.parseFunctionBody (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2105:24)
    at Parser.parseFunctionBody (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:14:32)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1065:10)
    at Parser.pp$1.parseFunctionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:818:17)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:694:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/simple-pool/node_modules/simple-pool/lib/simplepool.js. Coverage (Term): 10% Coverage (LOC): 13%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
