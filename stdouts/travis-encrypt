
> ursa@0.9.4 install /root/Targets/travis-encrypt/node_modules/ursa
> node-gyp rebuild

make: Entering directory '/root/Targets/travis-encrypt/node_modules/ursa/build'
  CXX(target) Release/obj.target/ursaNative/src/ursaNative.o
  SOLINK_MODULE(target) Release/obj.target/ursaNative.node
  COPY Release/ursaNative.node
make: Leaving directory '/root/Targets/travis-encrypt/node_modules/ursa/build'
/root/Targets/travis-encrypt
└─┬ travis-encrypt@2.1.1 
  ├── colors@1.1.2 
  ├── deep-property@1.1.0 
  ├─┬ lodash.merge@3.3.2 
  │ ├── lodash._arraycopy@3.0.0 
  │ ├── lodash._arrayeach@3.0.0 
  │ ├─┬ lodash._createassigner@3.1.1 
  │ │ ├── lodash._bindcallback@3.0.1 
  │ │ ├── lodash._isiterateecall@3.0.9 
  │ │ └── lodash.restparam@3.6.1 
  │ ├── lodash._getnative@3.9.1 
  │ ├── lodash.isarguments@3.1.0 
  │ ├── lodash.isarray@3.0.4 
  │ ├─┬ lodash.isplainobject@3.2.0 
  │ │ └── lodash._basefor@3.0.3 
  │ ├── lodash.istypedarray@3.0.6 
  │ ├── lodash.keys@3.1.2 
  │ ├── lodash.keysin@3.0.8 
  │ └─┬ lodash.toplainobject@3.0.0 
  │   └── lodash._basecopy@3.0.1 
  ├─┬ read-yaml@1.1.0 
  │ ├─┬ extend-shallow@2.0.1 
  │ │ └── is-extendable@0.1.1 
  │ └─┬ js-yaml@3.10.0 
  │   ├─┬ argparse@1.0.9 
  │   │ └── sprintf-js@1.0.3 
  │   └── esprima@4.0.0 
  ├─┬ travis-ci@2.1.1 
  │ ├── github@0.1.16 
  │ ├── lodash@1.3.1 
  │ ├─┬ request@2.74.0 
  │ │ ├── aws-sign2@0.6.0 
  │ │ ├── aws4@1.6.0 
  │ │ ├─┬ bl@1.1.2 
  │ │ │ └─┬ readable-stream@2.0.6 
  │ │ │   ├── core-util-is@1.0.2 
  │ │ │   ├── inherits@2.0.3 
  │ │ │   ├── isarray@1.0.0 
  │ │ │   ├── process-nextick-args@1.0.7 
  │ │ │   ├── string_decoder@0.10.31 
  │ │ │   └── util-deprecate@1.0.2 
  │ │ ├── caseless@0.11.0 
  │ │ ├─┬ combined-stream@1.0.5 
  │ │ │ └── delayed-stream@1.0.0 
  │ │ ├── extend@3.0.1 
  │ │ ├── forever-agent@0.6.1 
  │ │ ├─┬ form-data@1.0.1 
  │ │ │ └─┬ async@2.5.0 
  │ │ │   └── lodash@4.17.4 
  │ │ ├─┬ har-validator@2.0.6 
  │ │ │ ├─┬ chalk@1.1.3 
  │ │ │ │ ├── ansi-styles@2.2.1 
  │ │ │ │ ├── escape-string-regexp@1.0.5 
  │ │ │ │ ├── has-ansi@2.0.0 
  │ │ │ │ └── supports-color@2.0.0 
  │ │ │ ├── commander@2.11.0 
  │ │ │ ├─┬ is-my-json-valid@2.16.1 
  │ │ │ │ ├── generate-function@2.0.0 
  │ │ │ │ ├─┬ generate-object-property@1.2.0 
  │ │ │ │ │ └── is-property@1.0.2 
  │ │ │ │ ├── jsonpointer@4.0.1 
  │ │ │ │ └── xtend@4.0.1 
  │ │ │ └─┬ pinkie-promise@2.0.1 
  │ │ │   └── pinkie@2.0.4 
  │ │ ├─┬ hawk@3.1.3 
  │ │ │ ├── boom@2.10.1 
  │ │ │ ├── cryptiles@2.0.5 
  │ │ │ ├── hoek@2.16.3 
  │ │ │ └── sntp@1.0.9 
  │ │ ├─┬ http-signature@1.1.1 
  │ │ │ ├── assert-plus@0.2.0 
  │ │ │ ├─┬ jsprim@1.4.1 
  │ │ │ │ ├── assert-plus@1.0.0 
  │ │ │ │ ├── extsprintf@1.3.0 
  │ │ │ │ ├── json-schema@0.2.3 
  │ │ │ │ └─┬ verror@1.10.0 
  │ │ │ │   └── assert-plus@1.0.0 
  │ │ │ └─┬ sshpk@1.13.1 
  │ │ │   ├── asn1@0.2.3 
  │ │ │   ├── assert-plus@1.0.0 
  │ │ │   ├── bcrypt-pbkdf@1.0.1 
  │ │ │   ├─┬ dashdash@1.14.1 
  │ │ │   │ └── assert-plus@1.0.0 
  │ │ │   ├── ecc-jsbn@0.1.1 
  │ │ │   ├─┬ getpass@0.1.7 
  │ │ │   │ └── assert-plus@1.0.0 
  │ │ │   ├── jsbn@0.1.1 
  │ │ │   └── tweetnacl@0.14.5 
  │ │ ├── is-typedarray@1.0.0 
  │ │ ├── isstream@0.1.2 
  │ │ ├── json-stringify-safe@5.0.1 
  │ │ ├─┬ mime-types@2.1.17 
  │ │ │ └── mime-db@1.30.0 
  │ │ ├── node-uuid@1.4.8 
  │ │ ├── oauth-sign@0.8.2 
  │ │ ├── qs@6.2.3 
  │ │ ├── stringstream@0.0.5 
  │ │ ├─┬ tough-cookie@2.3.3 
  │ │ │ └── punycode@1.4.1 
  │ │ └── tunnel-agent@0.4.3 
  │ └── underscore.string@2.2.1 
  ├─┬ ursa@0.9.4 
  │ ├── bindings@1.3.0 
  │ └── nan@2.7.0 
  ├─┬ write-yaml@0.2.2 
  │ ├── lazy-cache@0.2.7 
  │ └─┬ write@0.2.1 
  │   └─┬ mkdirp@0.5.1 
  │     └── minimist@0.0.8 
  └─┬ yargs@3.32.0 
    ├── camelcase@2.1.1 
    ├─┬ cliui@3.2.0 
    │ ├─┬ strip-ansi@3.0.1 
    │ │ └── ansi-regex@2.1.1 
    │ └── wrap-ansi@2.1.0 
    ├── decamelize@1.2.0 
    ├─┬ os-locale@1.4.0 
    │ └─┬ lcid@1.0.0 
    │   └── invert-kv@1.0.0 
    ├─┬ string-width@1.0.2 
    │ ├── code-point-at@1.1.0 
    │ └─┬ is-fullwidth-code-point@1.0.0 
    │   └── number-is-nan@1.0.1 
    ├── window-size@0.1.4 
    └── y18n@3.2.1 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/travis-encrypt/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 28.999999999999996% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0405 took 2.7258s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (16:4) on program // Copyright 2012 The Obvious Corporation.

/*
 * "ursa": RSA crypto, with an emphasis on Buffer objects
 */

/*
 * Modules used
 */

"use strict";

// Note: This also forces OpenSSL to be initialized, which is important!
var crypto = require("crypto");

var assert = require("assert");

var ursaNative = require("bindings")("ursaNative");
var RsaWrap    = ursaNative.RsaWrap;
var textToNid  = ursaNative.textToNid;


/*
 * Variable definitions
 */

/** encoding constant */
var BASE64 = "base64";

/** encoding constant */
var BINARY = "binary";

/** encoding constant */
var HEX = "hex";

/** type name */
var STRING = "string";

/** encoding constant */
var UTF8 = "utf8";

/** hash algorithm constant */
var MD5 = "md5";

/** regex that matches PEM files, capturing the file type */
var PEM_REGEX =
    /^(-----BEGIN (.*) KEY-----\r?\n[:\s,-\/+=a-zA-Z0-9\r\n]*\r?\n-----END \2 KEY-----\r?\n)/m;

/** "unsealer" key object to authenticate objects */
var theUnsealer = [ "ursa unsealer" ];


/*
 * Helper functions
 */

/**
 * Return true iff x is either a string or a Buffer.
 */
function isStringOrBuffer(x) {
    return (typeof x === STRING) || Buffer.isBuffer(x);
}

/**
 * Extract and identify the PEM file type represented in the given
 * buffer. Returns the extracted type string or undefined if the
 * buffer doesn't seem to be any sort of PEM format file.
 */
function identifyPemType(buf) {
    var str = encodeBuffer(buf, UTF8);
    var match = PEM_REGEX.exec(str);

    if (!match) {
        return undefined;
    }

    return match[2];
}

/**
 * Return whether the given buffer or string appears (trivially) to be a
 * valid public key file in PEM format.
 */
function isPublicKeyPem(buf) {
    var kind = identifyPemType(buf);
    return (kind == "PUBLIC");
}

/**
 * Return whether the given buffer or string appears (trivially) to be a
 * valid private key file in PEM format.
 */
function isPrivateKeyPem(buf) {
    var kind = identifyPemType(buf);
    return (kind == "RSA PRIVATE");
}

/**
 * Return a buffer containing the encoding of the given bigint for use
 * as part of an SSH-style public key file. The input value must be a
 * buffer representing an unsigned bigint in big-endian order.
 */
function toSshBigint(value) {
    // The output is signed, so we need to add an extra 00 byte at the
    // head if the high-order bit is set.
    var prefix00 = ((value[0] & 0x80) !== 0);
    var length = value.length + (prefix00 ? 1 : 0);
    var result = new Buffer(length + 4);
    var offset = 0;

    result.writeUInt32BE(length, offset);
    offset += 4;

    if (prefix00) {
	result[offset] = 0;
	offset++;
    }

    value.copy(result, offset);
    return result;
}

/**
 * Create and return a buffer containing an SSH-style public key file for
 * the given RsaWrap object.
 *
 * For the record, an SSH-style public key file consists of three
 * concatenated values, each one length-prefixed:
 *
 *     literal string "ssh-rsa"
 *     exponent
 *     modulus
 *
 * The literal string header is length-prefixed.  The two numbers are
 * represented as signed big-int values in big-endian order, also
 * length-prefixed.
 */
function createSshPublicKey(rsa) {
    var e = toSshBigint(rsa.getExponent());
    var m = toSshBigint(rsa.getModulus());

    var header = toSshBigint(new Buffer("ssh-rsa", UTF8));
    var result = new Buffer(header.length + m.length + e.length);
    var offset = 0;

    header.copy(result, offset);
    offset += header.length;
    e.copy(result, offset);
    offset += e.length;
    m.copy(result, offset);

    return result;
}

/**
 * Validate the given encoding name. Throws an exception if invalid.
 */
function validateEncoding(encoding) {
    switch (encoding) {
        case BASE64:
        case BINARY:
        case HEX:
        case UTF8: {
            // These are all valid.
            break;
        }
        default: {
            throw new Error("Invalid encoding: " + encoding);
        }
    }
}

/**
 * Convert a buffer into an appropriately-encoded string, or return it
 * unmodified if the encoding is undefined.
 */
function encodeBuffer(buf, encoding) {
    if (encoding === undefined) {
        return buf;
    }

    validateEncoding(encoding);
    return buf.toString(encoding);
}

/**
 * Return a buffer or undefined argument as-is, or convert a given
 * string into a buffer by using the indicated encoding. An undefined
 * encoding is interpreted to mean UTF8.
 */
function decodeString(str, encoding) {
    if ((str === undefined) || Buffer.isBuffer(str)) {
        return str;
    }

    if (encoding === undefined) {
        encoding = UTF8;
    }

    validateEncoding(encoding);
    return new Buffer(str, encoding);
}
/**
 * OpenSSH Public key to RSA
 * @param {String|Object} key OpenSSH Public Key
 * @param <String> key encoding, default 'base64'
 * @returns {PublicKey}
 */
function openSshPublicKey(key, encoding) {
    if (!Buffer.isBuffer(key)) {
        key = key.substr(0, 3) === 'ssh' ? key.split(' ')[1] : key;
        key = new Buffer(key, encoding || 'base64');
    }

    function parsePublicKey(key) {
        var parts = [],
            partsLength = 3;

        while(key.length) {
            var dLen = key.readInt32BE(0);
            var data = key.slice(4, dLen+4);
            key = key.slice(4+dLen);
            parts.push(data);
            if (!(--partsLength)) break;
        }

        return {
            modulus :   parts[2],
            exponent:   parts[1],
            type    :   parts[0]
        };
    }

    var pubKey = parsePublicKey(key);
    var rsa = new RsaWrap();

    if (pubKey.type != 'ssh-rsa') {
        throw new TypeError('Only "ssh-rsa" format supported');
    }

    rsa.openPublicSshKey(pubKey.modulus, pubKey.exponent);

    return PublicKey(rsa);
}

/**
 * Public Key object. This is the externally-visible object that one gets
 * when constructing an instance from a public key. The constructor takes
 * a native RsaWrap object.
 */
function PublicKey(rsa) {
    var self;

    function getExponent(encoding) {
        return encodeBuffer(rsa.getExponent(), encoding);
    }

    function getModulus(encoding) {
        return encodeBuffer(rsa.getModulus(), encoding);
    }

    function toPublicPem(encoding) {
        return encodeBuffer(rsa.getPublicKeyPem(), encoding);
    }

    function toPublicSsh(encoding) {
        return encodeBuffer(createSshPublicKey(rsa), encoding);
    }

    function toPublicSshFingerprint(encoding) {
        return sshFingerprint(createSshPublicKey(rsa), undefined, encoding);
    }

    function encrypt(buf, bufEncoding, outEncoding, padding) {
        buf = decodeString(buf, bufEncoding);
        padding = (padding === undefined) ?
                ursaNative.RSA_PKCS1_OAEP_PADDING : padding;
        return encodeBuffer(rsa.publicEncrypt(buf, padding), outEncoding);
    }

    function publicDecrypt(buf, bufEncoding, outEncoding, padding) {
        buf = decodeString(buf, bufEncoding);
        padding = (padding === undefined) ?
                ursaNative.RSA_PKCS1_PADDING : padding;
        return encodeBuffer(rsa.publicDecrypt(buf, padding), outEncoding);
    }

    function verify(algorithm, hash, sig, encoding) {
        algorithm = textToNid(algorithm);
        hash = decodeString(hash, encoding);
        sig = decodeString(sig, encoding);
        return rsa.verify(algorithm, hash, sig);
    }

    function hashAndVerify(algorithm, buf, sig, encoding,
                           use_pss_padding, salt_len) {
        if (use_pss_padding) {
            sig = publicDecrypt(sig, encoding, undefined,
                                ursaNative.RSA_NO_PADDING);

            var hash = crypto.createHash(algorithm);
            hash.update(decodeString(buf, encoding));
            buf = new Buffer(hash.digest(BINARY), BINARY);

            return rsa.verifyPSSPadding(textToNid(algorithm), buf, sig,
                    (salt_len === undefined) ? ursaNative.RSA_PKCS1_SALT_LEN_HLEN : salt_len);
        } else {
            var verifier = createVerifier(algorithm);
            verifier.update(buf, encoding);
            return verifier.verify(self, sig, encoding);
        }
    }

    function unseal(unsealer) {
        return (unsealer === theUnsealer) ? self : undefined;
    }

    self = {
        encrypt:                encrypt,
        getExponent:            getExponent,
        getModulus:             getModulus,
        hashAndVerify:          hashAndVerify,
        publicDecrypt:          publicDecrypt,
        toPublicPem:            toPublicPem,
        toPublicSsh:            toPublicSsh,
        toPublicSshFingerprint: toPublicSshFingerprint,
        verify:                 verify,
        unseal:                 unseal
    };

    return self;
}

/**
 * Private Key object. This is the externally-visible object that one
 * gets when constructing an instance from a private key (aka a
 * keypair). The constructor takes a native RsaWrap object.
 */
function PrivateKey(rsa) {
    var self;

    function getPrivateExponent(encoding) {
        return encodeBuffer(rsa.getPrivateExponent(), encoding);
    }

    function toPrivatePem(encoding) {
        return encodeBuffer(rsa.getPrivateKeyPem(), encoding);
    }

    function toEncryptedPrivatePem(passPhrase, cipher, encoding) {
        if(!passPhrase) return toPrivatePem(encoding);
        return encodeBuffer(rsa.getPrivateKeyPem(passPhrase, cipher));
    }

    function decrypt(buf, bufEncoding, outEncoding, padding) {
        buf = decodeString(buf, bufEncoding);
        padding = (padding === undefined) ? ursaNative.RSA_PKCS1_OAEP_PADDING : padding;
        return encodeBuffer(rsa.privateDecrypt(buf, padding), outEncoding);
    }

    function privateEncrypt(buf, bufEncoding, outEncoding, padding) {
        buf = decodeString(buf, bufEncoding);
        padding = (padding === undefined) ? ursaNative.RSA_PKCS1_PADDING : padding;
        return encodeBuffer(rsa.privateEncrypt(buf, padding), outEncoding);
    }

    function sign(algorithm, hash, hashEncoding, outEncoding) {
        algorithm = textToNid(algorithm);
        hash = decodeString(hash, hashEncoding);
        return encodeBuffer(rsa.sign(algorithm, hash), outEncoding);
    }

    function hashAndSign(algorithm, buf, bufEncoding, outEncoding,
                         use_pss_padding, salt_len) {
        if (use_pss_padding) {
            var hash = crypto.createHash(algorithm);
            hash.update(decodeString(buf, bufEncoding));
            buf = new Buffer(hash.digest(BINARY), BINARY);

            buf = rsa.addPSSPadding(textToNid(algorithm), buf,
                    (salt_len === undefined) ? ursaNative.RSA_PKCS1_SALT_LEN_HLEN : salt_len);

            return privateEncrypt(buf, undefined, outEncoding,
                                  ursaNative.RSA_NO_PADDING);
        } else {
            var signer = createSigner(algorithm);
            signer.update(buf, bufEncoding);
            return signer.sign(self, outEncoding);
        }
    }

    self = PublicKey(rsa);
    self.decrypt                = decrypt;
    self.getPrivateExponent     = getPrivateExponent;
    self.hashAndSign            = hashAndSign;
    self.privateEncrypt         = privateEncrypt;
    self.sign                   = sign;
    self.toPrivatePem           = toPrivatePem;
    self.toEncryptedPrivatePem  = toEncryptedPrivatePem;
    return self;
}


/*
 * Exported bindings
 */

/**
 * Create a new public key object, from the given PEM-encoded file.
 */
function createPublicKey(pem, encoding) {
    var rsa = new RsaWrap();
    pem = decodeString(pem, encoding);

    try {
        rsa.setPublicKeyPem(pem);
    } catch (ex) {
        if (!isPublicKeyPem(pem)) {
            throw new Error("Not a public key.");
        }
        throw ex;
    }

    return PublicKey(rsa);
}

/**
 * Create a new private key object, from the given PEM-encoded file,
 * optionally decrypting the file with a password.
 */
function createPrivateKey(pem, password, encoding) {
    var rsa = new RsaWrap();
    pem = decodeString(pem, encoding);
    password = decodeString(password, encoding);

    try {
        // Note: The native code is sensitive to the actual number of
        // arguments. It's *not* okay to pass undefined as a password.
        if (password) {
            rsa.setPrivateKeyPem(pem, password);
        } else {
            rsa.setPrivateKeyPem(pem);
        }
    } catch (ex) {
        if (!isPrivateKeyPem(pem)) {
            throw new Error("Not a private key.");
        }
        throw ex;
    }

    return PrivateKey(rsa);
}

/**
  * Create public key from components
  */
function createPublicKeyFromComponents(modulus, exponent) {
    var rsa = new RsaWrap();
    rsa.createPublicKeyFromComponents(modulus, exponent);
    return PublicKey(rsa);
}

/**
 * Create private key from components
 */
function createPrivateKeyFromComponents(modulus, exponent, p, q, dp, dq, inverseQ, d) {
    var rsa = new RsaWrap();
    rsa.createPrivateKeyFromComponents(modulus, exponent, p, q, dp, dq, inverseQ, d);

    return PrivateKey(rsa);
}

/**
 * Generate a new private key object (aka a keypair).
 */
function generatePrivateKey(modulusBits, exponent) {
    if (modulusBits === undefined) {
        modulusBits = 2048;
    }

    if (exponent === undefined) {
        exponent = 65537;
    }

    var rsa = new RsaWrap();
    rsa.generatePrivateKey(modulusBits, exponent);

    return PrivateKey(rsa);
}

/**
 * Create a key object from a PEM format file, either a private or
 * public key depending on what kind of file is passed in. If given
 * a private key file, it must not be encrypted.
 */
function createKey(pem, encoding) {
    pem = decodeString(pem, encoding);

    if (isPublicKeyPem(pem)) {
        return createPublicKey(pem);
    } else if (isPrivateKeyPem(pem)) {
        return createPrivateKey(pem);
    } else {
        throw new Error("Not a key.");
    }
}

/**
 * Return the SSH-style public key fingerprint of the given SSH-format
 * public key.
 */
function sshFingerprint(sshKey, sshEncoding, outEncoding) {
    var hash = crypto.createHash(MD5);

    hash.update(decodeString(sshKey, sshEncoding));
    var result = new Buffer(hash.digest(BINARY), BINARY);
    return encodeBuffer(result, outEncoding);
}

/**
 * Return whether the given object is a key object (either public or
 * private), as constructed by this module.
 */
function isKey(obj) {
    var obj2;

    try {
        var unseal = obj.unseal;
        if (typeof unseal !== "function") {
            return false;
        }
        obj2 = unseal(theUnsealer);
    } catch (ex) {
        // Ignore; can't assume that other objects obey any particular
        // unsealing protocol.
        // TODO: Log?
        return false;
    }

    return obj2 !== undefined;
}

/**
 * Return whether the given object is a private key object, as
 * constructed by this module.
 */
function isPrivateKey(obj) {
    return isKey(obj) && (obj.decrypt !== undefined);
}

/**
 * Return whether the given object is a public key object (per se), as
 * constructed by this module.
 */
function isPublicKey(obj) {
    return isKey(obj) && !isPrivateKey(obj);
}

/**
 * Assert wrapper for isKey().
 */
function assertKey(obj) {
    assert(isKey(obj));
}

/**
 * Assert wrapper for isPrivateKey().
 */
function assertPrivateKey(obj) {
    assert(isPrivateKey(obj));
}

/**
 * Assert wrapper for isPublicKey().
 */
function assertPublicKey(obj) {
    assert(isPublicKey(obj));
}

/**
 * Coerce the given key value into an private key object, returning
 * it. If given a private key object, this just returns it as-is. If
 * given a string or Buffer, it tries to parse it as PEM. Anything
 * else is an error.
 */
function coercePrivateKey(orig) {
    if (isPrivateKey(orig)) {
        return orig;
    } else if (isStringOrBuffer(orig)) {
        return createPrivateKey(orig);
    }

    throw new Error("Not a private key: " + orig);
}

/**
 * Coerce the given key value into a public key object, returning
 * it. If given a private key object, this just returns it as-is. If
 * given a string or Buffer, it tries to parse it as PEM. Anything
 * else is an error.
 */
function coercePublicKey(orig) {
    if (isPublicKey(orig)) {
        return orig;
    } else if (isStringOrBuffer(orig)) {
        return createPublicKey(orig);
    }

    throw new Error("Not a public key: " + orig);
}

/**
 * Coerce the given key value into a key object (either public or
 * private), returning it. If given a private key object, this just
 * returns it as-is. If given a string or Buffer, it tries to parse it
 * as PEM. Anything else is an error.
 */
function coerceKey(orig) {
    if (isKey(orig)) {
        return orig;
    } else if (isStringOrBuffer(orig)) {
        return createKey(orig);
    }

    throw new Error("Not a key: " + orig);
}

/**
 * Check whether the two objects are both keys of some sort and
 * have the same public part.
 */
function matchingPublicKeys(key1, key2) {
    if (!(isKey(key1) && isKey(key2))) {
        return false;
    }

    // This isn't the most efficient implementation, but it will suffice:
    // We convert both to ssh form, which has very little leeway for
    // variation, and compare bytes.

    var ssh1 = key1.toPublicSsh(UTF8);
    var ssh2 = key2.toPublicSsh(UTF8);

    return ssh1 === ssh2;
}

/**
 * Check whether the two objects are both keys of some sort, are
 * both public or both private, and have the same contents.
 */
function equalKeys(key1, key2) {
    // See above for rationale. In this case, there's no ssh form for
    // private keys, so we just use PEM for that.

    if (isPrivateKey(key1) && isPrivateKey(key2)) {
        var pem1 = key1.toPrivatePem(UTF8);
        var pem2 = key2.toPrivatePem(UTF8);
        return pem1 === pem2;
    }

    if (isPublicKey(key1) && isPublicKey(key2)) {
        return matchingPublicKeys(key1, key2);
    }

    return false;
}

/**
 * Create a signer object.
 */
function createSigner(algorithm) {
    var hash = crypto.createHash(algorithm);
    var self = {};

    function update(buf, bufEncoding) {
        buf = decodeString(buf, bufEncoding);
        hash.update(buf);
        return self;
    }

    function sign(privateKey, outEncoding) {
        var hashBuf = new Buffer(hash.digest(BINARY), BINARY);
        return privateKey.sign(algorithm, hashBuf, undefined, outEncoding);
    }

    self.sign = sign;
    self.update = update;
    return self;
}

/**
 * Create a verifier object.
 */
function createVerifier(algorithm) {
    var hash = crypto.createHash(algorithm);
    var self = {};

    function update(buf, bufEncoding) {
        buf = decodeString(buf, bufEncoding);
        hash.update(buf);
        return self;
    }

    function verify(publicKey, sig, sigEncoding) {
        var hashBuf = new Buffer(hash.digest(BINARY), BINARY);
        sig = decodeString(sig, sigEncoding);
        return publicKey.verify(algorithm, hashBuf, sig);
    }

    self.update = update;
    self.verify = verify;
    return self;
}


/*
 * Initialization
 */

module.exports = {
    assertKey:                      assertKey,
    assertPrivateKey:               assertPrivateKey,
    assertPublicKey:                assertPublicKey,
    coerceKey:                      coerceKey,
    coercePrivateKey:               coercePrivateKey,
    coercePublicKey:                coercePublicKey,
    createKey:                      createKey,
    createPrivateKey:               createPrivateKey,
    createPrivateKeyFromComponents: createPrivateKeyFromComponents,
    openSshPublicKey:               openSshPublicKey,
    createPublicKey:                createPublicKey,
    createPublicKeyFromComponents:  createPublicKeyFromComponents,
    createSigner:                   createSigner,
    createVerifier:                 createVerifier,
    equalKeys:                      equalKeys,
    generatePrivateKey:             generatePrivateKey,
    isKey:                          isKey,
    isPrivateKey:                   isPrivateKey,
    isPublicKey:                    isPublicKey,
    matchingPublicKeys:             matchingPublicKeys,
    sshFingerprint:                 sshFingerprint,
    RSA_NO_PADDING:                 ursaNative.RSA_NO_PADDING,
    RSA_PKCS1_PADDING:              ursaNative.RSA_PKCS1_PADDING,
    RSA_PKCS1_OAEP_PADDING:         ursaNative.RSA_PKCS1_OAEP_PADDING,
    RSA_PKCS1_SALT_LEN_HLEN:        ursaNative.RSA_PKCS1_SALT_LEN_HLEN,
    RSA_PKCS1_SALT_LEN_MAX:         ursaNative.RSA_PKCS1_SALT_LEN_MAX,
    RSA_PKCS1_SALT_LEN_RECOVER:     ursaNative.RSA_PKCS1_SALT_LEN_RECOVER
};
 at SyntaxError: Unexpected token (16:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/travis-encrypt/node_modules/travis-encrypt/lib/travis-encrypt.js. Coverage (Term): 9% Coverage (LOC): 18%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
