/root/Targets/goodrouter
└─┬ goodrouter@0.0.27 
  ├── synchronize-async@1.0.2 
  └── tslib@1.7.1 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/goodrouter/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0241 took 2.7074s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (50:10) on program "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const _1 = require(".");
const synchronize_async_1 = require("synchronize-async");
exports.defaultTransitionOptions = { reload: false };
/**
 * GoodRouter Router class
 */
class Router {
    /**
     * Include a list of RouteConfig's when constructing this Router
     * @param routeList A list of routes!
     */
    constructor(routeList) {
        this.routeStateIndex = {};
        this.lastRoute = null;
        this.lastParams = {};
        this.lastContext = null;
        const normalizedRouteList = this.normalizeRouteList(routeList);
        this.routeNameList = normalizedRouteList.
            map(route => route.name);
        this.routePathIndex = normalizedRouteList.
            filter(router => router.path).
            reduce((index, route) => Object.assign(index, { [route.name]: new _1.RoutePath(route.path) }), {});
        this.routeIndex = normalizedRouteList.
            map(route => {
            if (!(route.name in this.routePathIndex))
                return route;
            const routePath = this.routePathIndex[route.name];
            if (!route.params)
                return Object.assign({}, route, { params: routePath.params });
            return Object.assign({}, route, { params: [...route.params, ...routePath.params].reduce(_1.uniqueReducer(i => i), []) });
        }).
            reduce((index, route) => Object.assign(index, { [route.name]: route }), {});
    }
    /**
     * Construct a path that points to a route based on it's name
     */
    path(name, params) {
        const routePath = this.routePathIndex[name];
        if (!routePath)
            throw new Error(`route ${name} not found`);
        const path = routePath.build(params);
        return path;
    }
    /**
     * Transition into a new state! (AKA perform the routing)
     */
    async transition(path, context = null, config = {}) {
        config = Object.assign({}, exports.defaultTransitionOptions, config);
        const { lastParams: prevParams, lastRoute: prevRoute } = this;
        const [nextRoute, nextParams] = this.matchRoute(path);
        const nextRouteStack = this.buildRouteStack(nextRoute);
        const prevRouteStack = this.buildRouteStack(prevRoute);
        const state = { prevParams, nextParams, context };
        const changedRouteOffset = config.reload ? 0 : this.getChangedRouteOffset(state, prevRouteStack, nextRouteStack);
        await this.applyTeardownHandler(state, prevRouteStack, changedRouteOffset);
        await this.applySetupHandler(state, nextRouteStack, changedRouteOffset);
        const result = await this.applyRenderHandler(state, nextRouteStack);
        Object.assign(this, { lastParams: nextParams, lastRoute: nextRoute, lastContext: context });
        return result;
    }
    /**
     * Teardown and setup all handlers again without calling the render functions.
     */
    async reload() {
        const { lastParams, lastRoute, lastContext } = this;
        const routeStack = this.buildRouteStack(lastRoute);
        const state = { prevParams: lastParams, nextParams: lastParams, context: lastContext };
        await this.applyTeardownHandler(state, routeStack, 0);
        await this.applySetupHandler(state, routeStack, 0);
    }
    async applyTeardownHandler(state, routeStack, changedRouteOffset) {
        for (let routeIndex = routeStack.length - 1; routeIndex >= changedRouteOffset; routeIndex--) {
            const route = routeStack[routeIndex];
            const { teardown } = route;
            if (teardown) {
                const local = this.routeStateIndex[route.name];
                await teardown.call(this, Object.assign({}, state, { local }));
            }
            delete this.routeStateIndex[route.name];
        }
    }
    async applySetupHandler(state, routeStack, changedRouteOffset) {
        for (let routeIndex = changedRouteOffset, routeCount = routeStack.length; routeIndex < routeCount; routeIndex++) {
            const route = routeStack[routeIndex];
            const { setup } = route;
            let local = route.parent ? this.routeStateIndex[route.parent] : {};
            if (setup) {
                local = Object.assign({}, local, await setup.call(this, Object.assign({}, state, { local })));
            }
            this.routeStateIndex[route.name] = local;
        }
    }
    async applyRenderHandler(state, routeStack) {
        let result = null;
        for (let routeIndex = routeStack.length - 1; routeIndex >= 0; routeIndex--) {
            const route = routeStack[routeIndex];
            const { render } = route;
            const child = result;
            const local = this.routeStateIndex[route.name];
            if (render)
                result = await render.call(this, Object.assign({}, state, { child, local }));
        }
        return result;
    }
    getChangedRouteOffset(state, prevRouteStack, nextRouteStack) {
        for (let routeIndex = 0, routeCount = Math.min(prevRouteStack.length, nextRouteStack.length); routeIndex < routeCount; routeIndex++) {
            const prevRoute = prevRouteStack[routeIndex];
            const nextRoute = nextRouteStack[routeIndex];
            let areEqual = false;
            if (prevRoute && nextRoute && prevRoute === nextRoute) {
                areEqual = this.paramsEqual(nextRoute.params, state.nextParams, state.prevParams);
            }
            if (!areEqual)
                return routeIndex;
        }
        return Math.min(prevRouteStack.length, nextRouteStack.length);
    }
    buildRouteStack(route) {
        const routeStack = [];
        for (let currentRoute = route; currentRoute; currentRoute = this.routeIndex[currentRoute.parent]) {
            routeStack.unshift(currentRoute);
        }
        return routeStack;
    }
    /**
     * Find a route for the provided path and return the config and parsed
     * params
     *
     * @param path Path to find a route for
     */
    matchRoute(path) {
        if (path !== null) {
            for (let name of this.routeNameList) {
                if (!(name in this.routePathIndex))
                    continue;
                const routePath = this.routePathIndex[name];
                const params = routePath.match(path);
                if (!params)
                    continue;
                const route = this.routeIndex[name];
                return [route, params];
            }
        }
        return [null, {}];
    }
    normalizeRouteList(routeList) {
        return routeList.
            map((item, index) => item.name ? item : Object.assign({}, item, { name: item.parent ? `${item.parent}-r${index + 1}` : `r${index + 1}` })).
            map(item => item.params ? item : Object.assign({}, item, { params: [] })).
            reduce((list, item) => [
            ...list,
            item,
            ...(item.children ? this.normalizeRouteList(item.children.map(child => (Object.assign({}, child, { parent: item.name })))) : []),
        ], []);
    }
    /**
     * see if the parameters, defined in this path, of two states are equal
     */
    paramsEqual(params, values1, values2) {
        for (let param of params) {
            if (values1[param] === values2[param])
                continue;
            return false;
        }
        return true;
    }
}
tslib_1.__decorate([
    synchronize_async_1.synchronize()
], Router.prototype, "transition", null);
tslib_1.__decorate([
    synchronize_async_1.synchronize()
], Router.prototype, "reload", null);
exports.Router = Router;
//# sourceMappingURL=router.js.map at SyntaxError: Unexpected token (50:10)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp.expect (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:597:28)
    at Parser.pp$3.parseMethod (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2071:10)
    at Parser.pp$1.parseClassMethod (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1137:25)
    at Parser.pp$1.parseClass (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1118:14)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:697:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
    at Parser.parse (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:516:17)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
