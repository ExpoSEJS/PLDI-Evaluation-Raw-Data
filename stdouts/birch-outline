/root/Targets/birch-outline
└── birch-outline@0.2.1 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/birch-outline/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 35% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0536 took 2.9736s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (19:7) on program var AttributedString, Birch, CompositeDisposable, Disposable, Emitter, Item, ItemPath, ItemSerializer, Mutation, Outline, UndoManager, _, assert, ref, shortid;

ref = require('event-kit'), Emitter = ref.Emitter, Disposable = ref.Disposable, CompositeDisposable = ref.CompositeDisposable;

AttributedString = require('./attributed-string');

ItemSerializer = require('./item-serializer');

UndoManager = require('./undo-manager');

ItemPath = require('./item-path');

Mutation = require('./mutation');

shortid = require('./shortid');

_ = require('underscore-plus');

assert = require('./util').assert;

Birch = require('./birch');

Item = require('./item');

Outline = (function() {
  Outline.prototype.type = null;

  Outline.prototype.metadata = null;

  Outline.prototype.idsToItems = null;

  Outline.prototype.retainCount = 0;

  Outline.prototype.changes = null;

  Outline.prototype.changeCount = 0;

  Outline.prototype.undoSubscriptions = null;

  Outline.prototype.changingCount = 0;

  Outline.prototype.changesCallbacks = null;

  Outline.prototype.coalescingMutation = null;

  Outline.prototype.stoppedChangingDelay = 300;

  Outline.prototype.stoppedChangingTimeout = null;


  /*
  Section: Construction
   */

  function Outline(type, serialization) {
    var ref1, undoManager;
    this.id = shortid();
    this.metadata = new Map();
    this.idsToItems = new Map();
    this.branchContentIDsToItems = null;
    this.type = type != null ? type : ItemSerializer.TEXTType;
    this.root = this.createItem('', Birch.RootID);
    this.root.isInOutline = true;
    this.changeDelegateProcessing = 0;
    this.changeDelegate = (ref1 = ItemSerializer.getSerializationsForType(this.type)[0]) != null ? ref1.changeDelegate : void 0;
    this.undoManager = undoManager = new UndoManager;
    this.emitter = new Emitter;
    this.undoSubscriptions = new CompositeDisposable;
    this.undoSubscriptions.add(undoManager.onDidCloseUndoGroup((function(_this) {
      return function(group) {
        if (!undoManager.isUndoing && !undoManager.isRedoing && group.length > 0) {
          return _this.updateChangeCount(Outline.ChangeDone);
        }
      };
    })(this)));
    this.undoSubscriptions.add(undoManager.onWillUndo((function(_this) {
      return function() {
        return _this.breakUndoCoalescing();
      };
    })(this)));
    this.undoSubscriptions.add(undoManager.onDidUndo((function(_this) {
      return function() {
        _this.updateChangeCount(Outline.ChangeUndone);
        return _this.breakUndoCoalescing();
      };
    })(this)));
    this.undoSubscriptions.add(undoManager.onWillRedo((function(_this) {
      return function() {
        return _this.breakUndoCoalescing();
      };
    })(this)));
    this.undoSubscriptions.add(undoManager.onDidRedo((function(_this) {
      return function() {
        _this.updateChangeCount(Outline.ChangeRedone);
        return _this.breakUndoCoalescing();
      };
    })(this)));
    if (serialization) {
      this.reloadSerialization(serialization);
    }
  }

  Outline.createTaskPaperOutline = function(content) {
    return new Outline(ItemSerializer.TaskPaperType, content);
  };

  Outline.prototype.destroy = function() {
    var ref1, ref2;
    if (!this.destroyed) {
      if ((ref1 = this.undoSubscriptions) != null) {
        ref1.dispose();
      }
      if ((ref2 = this.undoManager) != null) {
        ref2.removeAllActions();
      }
      this.undoManager.disableUndoRegistration();
      this.destroyed = true;
      return this.emitter.emit('did-destroy');
    }
  };


  /*
  Section: Finding Outlines
   */

  Outline.prototype.id = null;

  Outline.outlines = [];

  Outline.getOutlines = function() {
    return this.outlines.slice();
  };

  Outline.getOutlineForID = function(id) {
    var each, i, len, ref1;
    ref1 = this.outlines;
    for (i = 0, len = ref1.length; i < len; i++) {
      each = ref1[i];
      if (each.id === id) {
        return each;
      }
    }
  };

  Outline.addOutline = function(outline) {
    return this.addOutlineAtIndex(outline, this.outlines.length);
  };

  Outline.addOutlineAtIndex = function(outline, index) {
    assert(!this.getOutlineForID(outline.id));
    this.outlines.splice(index, 0, outline);
    outline.onDidDestroy((function(_this) {
      return function() {
        return _this.removeOutline(outline);
      };
    })(this));
    return outline;
  };

  Outline.removeOutline = function(outline) {
    var index;
    index = this.outlines.indexOf(outline);
    if (index !== -1) {
      return this.removeOutlineAtIndex(index);
    }
  };

  Outline.removeOutlineAtIndex = function(index) {
    var outline;
    outline = this.outlines.splice(index, 1)[0];
    return outline != null ? outline.destroy() : void 0;
  };


  /*
  Section: Lifecycle
   */

  Outline.prototype.isRetained = function() {
    return this.retainCount > 0;
  };

  Outline.prototype.retain = function() {
    assert(!this.destroyed, 'Cant retain destroyed outline');
    if (this.retainCount === 0) {
      Outline.addOutline(this);
    }
    this.retainCount++;
    return this;
  };

  Outline.prototype.release = function() {
    this.retainCount--;
    if (!this.isRetained()) {
      this.destroy();
    }
    return this;
  };


  /*
  Section: Metadata
   */

  Outline.prototype.getMetadata = function(key) {
    return this.metadata.get(key);
  };

  Outline.prototype.setMetadata = function(key, value) {
    var e;
    if (value) {
      try {
        JSON.stringify(value);
        this.metadata.set(key, value);
      } catch (error) {
        e = error;
        console.log("value: " + value + " not JSON serializable " + e);
      }
    } else {
      this.metadata["delete"](key);
    }
    return this.updateChangeCount(Outline.ChangeDone);
  };

  Outline.prototype.serializedMetadata = null;

  Object.defineProperty(Outline.prototype, 'serializedMetadata', {
    get: function() {
      var metadata;
      metadata = {};
      this.metadata.forEach(function(value, key) {
        return metadata[key] = value;
      });
      return JSON.stringify(metadata);
    },
    set: function(jsonMetadata) {
      var each, i, len, metadata, ref1, results;
      if (metadata = JSON.parse(jsonMetadata)) {
        this.metadata = new Map();
        ref1 = Object.keys(metadata);
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          each = ref1[i];
          results.push(this.setMetadata(each, metadata[each]));
        }
        return results;
      }
    }
  });


  /*
  Section: Events
   */

  Outline.prototype.onDidBeginChanges = function(callback) {
    return this.emitter.on('did-begin-changes', callback);
  };

  Outline.prototype.onWillChange = function(callback) {
    return this.emitter.on('will-change', callback);
  };

  Outline.prototype.onDidChange = function(callback) {
    return this.emitter.on('did-change', callback);
  };

  Outline.prototype.onDidEndChanges = function(callback) {
    return this.emitter.on('did-end-changes', callback);
  };

  Outline.prototype.onDidUpdateChangeCount = function(callback) {
    return this.emitter.on('did-update-change-count', callback);
  };

  Outline.prototype.onWillReload = function(callback) {
    return this.emitter.on('will-reload', callback);
  };

  Outline.prototype.onDidReload = function(callback) {
    return this.emitter.on('did-reload', callback);
  };

  Outline.prototype.onDidDestroy = function(callback) {
    return this.emitter.on('did-destroy', callback);
  };

  Outline.prototype.getStoppedChangingDelay = function() {
    return this.stoppedChangingDelay;
  };


  /*
  Section: Reading Items
   */

  Outline.prototype.root = null;

  Outline.prototype.isEmpty = null;

  Object.defineProperty(Outline.prototype, 'isEmpty', {
    get: function() {
      var firstChild;
      firstChild = this.root.firstChild;
      return !firstChild || (!firstChild.nextItem && firstChild.bodyString.length === 0);
    }
  });

  Outline.prototype.items = null;

  Object.defineProperty(Outline.prototype, 'items', {
    get: function() {
      return this.root.descendants;
    }
  });

  Outline.prototype.getItemForID = function(id) {
    return this.idsToItems.get(id);
  };

  Outline.prototype.getItemsForIDs = function(ids) {
    var each, i, items, len;
    if (!ids) {
      return [];
    }
    items = [];
    for (i = 0, len = ids.length; i < len; i++) {
      each = ids[i];
      each = this.getItemForID(each);
      if (each) {
        items.push(each);
      }
    }
    return items;
  };

  Outline.prototype.getItemForBranchContentID = function(contentID) {
    var each, i, len, ref1;
    if (!this.branchContentIDsToItems) {
      this.branchContentIDsToItems = new Map();
      ref1 = this.root.descendants;
      for (i = 0, len = ref1.length; i < len; i++) {
        each = ref1[i];
        this.branchContentIDsToItems.set(each.branchContentID, each);
      }
    }
    return this.branchContentIDsToItems.get(contentID);
  };

  Outline.prototype.getItemForFuzzyContentID = function(fuzzyContentID) {};

  Outline.prototype.getAttributeNames = function(autoIncludeAttributes, excludeAttributes) {
    var attributes, attributesArray, each, eachAttributeName, i, j, k, len, len1, len2, ref1, ref2;
    if (autoIncludeAttributes == null) {
      autoIncludeAttributes = [];
    }
    if (excludeAttributes == null) {
      excludeAttributes = [];
    }
    attributes = new Set();
    for (i = 0, len = autoIncludeAttributes.length; i < len; i++) {
      each = autoIncludeAttributes[i];
      attributes.add(each);
    }
    ref1 = this.root.descendants;
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      each = ref1[j];
      ref2 = Object.keys(each.attributes);
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        eachAttributeName = ref2[k];
        if (excludeAttributes.indexOf(eachAttributeName) === -1) {
          attributes.add(eachAttributeName);
        }
      }
    }
    attributesArray = [];
    attributes.forEach(function(each) {
      return attributesArray.push(each);
    });
    attributesArray.sort();
    return attributesArray;
  };

  Outline.prototype.getTagAttributeNames = function(autoIncludeAttributes, excludeAttributes) {
    if (autoIncludeAttributes == null) {
      autoIncludeAttributes = [];
    }
    if (excludeAttributes == null) {
      excludeAttributes = [];
    }
    return this.getAttributeNames(autoIncludeAttributes, excludeAttributes).filter(function(each) {
      return each.substring(0, 5) === 'data-';
    });
  };

  Outline.prototype.evaluateItemPath = function(itemPath, contextItem, options) {
    if (options == null) {
      options = {};
    }
    if (options.root == null) {
      options.root = this.root;
    }
    if (options.types == null) {
      options.types = ItemSerializer.getSerializationsForType(this.type)[0].itemPathTypes;
    }
    if (contextItem == null) {
      contextItem = this.root;
    }
    return ItemPath.evaluate(itemPath, contextItem, options);
  };


  /*
  Section: Creating Items
   */

  Outline.prototype.createItem = function(text, id, remapIDCallback) {
    return new Item(this, text, id, remapIDCallback);
  };

  Outline.prototype.cloneItem = function(item, deep, remapIDCallback) {
    var clonedChild, clonedChildren, clonedItem, eachChild;
    if (deep == null) {
      deep = true;
    }
    assert(!item.isOutlineRoot, 'Can not clone root');
    assert(item.outline === this, 'Item must be owned by this outline');
    clonedItem = this.createItem(item.bodyAttributedString.clone());
    if (item.attributes) {
      clonedItem.attributes = Object.assign({}, item.attributes);
    }
    clonedItem.indent = item.depth;
    if (deep && (eachChild = item.firstChild)) {
      clonedChildren = [];
      while (eachChild) {
        clonedChild = this.cloneItem(eachChild, deep);
        clonedChild.indent = eachChild.indent;
        clonedChildren.push(clonedChild);
        eachChild = eachChild.nextSibling;
      }
      clonedItem.insertChildrenBefore(clonedChildren, null, true);
    }
    if (typeof remapIDCallback === "function") {
      remapIDCallback(item.id, clonedItem.id, clonedItem);
    }
    return clonedItem;
  };

  Outline.prototype.cloneItems = function(items, deep, remapIDCallback) {
    var clones, each, i, len;
    if (deep == null) {
      deep = true;
    }
    clones = [];
    for (i = 0, len = items.length; i < len; i++) {
      each = items[i];
      clones.push(this.cloneItem(each, deep, remapIDCallback));
    }
    return clones;
  };

  Outline.prototype.importItem = function(item, deep, remapIDCallback) {
    var children, eachChild, importedItem;
    if (deep == null) {
      deep = true;
    }
    assert(!item.isOutlineRoot, 'Can not import root item');
    assert(item.outline !== this, 'Item must not be owned by this outline');
    importedItem = this.createItem(item.bodyAttributedString.clone(), item.id, remapIDCallback);
    if (item.attributes) {
      importedItem.attributes = Object.assign({}, item.attributes);
    }
    if (deep && (eachChild = item.firstChild)) {
      children = [];
      while (eachChild) {
        children.push(this.importItem(eachChild, deep));
        eachChild = eachChild.nextSibling;
      }
      importedItem.appendChildren(children);
    }
    return importedItem;
  };


  /*
  Section: Insert & Remove Items
   */

  Outline.prototype.insertItemsBefore = function(items, referenceItem) {
    if (!Array.isArray(items)) {
      items = [items];
    }
    if (!items.length) {
      return;
    }
    return this.groupUndoAndChanges((function(_this) {
      return function() {
        var ancestorStack, current, currentDepth, each, eachGroup, eachGroupDepth, i, j, k, l, lastRoot, len, len1, len2, len3, nextBranch, nextSibling, parent, parentDepth, rootGroups, roots, trailingBranches;
        roots = Item.buildItemHiearchy(items);
        if (referenceItem) {
          assert(referenceItem.isInOutline, 'reference item must be in outline if defined');
          assert(referenceItem.outline === _this, 'reference item outline must be this outline if defined');
        }
        for (i = 0, len = roots.length; i < len; i++) {
          each = roots[i];
          if (each.indent < 1) {
            each.indent = 1;
          }
        }
        rootGroups = [];
        currentDepth = void 0;
        for (j = 0, len1 = roots.length; j < len1; j++) {
          each = roots[j];
          if (each.depth === currentDepth) {
            current.push(each);
          } else {
            current = [each];
            rootGroups.push(current);
            currentDepth = each.depth;
          }
        }
        for (k = 0, len2 = rootGroups.length; k < len2; k++) {
          eachGroup = rootGroups[k];
          eachGroupDepth = eachGroup[0].depth;
          parent = (referenceItem != null ? referenceItem.previousItemOrRoot : void 0) || _this.root.lastBranchItem;
          nextSibling = parent.firstChild;
          parentDepth = parent.depth;
          nextBranch = referenceItem;
          while (parentDepth >= eachGroupDepth) {
            nextSibling = parent.nextSibling;
            parent = parent.parent;
            parentDepth = parent.depth;
          }
          for (l = 0, len3 = eachGroup.length; l < len3; l++) {
            each = eachGroup[l];
            each.indent = eachGroupDepth - parent.depth;
          }
          parent.insertChildrenBefore(eachGroup, nextSibling, true);
        }
        lastRoot = roots[roots.length - 1];
        ancestorStack = [];
        each = lastRoot;
        while (each) {
          ancestorStack.push(each);
          each = each.lastChild;
        }
        trailingBranches = [];
        while (referenceItem && (referenceItem.depth > lastRoot.depth)) {
          trailingBranches.push(referenceItem);
          referenceItem = referenceItem.nextBranch;
        }
        return Item.buildItemHiearchy(trailingBranches, ancestorStack);
      };
    })(this));
  };

  Outline.prototype.removeItems = function(items) {
    var contiguousItemRanges, currentRange, each, i, len, previousItem;
    if (!Array.isArray(items)) {
      items = [items];
    }
    if (!(items.length > 0)) {
      return;
    }
    contiguousItemRanges = [];
    previousItem = void 0;
    for (i = 0, len = items.length; i < len; i++) {
      each = items[i];
      if (previousItem && previousItem === each.previousItem) {
        currentRange.push(each);
      } else {
        currentRange = [each];
        contiguousItemRanges.push(currentRange);
      }
      previousItem = each;
    }
    return this.groupUndoAndChanges((function(_this) {
      return function() {
        var j, len1, results;
        results = [];
        for (j = 0, len1 = contiguousItemRanges.length; j < len1; j++) {
          each = contiguousItemRanges[j];
          results.push(_this._removeContiguousItems(each));
        }
        return results;
      };
    })(this));
  };

  Outline.prototype._removeContiguousItems = function(items) {
    var commonAncestors, coveredItems, each, end, i, insertBefore, j, len, len1, reinsertChildren, removeItemsSet;
    coveredItems = [];
    commonAncestors = Item.getCommonAncestors(items);
    end = commonAncestors[commonAncestors.length - 1].nextBranch;
    each = items[0];
    while (each !== end) {
      coveredItems.push(each);
      each = each.nextItem;
    }
    insertBefore = coveredItems[coveredItems.length - 1].nextBranch;
    removeItemsSet = new Set();
    for (i = 0, len = items.length; i < len; i++) {
      each = items[i];
      removeItemsSet.add(each);
    }
    reinsertChildren = [];
    for (j = 0, len1 = coveredItems.length; j < len1; j++) {
      each = coveredItems[j];
      if (!removeItemsSet.has(each)) {
        reinsertChildren.push(each);
      }
    }
    Item.removeItemsFromParents(items);
    return this.insertItemsBefore(reinsertChildren, insertBefore);
  };


  /*
  Section: Changes
   */

  Outline.prototype.isChanged = function() {
    return this.changeCount !== 0;
  };

  Outline.prototype.updateChangeCount = function(changeType) {
    switch (changeType) {
      case Outline.ChangeDone:
        this.changeCount++;
        break;
      case Outline.ChangeUndone:
        this.changeCount--;
        break;
      case Outline.ChangeCleared:
        this.changeCount = 0;
        break;
      case Outline.ChangeRedone:
        this.changeCount++;
    }
    return this.emitter.emit('did-update-change-count', changeType);
  };

  Outline.prototype.isChanging = null;

  Object.defineProperty(Outline.prototype, 'isChanging', {
    get: function() {
      return this.startItem === this.endItem && this.startOffset === this.endOffset;
    }
  });

  Outline.prototype.groupChanges = function(callback) {
    this.beginChanges();
    callback();
    return this.endChanges();
  };

  Outline.prototype.willChange = function(mutation) {
    return this.emitter.emit('will-change', mutation);
  };

  Outline.prototype.beginChanges = function() {
    this.changingCount++;
    if (this.changingCount === 1) {
      this.changes = [];
      this.changesCallbacks = [];
      return this.emitter.emit('did-begin-changes');
    }
  };

  Outline.prototype.itemDidChangeBody = function(item, oldBody) {
    if (!this.changeDelegate) {
      return;
    }
    this.changeDelegateProcessing++;
    this.changeDelegate.processItemDidChangeBody(item, oldBody);
    return this.changeDelegateProcessing--;
  };

  Outline.prototype.itemDidChangeAttribute = function(item, name, value, oldValue) {
    if (!this.changeDelegateProcessing && this.changeDelegate) {
      return this.changeDelegate.processItemDidChangeAttribute(item, name, value, oldValue);
    }
  };

  Outline.prototype.recordChange = function(mutation) {
    var metadata, undoSelection;
    if (!this.undoManager.isUndoRegistrationEnabled()) {
      return;
    }
    if (this.undoManager.isUndoing || this.undoManager.isUndoing) {
      this.breakUndoCoalescing();
    }
    if (this.coalescingMutation && this.coalescingMutation.coalesce(mutation)) {
      metadata = this.undoManager.getUndoGroupMetadata();
      undoSelection = metadata.undoSelection;
      if (undoSelection && this.coalescingMutation.type === Mutation.BODY_CHANGED) {
        undoSelection.anchorOffset = this.coalescingMutation.insertedTextLocation;
        undoSelection.startOffset = this.coalescingMutation.insertedTextLocation;
        undoSelection.headOffset = this.coalescingMutation.insertedTextLocation + this.coalescingMutation.replacedText.length;
        return undoSelection.endOffset = this.coalescingMutation.insertedTextLocation + this.coalescingMutation.replacedText.length;
      }
    } else {
      this.undoManager.registerUndoOperation(mutation);
      return this.coalescingMutation = mutation;
    }
  };

  Outline.prototype.didChange = function(mutation) {
    this.changes.push(mutation);
    return this.emitter.emit('did-change', mutation);
  };

  Outline.prototype.endChanges = function(callback) {
    var changesCallbacks, each, i, len;
    if (callback) {
      this.changesCallbacks.push(callback);
    }
    this.changingCount--;
    if (this.changingCount === 0) {
      this.branchContentIDsToItems = null;
      this.emitter.emit('did-end-changes', this.changes);
      changesCallbacks = this.changesCallbacks;
      this.changesCallbacks = null;
      for (i = 0, len = changesCallbacks.length; i < len; i++) {
        each = changesCallbacks[i];
        each(this.changes);
      }
      return this.changes = null;
    }
  };


  /*
  Section: Undo
   */

  Outline.prototype.groupUndo = function(callback) {
    this.beginUndoGrouping();
    callback();
    return this.endUndoGrouping();
  };

  Outline.prototype.groupUndoAndChanges = function(callback) {
    this.beginUndoGrouping();
    this.beginChanges();
    callback();
    this.endChanges();
    return this.endUndoGrouping();
  };

  Outline.prototype.beginUndoGrouping = function(metadata) {
    return this.undoManager.beginUndoGrouping(metadata);
  };

  Outline.prototype.endUndoGrouping = function() {
    return this.undoManager.endUndoGrouping();
  };

  Outline.prototype.breakUndoCoalescing = function() {
    return this.coalescingMutation = null;
  };

  Outline.prototype.undo = function() {
    return this.undoManager.undo();
  };

  Outline.prototype.redo = function() {
    return this.undoManager.redo();
  };


  /*
  Section: Serialization
   */

  Outline.prototype.serializeItems = function(items, options) {
    if (options == null) {
      options = {};
    }
    return ItemSerializer.serializeItems(items, options);
  };

  Outline.prototype.deserializeItems = function(serializedItems, options) {
    if (options == null) {
      options = {};
    }
    return ItemSerializer.deserializeItems(serializedItems, this, options);
  };

  Outline.prototype.serialize = function(options) {
    if (options == null) {
      options = {};
    }
    if (options['type'] == null) {
      options['type'] = this.type;
    }
    return ItemSerializer.serializeItems(this.root.descendants, options);
  };

  Outline.prototype.reloadSerialization = function(serialization, options) {
    if (options == null) {
      options = {};
    }
    if (serialization != null) {
      if (options['type'] == null) {
        options['type'] = this.type;
      }
      this.emitter.emit('will-reload');
      this.undoManager.removeAllActions();
      this.undoManager.disableUndoRegistration();
      this.groupChanges((function(_this) {
        return function() {
          var items;
          items = ItemSerializer.deserializeItems(serialization, _this, options);
          _this.root.removeChildren(_this.root.children);
          return _this.root.appendChildren(items);
        };
      })(this));
      this.undoManager.enableUndoRegistration();
      this.updateChangeCount(Outline.ChangeCleared);
      return this.emitter.emit('did-reload');
    }
  };


  /*
  Section: Debug
   */

  Outline.prototype.toString = function() {
    return this.root.branchToString();
  };


  /*
  Section: Private Utility Methods
   */

  Outline.prototype.nextOutlineUniqueItemID = function(candidateID) {
    var id, loadingLIUsedIDs;
    loadingLIUsedIDs = this.loadingLIUsedIDs;
    while (true) {
      id = candidateID || shortid();
      if (loadingLIUsedIDs && !loadingLIUsedIDs[id]) {
        loadingLIUsedIDs[id] = true;
        return id;
      } else if (!this.idsToItems.get(id)) {
        return id;
      } else {
        candidateID = null;
      }
    }
  };

  return Outline;

})();

Outline.ChangeDone = 'Done';

Outline.ChangeUndone = 'Undone';

Outline.ChangeRedone = 'Redone';

Outline.ChangeCleared = 'Cleared';

module.exports = Outline;
 at SyntaxError: Unexpected token (19:7)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$3.parseExprAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1822:12)
    at Parser.parseExprAtom (/root/ExpoSE/lib/Tropigate/bin/Expression.js:28:30)
    at Parser.pp$3.parseExprSubscripts (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1715:21)
    at Parser.parseMaybeUnary (/root/ExpoSE/lib/Tropigate/bin/Unary.js:34:29)
    at Parser.pp$3.parseExprOps (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1637:21)
    at Parser.pp$3.parseMaybeConditional (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1620:21)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1597:21)
    at Parser.pp$3.parseExpression (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1573:21)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/birch-outline/node_modules/birch-outline/lib/index.js. Coverage (Term): 32% Coverage (LOC): 33%
*- File /root/Targets/birch-outline/node_modules/birch-outline/lib/birch.js. Coverage (Term): 96% Coverage (LOC): 100%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
