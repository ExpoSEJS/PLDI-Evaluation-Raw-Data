
> contextify@0.1.15 install /root/Targets/redoak/node_modules/contextify
> node-gyp rebuild

make: Entering directory '/root/Targets/redoak/node_modules/contextify/build'
  CXX(target) Release/obj.target/contextify/src/contextify.o
contextify.target.mk:94: recipe for target 'Release/obj.target/contextify/src/contextify.o' failed
make: Leaving directory '/root/Targets/redoak/node_modules/contextify/build'

> websocket@1.0.8 install /root/Targets/redoak/node_modules/websocket
> node install.js

[websocket v1.0.8] Attempting to compile native extensions.
[websocket v1.0.8]
    Native code compile failed!!
    Please note that this module DOES NOT REQUIRE the native components
    and will still work without them, though not quite as efficiently.

    On Windows, native extensions require Visual Studio and Python.
    On Unix, native extensions require Python, make and a C++ compiler.
    Start npm with --websocket:verbose to show compilation output (if any).
/root/Targets/redoak
└─┬ redoak@0.1.9 
  ├─┬ express@3.0.0-rc3 
  │ ├── commander@0.6.1 
  │ ├─┬ connect@2.4.3 
  │ │ ├── bytes@0.1.0 
  │ │ ├── formidable@1.0.11 
  │ │ ├── pause@0.0.1 
  │ │ └── qs@0.4.2 
  │ ├── cookie@0.0.4 
  │ ├── crc@0.2.0 
  │ ├─┬ debug@3.1.0 
  │ │ └── ms@2.0.0 
  │ ├── fresh@0.1.0 
  │ ├── methods@0.0.1 
  │ ├── mkdirp@0.3.3 
  │ ├── range-parser@0.0.4 
  │ └─┬ send@0.0.3 
  │   └── mime@1.2.6 
  ├─┬ html5@0.3.8 
  │ ├── async@0.1.22 
  │ ├── bench@0.3.6 
  │ ├── opts@1.2.6 
  │ └─┬ tap@0.1.4 
  │   ├── inherits@1.0.0 
  │   ├─┬ runforcover@0.0.2 
  │   │ └─┬ bunker@0.1.2 
  │   │   └─┬ burrito@0.2.12 
  │   │     ├── traverse@0.5.2 
  │   │     └── uglify-js@1.1.1 
  │   ├── slide@1.1.6 
  │   ├─┬ tap-consumer@0.0.1 
  │   │ ├── inherits@2.0.3 
  │   │ ├─┬ tap-results@0.0.2 
  │   │ │ └── inherits@1.0.2 
  │   │ └── yamlish@0.0.7 
  │   └── yamlish@0.0.2 
  ├─┬ jsdom@0.2.15 
  │ ├── cssom@0.2.5 
  │ ├── htmlparser@1.7.7 
  │ └─┬ request@2.83.0 
  │   ├── aws-sign2@0.7.0 
  │   ├── aws4@1.6.0 
  │   ├── caseless@0.12.0 
  │   ├─┬ combined-stream@1.0.5 
  │   │ └── delayed-stream@1.0.0 
  │   ├── extend@3.0.1 
  │   ├── forever-agent@0.6.1 
  │   ├─┬ form-data@2.3.1 
  │   │ └── asynckit@0.4.0 
  │   ├─┬ har-validator@5.0.3 
  │   │ ├─┬ ajv@5.2.3 
  │   │ │ ├── co@4.6.0 
  │   │ │ ├── fast-deep-equal@1.0.0 
  │   │ │ ├── json-schema-traverse@0.3.1 
  │   │ │ └─┬ json-stable-stringify@1.0.1 
  │   │ │   └── jsonify@0.0.0 
  │   │ └── har-schema@2.0.0 
  │   ├─┬ hawk@6.0.2 
  │   │ ├── boom@4.3.1 
  │   │ ├─┬ cryptiles@3.1.2 
  │   │ │ └── boom@5.2.0 
  │   │ ├── hoek@4.2.0 
  │   │ └── sntp@2.0.2 
  │   ├─┬ http-signature@1.2.0 
  │   │ ├── assert-plus@1.0.0 
  │   │ ├─┬ jsprim@1.4.1 
  │   │ │ ├── extsprintf@1.3.0 
  │   │ │ ├── json-schema@0.2.3 
  │   │ │ └─┬ verror@1.10.0 
  │   │ │   └── core-util-is@1.0.2 
  │   │ └─┬ sshpk@1.13.1 
  │   │   ├── asn1@0.2.3 
  │   │   ├── bcrypt-pbkdf@1.0.1 
  │   │   ├── dashdash@1.14.1 
  │   │   ├── ecc-jsbn@0.1.1 
  │   │   ├── getpass@0.1.7 
  │   │   ├── jsbn@0.1.1 
  │   │   └── tweetnacl@0.14.5 
  │   ├── is-typedarray@1.0.0 
  │   ├── isstream@0.1.2 
  │   ├── json-stringify-safe@5.0.1 
  │   ├─┬ mime-types@2.1.17 
  │   │ └── mime-db@1.30.0 
  │   ├── oauth-sign@0.8.2 
  │   ├── performance-now@2.1.0 
  │   ├── qs@6.5.1 
  │   ├── safe-buffer@5.1.1 
  │   ├── stringstream@0.0.5 
  │   ├─┬ tough-cookie@2.3.3 
  │   │ └── punycode@1.4.1 
  │   ├── tunnel-agent@0.6.0 
  │   └── uuid@3.1.0 
  ├── Sheet@1.0.2-rc1 
  ├── uglify-js@1.3.2 
  ├── underscore@1.3.3 
  └── websocket@1.0.8 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/redoak/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 28.999999999999996% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","call","sort"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0775 took 14.8683s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (11:4) on program // Calculate dependency trees and watch them.
//
// Dependency trees are hierarchical representations of HTML/JS/CSS files.
// Each node looks like: [fileObj, children]. fileObj contains the type of the
// file, the filename, and other data after reading and sometimes parsing the
// file. children are the potential HTML/JS/CSS dependencies of the fileObj.
//
// watch lets you watch the filesystem for any changes to the tree.

var _ = require('underscore');
var assert = require('assert');
var fs = require('fs');
var html5 = require('html5');
var jsdom = require('jsdom');
var jsp = require('uglify-js').parser;
var mustache = require('./public/mustache');
var path = require('path');
var queryselector = require('./queryselector');
var sheet = require('Sheet');
var watcher = require('./watcher');

// jsdom options.
var defaultFeatures = {
  // Used for easier scraping.
  QuerySelector: true,

  // No need to fetch anything.
  FetchExternalResources: [],

  // domjs doesn't implement document.write correctly.
  ProcessExternalResources: []
};

// Every tree has these dependencies.
var widgetDependencies =
    ['create.mjs', 'widget.mjs', 'rapid.mjs', 'public/widget.js',
     'public/extra.js', 'public/mustache.js']
    .map(function(x) {
  return { type: path.extname(x).substr(1), filename: __dirname + '/' + x };
});

html5.Parser.prototype.on('setup', function(parser) {
  var opening = /{{[#^].*?}}/;
  var closing = /{{\/.*?}}/;
  var open = [];
  var countBlocks = function(numOpen, str) {
    var result = 0;
    while (true) {
      var openIndex = str.search(opening);
      var closeIndex = str.search(closing);
      var index = Math.min(openIndex, closeIndex);
      if (openIndex == -1 && closeIndex == -1) {
        return result;
      } else if (index == closeIndex && closeIndex >= 0 || openIndex == -1) {
        result = Math.max(result - 1, -numOpen);
        str = str.substring(closeIndex + 1);
      } else {
        result++;
        str = str.substring(openIndex + 1);
      }
    }
    return result;
  };

  var openElements = parser.tree.open_elements;
  parser.tokenizer.on('token', function listen(t) {
    if (t.type == 'Characters') {
      var numOpen = open.last() ? open.last().count : 0;
      var countDelta = countBlocks(numOpen, t.data);
      if (countDelta > 0) {
        if (open.last() == openElements.last()) {
          open.last().count += countDelta;
        } else {
          open.push({ count: countDelta, last: openElements.last() });
        }
      } else if (countDelta < 0) {
        assert.ok(open.last());
        var removeCount = 0;
        while (open.last() && removeCount < -countDelta) {
          var oldCount = open.last().count;
          open.last().count = Math.max(0, open.last().count + countDelta);
          removeCount += oldCount - open.last().count;
          if (open.last().count == 0) {
            open.pop();
          }
        }
      }

      if (countDelta != 0) {
        var lastInserted = openElements.last().lastChild;
        var isTextNode = lastInserted &&
                         lastInserted.nodeType == lastInserted.TEXT_NODE;
        var nodeValue = isTextNode ? lastInserted.value : '';
        nodeValue = nodeValue.replace(/^\s+|\s+$/g, '');
        var tokenData = t.data.replace(/^\s+|\s+$/g, '');
        if (isTextNode) {
          lastInserted.oakAddBlockDepth = countDelta;
        }
        if (!isTextNode || nodeValue != tokenData) {
          var table = parser.tree.getTableMisnestedNodePosition().insertBefore;
          var textNode = table.previousSibling;
          assert(textNode.nodeValue, t.data);

          var index = textNode.value.indexOf(t.data);
          if (index != 0) {
            var document = openElements.last().ownerDocument;
            var value = textNode.value;
            textNode.value = value.substring(0, index);
            textNode = document.createTextNode(value.substring(index));
          }
          openElements.last().appendChild(textNode);
        }
      }
    } else if (t.type == 'StartTag' && open.length > 0) {
      var count = open.reduce(function(a, b) { return a + b.count }, 0);
      assert.ok(count > 0);
      if (openElements.last().lastChild) {
        openElements.last().lastChild.oakBlockDepth = count;
      } else {
        openElements.last().oakBlockDepth = count;
      }
    } else if (t.type == 'EOF') {
      parser.tokenizer.removeListener('token', listen);
    }
  });
});

/**
 * Parse HTML into a document structure.
 * @returns Root document element if data is a complete document.
 *          Returns the body element if this data looks like a fragment.
 */
function parseHTML(data) {
  // Some boilerplate to parse the DOM.
  var options = { features: defaultFeatures, parser: html5 };
  var window = jsdom.jsdom(null, null, options).createWindow();
  var document = window.document;
  var parser = new html5.Parser({ document: document });

  var isFragment = true;
  parser.tokenizer = new html5.Tokenizer(data, document);
  parser.setup();

  parser.tokenizer.on('token', function listen(t) {
    if (t.type != 'SpaceCharacters') {
      isFragment = t.type == 'StartTag' && !t.name.match(/^html|head$/i);
      parser.tokenizer.removeListener('token', listen);
    }
  });

  parser.tokenizer.tokenize();
  return isFragment ? document.body : document.documentElement;
}

/**
 * Returns array of objects that represent the use elements.  Removes the use
 * elements from the DOM at the same time.
 */
function eatUses(parent) {
  var uses = parent.querySelectorAll('use');
  var result = _.map(uses, function(use) {
    // Process mixins.
    var mixins = use.getAttribute('mixins') || use.getAttribute('mx');
    mixins = mixins.split(' ');

    // Figure out the object that will be passed to the template. The object
    // is determined by other attributes of the use tag and its inner text
    // content.
    var dict = {};
    _(use.attributes).forEach(function(attr) {
      if (attr.name != 'mixins' && attr.name != 'mx') {
        if (attr.value === '') {
          attr.value = true;
        }
        dict[attr.name] = attr.value;
      }
    });
    var obj = use.textContent || '{}';
    try {
      // Augment JSON content with the attributes of use tag.
      var jsonobj = _.extend({}, JSON.parse(obj), dict);
      obj = JSON.stringify(jsonobj);
    } catch(e) {
      // Not a JSON object, so add text content as a value parameter.
      dict.value = use.textContent;
      obj = JSON.stringify(dict);
    }

    var result = _.extend({ mixins: mixins, obj: obj },
                          queryselector.objectify(use, parent));
    use.parentNode.removeChild(use);
    return result;
  });
  result.reverse();
  return result;
}

// Handlers the different directives we may come across.
var fileHandlers = {
  'mjs': function(fileObj, data) {
    return { data: data };
  },

  'js': function(fileObj, data) {
    var ast = jsp.parse(data);

    // AST looks like ['toplevel', [ -- statements -- ]].
    // Only look through toplevel for directives.
    var fileObjs = [];
    var types = { require: 'js' };
    ast[1].forEach(function(stmt) {
      if (stmt[0]  == 'directive') {
        var match = stmt[1].match(/^(.*)? (.*)/);
        if (match && types[match[1]]) {
          var name = match[2];
          fileObjs.push({ type: types[match[1]], filename: name });
        }
      }
    });

    return { data: data, fileObjs: fileObjs };
  },

  'css': function(fileObj, data) {
    if (!fileObj.process) {
      return { data: data };
    }

    data = data.replace(/\n/g, '');

    var prefixRules = [
        'background-clip', 'background-origin', 'background-size',
        'border-radius', 'border-top-left-radius', 'border-top-right-radius',
        'border-bottom-left-radius', 'border-bottom-right-radius',
        'box-shadow', 'transform', 'transform-origin',
        'transition', 'transition-property', 'transition-duration',
        'transition-timing-function', 'transition-delay',
        'animation', 'animation-property', 'animation-duration',
        'animation-timing-function', 'animation-name', 'animation-delay',
        'animation-direction', 'animation-iteration-count',
        'user-select'];
    prefixRules = _(prefixRules).groupBy(function(s) { return s; });
    // TODO gradients work a little differently in old webkit browsers
    //      http://css-tricks.com/css3-gradients/
    var stylesheet = new sheet.Sheet(data);

    var selectorPrefix = '';

    function addPrefixer(str) {
      return function(prefix) {
        return prefix + str;
      };
    }

    function valueReplacer(cssTokens, value) {
      return function(prefix) {
        var result = value;
        for (var i = 0; i < cssTokens.length; i++) {
          result = result.replace(
              RegExp(cssTokens[i] + '(\\((rgba?(.*?)|.*?)*\\))?'),
              prefix + '$&');
        }
        return result;
      };
    }

    var prefixes = ['-moz-', '-webkit-', '-o-', '-ms-', ''];
    function doStyles(prefix, style) {
      return ['{', _(style).map(function(name) {
        var names = [name];
        var value = style[name];
        var values = [value];

        if (name == 'background-image' || name == 'background') {
          var atoms = ['linear-gradient', 'radial-gradient'];
          values = prefixes.map(valueReplacer(atoms, value));
        } else if (name == 'transition-property' || name == 'transition') {
          var atoms = ['transform'];
          names = prefixes.map(addPrefixer(name));
          values = prefixes.map(valueReplacer(atoms, value));
        }

        if (prefixRules[name]) {
          if (prefix === undefined) {
            names = prefixes.map(addPrefixer(name));
          } else {
            names = [prefix + name];
          }
        }

        if (values[0] == values[1]) {
          values = [values[0]];
        }
        var maxlength = Math.max(names.length, values.length);
        var result = [];
        for (var i = 0; i < maxlength; i++) {
          var namei = Math.min(i, names.length - 1);
          var valuei = Math.min(i, values.length - 1);
          result.push.call(result, names[namei], ':', values[valuei], ';');
        }
        return result;
      }), '}'];
    }

    function doAnimSubRule(prefix, rule) {
      if (rule.cssRules) {
        return [rule.name, '{',
                _(rule.cssRules).map(doAnimSubRule.bind(null, prefix)), '}'];
      } else if (rule.selectorText) {
        return [rule.selectorText, doStyles(prefix, rule.style)];j
      } else {
        return rule.cssText;
      }
    }

    var text = _(stylesheet.cssRules).map(function doRule(rule) {
      if (rule.kind == '@keyframes') {
        function insideText(prefix) {
          return ['{', _(rule.cssRules).map(
              doAnimSubRule.bind(null, prefix)), '}'];
        }
        return ['@-moz-keyframes', rule.name, insideText('-moz-'),
                '@-webkit-keyframes', rule.name, insideText('-webkit-'),
                '@-ms-keyframes', rule.name, insideText('-ms-'),
                '@-o-keyframes', rule.name, insideText('-o-'),
                '@keyframes', rule.name, insideText('')];
      } else if (rule.kind == '@media') {
        return ['@media', rule.name, '{', _(rule.cssRules).map(doRule), '}'];
      } else if (rule.selectorText) {
        var selectorText = selectorPrefix + rule.selectorText;
        return [selectorText, doStyles(undefined, rule.style)];
      } else {
        return rule.cssText;
      }
    });
    return { data: _.flatten(text).join(' ') };
  },

  'resource': function(fileObj, data) {
    return  { data: data };
  },

  'oak': function(fileObj, data) {
    var element = parseHTML(data);
    var document = element.ownerDocument;

    // Gather up templates.
    var templates = [];
    _(document.querySelectorAll('template')).forEach(function(template) {
      template.parentNode.removeChild(template);
      var name = template.getAttribute('name');
      if (!name) {
        throw new Error('template but no name');
      }

      // Find all template dependencies.
      var links = template.querySelectorAll(
          'link[rel=stylesheet][href], link[rel=js][href]');
      var dependencies = _(links).map(function(link) {
        var useOak = !link.hasAttribute('oak-no');
        var data = '';
        var href = link.getAttribute('href');
        var el = null;
        link.parentNode.removeChild(link);

        if (href.charAt(0) == '#') {
          // Allow inline scripts.
          el = document.getElementById(href.substr(1));
          href = '';
        }

        return {
          process: useOak,
          type: link.getAttribute('rel') == 'js' ? 'js' : 'css',
          filename: href,
          fromTemplate: true,
          element: el
        };
      });

      var elements = [];
      var all = template.querySelectorAll('template *');

      // Find all the unbound variables.

      // unbound will be an array of tuples.
      //   the first item contains unbound data for child nodes.
      //   the second item contains unbound data for attributes.
      //   the third item contains lookup data for all the elements.
      var unboundFilter = function(x) { return x.match(/{{/); };
      var unbound = _(all).map(function(el, i) {
        if (el.tagName == 'USE' || el.oakBlockDepth > 0) {
          return;
        }
        var childMap = function(x, i) {
          if (x.nodeType != x.TEXT_NODE || !unboundFilter(x.value) ||
              x.oakAddBlockDepth) {
            return undefined;
          }
          return { eindex: elements.length, childi: i, value: x.value };
        };
        var attrMap = function(x) {
          if (!unboundFilter(x.value)) {
            return undefined;
          }
          return { eindex: elements.length, aname: x.name, value: x.value };
        };
        var transform = function(things, map) {
          return _.chain(things).map(map).compact().flatten().value();
        };

        var children = transform(el.childNodes, childMap);
        var attrs = transform(el.attributes, attrMap);
        if (attrs.length || children.length) {
          elements.push(el);
          return [children, attrs];
        } else {
          return undefined;
        }
      });
      unbound = _.compact(unbound);

      // Unzip unbound, which will be part of our template data.
      unbound = {
        children: _(_(unbound).pluck('0')).flatten(),
        attrs: _(_(unbound).pluck('1')).flatten()
      };

      // Find element names.
      var nameEls = template.querySelectorAll('*[oak-name]');
      var elementNames = _(nameEls).map(function(el) {
        var name = el.getAttribute('oak-name');
        el.removeAttribute('oak-name');
        elements.push(el);
        return { name: name, eindex: elements.length - 1 };
      });

      // Find all events.
      var events = [];
      for (var j = 0; j < all.length; j++) {
        if (all[j].oakBlockDepth > 0) {
          continue;
        }

        var attrs = Array.prototype.slice.call(all[j].attributes)
            .filter(function(x) { return x.name.substr(0, 6) === 'oak-on' });

        if (attrs.length) {
          for (var k = 0; k < attrs.length; k++) {
            events.push([elements.length,
                         attrs[k].name.substr(6), attrs[k].value]);
            all[j].removeAttribute(attrs[k].name);
          }
          if (events.length) {
            elements.push(all[j]);
          }
        }
      }

      var uses = eatUses(template);

      var firstElement = (function nextElementSibling(el) {
        while (el && el.nodeType != el.ELEMENT_NODE) {
          el = el.nextSibling;
        }
        return el;
      })(template.firstChild);

      unbound.attrs.forEach(function(attr) {
        var attrel = elements[attr.eindex];
        attrel.removeAttribute(attr.aname);
      });
      var qselements = elements.map(function(el) {
        if (el == firstElement) {
          return { toplevel: true };
        } else {
          // XXX shouldn't this be firstElement?
          return queryselector.to(el, template);
        }
      });
      unbound.attrs.forEach(function(attr) {
        var attrel = elements[attr.eindex];
        attrel.setAttribute(attr.aname, attr.value);
      });

      templates.push({
        elementNames: elementNames,
        elements: qselements,
        events: events,
        name: name,
        data: template.innerHTML.replace(/^\s+|\s+$/, ''),
        dependencies: dependencies,
        unbound: unbound,
        uses: uses,
        document: template.ownerDocument
      });
    });

    // Gather up remaining scripts and CSS not in templates.
    var includes = document.querySelectorAll(
        'script[src], link[rel=stylesheet][href], link[rel=oak][href]');
    var fileObjs = _(includes).map(function(include) {
      var attr = include.tagName == 'LINK' ? 'href' : 'src';
      var src = include.getAttribute(attr);
      if (src.charAt(0) == '/') {
        // We don't handle absolute paths right now.
        return [];
      }

      var type;
      if (include.tagName == 'SCRIPT') {
        type = 'js';
      } else if (include.getAttribute('rel') == 'stylesheet') {
        type = 'css';
      } else {
        type = 'oak';
      }
      var useOak = !include.hasAttribute('oak-no');
      if (useOak) {
        include.parentNode.removeChild(include);
        return { filename: src , type: type, process: useOak };
      } else {
        return [];
      }
    });

    if (document.querySelector('meta[oak-rapid~=]')) {
      fileObjs.push({
        filename: path.resolve(__dirname, 'rapid.mjs'),
        type: 'mjs'
      });
    }

    var out = {};
    out.templates = templates;
    out.isFragment = element != document.documentElement;
    out.document = document;
    out.uses = eatUses(document);
    out.fileObjs = uniq([fileObjs, _(templates).pluck('dependencies')]);
    return out;
  }
};

function uniq(arrays) {
  var map = function(fileObj) { return fileObj.filename; };
  return _.uniq(_.flatten(arrays), false, map);
}

/** Flattens tree to array of dependencies. */
function flatten(tree) {
  // The node looks like [fileObj, children]. We swap the order here, so that
  // when the tree is flattened the leaf nodes come first.
  return uniq([tree[1].map(flatten), tree[0]]);
}

function handleFile(fileObj, data) {
  var result = fileHandlers[fileObj.type](fileObj, data);
  result.fileObjs = _(result.fileObjs).map(function(childFileObj) {
    var extend = {};
    if (childFileObj.filename) {
      var filename = path.resolve(
          path.dirname(fileObj.filename), childFileObj.filename);
      extend = { filename: filename };
    }
    return _.extend({}, childFileObj, extend);
  });
  return result;
}

function handleFileWithCallback(fileObj, data, callback) {
  // Why does the code look so funny? If callback were in the try block and the
  // callback throws an error, the callback would be called twice.
  var result;
  try {
    result = handleFile(fileObj, data);
  } catch(e) {
    return callback(e, null);
  }
  callback(null, result);
}

/** Fetches fileObj if not already in files dictionary. */
function fetch(files, fileObj, callback) {
  if (files[fileObj.filename]) {
    callback(null, files[fileObj.filename]);
  } else if (!fileHandlers[fileObj.type]) {
    callback(new Error('Cannot handle fileObj type'), null);
  } else if (!fileObj.filename) {
    handleFileWithCallback(fileObj, fileObj.data, callback);
  } else {
    var attempts = 2;
    fs.readFile(fileObj.filename, 'utf-8', function read(err, data) {
      if (err) {
        if (--attempts == 0) {
          callback(new Error('Cannot open file.'), null);
        } else {
          setTimeout(function() {
            // Node workaround. On OSX, apparently readFile fails with ENOENT
            // if the file is locked, which happens for me when a watched file
            // changes (perhaps my vim holds on to the file a little longer
            // after writing?). So we give it a little time and attempt to read
            // the file again.
            fs.readFile(fileObj.filename, 'utf-8', read);
          }, 200);
        }
      } else {
        handleFileWithCallback(fileObj, data, callback);
      }
    });
  }
}

/** Builds a tree structure given root file objects and file dictionary. */
function build(roots, files, callback) {
  (function recurse(fileObj, fileObjs, cycles, callback) {
    if (fileObj.filename) {
      if (cycles[fileObj.filename]) {
        return callback([fileObj, []]);
      } else {
        cycles = Object.create(cycles);
        cycles[fileObj.filename] = true;
      }
    }

    if (!fileObjs.length) {
      return callback([fileObj, []]);
    }

    var total = fileObjs.length;
    var childResults = new Array(total);
    fileObjs.forEach(function(childFileObj, i) {
      fetch(files, childFileObj, function childCallback(err, data) {
        if (err && childFileObj.type == 'js' &&
            path.basename(childFileObj.filename) == 'widget.js') {
          // No widget.js file in local directory, so it must be referring
          // to redoak's basewidget. Start this particular child fetch over,
          // with the real path to widget.js.
          childFileObj = [];
          data = { fileObjs: widgetDependencies };
        } else if (err) {
          data = { error: err, fileObjs: [] };
        }

        if (childFileObj.filename) {
          files[childFileObj.filename] = data;
        } else if (childFileObj.data) {
          _.extend(childFileObj, data);
        }

        recurse(childFileObj, data.fileObjs, cycles, function(t) {
          childResults[i] = t;
          if (--total == 0) {
            callback([fileObj, childResults]);
          }
        });
      });
    });
  })([], roots, {}, callback);
}

/** TODO */
function tree(roots, callback) {
  var files = {};
  var firstTree = new Tree(
      files, [[], roots.map(function(x) { return [x, []]; })]);
  firstTree.recalculate(null, function(t) {
    callback(t);
  });
}

/** TODO */
function Tree(files, tree) {
  this.files_ = files;
  this.tree_ = tree;
}

Tree.prototype = {
  addRoot: function(fileObj, callback) {
    var files = _.extend({}, this.files_);
    var roots = _.pluck(this.tree_[1], '0');
    roots.push(fileObj);
    build(roots, files, function(t) {
      callback(new Tree(files, t));
    });
  },

  recalculate: function(fileObj, callback) {
    var files = _.extend({}, this.files_);
    if (fileObj && fileObj.filename) {
      if (files[fileObj.filename]) {
        delete files[fileObj.filename];
      }
    }

    var roots = _.pluck(this.tree_[1], '0');
    build(roots, files, function(t) {
      callback(new Tree(files, t));
    });
  },

  /** Finds data object for given file. */
  data: function(fileObj) {
    var data = {};
    var subtree = this.subtree(fileObj);
    if (subtree && subtree.tree_[0].filename) {
      data = this.files_[subtree.tree_[0].filename];
    }
    return _.extend({}, fileObj, (subtree ? subtree.tree_[0] : {}), data);
  },

  /** Creates tree that only contains root node's oak dependencies. */
  oakDependencies: function() {
    var tree = this.subtree();
    var files = this.files_;
    var treeJson = (function build(node) {
      var data = files[node[0].filename];
      if (data && data.templates && node[0].type == 'oak') {
        var oakChildren = node[1].filter(function(x) {
//          console.log(x[0], ' --> ', (x[0].element ? x[0].element.id : null),
//                 (x[0].type == 'oak' || x[0].fromTemplate ||
//                  x[0].length === 0 ||
//                  node[0].filename == tree.tree_[0].filename)
//          );
          return (x[0].type == 'oak' || x[0].fromTemplate ||
                  x[0].length === 0 ||
                  node[0].filename == tree.tree_[0].filename);
        });
        return [node[0], oakChildren.map(build)];
      } else {
        return node.slice();
      }
    })(tree.tree_);
    return new Tree(files, treeJson);
  },

  /** Finds the subtree whose root filename matches given object's filename. */
  subtree: function(fileObj) {
    if (!fileObj) {
      if (this.tree_[0].filename || this.tree_[0].data) {
        return new Tree(this.files_, this.tree_);
      } else if (this.tree_[1].length == 1 && (
          this.tree_[1][0][0].filename || this.tree_[1][0][0].data)) {
        return new Tree(this.files_, this.tree_[1][0]);
      } else {
        throw new Error('No fileObj specified, and could not make a guess.');
      }
    }

    if (!fileObj.filename) {
      return null;
    }

    var nodes = [this.tree_];
    while (nodes.length) {
      var node = nodes.shift();
      if (node && node[0].filename == fileObj.filename) {
        return new Tree(this.files_, node);
      } else if (node) {
        nodes.push.apply(nodes, node[1]);
      }
    }
    return null;
  },

  children: function() {
    var children = this.tree_[1].map(function(n) { return [n[0], []]; });
    return flatten([[], children]).map(function(f) {
      return _.extend({}, f, this.data(f));
    }.bind(this));
  },

  /** Flatten out to unique array of file objects with their data. */
  flatten: function() {
    return _.compact(flatten(this.tree_)).map(function(f) {
      return _.extend({}, f, this.data(f));
    }.bind(this));
  }
};

/** Watches for changes for file objects and their dependencies. */
function watch(tree, callback) {
  var listeners = [];
  var unwatch = function() {
    listeners.forEach(function(l) { watcher.unwatch.apply(watcher, l); });
    listeners = null;
  };

  (function dep(tree, fileObj) {
    tree.recalculate(fileObj, function(newTree) {
      if (listeners === null) {
        // Called unwatch while we were generating the tree.
        return;
      }

      unwatch();
      listeners = _.compact(newTree.flatten().map(function(fileObj) {
        if (fileObj.filename) {
          var fn = dep.bind(this, newTree, fileObj);
          watcher.watch(fileObj.filename, fn);
          return [fileObj.filename, fn];
        }
      }));

      if (fileObj) {
        callback(newTree);
      }
    });
  })(tree);

  return unwatch;
}

/** Stops watching. */
function unwatch(handle) {
  handle();
}

module.exports.parseHTML = parseHTML;
module.exports.tree = tree;
module.exports.watch = watch;
module.exports.unwatch = unwatch;

if (require.main === module) {
  // Fragments are given body element back.
  var el = parseHTML('<div></div>');
  assert.equal(el, el.ownerDocument.body);

  // Full documents are given html element back.
  el = parseHTML('<html><body><div></div></body></html>');
  assert.equal(el, el.ownerDocument.firstChild);

  // Text nodes with loops inside tables remain inside tables. By default,
  // HTML parsers put extraneous non-table stuff right before the table.
  el = parseHTML('<table>{{#rows}}<tr><td>test</td></tr>{{/rows}}</table>');
  assert.equal(el.firstChild.tagName, 'TABLE');
  var table = el.firstChild;
  var textNode = table.firstChild;
  assert.equal(textNode.nodeType, el.TEXT_NODE);
  assert.equal(table.rows[0].oakBlockDepth, 1);
  assert.equal(table.rows[0].cells[0].oakBlockDepth, 1);

  // Make sure inner loops work.
  el = parseHTML('{{#loop1}}{{#loop2}}<div></div>{{/loop2}} ' +
                 '<div>etc</div>{{/loop1}}');
  var divs = el.querySelectorAll('div');
  assert.equal(divs.length, 2);
  assert.equal(divs[0].oakBlockDepth, 2);
  assert.equal(divs[1].oakBlockDepth, 1);

  // Self-closing tags get oakBlockDepth.
  el = parseHTML('{{#loop}}<div><img src="blah.jpg"></div>{{/loop}}');
  var div = el.querySelector('div');
  var img = el.querySelector('img');
  assert.equal(div.oakBlockDepth, 1);
  assert.equal(img.oakBlockDepth, 1);

  // HTML parsers remove extra whitespace from nodeValue. Make sure no errors
  // occur.
  parseHTML('<div>  \n{{#loop1}}  <div>test</div>{{/loop1}}</div>');

  var testData = {
    'test.oak': '<template name="bar">' +
                '<link rel="js" href="widget.js">' +
                '<link rel="stylesheet" href="test.css">' +
                '<div>Some template</div></template>',
    'use.oak': '<link rel="oak" href="test.oak"><use name="bar"></use>',
    'test.css': 'body { background-color: white; }'
  };

  var files = {};
  for (var i in testData) {
    var filename = __dirname + '/' + i;
    var fileObj = { filename: filename, type: path.extname(i).substr(1) };
    files[filename] = handleFile(fileObj, testData[i]);
  }

  var testOakData = files[__dirname + '/test.oak'];
  var template = testOakData.templates[0];
  assert.equal(template.name, 'bar');
  assert.equal(template.data, '<div>Some template</div>');
  assert.equal(testOakData.fileObjs.length, 2);

  var cssFileObj = { filename: __dirname + '/test.css', type: 'css' };
  var testOakFileObj = { filename: __dirname + '/test.oak', type: 'oak' };
  var rootFileObj = { filename: __dirname + '/use.oak', type: 'oak' };
  build([rootFileObj], files, function(t) {
    (function test(n) {
      assert(n.length == 2);
      assert(!Array.isArray(n[0]) || n[0].length == 0);
      assert(Array.isArray(n[1]));
      n[1].forEach(test);
    })(t);

    var tree = new Tree(files, t);

    assert.ok(
        tree.data({ filename: __dirname + '/public/widget.js' }).data);
    assert.ok(tree.data({ filename: __dirname + '/widget.mjs' }).data);
    assert.ok(tree.data({ filename: __dirname + '/rapid.mjs' }).data);
    assert.ok(tree.data({ filename: __dirname + '/create.mjs' }).data);

    assert.strictEqual(tree.data(testOakFileObj).templates,
                       testOakData.templates);

    assert.strictEqual(tree.data(cssFileObj).data,
                       files[cssFileObj.filename].data);

    var fileObjs = tree.flatten();
    assert.equal(fileObjs.length, 10);
  });
}
 at SyntaxError: Unexpected token (11:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/redoak/node_modules/redoak/lib/redoak.js. Coverage (Term): 4% Coverage (LOC): 4%
*- File /root/Targets/redoak/node_modules/underscore/underscore.js. Coverage (Term): 17% Coverage (LOC): 32%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
