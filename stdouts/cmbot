
> keygrip@0.2.4 install /root/Targets/cmbot/node_modules/keygrip
> [ -x /usr/bin/nodejs ] && /usr/bin/nodejs ./install.js || node ./install.js


> sqlite3@3.1.13 install /root/Targets/cmbot/node_modules/sqlite3
> node-pre-gyp install --fallback-to-build

[sqlite3] Success: "/root/Targets/cmbot/node_modules/sqlite3/lib/binding/node-v51-linux-x64/node_sqlite3.node" is installed via remote
/root/Targets/cmbot
└─┬ cmbot@0.9.7 
  ├── crypto@1.0.1 
  ├── dateformat@3.0.2 
  ├─┬ http-get@0.5.10 
  │ ├── buffer-concat@1.0.0 
  │ └── semver@5.4.1 
  ├── jquery@3.2.1 
  ├─┬ jsdom@11.3.0 
  │ ├── abab@1.0.4 
  │ ├── acorn@5.1.2 
  │ ├── acorn-globals@4.0.0 
  │ ├── array-equal@1.0.0 
  │ ├── content-type-parser@1.0.1 
  │ ├── cssom@0.3.2 
  │ ├── cssstyle@0.2.37 
  │ ├── domexception@1.0.0 
  │ ├─┬ escodegen@1.9.0 
  │ │ ├── esprima@3.1.3 
  │ │ ├── estraverse@4.2.0 
  │ │ ├── esutils@2.0.2 
  │ │ ├─┬ optionator@0.8.2 
  │ │ │ ├── deep-is@0.1.3 
  │ │ │ ├── fast-levenshtein@2.0.6 
  │ │ │ ├── levn@0.3.0 
  │ │ │ ├── prelude-ls@1.1.2 
  │ │ │ ├── type-check@0.3.2 
  │ │ │ └── wordwrap@1.0.0 
  │ │ └── source-map@0.5.7 
  │ ├── html-encoding-sniffer@1.0.1 
  │ ├── nwmatcher@1.4.2 
  │ ├─┬ parse5@3.0.2 
  │ │ └── @types/node@6.0.88 
  │ ├── pn@1.0.0 
  │ ├─┬ request@2.83.0 
  │ │ ├── aws-sign2@0.7.0 
  │ │ ├── aws4@1.6.0 
  │ │ ├── caseless@0.12.0 
  │ │ ├─┬ combined-stream@1.0.5 
  │ │ │ └── delayed-stream@1.0.0 
  │ │ ├── extend@3.0.1 
  │ │ ├── forever-agent@0.6.1 
  │ │ ├─┬ form-data@2.3.1 
  │ │ │ └── asynckit@0.4.0 
  │ │ ├─┬ har-validator@5.0.3 
  │ │ │ ├─┬ ajv@5.2.3 
  │ │ │ │ ├── co@4.6.0 
  │ │ │ │ ├── fast-deep-equal@1.0.0 
  │ │ │ │ ├── json-schema-traverse@0.3.1 
  │ │ │ │ └─┬ json-stable-stringify@1.0.1 
  │ │ │ │   └── jsonify@0.0.0 
  │ │ │ └── har-schema@2.0.0 
  │ │ ├─┬ hawk@6.0.2 
  │ │ │ ├── boom@4.3.1 
  │ │ │ ├─┬ cryptiles@3.1.2 
  │ │ │ │ └── boom@5.2.0 
  │ │ │ ├── hoek@4.2.0 
  │ │ │ └── sntp@2.0.2 
  │ │ ├─┬ http-signature@1.2.0 
  │ │ │ ├── assert-plus@1.0.0 
  │ │ │ ├─┬ jsprim@1.4.1 
  │ │ │ │ ├── extsprintf@1.3.0 
  │ │ │ │ ├── json-schema@0.2.3 
  │ │ │ │ └─┬ verror@1.10.0 
  │ │ │ │   └── core-util-is@1.0.2 
  │ │ │ └─┬ sshpk@1.13.1 
  │ │ │   ├── asn1@0.2.3 
  │ │ │   ├── bcrypt-pbkdf@1.0.1 
  │ │ │   ├── dashdash@1.14.1 
  │ │ │   ├── ecc-jsbn@0.1.1 
  │ │ │   ├── getpass@0.1.7 
  │ │ │   ├── jsbn@0.1.1 
  │ │ │   └── tweetnacl@0.14.5 
  │ │ ├── is-typedarray@1.0.0 
  │ │ ├── isstream@0.1.2 
  │ │ ├── json-stringify-safe@5.0.1 
  │ │ ├─┬ mime-types@2.1.17 
  │ │ │ └── mime-db@1.30.0 
  │ │ ├── oauth-sign@0.8.2 
  │ │ ├── performance-now@2.1.0 
  │ │ ├── qs@6.5.1 
  │ │ ├── safe-buffer@5.1.1 
  │ │ ├── stringstream@0.0.5 
  │ │ ├── tunnel-agent@0.6.0 
  │ │ └── uuid@3.1.0 
  │ ├─┬ request-promise-native@1.0.5 
  │ │ ├─┬ request-promise-core@1.1.1 
  │ │ │ └── lodash@4.17.4 
  │ │ └── stealthy-require@1.1.1 
  │ ├── sax@1.2.4 
  │ ├── symbol-tree@3.2.2 
  │ ├─┬ tough-cookie@2.3.3 
  │ │ └── punycode@1.4.1 
  │ ├── webidl-conversions@4.0.2 
  │ ├─┬ whatwg-encoding@1.0.1 
  │ │ └── iconv-lite@0.4.13 
  │ ├─┬ whatwg-url@6.3.0 
  │ │ ├── lodash.sortby@4.7.0 
  │ │ └─┬ tr46@1.0.1 
  │ │   └── punycode@2.1.0 
  │ └── xml-name-validator@2.0.1 
  ├─┬ mysql@0.9.6 
  │ └─┬ hashish@0.0.4 
  │   └── traverse@0.6.6 
  ├─┬ ntwitter@0.5.0 
  │ ├── cookies@0.1.6 
  │ ├── keygrip@0.2.4 
  │ └── oauth@0.9.15 
  ├─┬ path@0.12.7 
  │ ├── process@0.11.10 
  │ └─┬ util@0.10.3 
  │   └── inherits@2.0.1 
  ├── querystring@0.2.0 
  ├── simple-lastfm@1.0.5 
  ├── sprintf@0.1.5 
  ├─┬ sqlite3@3.1.13 
  │ ├── nan@2.7.0 
  │ └─┬ node-pre-gyp@0.6.38 
  │   ├─┬ hawk@3.1.3 
  │   │ ├── boom@2.10.1 
  │   │ ├── cryptiles@2.0.5 
  │   │ ├── hoek@2.16.3 
  │   │ └── sntp@1.0.9 
  │   ├─┬ mkdirp@0.5.1 
  │   │ └── minimist@0.0.8 
  │   ├─┬ nopt@4.0.1 
  │   │ ├── abbrev@1.1.1 
  │   │ └─┬ osenv@0.1.4 
  │   │   ├── os-homedir@1.0.2 
  │   │   └── os-tmpdir@1.0.2 
  │   ├─┬ npmlog@4.1.2 
  │   │ ├─┬ are-we-there-yet@1.1.4 
  │   │ │ └── delegates@1.0.0 
  │   │ ├── console-control-strings@1.1.0 
  │   │ ├─┬ gauge@2.7.4 
  │   │ │ ├── aproba@1.2.0 
  │   │ │ ├── has-unicode@2.0.1 
  │   │ │ ├── object-assign@4.1.1 
  │   │ │ ├── signal-exit@3.0.2 
  │   │ │ ├─┬ string-width@1.0.2 
  │   │ │ │ ├── code-point-at@1.1.0 
  │   │ │ │ └─┬ is-fullwidth-code-point@1.0.0 
  │   │ │ │   └── number-is-nan@1.0.1 
  │   │ │ ├─┬ strip-ansi@3.0.1 
  │   │ │ │ └── ansi-regex@2.1.1 
  │   │ │ └── wide-align@1.1.2 
  │   │ └── set-blocking@2.0.0 
  │   ├─┬ rc@1.2.1 
  │   │ ├── deep-extend@0.4.2 
  │   │ ├── ini@1.3.4 
  │   │ ├── minimist@1.2.0 
  │   │ └── strip-json-comments@2.0.1 
  │   ├─┬ request@2.81.0 
  │   │ ├── aws-sign2@0.6.0 
  │   │ ├── aws4@1.6.0 
  │   │ ├── caseless@0.12.0 
  │   │ ├─┬ combined-stream@1.0.5 
  │   │ │ └── delayed-stream@1.0.0 
  │   │ ├── extend@3.0.1 
  │   │ ├── forever-agent@0.6.1 
  │   │ ├─┬ form-data@2.1.4 
  │   │ │ └── asynckit@0.4.0 
  │   │ ├─┬ har-validator@4.2.1 
  │   │ │ ├─┬ ajv@4.11.8 
  │   │ │ │ ├── co@4.6.0 
  │   │ │ │ └─┬ json-stable-stringify@1.0.1 
  │   │ │ │   └── jsonify@0.0.0 
  │   │ │ └── har-schema@1.0.5 
  │   │ ├─┬ http-signature@1.1.1 
  │   │ │ ├── assert-plus@0.2.0 
  │   │ │ ├─┬ jsprim@1.4.1 
  │   │ │ │ ├── assert-plus@1.0.0 
  │   │ │ │ ├── extsprintf@1.3.0 
  │   │ │ │ ├── json-schema@0.2.3 
  │   │ │ │ └─┬ verror@1.10.0 
  │   │ │ │   └── assert-plus@1.0.0 
  │   │ │ └─┬ sshpk@1.13.1 
  │   │ │   ├── asn1@0.2.3 
  │   │ │   ├── assert-plus@1.0.0 
  │   │ │   ├── bcrypt-pbkdf@1.0.1 
  │   │ │   ├─┬ dashdash@1.14.1 
  │   │ │   │ └── assert-plus@1.0.0 
  │   │ │   ├── ecc-jsbn@0.1.1 
  │   │ │   ├─┬ getpass@0.1.7 
  │   │ │   │ └── assert-plus@1.0.0 
  │   │ │   ├── jsbn@0.1.1 
  │   │ │   └── tweetnacl@0.14.5 
  │   │ ├── is-typedarray@1.0.0 
  │   │ ├── isstream@0.1.2 
  │   │ ├── json-stringify-safe@5.0.1 
  │   │ ├─┬ mime-types@2.1.17 
  │   │ │ └── mime-db@1.30.0 
  │   │ ├── oauth-sign@0.8.2 
  │   │ ├── performance-now@0.2.0 
  │   │ ├── qs@6.4.0 
  │   │ ├── safe-buffer@5.1.1 
  │   │ ├── stringstream@0.0.5 
  │   │ ├─┬ tough-cookie@2.3.3 
  │   │ │ └── punycode@1.4.1 
  │   │ ├── tunnel-agent@0.6.0 
  │   │ └── uuid@3.1.0 
  │   ├─┬ rimraf@2.6.2 
  │   │ └─┬ glob@7.1.2 
  │   │   ├── fs.realpath@1.0.0 
  │   │   ├── inflight@1.0.6 
  │   │   ├─┬ minimatch@3.0.4 
  │   │   │ └─┬ brace-expansion@1.1.8 
  │   │   │   ├── balanced-match@1.0.0 
  │   │   │   └── concat-map@0.0.1 
  │   │   └── path-is-absolute@1.0.1 
  │   ├── semver@5.4.1 
  │   ├─┬ tar@2.2.1 
  │   │ ├── block-stream@0.0.9 
  │   │ ├─┬ fstream@1.0.11 
  │   │ │ └── graceful-fs@4.1.11 
  │   │ └── inherits@2.0.3 
  │   └─┬ tar-pack@3.4.0 
  │     ├─┬ debug@2.6.9 
  │     │ └── ms@2.0.0 
  │     ├── fstream-ignore@1.0.5 
  │     ├─┬ once@1.4.0 
  │     │ └── wrappy@1.0.2 
  │     ├─┬ readable-stream@2.3.3 
  │     │ ├── core-util-is@1.0.2 
  │     │ ├── isarray@1.0.0 
  │     │ ├── process-nextick-args@1.0.7 
  │     │ ├── string_decoder@1.0.3 
  │     │ └── util-deprecate@1.0.2 
  │     └── uid-number@0.0.6 
  ├── ttapi@3.1.2 
  └─┬ xml2js@0.4.19 
    └── xmlbuilder@9.0.4 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/cmbot/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 17% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","call","create","fromCharCode","RegExp"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0591 took 35.1802s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (31:4) on program /**
 * Copyright (c) 2010, Peter Griess <pg@std.in>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above copyright notice,
 *       this list of conditions and the following disclaimer in the documentation
 *       and/or other materials provided with the distribution.
 *
 *     * Neither the name of node-websocket-client nor the names of its
 *       contributors may be used to endorse or promote products derived from this
 *       software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var assert = require('assert');
var buffer = require('buffer');
var crypto = require('crypto');
var events = require('events');
var http = require('http');
var net = require('net');
var urllib = require('url');

var reg = /^v0.([0-9]+)/i.exec(process.version);
var oldVersion = reg ? +reg[1] <= 4 : false;
var sys = oldVersion ? require('sys') : require('util');

var FRAME_NO = 0;
var FRAME_LO = 1;
var FRAME_HI = 2;

// Values for readyState as per the W3C spec
var CONNECTING = 0;
var OPEN = 1;
var CLOSING = 2;
var CLOSED = 3;

var debugLevel = parseInt(process.env.NODE_DEBUG, 16);
var debug = (debugLevel & 0x4) ?
    function() { sys.error.apply(this, arguments); } :
    function() { };

// Generate a Sec-WebSocket-* value
var createSecretKey = function() {
    // How many spaces will we be inserting?
    var numSpaces = 1 + Math.floor(Math.random() * 12);
    assert.ok(1 <= numSpaces && numSpaces <= 12);

    // What is the numerical value of our key?
    var keyVal = (Math.floor(
        Math.random() * (4294967295 / numSpaces)
    ) * numSpaces);

    // Our string starts with a string representation of our key
    var s = keyVal.toString();

    // Insert 'numChars' worth of noise in the character ranges
    // [0x21, 0x2f] (14 characters) and [0x3a, 0x7e] (68 characters)
    var numChars = 1 + Math.floor(Math.random() * 12);
    assert.ok(1 <= numChars && numChars <= 12);
    
    for (var i = 0; i < numChars; i++) {
        var pos = Math.floor(Math.random() * s.length + 1);

        var c = Math.floor(Math.random() * (14 + 68));
        c = (c <= 14) ?
            String.fromCharCode(c + 0x21) :
            String.fromCharCode((c - 14) + 0x3a);

        s = s.substring(0, pos) + c + s.substring(pos, s.length);
    }

    // We shoudln't have any spaces in our value until we insert them
    assert.equal(s.indexOf(' '), -1);

    // Insert 'numSpaces' worth of spaces
    for (var i = 0; i < numSpaces; i++) {
        var pos = Math.floor(Math.random() * (s.length - 1)) + 1;
        s = s.substring(0, pos) + ' ' + s.substring(pos, s.length);
    }

    assert.notEqual(s.charAt(0), ' ');
    assert.notEqual(s.charAt(s.length), ' ');

    return s;
};

// Generate a challenge sequence
var createChallenge = function() {
    var c = ''; 
    for (var i = 0; i < 8; i++) {
        c += String.fromCharCode(Math.floor(Math.random() * 255));
    }

    return c;
};

// Get the value of a secret key string
//
// This strips non-digit values and divides the result by the number of
// spaces found.
var secretKeyValue = function(sk) {
    var ns = 0;
    var v = 0;

    for (var i = 0; i < sk.length; i++) {
        var cc = sk.charCodeAt(i);
        
        if (cc == 0x20) {
            ns++;
        } else if (0x30 <= cc && cc <= 0x39) {
            v = v * 10 + cc - 0x30;
        }
    }

    return Math.floor(v / ns);
}

// Get the to-be-hashed value of a secret key string
//
// This takes the result of secretKeyValue() and encodes it in a big-endian
// byte string
var secretKeyHashValue = function(sk) {
    var skv = secretKeyValue(sk);
   
    var hv = '';
    hv += String.fromCharCode((skv >> 24) & 0xff);
    hv += String.fromCharCode((skv >> 16) & 0xff);
    hv += String.fromCharCode((skv >> 8) & 0xff);
    hv += String.fromCharCode((skv >> 0) & 0xff);

    return hv;
};

// Compute the secret key signature based on two secret key strings and some
// handshaking data.
var computeSecretKeySignature = function(s1, s2, hs) { 
    assert.equal(hs.length, 8);

    var hash = crypto.createHash('md5');

    hash.update(secretKeyHashValue(s1));
    hash.update(secretKeyHashValue(s2));
    hash.update(hs);

    return hash.digest('binary');
};

// Return a hex representation of the given binary string; used for debugging
var str2hex = function(str) {
    var hexChars = [
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
        'a', 'b', 'c', 'd', 'e', 'f'
    ];

    var out = '';
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        out += hexChars[(c & 0xf0) >>> 4];
        out += hexChars[c & 0x0f];
        out += ' ';
    }

    return out.trim();
};

// Get the scheme for a URL, undefined if none is found
var getUrlScheme = function(url) {
    var i = url.indexOf(':');
    if (i == -1) {
        return undefined;
    }

    return url.substring(0, i);
};

// Set a constant on the given object
var setConstant = function(obj, name, value) {
    Object.defineProperty(obj, name, {
        get : function() {
            return value;
        }
    });
};

// WebSocket object
//
// This is intended to conform (mostly) to http://dev.w3.org/html5/websockets/
//
// N.B. Arguments are parsed in the anonymous function at the bottom of the
//      constructor.
var WebSocket = function(url, proto, opts) {
    events.EventEmitter.call(this);

    // Retain a reference to our object
    var self = this;

    // State of our end of the connection
    var readyState = CONNECTING;

    // Whether or not the server has sent a close handshake
    var serverClosed = false;

    // Our underlying net.Stream instance
    var stream = undefined;

    opts = opts || {
        origin : 'http://www.example.com'
    };

    // Frame parsing functions
    //
    // These read data from the given buffer starting at the given offset,
    // looking for the end of the current frame. If found, the current frame is
    // emitted and the function returns. Only a single frame is processed at a
    // time.
    //
    // The number of bytes read to complete a frame is returned, which the
    // caller is to use to advance along its buffer. If 0 is returned, no
    // completed frame bytes were found, and the caller should probably enqueue
    // the buffer as a continuation of the current message. If a complete frame
    // is read, the function is responsible for resting 'frameType'.

    // Framing data
    var frameType = FRAME_NO;
    var bufs = [];
    var bufsBytes = 0;

    // Frame-parsing functions
    var frameFuncs = [
        // FRAME_NO
        function(buf, off) {
            if (buf[off] & 0x80) {
                frameType = FRAME_HI;
            } else {
                frameType = FRAME_LO;
            }

            return 1;
        },

        // FRAME_LO
        function(buf, off) {
            debug('frame_lo(' + sys.inspect(buf) + ', ' + off + ')');

            // Find the first instance of 0xff, our terminating byte
            for (var i = off; i < buf.length && buf[i] != 0xff; i++)
                ;

            // We didn't find a terminating byte
            if (i >= buf.length) {
                return 0;
            }

            // We found a terminating byte; collect all bytes into a single buffer
            // and emit it
            var mb = null;
            if (bufs.length == 0) {
                mb = buf.slice(off, i);
            } else {
                mb = new buffer.Buffer(bufsBytes + i);

                var mbOff = 0;
                bufs.forEach(function(b) {
                    b.copy(mb, mbOff, 0, b.length);
                    mbOff += b.length;
                });

                assert.equal(mbOff, bufsBytes);

                // Don't call Buffer.copy() if we're coping 0 bytes. Rather
                // than being a no-op, this will trigger a range violation on
                // the destination.
                if (i > 0) {
                    buf.copy(mb, mbOff, off, i);
                }

                // We consumed all of the buffers that we'd been saving; clear
                // things out
                bufs = [];
                bufsBytes = 0;
            }

            process.nextTick(function() {
                var b = mb;
                return function() {
                    var m = b.toString('utf8');

                    self.emit('data', b);
                    self.emit('message', m);        // wss compat

                    if (self.onmessage) {
                        self.onmessage({data: m});
                    }
                };
            }());

            frameType = FRAME_NO;
            return i - off + 1;
        },

        // FRAME_HI
        function(buf, off) {
            debug('frame_hi(' + sys.inspect(buf) + ', ' + off + ')');

            if (buf[off] !== 0) {
                throw new Error('High-byte framing not supported.');
            }

            serverClosed = true;
            return 1;
        }
    ];

    // Handle data coming from our socket
    var dataListener = function(buf) {
        if (buf.length <= 0 || serverClosed) {
            return;
        }

        debug('dataListener(' + sys.inspect(buf) + ')');

        var off = 0;
        var consumed = 0;

        do {
            if (frameType < 0 || frameFuncs.length <= frameType) {
                throw new Error('Unexpected frame type: ' + frameType);
            }

            assert.equal(bufs.length === 0, bufsBytes === 0);
            assert.ok(off < buf.length);

            consumed = frameFuncs[frameType](buf, off);
            off += consumed;
        } while (!serverClosed && consumed > 0 && off < buf.length);

        if (serverClosed) {
            serverCloseHandler();
        }
        
        if (consumed == 0) {
            bufs.push(buf.slice(off, buf.length));
            bufsBytes += buf.length - off;
        }
    };

    // Handle incoming file descriptors
    var fdListener = function(fd) {
        self.emit('fd', fd);
    };

    // Handle errors from any source (HTTP client, stream, etc)
    var errorListener = function(e) {
        process.nextTick(function() {
            self.emit('wserror', e);

            if (self.onerror) {
                self.onerror(e);
            }
        });
    };

    // Finish the closing process; destroy the socket and tell the application
    // that we've closed.
    var finishClose = function() {
        readyState = CLOSED;

        if (stream) {
            stream.end();
            stream.destroy();
            stream = undefined;
        }

        process.nextTick(function() {
            self.emit('close');
            if (self.onclose) {
                self.onclose();
            }
        });
    };

    // Send a close frame to the server
    var sendClose = function() {
        assert.equal(OPEN, readyState);

        readyState = CLOSING;
        stream.write('\xff\x00', 'binary');
    };

    // Handle a close packet sent from the server
    var serverCloseHandler = function() {
        assert.ok(serverClosed);
        assert.ok(readyState === OPEN || readyState === CLOSING);

        bufs = [];
        bufsBytes = 0;

        // Handle state transitions asynchronously so that we don't change
        // readyState before the application has had a chance to process data
        // events which are already in the delivery pipeline. For example, a
        // 'data' event could be delivered with a readyState of CLOSING if we
        // received both frames in the same packet.
        process.nextTick(function() {
            if (readyState === OPEN) {
                sendClose();
            }

            finishClose();
        });
    };

    // External API
    self.close = function(timeout) {
        if (readyState === CONNECTING) {
            // If we're still in the process of connecting, the server is not
            // in a position to understand our close frame. Just nuke the
            // connection and call it a day.
            finishClose();
        } else if (readyState === OPEN) {
            sendClose();

            if (timeout) {
                setTimeout(finishClose, timeout * 1000);
            }
        }
    };

    self.send = function(str, fd) {
        if (readyState != OPEN) {
            return;
        }

        stream.write('\x00', 'binary');
        stream.write(str, 'utf8', fd);
        stream.write('\xff', 'binary');
    };

    // wss compat
    self.write = self.send;

    setConstant(self, 'url', url);

    Object.defineProperty(self, 'readyState',  {
        get : function() {
            return readyState;
        }
    });

    // Connect and perform handshaking with the server
    (function() {
        // Parse constructor arguments 
        if (!url) {
            throw new Error('Url and must be specified.');
        }

        // Secrets used for handshaking
        var key1 = createSecretKey();
        var key2 = createSecretKey();
        var challenge = createChallenge();

        debug(
            'key1=\'' + str2hex(key1) + '\'; ' +
            'key2=\'' + str2hex(key2) + '\'; ' +
            'challenge=\'' + str2hex(challenge) + '\''
        );

        var httpHeaders = {
            'Connection' : 'Upgrade',
            'Upgrade' : 'WebSocket',
            'Sec-WebSocket-Key1' : key1,
            'Sec-WebSocket-Key2' : key2
        };
        if (opts.origin) {
            httpHeaders['Origin'] = opts.origin;
        }
        if (proto) {
            httpHeaders['Sec-WebSocket-Protocol'] = proto;
        }

        var httpPath = '/';

        // Create the HTTP client that we'll use for handshaking. We'll cannabalize
        // its socket via the 'upgrade' event and leave it to rot.
        //
        // N.B. The ws+unix:// scheme makes use of the implementation detail
        //      that http.Client passes its constructor arguments through,
        //      un-inspected to net.Stream.connect(). The latter accepts a
        //      string as its first argument to connect to a UNIX socket.
        var httpClient = undefined;
        switch (getUrlScheme(url)) {
        case 'ws':
            var u = urllib.parse(url);
            httpPath = (u.pathname || '/') + (u.search || '');
            httpHeaders.Host = u.hostname + (u.port ? (":" + u.port) : "");
            var options = {
               port: u.port || 80,
               host: u.hostname,
               path: httpPath,
               headers: httpHeaders
            };
            httpClient = oldVersion ? http.createClient(u.port || 80, u.hostname) : http.request(options);
            break;

        case 'ws+unix':
            var sockPath = url.substring('ws+unix://'.length, url.length);
            httpClient = http.createClient(sockPath);
            httpHeaders.Host = 'localhost';
            break;

        default:
            throw new Error('Invalid URL scheme \'' + urlScheme + '\' specified.');
        }

        httpClient.on('upgrade', (function() {
            var data = undefined;

            return function(req, s, head) {
                stream = s;

                stream.on('data', function(d) {
                    if (d.length <= 0) {
                        return;
                    }

                    if (!data) {
                        data = d;
                    } else {
                        var data2 = new buffer.Buffer(data.length + d.length);

                        data.copy(data2, 0, 0, data.length);
                        d.copy(data2, data.length, 0, d.length);

                        data = data2;
                    }

                    if (data.length >= 16) {
                        var expected = computeSecretKeySignature(key1, key2, challenge);
                        var actual = data.slice(0, 16).toString('binary');

                        // Handshaking fails; we're donezo
                        if (actual != expected) {
                            debug(
                                'expected=\'' + str2hex(expected) + '\'; ' +
                                'actual=\'' + str2hex(actual) + '\''
                            );

                            process.nextTick(function() {
                                // N.B. Emit 'wserror' here, as 'error' is a reserved word in the
                                //      EventEmitter world, and gets thrown.
                                self.emit(
                                    'wserror',
                                    new Error('Invalid handshake from server:' +
                                        'expected \'' + str2hex(expected) + '\', ' +
                                        'actual \'' + str2hex(actual) + '\''
                                    )
                                );

                                if (self.onerror) {
                                    self.onerror();
                                }

                                finishClose();
                            });
                        }

                        // Un-register our data handler and add the one to be used
                        // for the normal, non-handshaking case. If we have extra
                        // data left over, manually fire off the handler on
                        // whatever remains.
                        //
                        // XXX: This is lame. We should only remove the listeners
                        //      that we added.
                        httpClient.removeAllListeners('upgrade');
                        stream.removeAllListeners('data');
                        stream.on('data', dataListener);

                        readyState = OPEN;

                        process.nextTick(function() {
                            self.emit('open');

                            if (self.onopen) {
                                self.onopen();
                            }
                        });

                        // Consume any leftover data
                        if (data.length > 16) {
                            stream.emit('data', data.slice(16, data.length));
                        }
                    }
                });
                stream.on('fd', fdListener);
                stream.on('error', errorListener);
                stream.on('close', function() {
                    errorListener(new Error('Stream closed unexpectedly.'));
                });

                stream.emit('data', head);
            };
        })());
        httpClient.on('error', function(e) {
            httpClient.end();
            errorListener(e);
        });

        var httpReq = oldVersion ? httpClient.request(httpPath, httpHeaders) : httpClient;

        httpReq.write(challenge, 'binary');
        httpReq.end();
    })();
};
sys.inherits(WebSocket, events.EventEmitter);
exports.WebSocket = WebSocket;

// Add some constants to the WebSocket object
setConstant(WebSocket.prototype, 'CONNECTING', CONNECTING);
setConstant(WebSocket.prototype, 'OPEN', OPEN);
setConstant(WebSocket.prototype, 'CLOSING', CLOSING);
setConstant(WebSocket.prototype, 'CLOSED', CLOSED);

// vim:ts=4 sw=4 et
 at SyntaxError: Unexpected token (31:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/cmbot/node_modules/cmbot/lib/index.js. Coverage (Term): 0% Coverage (LOC): 0%
*- File /root/Targets/cmbot/node_modules/xml2js/lib/xml2js.js. Coverage (Term): 92% Coverage (LOC): 97%
*- File /root/Targets/cmbot/node_modules/xml2js/lib/defaults.js. Coverage (Term): 98% Coverage (LOC): 100%
*- File /root/Targets/cmbot/node_modules/xml2js/lib/builder.js. Coverage (Term): 12% Coverage (LOC): 15%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/index.js. Coverage (Term): 37% Coverage (LOC): 39%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/Utility.js. Coverage (Term): 26% Coverage (LOC): 34%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/XMLDocument.js. Coverage (Term): 51% Coverage (LOC): 56%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/XMLNode.js. Coverage (Term): 15% Coverage (LOC): 28%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/XMLStringifier.js. Coverage (Term): 26% Coverage (LOC): 46%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/XMLStringWriter.js. Coverage (Term): 13% Coverage (LOC): 21%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/XMLDeclaration.js. Coverage (Term): 48% Coverage (LOC): 53%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/XMLDocType.js. Coverage (Term): 36% Coverage (LOC): 53%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/XMLDTDAttList.js. Coverage (Term): 37% Coverage (LOC): 38%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/XMLDTDEntity.js. Coverage (Term): 36% Coverage (LOC): 37%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/XMLDTDElement.js. Coverage (Term): 49% Coverage (LOC): 54%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/XMLDTDNotation.js. Coverage (Term): 46% Coverage (LOC): 51%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/XMLCData.js. Coverage (Term): 57% Coverage (LOC): 68%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/XMLComment.js. Coverage (Term): 57% Coverage (LOC): 68%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/XMLElement.js. Coverage (Term): 29% Coverage (LOC): 31%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/XMLAttribute.js. Coverage (Term): 33% Coverage (LOC): 48%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/XMLRaw.js. Coverage (Term): 57% Coverage (LOC): 68%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/XMLText.js. Coverage (Term): 57% Coverage (LOC): 68%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/XMLProcessingInstruction.js. Coverage (Term): 53% Coverage (LOC): 62%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/XMLWriterBase.js. Coverage (Term): 12% Coverage (LOC): 16%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/XMLDocumentCB.js. Coverage (Term): 21% Coverage (LOC): 33%
*- File /root/Targets/cmbot/node_modules/xmlbuilder/lib/XMLStreamWriter.js. Coverage (Term): 15% Coverage (LOC): 26%
*- File /root/Targets/cmbot/node_modules/xml2js/lib/parser.js. Coverage (Term): 10% Coverage (LOC): 12%
*- File /root/Targets/cmbot/node_modules/sax/lib/sax.js. Coverage (Term): 15% Coverage (LOC): 33%
*- File /root/Targets/cmbot/node_modules/xml2js/lib/bom.js. Coverage (Term): 54% Coverage (LOC): 60%
*- File /root/Targets/cmbot/node_modules/xml2js/lib/processors.js. Coverage (Term): 35% Coverage (LOC): 58%
*- File /root/Targets/cmbot/node_modules/dateformat/lib/dateformat.js. Coverage (Term): 17% Coverage (LOC): 43%
*- File /root/Targets/cmbot/node_modules/ttapi/lib/index.js. Coverage (Term): 76% Coverage (LOC): 100%
*- File /root/Targets/cmbot/node_modules/ttapi/lib/bot.js. Coverage (Term): 1% Coverage (LOC): 0%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
