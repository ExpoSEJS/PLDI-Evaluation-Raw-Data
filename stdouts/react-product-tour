/root/Targets/react-product-tour
└─┬ react-product-tour@1.1.1 
  ├── jquery@2.2.4 
  └─┬ react@0.14.9 
    ├─┬ envify@3.4.1 
    │ ├─┬ jstransform@11.0.3 
    │ │ ├── base62@1.2.0 
    │ │ ├─┬ commoner@0.10.8 
    │ │ │ ├── commander@2.11.0 
    │ │ │ ├─┬ detective@4.5.0 
    │ │ │ │ ├── acorn@4.0.13 
    │ │ │ │ └── defined@1.0.0 
    │ │ │ ├─┬ glob@5.0.15 
    │ │ │ │ ├─┬ inflight@1.0.6 
    │ │ │ │ │ └── wrappy@1.0.2 
    │ │ │ │ ├── inherits@2.0.3 
    │ │ │ │ ├─┬ minimatch@3.0.4 
    │ │ │ │ │ └─┬ brace-expansion@1.1.8 
    │ │ │ │ │   ├── balanced-match@1.0.0 
    │ │ │ │ │   └── concat-map@0.0.1 
    │ │ │ │ ├── once@1.4.0 
    │ │ │ │ └── path-is-absolute@1.0.1 
    │ │ │ ├── graceful-fs@4.1.11 
    │ │ │ ├── iconv-lite@0.4.19 
    │ │ │ ├─┬ mkdirp@0.5.1 
    │ │ │ │ └── minimist@0.0.8 
    │ │ │ ├── private@0.1.7 
    │ │ │ ├── q@1.5.0 
    │ │ │ └─┬ recast@0.11.23 
    │ │ │   ├── ast-types@0.9.6 
    │ │ │   ├── esprima@3.1.3 
    │ │ │   └── source-map@0.5.7 
    │ │ ├── esprima-fb@15001.1.0-dev-harmony-fb 
    │ │ ├── object-assign@2.1.1 
    │ │ └─┬ source-map@0.4.4 
    │ │   └── amdefine@1.0.1 
    │ └── through@2.3.8 
    └─┬ fbjs@0.6.1 
      ├── core-js@1.2.7 
      ├─┬ loose-envify@1.3.1 
      │ └── js-tokens@3.0.2 
      ├─┬ promise@7.3.1 
      │ └── asap@2.0.6 
      ├── ua-parser-js@0.7.14 
      └── whatwg-fetch@0.9.0 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/react-product-tour/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0529 took 3.3138s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (249:8) on program /**
 * Created by AntonioGiordano on 21/11/15.
 */

import React, {PropTypes} from 'react'
import $ from 'jquery'

var ReactProductTour = React.createClass({
  propTypes: {
    steps: PropTypes.array,
    enableAutoPositioning: PropTypes.bool,
    onTourEnd: PropTypes.func
  },
  getDefaultProps () {
    return {
      steps: [],
      enableAutoPositioning: true,
      onTourEnd () {}
    }
  },
  focusElemStyleProps: [
    'zIndex', 'position', 'borderRadius', 'boxShadow'
  ],
  modalPositions: [
    'top', 'bottom', 'right', 'left', 'center'
  ],
  arrowPositions: {
    'top': 'bottom',
    'bottom': 'top',
    'right': 'left',
    'left': 'right',
    'center': 'none'
  },
  constants: {
    MODAL_MAX_WIDTH: 320,
    MODAL_FULL_SCREEN_WIDTH: 450,
    MODAL_HEIGHT: 150,
    MODAL_ARROW_W: 16,
    DISTANCE_FROM_ELEM: 5
  },
  componentDidMount () {
    this.refs['rpt'].style.display = 'none'
  },
  getInitialState () {
    return {
      currentStep: -1,
      isTourActive: false,
      overlayZindex: 999999,
      overlayClass: 'rpt-overlay',
      modalClass: 'rpt-modal',
      arrowClass: 'rpt-arrow rpt-arrow-bottom',
      focusElem: null,
      oldFocusElemStyle: null
    }
  },
  resizer () {
    var state = {
      currentStep: this.state.currentStep,
      focusElem: this.state.focusElem
    }
    this.focusOnElement(state)
  },
  startTour () {
    $(window).off('resize', this.resizer)
    $(window).resize(this.resizer)
    $(window).off('scroll', this.resizer)
    $(window).scroll(this.resizer)
    this.refs['rpt'].style.display = 'block'
    var focusElem = this.getElement(0)
    var oldFocusStyle = {}
    for (var prop of this.focusElemStyleProps) {
      oldFocusStyle[prop] = focusElem.style[prop]
    }
    this.setState({
      isTourActive: true,
      overlayClass: 'rpt-overlay rpt-active',
      modalClass: 'rpt-modal rpt-active'
    })
    this.goToStep(0)
  },
  nextStep () {
    this.goToStep(this.state.currentStep + 1)
  },
  prevStep () {
    this.goToStep(this.state.currentStep - 1)
  },
  goToStep (index) {
    if (typeof this.props.steps[index].onChange === 'function') {
      this.props.steps[index].onChange(index)
    }
    this.restoreElemStyle()
    var focusElem = this.getElement(index)
    var oldFocusStyle = {}
    for (var prop of this.focusElemStyleProps) {
      oldFocusStyle[prop] = focusElem.style[prop]
    }
    this.setState({
      oldFocusElemStyle: oldFocusStyle,
      focusElem: focusElem,
      currentStep: index
    })
    var state = {
      currentStep: index,
      focusElem: focusElem
    }
    var ret = this.focusOnElement(state)
    if (typeof ret.top !== 'undefined') {
      $('html, body').animate({scrollTop: ret.top}, 200)
    }
  },
  getElement (currStep) {
    var steps = this.props.steps
    var focusElem
    // Evaluating focused element
    if (typeof steps[currStep].selector === 'function') {
      focusElem = steps[currStep].selector()
    } else if (typeof steps[currStep].selector === 'string') {
      focusElem = $(steps[currStep].selector)[0]
    }
    return focusElem
  },
  focusOnElement (nextState) {
    var steps = this.props.steps
    var currStep = nextState.currentStep
    var focusElem = nextState.focusElem
    var ret = {}
    if (currStep >= this.props.steps.length) {

    } else {
      if (typeof focusElem !== 'undefined' && focusElem !== null) {
        // Set focused element new style
        focusElem.style.zIndex = (this.state.overlayZindex + 1).toString()
        focusElem.style.position = 'relative'
        focusElem.style.borderRadius = '5px'
        focusElem.style.boxShadow = '0 0 6px rgba(0,0,0,.5)'
      }
      // Evaluating modal position
      var modalPosition = 'top'
      if (typeof steps[currStep].modalPosition === 'string') {
        if (this.modalPositions.indexOf(steps[currStep].modalPosition) !== -1) {
          modalPosition = steps[currStep].modalPosition
        } else {
          modalPosition = 'top'
        }
      }
      var elemTop = $(focusElem).offset().top
      var elemLeft = $(focusElem).offset().left
      var elemW = focusElem.offsetWidth
      var elemH = focusElem.offsetHeight
      var winW = $(window).width()
      var winH = $(window).height()
      // Check and eventually correct modal position (change if bool enabled and for lack of space)
      if (this.props.enableAutoPositioning) {
        var positionEnabled = {}
        positionEnabled['top'] = (elemTop > 150 && (winW - elemLeft > this.constants.MODAL_MAX_WIDTH))
        positionEnabled['left'] = (elemLeft > this.constants.MODAL_MAX_WIDTH && ($(window).height() - elemTop > 150))
        positionEnabled['right'] = ((winW - elemLeft - elemW > this.constants.MODAL_MAX_WIDTH) && (winH - elemTop > 150))
        positionEnabled['bottom'] = ((winH - elemTop - elemH > this.constants.MODAL_MAX_WIDTH) && (winW - elemLeft > this.constants.MODAL_MAX_WIDTH))
        positionEnabled['center'] = true
        if (!positionEnabled[modalPosition]) {
          ['top', 'left', 'right', 'bottom', 'center'].forEach((prop) => {
            if (!positionEnabled[modalPosition] && positionEnabled[prop]) {
              modalPosition = prop
            }
          })
        }
      }
      // Calculate modal position in window
      var top, left, width
      var bottom = 'initial'
      var height = 'auto'
      var modalPad = parseInt($(this.refs['modal']).css('padding-left').replace('px', ''), 10) * 2
      var scrollTop = window.scrollY
      var scrollLeft = window.scrollX
      switch (modalPosition) {
        case 'bottom':
          top = (elemTop + elemH + this.constants.MODAL_ARROW_W + this.constants.DISTANCE_FROM_ELEM - scrollTop).toString() + 'px'
          left = elemLeft + 5 - scrollLeft
          width = Math.min(winW - modalPad - 30, this.constants.MODAL_FULL_SCREEN_WIDTH)
          break
        case 'top':
          top = (elemTop - this.constants.MODAL_HEIGHT - this.constants.MODAL_ARROW_W - this.constants.DISTANCE_FROM_ELEM - scrollTop).toString() + 'px'
          left = elemLeft + 5 - scrollLeft
          width = Math.min(winW - modalPad - 30, this.constants.MODAL_FULL_SCREEN_WIDTH)
          height = this.constants.MODAL_HEIGHT - modalPad
          break
        case 'right':
          top = (elemTop - 5 - scrollTop).toString() + 'px'
          left = elemLeft + elemW + this.constants.MODAL_ARROW_W + this.constants.DISTANCE_FROM_ELEM - scrollLeft
          width = Math.min(winW - elemLeft - elemW - this.constants.MODAL_ARROW_W - this.constants.DISTANCE_FROM_ELEM - modalPad - 20, this.constants.MODAL_FULL_SCREEN_WIDTH)
          break
        case 'left':
          top = (elemTop - 5 - scrollTop).toString() + 'px'
          width = Math.min(elemLeft - this.constants.MODAL_ARROW_W - this.constants.DISTANCE_FROM_ELEM - modalPad - 20, this.constants.MODAL_FULL_SCREEN_WIDTH)
          left = elemLeft - width - this.constants.MODAL_ARROW_W - this.constants.DISTANCE_FROM_ELEM - modalPad - scrollLeft
          break
        case 'center':
          bottom = '5px'
          top = 'initial'
          left = 10
          width = winW - modalPad - 20
          break
      }
      // Set modal position
      $(this.refs['modal']).width(width)
      $(this.refs['modal']).height(height)
      this.refs['modal'].style.top = top
      this.refs['modal'].style.bottom = bottom
      this.refs['modal'].style.left = Math.floor(left).toString() + 'px'
      // Set modal arrow position based on modal position
      var arrowClass = 'rpt-arrow rpt-arrow-' + this.arrowPositions[modalPosition]
      this.setState({
        arrowClass: arrowClass
      })
      ret = {
        top: top !== 'initial' ? Math.min(parseInt(top.replace('px', ''), 10), elemTop) - 20 : elemTop - 20
      }
    }
    return ret
  },
  restoreElemStyle () {
    if (this.state.focusElem !== null) {
      for (var prop of this.focusElemStyleProps) {
        this.state.focusElem.style[prop] = this.state.oldFocusElemStyle[prop]
      }
    }
  },
  dismissTour () {
    $(window).off('resize', this.resizer)
    $(window).off('scroll', this.resizer)
    this.restoreElemStyle()
    this.setState({
      isTourActive: false,
      overlayClass: 'rpt-overlay',
      modalClass: 'rpt-modal',
      focusElem: null,
      oldFocusElemStyle: null
    })
    setTimeout(() => {
      this.refs['rpt'].style.display = 'none'
    }, 300)
    this.props.onTourEnd()
  },
  getIconClassName (index) {
    return this.state.currentStep === index ? 'rpt-step-icon rpt-step-icon-active' : 'rpt-step-icon'
  },
  render () {
    return (
        <div ref='rpt' className='rpt'>
          <div className={this.state.overlayClass} onClick={this.dismissTour} style={{zIndex: this.state.overlayZindex}} />
          <div ref='modal' className={this.state.modalClass} style={{zIndex: this.state.overlayZindex + 1}}>
            <div className={this.state.arrowClass}></div>
            {
              this.state.isTourActive ? (
                  <p>{this.props.steps[this.state.currentStep > -1 ? this.state.currentStep : 0].message}</p>
              ) : null
            }
              <div className='rpt-button-container'>
                {
                  this.state.currentStep > 0 ? (
                      <button onClick={this.prevStep}>Prev</button>
                  ) : (
                      null
                  )
                }
                <div className='rpt-steps-container'>
                  <div className='rpt-steps-icons-container'>
                    {
                      this.props.steps.map(function (step, index) {
                        return (
                            <div onClick={this.goToStep.bind(this, index)} className={this.getIconClassName.bind(this, index)()} key={index}></div>
                        )
                      }, this)
                    }
                  </div>
                  <button className='rpt-skip-button' onClick={this.dismissTour}>Skip</button>
                </div>
                {
                  this.state.currentStep < this.props.steps.length - 1 ? (
                      <button onClick={this.nextStep}>Next</button>
                  ) : (
                      <button onClick={this.dismissTour}>Done</button>
                  )
                }
              </div>
          </div>
        </div>
      )
  }
})

export default ReactProductTour
 at SyntaxError: Unexpected token (249:8)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$3.parseExprAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1822:12)
    at Parser.parseExprAtom (/root/ExpoSE/lib/Tropigate/bin/Expression.js:28:30)
    at Parser.pp$3.parseExprSubscripts (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1715:21)
    at Parser.parseMaybeUnary (/root/ExpoSE/lib/Tropigate/bin/Unary.js:34:29)
    at Parser.pp$3.parseExprOps (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1637:21)
    at Parser.pp$3.parseMaybeConditional (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1620:21)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1597:21)
    at Parser.pp$3.parseParenAndDistinguishExpression (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1861:32)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
