/root/Targets/ipld-graph-builder
└─┬ ipld-graph-builder@1.3.1 
  ├─┬ assert@1.4.1 
  │ └─┬ util@0.10.3 
  │   └── inherits@2.0.1 
  ├─┬ base-x@3.0.2 
  │ └── safe-buffer@5.1.1 
  ├─┬ cids@0.5.1 
  │ ├─┬ multibase@0.3.4 
  │ │ └── base-x@3.0.0 
  │ └── multicodec@0.1.9 
  └─┬ multihashes@0.4.9 
    ├── bs58@4.0.1 
    └── varint@5.0.0 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/ipld-graph-builder/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0313 took 2.101s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (3:6) on program const CID = require('cids')
const multihashes = require('multihashes')
const assert = require('assert')

function isValidCID (link) {
  try {
    CID.isCID(new CID(link))
  } catch (e) {
    return false
  }
  return true
}

function isObject (obj) {
  return typeof obj === 'object' && obj !== null
}

function clearObject (myObject) {
  for (var member in myObject) {
    delete myObject[member]
  }
}

function findLeafLinks (node) {
  let links = []
  for (const name in node) {
    const edge = node[name]
    if (isObject(edge)) {
      if (edge['/'] !== undefined && !isValidCID(edge)) {
        links.push(edge)
      } else {
        links = findLeafLinks(edge).concat(links)
      }
    }
  }
  return links
}

module.exports = class Graph {
  /**
   * @param {Object} ipfsDag an instance of [ipfs.dag](https://github.com/ipfs/interface-ipfs-core/tree/master/API/dag#dag-api)
   */
  constructor (ipfsDag) {
    assert(ipfsDag, 'ipld-graph must have an instance of ipfs.dag')
    this._dag = ipfsDag
    this._loading = new Map()
  }

  _loadCID (node, link, dropOptions = false) {
    const loadingOp = this._loading.get(link)
    if (loadingOp) {
      return loadingOp
    } else {
      const promise = new Promise(async (resolve, reject) => {
        const cid = new CID(link)
        if (!dropOptions) {
          node.options = {}
          node.options.format = cid.codec
          node.options.hashAlg = multihashes.decode(cid.multihash).name
        }
        let value = (await this._dag.get(cid)).value
        node['/'] = value
        this._loading.delete(link)
        resolve()
      })
      this._loading.set(link, promise)
      return promise
    }
  }

  /**
   * sets a value on a root object given its path
   * @param {Object} node
   * @param {String} path
   * @param {*} value
   * @return {Promise}
   */
  async set (node, path, value) {
    path = formatPath(path)
    value = {
      '/': value
    }
    const last = path.pop()
    let {
      value: foundVal,
      remainderPath: remainder,
      parent
    } = await this._get(node, path)

    // if the found value is a litaral attach an object to the parent object
    if (!isObject(foundVal)) {
      const pos = path.length - remainder.length - 1
      const name = path.slice(pos, pos + 1)[0]
      foundVal = parent[name] = {}
    }
    // extend the path for the left over path names
    for (const name of remainder) {
      foundVal = foundVal[name] = {}
    }
    foundVal[last] = value
    return node
  }

  /**
   * traverses an object's path and returns the resulting value in a Promise
   * @param {Object} node
   * @param {String} path
   * @param {boolean} dropOptions - whether to add the encoding options of the
   * nodes when loading from IPFS. Defaults to true
   * @return {Promise}
   */
  async get (node, path, dropOptions) {
    path = formatPath(path)
    const {value} = await this._get(node, path, dropOptions)
    return value
  }

  async _get (node, path, dropOptions) {
    let parent = node
    path = path.slice(0)
    while (1) {
      const link = node['/']
      // if there is a link, traverse throught it
      if (isValidCID(link)) {
        await this._loadCID(node, link, dropOptions)
      } else {
        if (link !== undefined) {
          // link is a POJO
          node = link
        }
        // traverse through POJOs
        if (!path.length) {
          break
        }
        const name = path.shift()
        const edge = node[name]
        node = edge
        if (isObject(edge)) {
          parent = node
        } else {
          break
        }
      }
    }
    return {
      value: node,
      remainderPath: path,
      parent: parent
    }
  }

  /**
   * Resolves all the links in an object and does so recusivly for N `level`
   * @param {Object} node
   * @param {Integer} levels
   * @param {boolean} dropOptions - whether to add the encoding options of the
   * nodes when loading from IPFS. Defaults to true
   * @return {Promise}
   */
  async tree (node, levels = 1, dropOptions) {
    const orignal = node
    if (node) {
      const link = node['/']
      if (isValidCID(link)) {
        await this._loadCID(node, link, dropOptions)
        node = node['/']
      }
      if (levels && isObject(node)) {
        levels--
        const promises = []
        for (const name in node) {
          const edge = node[name]
          promises.push(this.tree(edge, levels, dropOptions))
        }
        await Promise.all(promises)
      }
    }
    return orignal
  }

  _flush (node, opts) {
    const awaiting = []

    const links = findLeafLinks(node)
    links.forEach(link => awaiting.push(this._flush(link, opts)))

    return Promise.all(awaiting).then(() => {
      const link = node['/']
      let options = Object.assign(opts, node.options)
      delete node.options
      return this._dag.put(link, options).then(cid => {
        const str = cid.buffer
        node['/'] = str
      })
    })
  }

  /**
   * flush an object to ipfs returning the resulting CID in a promise
   * @param {Object} node
   * @param {Object} opts - encoding options for [`dag.put`](https://github.com/ipfs/interface-ipfs-core/tree/master/API/dag#dagput)
   * @param {Function} opts.onHash - a callback that happens on each merklized node. It is given two arguments `hash` and `node` which is the node that was hashed
   * @return {Promise}
   */
  async flush (node, opts = {}) {
    const defaults = {
      format: 'dag-cbor',
      hashAlg: 'sha2-256'
    }
    Object.assign(opts, defaults)
    if (!node['/']) {
      const oldRoot = Object.assign({}, node)
      clearObject(node)
      node['/'] = oldRoot
    }
    await this._flush(node, opts)
    return node
  }
}

function formatPath (path) {
  if (!path.split) {
    path = path.toString()
  }
  return path.split('/')
}
 at SyntaxError: Unexpected token (3:6)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
