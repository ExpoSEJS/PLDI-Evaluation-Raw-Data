/root/Targets/workhorse
└─┬ workhorse@0.1.0 
  ├─┬ connect@3.6.5 
  │ ├─┬ debug@2.6.9 
  │ │ └── ms@2.0.0 
  │ ├─┬ finalhandler@1.0.6 
  │ │ └── unpipe@1.0.0 
  │ ├── parseurl@1.3.2 
  │ └── utils-merge@1.0.1 
  ├── ejs@2.5.7 
  ├─┬ express@4.16.0 
  │ ├─┬ accepts@1.3.4 
  │ │ ├─┬ mime-types@2.1.17 
  │ │ │ └── mime-db@1.30.0 
  │ │ └── negotiator@0.6.1 
  │ ├── array-flatten@1.1.1 
  │ ├─┬ body-parser@1.18.2 
  │ │ ├── bytes@3.0.0 
  │ │ ├─┬ http-errors@1.6.2 
  │ │ │ ├── inherits@2.0.3 
  │ │ │ └── setprototypeof@1.0.3 
  │ │ ├── iconv-lite@0.4.19 
  │ │ └── raw-body@2.3.2 
  │ ├── content-disposition@0.5.2 
  │ ├── content-type@1.0.4 
  │ ├── cookie@0.3.1 
  │ ├── cookie-signature@1.0.6 
  │ ├── depd@1.1.1 
  │ ├── encodeurl@1.0.1 
  │ ├── escape-html@1.0.3 
  │ ├── etag@1.8.1 
  │ ├── finalhandler@1.1.0 
  │ ├── fresh@0.5.2 
  │ ├── merge-descriptors@1.0.1 
  │ ├── methods@1.1.2 
  │ ├─┬ on-finished@2.3.0 
  │ │ └── ee-first@1.1.1 
  │ ├── path-to-regexp@0.1.7 
  │ ├─┬ proxy-addr@2.0.2 
  │ │ ├── forwarded@0.1.2 
  │ │ └── ipaddr.js@1.5.2 
  │ ├── qs@6.5.1 
  │ ├── range-parser@1.2.0 
  │ ├── safe-buffer@5.1.1 
  │ ├─┬ send@0.16.0 
  │ │ ├── destroy@1.0.4 
  │ │ └── mime@1.4.1 
  │ ├── serve-static@1.13.0 
  │ ├── setprototypeof@1.1.0 
  │ ├── statuses@1.3.1 
  │ ├─┬ type-is@1.6.15 
  │ │ └── media-typer@0.3.0 
  │ └── vary@1.1.2 
  └── keys@0.1.0 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/workhorse/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 26% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0618 took 5.9918s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (4:4) on program var connect = require('connect'),
    express = require('express'),
    request = require('request'),
    assert = require('assert'),
    keys = require('keys'),
    log = require('./logger').log,
    problem_registry = require('./problem_registry');

/**
 * Creates a workhorse, along with it's data store and servers (see createServers() and register())
 */
exports.create = function(datastore) {
    return new workhorse(datastore);
};

exports.datastores = {
    couchdb: require('./datastores/couchdb')
};

/**
 * Create a new workhorse.
 */
function workhorse(datastore) {

    // Listeners for problem post events
    // TODO: extend EventEmitter instead
    var problem_listeners = [];
    function addProblemListener(listener) {
        validate([[listener, 'function']]);
        problem_listeners.push(listener);
    }

    function callProblemListeners() {
        for(var i = 0; i < problem_listeners.length; i++) {
            listener = problem_listeners[i];
            listener('workhorse problem added');
        }
    }

    if (!datastore) {
        datastore = new keys.Memory({ reapInterval: 200 });
        log('Warning: Using an in-memory data store. The problems and solutions will not be persisted'
                + ' between application restarts');
    }

    // Holds all of the solution_callback functions in memory
    var solution_callbacks = {};

    var registry = problem_registry.create(datastore);

    // TODO: move this out of here
    function validate(argtypes, message) {

        for (i in argtypes) {
            var arg = argtypes[i][0];
            var type = argtypes[i][1];
            assert.ok(arg, message);
            assert.equal(typeof arg, type);
        }

    }

    /**
     * Registers a problem to be solved
     * TODO: Change the order of the arguments so that callback args are at the end
     * @param problem_id -- a unique id
     * @param solver -- the type of solver that is used to solve this problem
     * @param data -- the data to pass to the solver
     * @param callback -- called after the problem is registered
     * @param solution_callback -- called once the problem has been solved
     */
    function postProblem(problem_id, solver, data, callback, solution_callback) {
        validate(
                [
                    [problem_id, 'string'],
                    [solver, 'string'],
                    [data, 'object'],
                    [callback, 'function']
                ],
                'Could not register a problem due to invalid arguments. Expecting:' +
                        '{ problem_id : "..."}, solver: "...", data: {...}, callback: function(err){...} }'
                );

        registry.register(
                problem_id,
                solver,
                data,
                function(err) {
                    if(!err) {
                        solution_callbacks[problem_id] = solution_callback;
                    }
                    callProblemListeners();
                    callback(err);
                });

    }

    // TODO: This should be the socket "ready:true" handler
    function getProblem(callback) {

        registry.getNextProblemToSolve(function(err, problem) {

            if (err) {
                throw callback(err);
            }
            else {
                if (!problem) {
                    // Not an error, but no problems. Caller shouldhandle this.
                    callback(null,null);
                }
                callback(null, problem);
            }

        });

    }

    // TODO: this should be the socket "postSolution" handler
    function postSolution(body, callback) {

        var solution = body.solution;
        var problem_id = body.problem_id;

        registry.solve(problem_id, solution, function(err, problem) {

            if (err) {
                callback(err);
            }
            else if(problem) {
                solution_callbacks[problem_id]({problem_id: problem_id, solution: solution});
                callback(null, {problem_id: problem_id, wrote_solution: "OK"});
            }

        });

    }

    // TODO: This should be an asynchronous function call to get a solution
    // TODO: Need a similar notion for a batch
    function getSolution(problem_id, callback) {

        registry.get(problem_id, function(err, problem) {

            if (err) {
                callback(err);
            }
            else if (!problem) {
                callback({ error: 'No problem with id [' + problem_id + ']'});
            }
            else if (!problem.solution) {
                callback({ error: 'No solution for problem with id [' + problem_id + ']' });
            }
            else if (problem.solution) {

                var solution = problem.solution;

                // respond with the solution
                callback(null, solution);

            }

        });

    }

    // TODO: need to figure out where/how the client script gets loaded/passed/etc.
    return {
        postSolution: postSolution,
        getSolution: getSolution,
        postProblem: postProblem,
        getProblem: getProblem,
        addProblemListener: addProblemListener
    };

}
 at SyntaxError: Unexpected token (4:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/workhorse/node_modules/workhorse/workhorse.js. Coverage (Term): 6% Coverage (LOC): 7%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
