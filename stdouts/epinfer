/root/Targets/epinfer
└─┬ epinfer@1.1.3 
  ├─┬ country-data@0.0.31 
  │ ├── currency-symbol-map@2.2.0 
  │ └── underscore@1.8.3 
  └── protoblast@0.1.12 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/epinfer/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 25% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","isArray","create","RegExp"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.049 took 9.5093s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: 'with' in strict mode (10:46) on program module.exports = function BlastPath(Blast, Collection) {

	var internalJPCache = {},
	    vm;

	try {
		vm = require('vm');
	} catch (err) {
		vm = {
			runInNewContext: function(expr, context) { with (context) return eval(expr); }
		};
	}

	function push(arr, elem) { arr = arr.slice(); arr.push(elem); return arr; }
	function unshift(elem, arr) { arr = arr.slice(); arr.unshift(elem); return arr; }

	/**
	 * Extract data from objects using JSONPath
	 *
	 * @author    Stefan Goessner    <goessner.net>
	 * @author    Jelle De Loecker   <jelle@develry.be>
	 * @since     0.1.0
	 * @version   0.1.0
	 *
	 * @param     {String}   expr   The string expression
	 */
	function JSONPath(expression, options) {

		if (!options || typeof options != 'object') {
			options = {};
		}

		if (!options.resultType) {
			options.resultType = 'value';
		}

		if (typeof options.flatten == 'undefined') {
			options.flatten = false;
		}

		if (typeof options.wrap == 'undefined') {
			options.wrap = true;
		}

		if (typeof options.sandbox == 'undefined') {
			options.sandbox = {};
		}

		this.expression = expression;
		this.options = options;
		this.resultType = options.resultType;
	};

	/**
	 * Compile a string expression
	 *
	 * @author    Stefan Goessner    <goessner.net>
	 * @author    Jelle De Loecker   <jelle@develry.be>
	 * @since     0.1.0
	 * @version   0.1.0
	 *
	 * @param     {String}   expr   The string expression
	 * 
	 * @return    {Array}
	 */
	Blast.defineValue(JSONPath.prototype, 'normalize', function normalize(expr) {

		var normalized,
		    exprList,
		    subx;

		if (internalJPCache[expr]) return internalJPCache[expr];

		subx = [];

		normalized = expr.replace(/[\['](\??\(.*?\))[\]']/g, function($0,$1){return "[#"+(subx.push($1)-1)+"]";})
						.replace(/'?\.'?|\['?/g, ";")
						.replace(/(;)?(\^+)(;)?/g, function(_, front, ups, back) { return ';' + ups.split('').join(';') + ';'; })
						.replace(/;;;|;;/g, ";..;")
						.replace(/;$|'?\]|'$/g, "");

		exprList = normalized.split(';').map(function(expr) {
			var match = expr.match(/#([0-9]+)/);
			return !match || !match[1] ? expr : subx[match[1]];
		});

		return internalJPCache[expr] = exprList;
	});

	/**
	 *
	 * @author    Stefan Goessner    <goessner.net>
	 * @since     0.1.0
	 * @version   0.1.0
	 *
	 * @param     {String}   path
	 * 
	 * @return    {String}
	 */
	Blast.defineValue(JSONPath.prototype, 'asPath', function asPath(path) {

		var i, p, x;

		x = path;
		p = '$';

		for (i = 1, n = x.length; i < n; i++) {
			p += /^[0-9*]+$/.test(x[i]) ? ("["+x[i]+"]") : ("['"+x[i]+"']");
		}

		return p;
	});

	/**
	 *
	 * @author    Stefan Goessner    <goessner.net>
	 * @since     0.1.0
	 * @version   0.1.0
	 * 
	 * @return    {Array}
	 */
	Blast.defineValue(JSONPath.prototype, 'trace', function trace(expr, val, path) {

		var that = this,
		    result,
		    ea,
		    i;

		// no expr to follow? return path and value as the result of this trace branch
		if (!expr.length) return [{path: path, value: val}];

		var loc = expr[0], x = expr.slice(1);
		// the parent sel computation is handled in the frame above using the
		// ancestor object of val
		if (loc === '^') return path.length ? [{path: path.slice(0,-1), expr: x, isParentSelector: true}] : [];

		// we need to gather the return value of recursive trace calls in order to
		// do the parent sel computation.
		var ret = [];
		function addRet(elems) { ret = ret.concat(elems); }

		if (val && val.hasOwnProperty(loc)) // simple case, directly follow property
			addRet(this.trace(x, val[loc], push(path, loc)));
		else if (loc === "*") { // any property
			this.walk(loc, x, val, path, function(m,l,x,v,p) {
				addRet(this.trace(unshift(m, x), v, p)); });
		}
		else if (loc === "..") { // all chid properties
			addRet(this.trace(x, val, path));
			this.walk(loc, x, val, path, function(m,l,x,v,p) {
				if (typeof v[m] === "object")
					addRet(that.trace(unshift("..", x), v[m], push(p, m)));
			});
		}
		else if (loc[0] === '(') { // [(expr)]
			addRet(this.trace(unshift(this.eval(loc, val, path[path.length], path),x), val, path));
		}
		else if (loc.indexOf('?(') === 0) { // [?(expr)]
			this.walk(loc, x, val, path, function(m,l,x,v,p) {
				if (this.eval(l.replace(/^\?\((.*?)\)$/,"$1"),v[m],m, path))
					addRet(that.trace(unshift(m,x),v,p));
			});
		}
		else if (loc.indexOf(',') > -1) { // [name1,name2,...]
			for (var parts = loc.split(','), i = 0; i < parts.length; i++)
				addRet(this.trace(unshift(parts[i], x), val, path));
		}
		else if (/^(-?[0-9]*):(-?[0-9]*):?([0-9]*)$/.test(loc)) { // [start:end:step]  python slice syntax
			addRet(this.slice(loc, x, val, path));
		}

		result = [];

		// we check the resulting values for parent selections. for parent
		// selections we discard the value object and continue the trace with the
		// current val object
		for (i = 0; i < ret.length; i++) {
			ea = ret[i];

			if (ea.isParentSelector) {
				result.push(this.trace(ea.expr, val, ea.path));
			} else {
				result.push(ea);
			}
		}

		return result;
	});

	/**
	 * Walk over the entries in a certain object
	 *
	 * @author    Stefan Goessner    <goessner.net>
	 * @since     0.1.0
	 * @version   0.1.0
	 */
	Blast.defineValue(JSONPath.prototype, 'walk', function walk(loc, expr, val, path, f) {

		var i, m, n;

		if (Array.isArray(val)) {
			for (i = 0, n = val.length; i < n; i++)
				f(i, loc, expr, val, path);
		} else if (typeof val === "object") {
			for (var m in val) {
				if (val.hasOwnProperty(m)) {
					f(m, loc, expr, val, path);
				}
			}
		}
	});

	/**
	 *
	 * @author    Stefan Goessner    <goessner.net>
	 * @since     0.1.0
	 * @version   0.1.0
	 *
	 * @return    {Array}
	 */
	Blast.defineValue(JSONPath.prototype, 'slice', function slice(loc, expr, val, path) {
		if (!Array.isArray(val)) return;
		var len = val.length, parts = loc.split(':'),
			 start = (parts[0] && parseInt(parts[0])) || 0,
			 end = (parts[1] && parseInt(parts[1])) || len,
			 step = (parts[2] && parseInt(parts[2])) || 1;
		start = (start < 0) ? Math.max(0,start+len) : Math.min(len,start);
		end   = (end < 0)   ? Math.max(0,end+len)   : Math.min(len,end);
		var ret = [];
		for (var i = start; i < end; i += step)
			ret = ret.concat(this.trace(unshift(i,expr), val, path));
		return ret;
	});

	/**
	 *
	 * @author    Stefan Goessner    <goessner.net>
	 * @since     0.1.0
	 * @version   0.1.0
	 */
	Blast.defineValue(JSONPath.prototype, 'eval', function eval(code, _v, _vname, path) {
		if (!$ || !_v) return false;
		if (code.indexOf("@path") > -1) {
			this.sandbox["_path"] = this.asPath(path.concat([_vname]));
			code = code.replace(/@path/g, "_path");
		}
		if (code.indexOf("@") > -1) {
			this.sandbox["_v"] = _v;
			code = code.replace(/@/g, "_v");
		}
		try {
			return vm.runInNewContext(code, this.sandbox);
		}
		catch(e) {
			console.log(e);
			throw new Error("jsonPath: " + e.message + ": " + code);
		}
	});

	/**
	 * Execute this path on the given object
	 *
	 * @author    Stefan Goessner    <goessner.net>
	 * @author    Jelle De Loecker   <jelle@develry.be>
	 * @since     0.1.0
	 * @version   0.1.0
	 *
	 * @param     {Object}   obj   The object to apply the path to
	 * 
	 * @return    {Array}
	 */
	Blast.defineValue(JSONPath.prototype, 'exec', function exec(obj, resultType) {

		var that = this,
		    valOrPath,
		    exprList,
		    result,
		    traced,
		    temp,
		    i;

		if (!resultType) {
			resultType = 'value';
		}

		exprList = this.normalize(this.expression);
		if (exprList[0] === "$" && exprList.length > 1) exprList.shift();

		traced = this.trace(exprList, obj, ["$"]);

		temp = [];

		for (i = 0; i < traced.length; i++) {
			if (!traced[i].isParentSelector) {
				temp.push(traced[i]);
			}
		}

		if (!temp.length) {
			return this.wrap ? [] : false;
		}

		if (temp.length === 1 && !this.wrap && !Array.isArray(temp[0].value)) {
			return temp[0][resultType] || false;
		}

		result = [];

		for (i = 0; i < temp.length; i++) {

			valOrPath = temp[i][resultType];

			if (resultType === 'path') valOrPath = this.asPath(valOrPath);

			if (that.flatten && Array.isArray(valOrPath)) {
				result = result.concat(valOrPath);
			} else {
				result.push(valOrPath);
			}
		}

		return result;
	});

	Blast.defineClass('JSONPath', JSONPath);
}; at SyntaxError: 'with' in strict mode (10:46)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$1.parseWithStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:932:27)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:708:32)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseBlock (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:981:25)
    at Parser.pp$3.parseFunctionBody (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2105:24)
    at Parser.parseFunctionBody (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:14:32)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1065:10)
    at Parser.pp$3.parseExprAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1810:19)
    at Parser.parseExprAtom (/root/ExpoSE/lib/Tropigate/bin/Expression.js:28:30)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/epinfer/node_modules/epinfer/lib/init.js. Coverage (Term): 2% Coverage (LOC): 1%
*- File /root/Targets/epinfer/node_modules/protoblast/index.js. Coverage (Term): 95% Coverage (LOC): 100%
*- File /root/Targets/epinfer/node_modules/protoblast/lib/init.js. Coverage (Term): 40% Coverage (LOC): 48%
*- File /root/Targets/epinfer/node_modules/protoblast/lib/function_inheritance.js. Coverage (Term): 49% Coverage (LOC): 52%
*- File /root/Targets/epinfer/node_modules/protoblast/lib/function.js. Coverage (Term): 17% Coverage (LOC): 27%
*- File /root/Targets/epinfer/node_modules/protoblast/lib/array.js. Coverage (Term): 10% Coverage (LOC): 15%
*- File /root/Targets/epinfer/node_modules/protoblast/lib/boolean.js. Coverage (Term): 69% Coverage (LOC): 86%
*- File /root/Targets/epinfer/node_modules/protoblast/lib/crypto.js. Coverage (Term): 16% Coverage (LOC): 25%
*- File /root/Targets/epinfer/node_modules/protoblast/lib/date.js. Coverage (Term): 17% Coverage (LOC): 29%
*- File /root/Targets/epinfer/node_modules/protoblast/lib/error.js. Coverage (Term): 31% Coverage (LOC): 48%
*- File /root/Targets/epinfer/node_modules/protoblast/lib/informer.js. Coverage (Term): 8% Coverage (LOC): 13%
*- File /root/Targets/epinfer/node_modules/protoblast/lib/functionqueue.js. Coverage (Term): 11% Coverage (LOC): 15%
*- File /root/Targets/epinfer/node_modules/protoblast/lib/iterator.js. Coverage (Term): 38% Coverage (LOC): 44%
*- File /root/Targets/epinfer/node_modules/protoblast/lib/deck.js. Coverage (Term): 16% Coverage (LOC): 24%
*- File /root/Targets/epinfer/node_modules/protoblast/lib/json.js. Coverage (Term): 9% Coverage (LOC): 10%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
