
> uws@0.14.5 install /root/Targets/storekey/node_modules/uws
> node-gyp rebuild > build_log.txt 2>&1 || exit 0

/root/Targets/storekey
└─┬ storekey@0.0.2 
  ├─┬ clui@0.3.6 
  │ └─┬ cli-color@0.3.2 
  │   ├── d@0.1.1 
  │   ├─┬ es5-ext@0.10.30 
  │   │ ├─┬ es6-iterator@2.0.1 
  │   │ │ └── d@1.0.0 
  │   │ └─┬ es6-symbol@3.1.1 
  │   │   └── d@1.0.0 
  │   ├─┬ memoizee@0.3.10 
  │   │ ├─┬ es6-weak-map@0.1.4 
  │   │ │ ├── es6-iterator@0.1.3 
  │   │ │ └── es6-symbol@2.0.1 
  │   │ ├─┬ event-emitter@0.3.5 
  │   │ │ └── d@1.0.0 
  │   │ ├── lru-queue@0.1.0 
  │   │ └── next-tick@0.2.2 
  │   └─┬ timers-ext@0.1.2 
  │     └── next-tick@1.0.0 
  └─┬ socket.io@2.0.3 
    ├─┬ debug@2.6.9 
    │ └── ms@2.0.0 
    ├─┬ engine.io@3.1.2 
    │ ├─┬ accepts@1.3.3 
    │ │ ├─┬ mime-types@2.1.17 
    │ │ │ └── mime-db@1.30.0 
    │ │ └── negotiator@0.6.1 
    │ ├── base64id@1.0.0 
    │ ├── cookie@0.3.1 
    │ ├─┬ engine.io-parser@2.1.1 
    │ │ ├── after@0.8.2 
    │ │ ├── arraybuffer.slice@0.0.6 
    │ │ └── blob@0.0.4 
    │ ├── uws@0.14.5 
    │ └─┬ ws@2.3.1 
    │   ├── safe-buffer@5.0.1 
    │   └── ultron@1.1.0 
    ├── object-assign@4.1.1 
    ├── socket.io-adapter@1.1.1 
    ├─┬ socket.io-client@2.0.3 
    │ ├── backo2@1.0.2 
    │ ├── base64-arraybuffer@0.1.5 
    │ ├── component-bind@1.0.0 
    │ ├── component-emitter@1.2.1 
    │ ├─┬ engine.io-client@3.1.2 
    │ │ ├── component-inherit@0.0.3 
    │ │ ├── xmlhttprequest-ssl@1.5.3 
    │ │ └── yeast@0.1.2 
    │ ├── has-cors@1.1.0 
    │ ├── indexof@0.0.1 
    │ ├── object-component@0.0.3 
    │ ├─┬ parseqs@0.0.5 
    │ │ └─┬ better-assert@1.0.2 
    │ │   └── callsite@1.0.0 
    │ ├── parseuri@0.0.5 
    │ └── to-array@0.1.4 
    └─┬ socket.io-parser@3.1.2 
      ├── has-binary2@1.0.2 
      └── isarray@2.0.1 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/storekey/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0262 took 2.3032s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: The keyword 'package' is reserved (8:0) on program /**
 * Storekey Server
 **/

http = require('http');
fs = require('fs');
path = require('path');
package = require('./package.json');
var port = 1337;
var io = require('socket.io').listen(port);
var os   = require('os'),
    clui = require('clui');

var allocation = 32000000; // 32mb max key value memory usage
var allocated = 0;
var datastore = {};
var datadiff = "";
var lastcheck = 0;
var tick = 0;
var nile = 1024;
var deltajson = path.resolve(__dirname + "/storage/delta.txt");
var delta = Math.ceil(fs.readFileSync(deltajson).toString()).toFixed(0);
var storekeyjson = path.resolve(__dirname + "/storage/storekey.json");
var uptime = new Date();
var tock = 0;
var bestTick = 10;
var ticker = [0,0,0,0,0,0,0,0,0,0,0,0];
var saving = false;

//
// DATA STORAGE
//
var datastore = require(storekeyjson);
    if (datastore !== "") {
        console.log("Storage Delta: ", delta);
        console.log("Loaded Stored Keys: ", storekeyjson);
        var date = new Date();
        for (var ds in datastore) {
            if (typeof datastore[ds] !== "undefined") {
                allocated += JSON.stringify(datastore[ds]).length;
                if (datastore[ds].expires < date.getTime()) {
                    allocated -= JSON.stringify(datastore[ds]).length;
                    delete datastore[ds];
                    lastcheck = date.getTime();
                    tick++;
                }
            }
        }
        lastcheck = date.getTime();
        console.log("Memory Allocated: ", allocated +" bytes %", (allocated/allocation *100).toFixed(2));
    }

//
// DATE SORT FUNCTION
//
function custom_sort(a, b) {
    return new Date(a.expires).getTime() - new Date(b.expires).getTime();
}

var number = 1;
var statsinterval = null;
var Spinner = clui.Spinner;
var countdown = new Spinner('');
var datastoreLENGTH = Object.keys(datastore).length;

// Interval Based Object Counts (Enable For Debugging Only
//setInterval(function() {
//    datastoreLENGTH = Object.keys(datastore).length;
//},15000);

function storekey_stats() {
    var Gauge = clui.Gauge;
    var total = os.totalmem();
    var free = os.freemem();
    var used = total - free;
    var human = Math.ceil(used / 1000000) + ' MB';
    var lines = process.stdout.getWindowSize()[1];
    var Sparkline = require('clui').Sparkline;
    ticker.push(tick);
    if (ticker.length>12) {
        ticker.shift();
    }
    if (bestTick<tick) {
        bestTick = tick;
    }
    var reqSec = Sparkline(ticker, 'reqs/sec');
    var sysMem = Gauge(used, total, 20, total * 0.8, human);
    var skMem = Gauge(allocated, allocation, 20, allocation * 0.8, Math.ceil(allocated / 1000000) + ' MB');
    for(var i = 0; i < lines; i++) {
        console.log('\r\n');
    }
    var Progress = clui.Progress;
    var thisProgressBar = new Progress(20);
    //console.log(" Storekey Objects: "+ datastoreLENGTH); // Debugging Only!
    console.log(" Uptime:",tock);
    console.log(" StoreKey Load:   "+ thisProgressBar.update(tick, bestTick));
    console.log(" Requests/Sec:    "+ reqSec);
    console.log(" System Memory:   "+ sysMem);
    console.log(" Storekey Memory: "+ skMem);
    console.log(" Delta:",delta);
    console.log("");
    clearInterval(statsinterval);
    delete reqSec;
    delete memObj;
    delete sysMem;
    delete skMem;
    tick = 0;
    tock++;

    if (saving) {
        countdown.start();
        var savex = setInterval(function() {
            if (!saving) {
                countdown.stop();   
                clearInterval(savex);
            }
        }, 1000);
    }
}

//
// SHOW STOREKEY DATA
//
var date = new Date();
setInterval(function() {
    storekey_stats();
}, 1000);

//
// SAVE THE DATASTORE ARCHIVE INTERVAL
//
var date = new Date();
setInterval(function() {
    if (saving) {
        return;
    } else {
        saving = true;
        for (var ds in datastore) {
            if (datastore[ds].expires<date.getTime()) {
                allocated -= JSON.stringify(datastore[ds]).length;
                delete datastore[ds];
                tick++;
            }
        }
        datastore = Object.keys(datastore).sort(custom_sort);
        for (var ds in datastore) {
            if (allocated>allocation) {
                allocated -= JSON.stringify(datastore[ds]).length;
                delete datastore[ds];
                lastcheck = date.getTime();
                tick++;
            }
        }
        lastcheck = date.getTime();
        delta++;

        fs.writeFile(deltajson, delta, {flag:"w+"}, function() {
            fs.writeFile(storekeyjson, JSON.stringify(datastore), {flag:"w+"}, function() {
                saving = false;
            });
        });
    }
}, 60000);

//
// SERVER STARTUP STATUS
//
console.log("STORE KEY SERVER - Version ", package.version);
console.log("Listening On Port ", port);
console.log("Allocating ", allocation, " bytes");
console.log("\n================================================\n=         STORE KEY SERVER NOW ONLINE!         =\n================================================\n");

//
// GET DATA
//
function getData(data, cb) {
    if (typeof datastore[data[0].key] !== "undefined") {
        var date = new Date();
        if (datastore[data[0].key].expires>date.getTime()) {
            cb({
                key: data[0].key,
                value: datastore[data[0].key].value,
                expires: datastore[data[0].key].expires
            });
        }
    }
}

//
// SET DATA
//
function setData(data, cb) {
    while (allocated>allocation) {
        if (datastore[data[0].key]) {
            tick++;
            allocated -= JSON.stringify(datastore[data[0]]).length;
            delete datastore[data[0].key];
        } else {
            break;
        }
    }
    datastore[data[0].key] = {
        value: data[0].value,
        expires: data[0].expires
    };
    allocated += JSON.stringify(datastore[data[0].key]).length;
}

//
// DELETE DATA
//
function deleteData(data, cb) {
    if (typeof datastore[data[0].key] !== "undefined") {
        if (typeof datastore[data[0]] !== "undefined") {
            allocated -= JSON.stringify(datastore[data[0]]).length;
        }
        delete datastore[data[0].key];
        cb(true);
    }
}

//
// LISTEN FOR CONNECTIONS
//
io.on('connection', function (socket) {

    /**
     * Occurs when the client disconnects from the server
     * @var string reason - Optional - reason for disconnecting, not used
     */
    socket.on('disconnected', function (reason) {
    // Disconnected User
    });


    /**
     * Occurs when a client requests data
     * @var string data - Key of the memory object to get
     */
    socket.on('get', function(data) {
        getData(data, function(bits) {
            socket.emit('get', bits);
        });
        tick++;
    });


    /**
     * Occurs when a client requests data synchronously
     * @var string data - Key of the memory object to get
     * @function fn - Function to callback upon data completion
     */
    socket.on('getSync', function(data,fn) {
        getData(data, function(bits) {
            socket.emit('getSync', bits);
        });
        tick++;
    });


    /**
     * Occurs when a client sets data
     * @var string data - Key & Value of the data to set
     */
    socket.on('set', function(data) {
        setData(data, function(bits) {
        });
        tick++;
    });


    /**
     * Occurs when a client sets data synchronously
     * @var string data - Key & Value of the data to set
     * @function fn - Function to callback upon data completion
     */
    socket.on('setSync', function(data) {
        setData(data, function(bits) {
            socket.emit('setSync');
        });
        tick++;
    });


    /**
     * Occurs when a client requests a deletion
     * @var string data - Key of the data to remove
     */
    socket.on('delete', function(data) {
        deleteData(data, function(bits) {
        });
        tick++;
    });


    /**
     * Occurs when a client requests a deletion synchronously
     * @var string data - Key of the data to remove
     * @function fn - Function to callback upon data completion
     */
    socket.on('deleteSync', function(data) {
        deleteData(data, function(bits) {
            socket.emit('deleteSync');
        });
        tick++;
    });

    //
    // CONNECTED
    //
    socket.emit('connected', {
        "online": "true"
    });

});
 at SyntaxError: The keyword 'package' is reserved (8:0)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$3.parseIdent (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2182:14)
    at Parser.pp$3.parseExprAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1774:21)
    at Parser.parseExprAtom (/root/ExpoSE/lib/Tropigate/bin/Expression.js:28:30)
    at Parser.pp$3.parseExprSubscripts (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1715:21)
    at Parser.parseMaybeUnary (/root/ExpoSE/lib/Tropigate/bin/Unary.js:34:29)
    at Parser.pp$3.parseExprOps (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1637:21)
    at Parser.pp$3.parseMaybeConditional (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1620:21)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1597:21)
    at Parser.pp$3.parseExpression (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1573:21)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
