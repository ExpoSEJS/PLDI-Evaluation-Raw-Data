/root/Targets/npg_ranger
└─┬ npg_ranger@1.4.2 
  ├─┬ async@2.1.4 
  │ └── lodash@4.17.4 
  ├─┬ commander@2.9.0 
  │ └── graceful-readlink@1.0.1 
  ├─┬ config-chain@1.1.11 
  │ ├── ini@1.3.4 
  │ └── proto-list@1.2.4 
  ├─┬ fs-extra@2.0.0 
  │ ├── graceful-fs@4.1.11 
  │ └── jsonfile@2.4.0 
  ├── http-shutdown@1.1.0 
  ├── js-md5@0.4.2 
  ├── moment@2.17.1 
  ├─┬ mongodb@2.2.22 
  │ ├── es6-promise@3.2.1 
  │ ├─┬ mongodb-core@2.1.7 
  │ │ ├── bson@1.0.4 
  │ │ └─┬ require_optional@1.0.1 
  │ │   ├── resolve-from@2.0.0 
  │ │   └── semver@5.4.1 
  │ └─┬ readable-stream@2.1.5 
  │   ├── buffer-shims@1.0.0 
  │   ├── core-util-is@1.0.2 
  │   ├── inherits@2.0.3 
  │   ├── isarray@1.0.0 
  │   ├── process-nextick-args@1.0.7 
  │   ├── string_decoder@0.10.31 
  │   └── util-deprecate@1.0.2 
  ├── node-getopt@0.2.3 
  ├─┬ request@2.79.0 
  │ ├── aws-sign2@0.6.0 
  │ ├── aws4@1.6.0 
  │ ├── caseless@0.11.0 
  │ ├─┬ combined-stream@1.0.5 
  │ │ └── delayed-stream@1.0.0 
  │ ├── extend@3.0.1 
  │ ├── forever-agent@0.6.1 
  │ ├─┬ form-data@2.1.4 
  │ │ └── asynckit@0.4.0 
  │ ├─┬ har-validator@2.0.6 
  │ │ ├─┬ chalk@1.1.3 
  │ │ │ ├── ansi-styles@2.2.1 
  │ │ │ ├── escape-string-regexp@1.0.5 
  │ │ │ ├─┬ has-ansi@2.0.0 
  │ │ │ │ └── ansi-regex@2.1.1 
  │ │ │ ├── strip-ansi@3.0.1 
  │ │ │ └── supports-color@2.0.0 
  │ │ ├─┬ is-my-json-valid@2.16.1 
  │ │ │ ├── generate-function@2.0.0 
  │ │ │ ├─┬ generate-object-property@1.2.0 
  │ │ │ │ └── is-property@1.0.2 
  │ │ │ ├── jsonpointer@4.0.1 
  │ │ │ └── xtend@4.0.1 
  │ │ └─┬ pinkie-promise@2.0.1 
  │ │   └── pinkie@2.0.4 
  │ ├─┬ hawk@3.1.3 
  │ │ ├── boom@2.10.1 
  │ │ ├── cryptiles@2.0.5 
  │ │ ├── hoek@2.16.3 
  │ │ └── sntp@1.0.9 
  │ ├─┬ http-signature@1.1.1 
  │ │ ├── assert-plus@0.2.0 
  │ │ ├─┬ jsprim@1.4.1 
  │ │ │ ├── assert-plus@1.0.0 
  │ │ │ ├── extsprintf@1.3.0 
  │ │ │ ├── json-schema@0.2.3 
  │ │ │ └─┬ verror@1.10.0 
  │ │ │   └── assert-plus@1.0.0 
  │ │ └─┬ sshpk@1.13.1 
  │ │   ├── asn1@0.2.3 
  │ │   ├── assert-plus@1.0.0 
  │ │   ├── bcrypt-pbkdf@1.0.1 
  │ │   ├─┬ dashdash@1.14.1 
  │ │   │ └── assert-plus@1.0.0 
  │ │   ├── ecc-jsbn@0.1.1 
  │ │   ├─┬ getpass@0.1.7 
  │ │   │ └── assert-plus@1.0.0 
  │ │   ├── jsbn@0.1.1 
  │ │   └── tweetnacl@0.14.5 
  │ ├── is-typedarray@1.0.0 
  │ ├── isstream@0.1.2 
  │ ├── json-stringify-safe@5.0.1 
  │ ├─┬ mime-types@2.1.17 
  │ │ └── mime-db@1.30.0 
  │ ├── oauth-sign@0.8.2 
  │ ├── qs@6.3.2 
  │ ├── stringstream@0.0.5 
  │ ├─┬ tough-cookie@2.3.3 
  │ │ └── punycode@1.4.1 
  │ ├── tunnel-agent@0.4.3 
  │ └── uuid@3.1.0 
  ├─┬ send@0.14.2 
  │ ├─┬ debug@2.2.0 
  │ │ └── ms@0.7.1 
  │ ├── depd@1.1.1 
  │ ├── destroy@1.0.4 
  │ ├── encodeurl@1.0.1 
  │ ├── escape-html@1.0.3 
  │ ├── etag@1.7.0 
  │ ├── fresh@0.3.0 
  │ ├─┬ http-errors@1.5.1 
  │ │ └── setprototypeof@1.0.2 
  │ ├── mime@1.3.4 
  │ ├── ms@0.7.2 
  │ ├─┬ on-finished@2.3.0 
  │ │ └── ee-first@1.1.1 
  │ ├── range-parser@1.2.0 
  │ └── statuses@1.3.1 
  └─┬ winston@2.3.1 
    ├── async@1.0.0 
    ├── colors@1.0.3 
    ├── cycle@1.0.3 
    ├── eyes@0.1.8 
    └── stack-trace@0.0.10 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/npg_ranger/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 34% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.069 took 2.8168s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (4:6) on program "use strict";

const EventEmitter = require('events');
const assert       = require('assert');

const HTTPAsPromise = require('./httpAsPromise');

/**
 * @external events
 * @see {@link https://nodejs.org/dist/latest-v4.x/docs/api/events.html|events}
 */

/**
 * @external EventEmitter
 * @see {@link https://nodejs.org/dist/latest-v4.x/docs/api/events.html#events_class_eventemitter|EventEmitter}
 */

/**
 * <p>Module which provides the RangerRequest object. This object is a wrapper of the generic
 * http request. It understands GA4GH data API and therefore simplifies requests.</p>
 *
 * <p>Defines implemented ready states reported by HTTPAsPromise object during a
 * request
 * (see <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState">
 * XMLHttpRequest.readyState</a>).</p>
 *
 * <p>Defines http error code used to report npg_ranger library-exclusive
 * errors (<code>424</code>)</p>
 *
 * @module client/rangerRequest
 *
 * @requires {@link external:events|events}
 * @requires {@link external:assert|assert}
 * @requires module:client/httpAsPromise
 *
 * @author Jaime Tovar
 * @copyright Genome Research Limited 2017
 */

/**
 * Set to <i>0</i>. Client has been created. <code>open()</code> not called yet.
 * @type {Number}
 */
const UNSENT = 0;

/**
 * Set to <i>1</i>. Matching XMLHttpRequest.<code>open()</code> has been called for this request.
 * @type {Number}
 */
const OPENED = 1;

// const HEADERS_RECEIVED = 2; // send() has been called, and headers and status are available.
// const LOADING          = 3; // Downloading; responseText holds partial data.

/**
 * Set to <i>4</i>. The operation is complete
 * @type {Number}
 */
const DONE   = 4;

const ENC_DATA_PREFIX = 'data:application/vnd-ga4gh;base64,';

/**
 * The 3-digit HTTP request error code. Set as <code>424</code> following the
 * 400's for client requests.
 * <p>This is the kind of error raised when for example:</p>
 * <ul>
 *  <li>
 *    there was an error but no error code can be obtained from the lower
 *    level http request implementation
 *  </li>
 *  <li>
 *    the process fails before the lower level http request is created
 *  </li>
 *  <li>
 *    the process fails after the lower level http request is finished but
 *    before this module can process it
 *  </li>
 * </ul>
 * @type {Number}
 */
const DEFAULT_APPLICATION_ERROR_CODE = 424;

/*
 * Merge properties of two objects passed as parameters, give priority
 * (don't overwrite) properties of first parameter.
 * Returns a new object with the merged properties
 * @param {object} h1 - First header object, properties of this object will
 *                      have priority over the second object
 * @param {object} h2 - Second header object
 * @return {object} New object with merged properties
 */
var _mergeHeaders = (h1, h2) => {
  assert(h1, 'headers 1 is required');
  assert(h2, 'headers 2 is required');
  assert(typeof h1 === 'object', 'headers 1 must be an object');
  assert(typeof h2 === 'object', 'headers 2 must be an object');
  var mergedHeaders = {};

  for ( let i in h1 ) {
    mergedHeaders[i] = h1[i];
  }
  for ( let i in h2 ) {
    if ( typeof mergedHeaders[i] === 'undefined' ) {
      mergedHeaders[i] = h2[i];
    }
  }
  return mergedHeaders;
};

/**
 * Process a data buffer containing a GA4GH JSON response. Will extract URIs and
 * their corresponding headers.
 * @param  {string|Buffer} data Data in JSON format
 * @return {object}             Object with two lists one for URIs and one for
 *                              the corresponding headers. Both lists should be
 *                              of same size.
 */
var procJSON = ( data, headers ) => {
  assert(data, 'data is required');
  let decdStr;
  headers = headers || {};
  if ( typeof data === 'string' ) {
    decdStr = data;
  } else {
    // TODO suspect big buffers may overflow with this method
    decdStr = String.fromCharCode.apply(null, new Uint8Array( data ));
  }

  var jsonResponse = JSON.parse(decdStr);
  var uris         = [];
  var headers4uris = [];

  var prefix;
  var suffix;

  for (let i = 0; i < jsonResponse.urls.length; i++ ) {
    let uri;
    if ( jsonResponse.urls[i].url ) {
      uri = jsonResponse.urls[i].url;
      if ( jsonResponse.urls[i].headers ) {

        // Merge headers, give priority to new headers provided
        headers = _mergeHeaders(jsonResponse.urls[i].headers, headers);
      }
    } else {
      throw new Error( 'Malformed JSON redirect, missing url field in: ' +
                       JSON.stringify(jsonResponse.urls[i]) );
    }
    uris[i] = uri;
    headers4uris[i] = headers;
  }

  if ( jsonResponse.prefix && jsonResponse.prefix.length ) {
    prefix = ENC_DATA_PREFIX + jsonResponse.prefix;
    uris.unshift(prefix);
    headers4uris.unshift({});
  }

  if ( jsonResponse.suffix && jsonResponse.suffix.length ) {
    suffix = ENC_DATA_PREFIX + jsonResponse.suffix;
    uris.push(suffix);
    headers4uris.push({});
  }

  return {
    uris:         uris,
    headers4uris: headers4uris
  };
};

/**
 * Class wrapping the business logic of a GA4GH request and exposing it, as
 * much as possible, as a {@link external:EventEmitter|EventEmitter} based on
 * the http request pattern.
 *
 * @example
 * var RangerRequest = require('npg_ranger').RangerRequest;
 * var url = 'http://192.168.0.1:5050/' +
 *           'resources/AA0011?referenceName=1&start=165000&end=175000&format=BAM';
 * var request = new RangerRequest();
 * request.open('GET', url);
 * // Add listeners
 * request.onreadystatechange = () => {
 *   console.log('readystatechange' + request.readyState);
 *   // ...
 * }
 * request.send('');
 *
 * @extends {external:EventEmitter}
 */
class RangerRequest extends EventEmitter {
  /**
   * Returns a RangerRequest object initilised with readyState set to
   * <code>UNSENT</code>. It also sets up default calls for error and
   * readystatechange events. It is expected listeners should will assigned
   * to process these events.
   */
  constructor ( acceptTrailers ) {
    super();
    this.readyState       = UNSENT;
    this.status           = 0;
    this.response         = '';
    this.withCredentials  = false;
    this.acceptTrailers   = !!acceptTrailers;
    this.requestHeaders   = {};
    this._requestOptions  = {};
    this._responseHeaders = {};

    // TODO add max number or retries
    // TODO add max number of redirects

    var self = this;

    // Set default empty listeners for basic functionality
    this.on('readystatechange', () => { self.onreadystatechange(); });
    this.on('error',            () => { self.onerror(); });

    // Not yet emitted but will.
    this.on('abort',            () => { self.onabort(); });
    this.on('load',             () => { self.onload(); });
    this.on('loadstart',        () => { self.onloadstart(); });
    this.on('progress',         () => { self.onprogress(); });
  }

  /**
   * <p>Set up the configuration for the request. <code>method</code> and <code>url</code>
   * are passed directly to the internal implementation of the request. This object only
   * enforces the async parameter to be <code>true</code> (and is the default value). Sync
   * requests are not appropiate for the use case.</p>
   *
   * <p>Method is not enforced at this level. But only <code>'GET'</code> has been tested.</p>
   *
   * @example
   * // ...
   * var request = new RangerRequest();
   * request.open('GET', url, true);
   * request.send('');
   * // ...
   * var request2 = new RangerRequest();
   * request2.open('GET', url);
   * request2.send('');
   * // ...
   *
   * @param {string} method - The http method to use for the request. Usually a
   *                          <code>GET</code> is expected but not enforced.
   * @param {string} url - The url of the resource
   * @param {boolean} [async] - By default the request will be async. If a value is
   *                            passed, the value must be <code>true</code>.
   *                            Otherwise an <code>AssertionError</code> will be rised.
   *                            This parameter is part of the method's
   *                            signature just to maintain a signature compatible with
   *                            the general <code>request</code> object.
   */
  open( method, url, async ) {
    assert(method, 'method is required');
    assert(url, 'url is required');
    assert(typeof method === 'string', 'method must be a string');
    assert(typeof url === 'string', 'url must be a string');

    if ( typeof async !== 'undefined' ) {
      assert(typeof async === 'boolean', 'async can only be boolean');
      assert(async === true, 'Only async requests are supported');
    } else {
      async = true;
    }

    this._requestOptions.url    = url;
    this._requestOptions.method = method;
    this._requestOptions.async  = async;

    this._setReadyState(OPENED);
  }

  /**
   * Sends the request with the specified payload. Usually an empty payload is expected.
   *
   * @example
   * // ...
   * request.open('GET', url);
   * request.send('');
   * // ...
   * request2.open('GET', url);
   * request2.send(null);
   * // ...
   * request3.open('GET', url);
   * request3.send();
   *
   * @param {object} [payload] - data to be sent as the body of the request. Likely
   *                             to be empty () or empty string (''). defaults to
   *                             empty string.
   */
  send( payload ) {
    payload = payload || '';
    var self = this;

    if ( this.readyState !== OPENED ) {
      throw new Error('The object state must be OPENED');
    }

    if ( this.withCredentials ) {
      this.requestHeaders.withCredentials = this.withCredentials;
    }

    if ( this.acceptTrailers ) {
      this.requestHeaders.TE = 'trailers';
    }

    var httpP = new HTTPAsPromise( self._requestOptions.url, this.requestHeaders );
    var dataPromise = httpP.run();

    dataPromise.then( ( r ) => {
      var contentType = self._getContentType(r);
      if ( contentType.startsWith('application/json') ) {
        try {
          let uriData = procJSON(r.response, this.headers);
          this._procURIsPromise( uriData.uris, uriData.headers4uris );
        } catch (e) {
          console.log(e);
          self.status        = DEFAULT_APPLICATION_ERROR_CODE;
          self.statusMessage = "Error while processing JSON " + e;
          delete self.response;
          self._setReadyState(DONE);
        }
      } else {
        self.status        = r.status;
        self.statusMessage = r.statusMessage;
        let response = r.response;
        // Browser implementation of zlib is expecting an ArrayBuffer. The node version
        // can directly work with a Buffer object.
        if ( response.toArrayBuffer ) {
          response = response.toArrayBuffer();
        }
        self.response = response;
        self._setReadyState(DONE);
      }
    }, ( reason ) => {
      self.status        = reason.rejectStatus;
      self.statusMessage = reason.rejectMessage + ' for ' + reason.rejectUrl;
      delete self.response;
      self._setReadyState(DONE);
    });
  }

  _getContentType( r ) {
    var contentType = r.headers['content-type'];
    contentType = ( typeof contentType === 'string' ) ? contentType.toLowerCase()
                                                      : '';
    return contentType;
  }

  _procURIsPromise( uris, headers4uris ) {
    let uriPromises  = [];

    for ( let i = 0; i < uris.length; i++ ) {
      let httpP = new HTTPAsPromise( uris[i], headers4uris[i] );
      uriPromises[i] = httpP.run();
    }

    Promise.all(uriPromises).then( values => {
      try {
        let dataChunks = [];
        for ( let i = 0; i < values.length; i ++ ) {
          dataChunks[i] = values[i].response;
        }

        let buffer = Buffer.concat(dataChunks);
        // Browser implementation of zlib is expecting an ArrayBuffer. The node version
        // can directly work with a Buffer object.
        if ( buffer.toArrayBuffer ) {
          buffer = buffer.toArrayBuffer();
        }
        this.response      = buffer;
        this.status        = 200;
        this.statusMessage = 'OK';
      } catch (e) {
        this.response      = 'Error while building reponse ' + e;
        this.status        = DEFAULT_APPLICATION_ERROR_CODE;
        this.statusMessage = 'Error while building reponse ' + e;
      }
      this._setReadyState(DONE);
    }, ( reason ) => {
      let url           = reason.rejectUrl;
      this.status       = DEFAULT_APPLICATION_ERROR_CODE;
      let statusMessage = 'Error while requesting resources provided in JSON ' +
                          url + ' ' +
                          reason.rejectStatus + ' ' +
                          reason.rejectMessage;
      this.response      = statusMessage;
      this.statusMessage = statusMessage;
      this._setReadyState(DONE);
    });
  }

  _cloneResponse( response ) {
    var newResponse = {};
    var toCopy = 'headers rawHeaders rawTrailers trailers readable statusCode statusMessage url'.split(' ');
    for ( let i = 0; i < toCopy.length; i++ ) {
      newResponse[toCopy[i]] = JSON.parse(JSON.stringify( response[toCopy[i]] ));
    }
    return newResponse;
  }

  _setReadyState( readyState ) {
    assert(readyState, 'readyState is required');
    this.readyState = readyState;
    this.emit('readystatechange');
  }

  /**
   * Set or overwrite the header for the request
   * @param {string} name - name of the header
   * @param {object} value - new value for the header
   */
  setRequestHeader( name, value ) {
    assert(name, 'name is required');
    assert(value, 'value is required');
    this.requestHeaders[name] = value;
  }

  /**
   * Get a header from the reponse by header name
   * @param  {string} headerName - name of the header required
   * @return {string} value of the header if it exists undefined otherwise
   */
  getResponseHeader( headerName ) {
    assert(headerName, 'headerName is required');
    assert(headerName.toLowerCase, 'headerName must be a string');
    headerName = headerName.toLowerCase();
    return this._responseHeaders[headerName];
  }

  /**
   * Empty method, expected to be overwritten by user. Will be called when
   * object raises a <code>readystatechange</code> event.
   */
  onreadystatechange() {}

  /**
   * Empty method, expected to be overwritten by user. Will be called when
   * object raises a <code>error</code> event.
   */
  onerror() { console.log('Default on.error call'); }

  /**
   * Waiting for implementation
   */
  onabort() { console.log('Default on.abort call'); }
  /**
   * Waiting for implementation
   */
  onload() { console.log('Default on.load call'); }
  /**
   * Waiting for implementation
   */
  onloadstart() { console.log('Default on.loadstart call'); }
  /**
   * Waiting for implementation
   */
  onprogress() { console.log('Default on.progress call'); }
}

module.exports = {
  RangerRequest: RangerRequest,
  procJSON:      procJSON
};
 at SyntaxError: Unexpected token (4:6)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/npg_ranger/node_modules/npg_ranger/lib/main.js. Coverage (Term): 62% Coverage (LOC): 100%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
