/root/Targets/ragflag
└─┬ ragflag@0.2.1 
  └── contra@1.6.10 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/ragflag/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0475 took 3.3519s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (10:4) on program //
// # RagFlag
//

/* jshint node: true */
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('util').inherits;
var assert = require('assert');

var contra = require('contra');

var Flags = require('./lib/flags');

var RagFlag = module.exports = function RagFlag(connection, opts) {
  EventEmitter.call(this);

  opts = opts || {};
  this.connection = connection;
  this.defaultNamespace= opts.defaultNamespace || 'flags';
  this.namespaces = {};
  this.queue = contra.queue(ragflagPerformSave(this), opts.concurrent || 2);
  this.Flags = connection.model('RagFlags', {
    identifier: Number,
    flags: {}
  });

  if (opts.namespaces) {
    this.configure(opts.namespaces);
  }
};

inherits(RagFlag, EventEmitter);

RagFlag.prototype.configure = function ragflagConfigure(namespace, flags) {
  if (typeof namespace === 'object') {
    for (var n in namespace) {
      this.configure(n, namespace[n]);
    }
    return;
  }

  assert(typeof namespace === 'string', 'Namespace name must be a string.');
  assert(Array.isArray(flags), 'Flags must be an array.');
  this.namespaces[namespace] = flags;
};

RagFlag.prototype.get = function ragflagGet(name, id, fn) {
  assert(this.namespaces[name], 'Invalid namespace.');
  var identifier = { identifier: id };
  var self = this;
  this.Flags.findOne(identifier, 'flags', { lean: true }, function ragFetch(err, c) {
    /* istanbul ignore if */
    if (err) return fn(err, null);
    var flags = c ? c.flags[name] : false;
    var instance = new Flags(name, id, flags, self);
    fn(null, instance);
  });
};

RagFlag.prototype.validateFlag = function ragflagValidate(namespace, flag) {
  var hasNamespace = Array.isArray(this.namespaces[namespace]);
  if (!hasNamespace) return false;
  var hasFlag = this.namespaces[namespace].indexOf(flag) !== -1;
  return hasFlag;
};

RagFlag.prototype.save = function ragflagSave(name, id, flag, on, fn) {
  var job = {
    name: name,
    id: id,
    flag: flag,
    on: on
  };

  var self = this;
  if (typeof fn === 'function') {
    this.queue.unshift(job, function () {
      self.emit('saved', job);
      fn.apply(fn, arguments);
    });
  }
  else {
    this.queue.push(job, function () {
      self.emit('saved', job);
    });
  }
};

RagFlag.prototype.initFlag = function ragflagInitFlag(namespace, id, flags) {
  var self = this;
  var valid = Object.keys(flags).map(function (flagName) {
    return self.validateFlag(namespace, flags[flagName]);
  }).indexOf(false) !== -1;

  var errmsg = 'Invalid flag: ' + flag + ' for collection: ' + this.name;
  assert(valid, errmsg);

  var flag = new Flags(namespace, id, flags, this);
  return flag;
};

function ragflagPerformSave(context) {
  return function (job, done) {
    var identifier = { identifier: job.id };
    var update = { flags: {} };
    update.flags[job.name] = {};
    update.flags[job.name][job.flag] = job.on;
    update = {$set: {}};
    update.$set['flags.' + job.name + '.' + job.flag] = job.on;
    var options = { upsert: true };

    context.Flags.findOneAndUpdate(identifier, update, options, handleSave);

    function handleSave(err, doc) {
      /* istanbul ignore if */
      if (err) {
        context.emit('error', err);
      }
      done();
    }
  };
}

 at SyntaxError: Unexpected token (10:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
