/root/Targets/itsa-react-multicheckbox
├─┬ itsa-react-multicheckbox@16.0.3 
│ ├── itsa-jsext@1.4.0 
│ ├─┬ itsa-react-checkbox@16.0.2 
│ │ └── itsa-dom@1.2.0 
│ ├─┬ itsa-react-option@16.0.3 
│ │ ├─┬ itsa-react-focuscontainer@16.0.3 
│ │ │ └─┬ itsa-event@1.1.10 
│ │ │   └── itsa-classes@1.0.3 
│ │ └── UNMET PEER DEPENDENCY react@>=15
│ ├── itsa-utils@1.4.0 
│ ├─┬ prop-types@15.6.0 
│ │ ├─┬ fbjs@0.8.16 
│ │ │ ├── core-js@1.2.7 
│ │ │ ├─┬ isomorphic-fetch@2.2.1 
│ │ │ │ ├─┬ node-fetch@1.7.3 
│ │ │ │ │ ├─┬ encoding@0.1.12 
│ │ │ │ │ │ └── iconv-lite@0.4.19 
│ │ │ │ │ └── is-stream@1.1.0 
│ │ │ │ └── whatwg-fetch@2.0.3 
│ │ │ ├─┬ promise@7.3.1 
│ │ │ │ └── asap@2.0.6 
│ │ │ ├── setimmediate@1.0.5 
│ │ │ └── ua-parser-js@0.7.14 
│ │ ├─┬ loose-envify@1.3.1 
│ │ │ └── js-tokens@3.0.2 
│ │ └── object-assign@4.1.1 
│ └── UNMET PEER DEPENDENCY react@>=15
└── UNMET PEER DEPENDENCY react@>=15

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/itsa-react-multicheckbox/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0565 took 2.7065s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (116:12) on program "use strict";

/**
 * React MultiCheckbox element --> multiple checkboxes.
 *
 *
 *
 * <i>Copyright (c) 2016 ItsAsbreuk - http://itsasbreuk.nl</i><br>
 * New BSD License - http://choosealicense.com/licenses/bsd-3-clause/
 *
 *
 * @module multicheckbox/lib/component.jsx
 * @class MultiCheckbox
 * @since 15.0.0
*/

require("itsa-jsext");

const React = require("react"),
    PropTypes = require("prop-types"),
    Option = require("itsa-react-option"),
    CheckBox = require("itsa-react-checkbox"),
    async = require("itsa-utils").async,
    later = require("itsa-utils").later,
    MAIN_CLASS = "itsa-multicheckbox",
    MAIN_OPTION_CLASS = "itsa-option",
    OPTION_ITEM_CLASS = MAIN_OPTION_CLASS + "-option",
    OPTION_TEXT_CLASS = " " + MAIN_OPTION_CLASS + "-text";

class MultiCheckbox extends React.Component {
    constructor(props) {
        super(props);
        const instance = this;
        instance.focusItem = instance.focusItem.bind(instance);
        instance.focus = instance.focus.bind(instance);
        instance.handleSetItem = instance.handleSetItem.bind(instance);
        instance.renderItem = instance.renderItem.bind(instance);
        instance._saveHTML = instance._saveHTML.bind(instance);
    }

    /**
     * componentDidMount may call `this.focus()`;
     *
     * @method componentDidMount
     * @since 0.0.1
     */
    componentDidMount() {
        const instance = this;
        instance.props.autoFocus && instance.focus();
    }

    /**
     * Sets the focus on the active Element of the Container.
     *
     * @method focus
     * @chainable
     * @since 0.0.1
     */
    focus() {
        this.focusItem(0);
    }

    /**
     * Sets the focus on the specified Element of the Container.
     *
     * @method focusItem
     * @param index {Number} the index of the option to be focussed
     * @chainable
     * @since 0.0.1
     */
    focusItem(index) {
        return this._focusContainer.focusOption(index);
    }

    /**
     * Sets a new option.
     *
     * @method handleSetItem
     * @param index {Number}
     * @since 0.0.1
     */
    handleSetItem(index) {
        let newValue;
        const instance = this,
            props = instance.props,
            checked = props.checked;
        if (!props.disabled) {
            newValue = (typeof checked === "number") ? [checked] : checked.itsa_deepClone();
            if (newValue.itsa_contains(index)) {
                newValue.itsa_remove(index);
            } else {
                newValue.push(index);
            }
            props.onChange(newValue);
            async(() => instance.focusItem(index));
        }
    }

    /**
     * Render-function for the options. You can use this property to override the default
     * renderer. When not set, the default-renderer will be used.
     *
     * @method renderItem
     * @param option {String} the option to be rendered
     * @param i {Number} the index of the option
     * @param checked {Number} the index of the option to be focussed
     * return {JSX} li-element for the option
     * @since 0.0.1
    */
    renderItem(option, i, checked) {
        const instance = this,
            ariaLabel = instance._saveHTML(option),
            props = instance.props;

        return (
            <li
                aria-label={ariaLabel}
                className={OPTION_ITEM_CLASS}
                data-id={i}
                key={i}
                role="listitem" >
                <CheckBox
                    autoFocus={false}
                    checked={checked}
                    disabled={props.disabled}
                    onChange={instance.handleSetItem.bind(instance, i)}
                    readOnly={props.readOnly} />
                <div className={OPTION_TEXT_CLASS} dangerouslySetInnerHTML={{__html: option }} />
            </li>
        );
    }

    /**
     * React render-method --> renderes the Component.
     *
     * @method render
     * @return ReactComponent
     * @since 15.0.0
     */
    render() {
        let classname = MAIN_CLASS;
        const instance = this,
            props = instance.props,
            propsClassName = props.className;

        propsClassName && (classname+=" "+propsClassName);
        return (
            <Option
                {...props}
                autoFocus={false}
                className={classname}
                itemRenderer={instance.renderItem}
                keySelect={[]}
                multi={true}
                ref={inst => instance._focusContainer = inst}
                selector=".itsa-checkbox" />
        );
    }

    /**
     * Returns a save string
     *
     * @method _saveHTML
     * @private
     * @param String html the text that should be removed from any html-entities
     * @return String
     * @since 0.0.1
     */
    _saveHTML(html) {
        return html && html.replace(/<[^>]*>/g, "");
    }


}

MultiCheckbox.propTypes = {
    /**
     * Whether to autofocus the Component.
     *
     * @property autoFocus
     * @type Boolean
     * @default false
     * @since 0.0.1
    */
    autoFocus: PropTypes.bool,

    /**
     * A number -or Array with numbers- that define the option that is selected
     *
     * @property checked
     * @type Number|Array
     * @since 0.0.1
    */
    checked: PropTypes.oneOfType([PropTypes.number, PropTypes.array]),

    /**
     * Whether render the options as HTML. When set `false`, they will be plain text, removed from any html-entities.
     *
     * @property dangerousInnerHTML
     * @type Boolean
     * @default false
     * @since 0.0.1
    */
    dangerousInnerHTML: PropTypes.bool,

    /**
     * Whether the focuscontainer is disabled (doesn"t response to focusevents)
     *
     * @property disabled
     * @type Boolean
     * @since 15.0.0
    */
    disabled: PropTypes.bool,

    /**
     * What key/keys are responsible for re-focussing `down`. Valid values are charcodes possible prepende with
     * a special key: 9 or `shift+9` or `ctrl+shift+9`. Multiple key combinations can be defined bydefining an array of keyDown-values.
     *
     * @property keyDown
     * @default 40
     * @type String|number|Array
     * @since 15.0.0
    */
    keyDown: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.array]),

    /**
     * Whenever `keyEnter` is set, then the focus-container will become a `nested`- focuscontainer.
     * Nested focuscontainers will automaticcaly become focussable by their parent-container.
     *
     * The `keyEnter` determines what key/keys are responsible for `entering` this container. Valid values are charcodes possible prepende with
     * a special key: 39 or `shift+39` or `ctrl+shift+39`. Multiple key combinations can be defined bydefining an array of keyUp-values.
     *
     * @property keyEnter
     * @default 13
     * @type String|number|Array
     * @since 15.0.0
    */
    keyEnter: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.array]),

    /**
     * The `keyLeave` determines what key/keys are responsible for `leaving` this container and go to the parent focus-container.
     * Valid values are charcodes possible prepende with
     * a special key: 39 or `shift+39` or `ctrl+shift+39`. Multiple key combinations can be defined bydefining an array of keyUp-values.
     *
     * @property keyLeave
     * @default 27
     * @type String|number|Array
     * @since 15.0.0
    */
    keyLeave: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.array]),

    /**
     * What key/keys are responsible for re-focussing `up`. Valid values are charcodes possible prepended with
     * a special key: 9 or `shift+9` or `ctrl+shift+9`. Multiple key combinations can be defined bydefining an array of keyUp-values.
     *
     * @property keyUp
     * @default 38
     * @type String|number|Array
     * @since 15.0.0
    */
    keyUp: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.array]),

    /**
     * Whether the loop the focus when the last/first option is reached.
     *
     * @property loop
     * @default false
     * @type Boolean
     * @since 15.0.0
    */
    loop: PropTypes.bool,

    /**
     * Callback whenever a new value is set. The callbackFn will recieve 1 argment: the new `checked` option(s).
     * Which is a `number` in case `props.multi`===fals,e, otherwise it is an array with numbers.
     *
     * @property onChange
     * @required
     * @type Function
     * @since 15.0.0
    */
    onChange: PropTypes.func.isRequired,

    /**
     * Callback for when the component did mount.
     *
     * @property onMount
     * @type Function
     * @since 15.0.8
    */
    onMount: PropTypes.func,

    /**
     * List with all options
     *
     * @property options
     * @type Array
     * @required
     * @since 15.0.0
    */
    options: PropTypes.array.isRequired,

    /**
     * Whether the focuscontainer is readOnly (doesn't response to focusevents)
     *
     * @property readOnly
     * @type Boolean
     * @since 15.0.4
    */
    readOnly: PropTypes.bool,

    /**
     * Whether the focussed option should be scrolled into the view when the focusselector focuses it.
     *
     * @property scrollIntoView
     * @default false
     * @type String
     * @since 15.0.30
    */
    scrollIntoView: PropTypes.bool,

    /**
     * Inline styles for the focus-container
     *
     * @property style
     * @type Object
     * @since 15.0.0
    */
    style: PropTypes.object,

    /**
     * The tabIndex
     *
     * @property tabIndex
     * @type Number
     * @since 0.0.1
    */
    tabIndex: PropTypes.number,

    /**
     * The transition-time when the window needs to be scrolled in order to get the focussable node into the view.
     *
     * @property transitionTime
     * @type Number
     * @since 15.0.0
    */
    transitionTime: PropTypes.number
};

module.exports = MultiCheckbox;
 at SyntaxError: Unexpected token (116:12)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$3.parseExprAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1822:12)
    at Parser.parseExprAtom (/root/ExpoSE/lib/Tropigate/bin/Expression.js:28:30)
    at Parser.pp$3.parseExprSubscripts (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1715:21)
    at Parser.parseMaybeUnary (/root/ExpoSE/lib/Tropigate/bin/Unary.js:34:29)
    at Parser.pp$3.parseExprOps (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1637:21)
    at Parser.pp$3.parseMaybeConditional (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1620:21)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1597:21)
    at Parser.pp$3.parseParenAndDistinguishExpression (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1861:32)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
