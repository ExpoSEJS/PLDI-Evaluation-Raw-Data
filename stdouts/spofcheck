/root/Targets/spofcheck
└─┬ spofcheck@0.1.7 
  ├── async@0.1.22 
  ├── jquery@3.2.1 
  ├─┬ jsdom@9.12.0 
  │ ├── abab@1.0.4 
  │ ├── acorn@4.0.13 
  │ ├── acorn-globals@3.1.0 
  │ ├── array-equal@1.0.0 
  │ ├── content-type-parser@1.0.1 
  │ ├── cssom@0.3.2 
  │ ├── cssstyle@0.2.37 
  │ ├─┬ escodegen@1.9.0 
  │ │ ├── esprima@3.1.3 
  │ │ ├── estraverse@4.2.0 
  │ │ ├── esutils@2.0.2 
  │ │ ├─┬ optionator@0.8.2 
  │ │ │ ├── deep-is@0.1.3 
  │ │ │ ├── fast-levenshtein@2.0.6 
  │ │ │ ├── levn@0.3.0 
  │ │ │ ├── prelude-ls@1.1.2 
  │ │ │ ├── type-check@0.3.2 
  │ │ │ └── wordwrap@1.0.0 
  │ │ └── source-map@0.5.7 
  │ ├── html-encoding-sniffer@1.0.1 
  │ ├── nwmatcher@1.4.2 
  │ ├── parse5@1.5.1 
  │ ├─┬ request@2.83.0 
  │ │ ├── aws-sign2@0.7.0 
  │ │ ├── aws4@1.6.0 
  │ │ ├── caseless@0.12.0 
  │ │ ├─┬ combined-stream@1.0.5 
  │ │ │ └── delayed-stream@1.0.0 
  │ │ ├── extend@3.0.1 
  │ │ ├── forever-agent@0.6.1 
  │ │ ├─┬ form-data@2.3.1 
  │ │ │ └── asynckit@0.4.0 
  │ │ ├─┬ har-validator@5.0.3 
  │ │ │ ├─┬ ajv@5.2.3 
  │ │ │ │ ├── co@4.6.0 
  │ │ │ │ ├── fast-deep-equal@1.0.0 
  │ │ │ │ ├── json-schema-traverse@0.3.1 
  │ │ │ │ └─┬ json-stable-stringify@1.0.1 
  │ │ │ │   └── jsonify@0.0.0 
  │ │ │ └── har-schema@2.0.0 
  │ │ ├─┬ hawk@6.0.2 
  │ │ │ ├── boom@4.3.1 
  │ │ │ ├─┬ cryptiles@3.1.2 
  │ │ │ │ └── boom@5.2.0 
  │ │ │ ├── hoek@4.2.0 
  │ │ │ └── sntp@2.0.2 
  │ │ ├─┬ http-signature@1.2.0 
  │ │ │ ├── assert-plus@1.0.0 
  │ │ │ ├─┬ jsprim@1.4.1 
  │ │ │ │ ├── extsprintf@1.3.0 
  │ │ │ │ ├── json-schema@0.2.3 
  │ │ │ │ └─┬ verror@1.10.0 
  │ │ │ │   └── core-util-is@1.0.2 
  │ │ │ └─┬ sshpk@1.13.1 
  │ │ │   ├── asn1@0.2.3 
  │ │ │   ├── bcrypt-pbkdf@1.0.1 
  │ │ │   ├── dashdash@1.14.1 
  │ │ │   ├── ecc-jsbn@0.1.1 
  │ │ │   ├── getpass@0.1.7 
  │ │ │   ├── jsbn@0.1.1 
  │ │ │   └── tweetnacl@0.14.5 
  │ │ ├── is-typedarray@1.0.0 
  │ │ ├── isstream@0.1.2 
  │ │ ├── json-stringify-safe@5.0.1 
  │ │ ├─┬ mime-types@2.1.17 
  │ │ │ └── mime-db@1.30.0 
  │ │ ├── oauth-sign@0.8.2 
  │ │ ├── performance-now@2.1.0 
  │ │ ├── qs@6.5.1 
  │ │ ├── safe-buffer@5.1.1 
  │ │ ├── stringstream@0.0.5 
  │ │ ├── tunnel-agent@0.6.0 
  │ │ └── uuid@3.1.0 
  │ ├── sax@1.2.4 
  │ ├── symbol-tree@3.2.2 
  │ ├─┬ tough-cookie@2.3.3 
  │ │ └── punycode@1.4.1 
  │ ├── webidl-conversions@4.0.2 
  │ ├─┬ whatwg-encoding@1.0.1 
  │ │ └── iconv-lite@0.4.13 
  │ ├─┬ whatwg-url@4.8.0 
  │ │ ├── tr46@0.0.3 
  │ │ └── webidl-conversions@3.0.1 
  │ └── xml-name-validator@2.0.1 
  ├── mkdirp@0.3.4 
  ├─┬ nopt@2.0.0 
  │ └── abbrev@1.1.1 
  ├── q@1.0.1 
  └─┬ request@2.12.0 
    ├─┬ form-data@0.0.3 
    │ ├── async@0.1.9 
    │ └─┬ combined-stream@0.0.3 
    │   └── delayed-stream@0.0.5 
    └── mime@1.2.7 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/spofcheck/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0678 took 3.0722s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected character '#' (1:78) on program #!/usr/bin/env node

/**
 * Copyright (c) 2012 eBay Inc.
 * Author: Senthil Padmanabhan
 *
 * Released under the MIT License
 * http://www.opensource.org/licenses/MIT
 *
 * spofcheck
 *
 * CLI for frontend spof detection
 *
 */

// dependencies
var path = require('path'),
    fs = require('fs'),
    nopt = require('nopt'),
    request = require('request'),
    async = require('async'),
    jsdom = require('jsdom').jsdom,
    mkdirp = require('mkdirp'),
    Q = require('q'),
    $ = require('jquery')(jsdom().defaultView);

// Setting jsdom global config
require("jsdom").defaultDocumentFeatures = {
    FetchExternalResources: false,
    ProcessExternalResources: false,
    MutationEvents: false,
    QuerySelector: false
};

// Locals
var options = {
        "outputdir": path,
        "format": String,
        "help": Boolean,
        "rules": String,
        "print": Boolean,
        "quiet": Boolean
    },
    shortHand = {
        "o": ['--outputdir'],
        "f": ['--format'],
        "h": ['--help'],
        "r": ['--rules'],
        "p": ['--print'],
        "q": ['--quiet']
    };

// options
options = nopt(options, shortHand);

/**
 * Convert a given relative URL to absolute URL
 * @param {String} url The url to be converted to absolute.
 * @param {String} mainUrl The main URL of the page.
 * @return {String} The fully qualified absolute URL.
 * @method getAbsoluteUrl
 */
function getAbsoluteUrl(url, mainUrl) {
    // If url or mainUrl not present return the given url
    if (!url || !mainUrl) {
        return url;
    }
    // If url begins with http(s) then it is already an absolute URL, so return given url
    if (/^http[s]?:\/\//i.test(url)) {
        return url;
    }
    // If url begins with // it is shortcut to use main page protocol
    // Change given URL with mainPage url protocol and return
    if (/^\/\//.test(url)) {
        return /^http[s]?:/i.exec(mainUrl) + url;
    }
    var protocol = /^http[s]?/i.exec(mainUrl),
        domain = /^http[s]?:\/\/([^\/]*)[\/]?/i.exec(mainUrl)[1],
        path = '',
        depth = url.match(/\.\./g) ? url.match(/\.\./g).length : 0,
        index;
    // If url needs depth i.e. has folder traverse (..), then strip the folder information
    url = url.replace(/\.\.\//g, '');

    // If given url starts with / then ignore path
    if (!/^\//.test(url)) {
        path = mainUrl.replace(protocol + '://' + domain, '');
        // if path is present then remove the resource from the path
        if (path.length) {
            index = path.lastIndexOf('/');
            path = index < 1 ? '/' : path.substr(0, index + 1); // path should always end with slash /
            // If there is a folder traverse (..) in given url, then traverse upto the depth
            while (depth-- && path.length > 1) {
                path = path.replace(/[^\/]*\/$/, '');
            }
        }
    }

    return protocol + '://' + domain + path + url;
}

/**
 * Retrieve the list of external CSS URLs in the page
 * @param {Object} $dom The DOM handler (jQuery) for the page.
 * @return {Array} An array of URLs.
 * @param {String} mainUrl The main URL of the page.
 * @return {Array} The CSS urls in the page
 * @method getCssUrls
 */
function getCssUrls($dom, mainUrl) {
    // Retrieving the link elements, using both type and rel attributes 
    var urls = [].concat($dom('link[type="text/css"]').get())
        .concat($dom('link[rel="stylesheet"]').get());

    // Retrieving the actual urls
    urls = urls.map(function(url) {
        return getAbsoluteUrl(url.href, mainUrl);
    });

    // removing duplicates and returning
    return urls.filter(function(url, index) {
        return this.indexOf(url) === index;
    }, urls);
}

/**
 * Creates a CSS callback function stack to be executed after each external
 * CSS is loaded
 * @param {Array} urls The external CSS URLs
 * @return {Array} An array of functions.
 * @method getCssFnStack
 */
function getCssFnStack(urls) {
    var cssFnStack = [];
    urls.forEach(function(url) {
        cssFnStack.push(function(callback) {
            request(url, function(error, response, body) {
                if (error || response.statusCode !== 200) {
                    body = '';
                    log('spof: ERROR Unable to load CSS resource ' + url);
                }
                callback(null, body);
            });
        });
    });
    return cssFnStack;
}

/**
 * Checks if spofcheck was triggered from command line
 * Wrapper for console.log, checks for quiet mode first
 * @return {Boolean} true if triggered from a command line interface
 * @method isCLI
 */
function isCLI() {
    return require.main === module;
}

/**
 * Wrapper for console.log, checks for quiet mode first
 * @param {String} message The message to be logged
 * @method log
 */
function log(message) {
    // Return if quiet mode
    if (options.quiet) {
        return;
    }
    console.log(message);
}

/**
 * Wrapper for process.exit, checks for command line mode, print the message & exit
 * @param {String} message The message to be logged
 * @method exit
 */
function exit(message) {
    if (isCLI()) {
        console.log(message);
        process.exit(0);
    }
}


/**
 * Opens a file and writes the given message
 * @param {String} file The full path file name to write a message
 * @param {String} message The message to be written
 * @method write
 */
function write(file, message) {
    var fd = fs.openSync(file, 'w');
    fs.writeSync(fd, message);
}

/**
 * Normalizes the rules based on the ruleIds provided in option (-r)
 * and previously registered with spof engine
 * @param {Array} ruleIds The rule IDs to be included in the analysis
 * @param {Array} rules The rules registered with the spof engine
 * @return {Array} Normalized set of rules
 * @method gatherRules
 */
function gatherRules(ruleIds, rules) {
    var idHash = {};
    // Normalize ruleIds
    if (!Array.isArray(ruleIds)) {
        ruleIds = ruleIds.split(',');
    }
    ruleIds.forEach(function(id) {
        idHash[id] = 1;
    });

    return rules.filter(function(rule) {
        return idHash[rule.id];
    });

}

/**
 * Creates a CSS callback function stack to be executed after each external
 * CSS is loaded
 * @param {Array} args The URLS(s) to run spofcheck
 * @param {Object} deferred (optional) The deferred object to reject/resolve based on the result
 * @method exec
 */
function exec(args, deferred) {
    var spof = require('../lib/spof.js').spof,
        rules = spof.getRules(), // Get the default registered ruleset
        usage = [
            "\nUSAGE: spofcheck [options]* [urls]*",
            " ",
            "Options:",
            "  --help | -h                      			Displays this information.",
            "  --format=<format> | -f <format>  			Indicate which format [junit-xml | spof-xml | text] to use for output",
            "  --outputdir=<dir> | -o <dir>     			Outputs the spof results to this directory.",
            "  --rules=<rule[,rule]+> | -r <rule[,rule]+>   Indicate which rules to include.",
            "  --print | -p                     			Outputs the results in console, instead of saving to a file.",
            "  --quiet | -q                     			Keeps the console clear from logging.",
            " ",
            "Example:",
            "  spofcheck -f junit-xml -o /tests www.ebay.com www.amazon.com",
            " "
        ].join("\n"),
        formatter = spof.getFormatter(options.format || 'junit-xml'),
        length = args.length,
        counter = 0,
        msg = '',
        resultsQ = [], // Queue to hold the analyzed results
        formattedResultsQ = [], // Queue to hold the formatted results
        /**
         * Flush the spof results to a file
         * @param {String} results The spof results to flush
         * @method flush
         * @private
         */
        flush = function(results) {
            var buffer = [],
                file = (options.outputdir || '.') + '/' + formatter.id + '.' + formatter.extension,
                output;

            if (options.outputdir) {
                // Create output directory
                mkdirp.sync(options.outputdir);
            }

            log('spof: Flushing the results');
            // Buffer the formatter start
            output = formatter.startFormat();
            if (output) {
                buffer.push(output);
            }

            // Buffer the results
            if (results.length) {
                buffer.push(results);
            }

            // Buffer the formatter end
            output = formatter.endFormat();
            if (output) {
                buffer.push(output);
            }

            // Flush the buffer
            if (options.print) {
                log('\nspof: Output\n');
                console.log(buffer.join('\n'));
            } else {
                write(file, buffer.join('\n'));
                log('\nspof: Results available at ' + file);
            }
            log('\nspof: SPOF check DONE!\n');
        };

    // if deferred is null create noops
    deferred = deferred || {
        reject: function() {},
        resolve: function() {}
    };

    if (!length || options.help) {
        // Reject the promise
        deferred.reject(new Error(usage));
        // Exit immediately
        return exit(usage);
    }

    if (!formatter) {
        msg = 'spof:  Unknown format \'' + options.format + '\'. Cannot proceed';
        // Reject the promise
        deferred.reject(new Error(msg));
        // Exit immediately		
        return exit(msg);
    }

    // Normalize the rules
    if (options.rules) {
        // Normalize the rules
        rules = gatherRules(options.rules, rules);
        if (!rules.length) {
            msg = 'spof: Invalid rules - ' + options.rules;
            deferred.reject(new Error(msg));
            return exit(msg);
        }
    }

    args.forEach(function(url) {
        // Check if http is present, else append it
        url = /^http[s]?:\/\//.test(url) ? url : 'http://' + url;
        log('spof: Analyzing ' + url);
        request(url, function(error, response, body) {
            if (!error && response.statusCode === 200) {
                // Create the DOM window from the page 
                var win = jsdom(body).defaultView,
                    // Get the jQuery DOM interface
                    $dom = require('jquery')(win),
                    // Create the CSS function stack for the async parallelization
                    cssFnStack = getCssFnStack(getCssUrls($dom, url));

                // Retrieve the CSS results in parallel and join them
                log('spof: Processing external CSS resources for ' + url);
                async.parallel(cssFnStack, function(err, results) {
                    var result = spof.analyze($dom, results.join(), rules),
                        formattedResults = formatter.formatResults(result, url);

                    // Push the formatted results & the original results to their corresponding Queues
                    if (formattedResults && formattedResults.length) {
                        formattedResultsQ.push(formattedResults);
                        // Add the url to the result before pushing
                        result.url = url;
                        resultsQ.push(result);
                    }

                    // Publish the results if last url
                    if (++counter === length) {
                        // If CLI flush the results, else resolve promise
                        if (isCLI()) {
                            flush(formattedResultsQ.join('\n'));
                        } else {
                            deferred.resolve(resultsQ);
                        }
                    }
                });
            } else {
                // Decrement the length
                length--;
                msg = 'spof: ERROR Unable to load ' + url;
                log(msg);
                // Reject the promise
                deferred.reject(new Error(msg));
            }
        });
    });
}

// Start the execution only if CLI
if (isCLI()) {
    exec(options.argv.remain);
}

/** SPOFCheck programmable API **/
/**
 * The programmable API interface for SPOFCheck
 * @param {Array|String} urls The URL(s) to perform the spof check
 * @param {Object} opts The options to run SPOFCheck, same as the command line
 * @return {Promise} A spof check results promise to be fullfilled by the caller
 * @method run
 */
var run = function(urls, opts) {
    var deferred = Q.defer();
    if (!urls) {
        urls = [];
    }
    urls = Array.isArray(urls) ? urls : [urls];
    options = $.extend({}, {
        quiet: true // for the programmable API make it quiet by default
    }, opts);
    // Execute
    exec(urls, deferred);
    // Retunr the promise
    return deferred.promise;
};

// Expose the API
module.exports.run = run; at SyntaxError: Unexpected character '#' (1:78)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$7.getTokenFromCode (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2756:10)
    at Parser.pp$7.readToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2477:17)
    at Parser.readToken (/root/ExpoSE/lib/Tropigate/bin/Tokens.js:124:26)
    at Parser.pp$7.nextToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2468:15)
    at Parser.pp$7.next (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2413:10)
    at Parser.pp.eat (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:536:12)
    at Parser.pp.semicolon (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:581:15)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:918:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
