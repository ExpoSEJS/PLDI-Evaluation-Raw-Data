/root/Targets/metadisk-client
└─┬ metadisk-client@0.3.2 
  ├── async@1.5.2 
  ├─┬ elliptic@6.4.0 
  │ ├── bn.js@4.11.8 
  │ ├── brorand@1.1.0 
  │ ├── hash.js@1.1.3 
  │ ├── hmac-drbg@1.0.1 
  │ ├── inherits@2.0.3 
  │ ├── minimalistic-assert@1.0.0 
  │ └── minimalistic-crypto-utils@1.0.1 
  ├── ms@0.7.3 
  ├─┬ readable-stream@2.3.3 
  │ ├── core-util-is@1.0.2 
  │ ├── isarray@1.0.0 
  │ ├── process-nextick-args@1.0.7 
  │ ├── safe-buffer@5.1.1 
  │ ├── string_decoder@1.0.3 
  │ └── util-deprecate@1.0.2 
  ├─┬ request@2.82.0 
  │ ├── aws-sign2@0.7.0 
  │ ├── aws4@1.6.0 
  │ ├── caseless@0.12.0 
  │ ├─┬ combined-stream@1.0.5 
  │ │ └── delayed-stream@1.0.0 
  │ ├── extend@3.0.1 
  │ ├── forever-agent@0.6.1 
  │ ├─┬ form-data@2.3.1 
  │ │ └── asynckit@0.4.0 
  │ ├─┬ har-validator@5.0.3 
  │ │ ├─┬ ajv@5.2.2 
  │ │ │ ├── co@4.6.0 
  │ │ │ ├── fast-deep-equal@1.0.0 
  │ │ │ ├── json-schema-traverse@0.3.1 
  │ │ │ └─┬ json-stable-stringify@1.0.1 
  │ │ │   └── jsonify@0.0.0 
  │ │ └── har-schema@2.0.0 
  │ ├─┬ hawk@6.0.2 
  │ │ ├── boom@4.3.1 
  │ │ ├─┬ cryptiles@3.1.2 
  │ │ │ └── boom@5.2.0 
  │ │ ├── hoek@4.2.0 
  │ │ └── sntp@2.0.2 
  │ ├─┬ http-signature@1.2.0 
  │ │ ├── assert-plus@1.0.0 
  │ │ ├─┬ jsprim@1.4.1 
  │ │ │ ├── extsprintf@1.3.0 
  │ │ │ ├── json-schema@0.2.3 
  │ │ │ └── verror@1.10.0 
  │ │ └─┬ sshpk@1.13.1 
  │ │   ├── asn1@0.2.3 
  │ │   ├── bcrypt-pbkdf@1.0.1 
  │ │   ├── dashdash@1.14.1 
  │ │   ├── ecc-jsbn@0.1.1 
  │ │   ├── getpass@0.1.7 
  │ │   ├── jsbn@0.1.1 
  │ │   └── tweetnacl@0.14.5 
  │ ├── is-typedarray@1.0.0 
  │ ├── isstream@0.1.2 
  │ ├── json-stringify-safe@5.0.1 
  │ ├─┬ mime-types@2.1.17 
  │ │ └── mime-db@1.30.0 
  │ ├── oauth-sign@0.8.2 
  │ ├── performance-now@2.1.0 
  │ ├── qs@6.5.1 
  │ ├── stringstream@0.0.5 
  │ ├─┬ tough-cookie@2.3.2 
  │ │ └── punycode@1.4.1 
  │ ├── tunnel-agent@0.6.0 
  │ └── uuid@3.1.0 
  └─┬ ws@1.1.4 
    ├── options@0.0.6 
    └── ultron@1.0.2 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/metadisk-client/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 34% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.053 took 4.8231s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (6:4) on program 'use strict';

var fs = require('fs');
var async = require('async');
var crypto = require('crypto');
var assert = require('assert');
var querystring = require('querystring');
var request = require('request');
var ms = require('ms');
var WebSocketClient = typeof window === 'undefined' ? require('ws') : WebSocket;
var EventEmitter = require('events').EventEmitter;
var ReadableStream = require('readable-stream');
var KeyPair = require('./keypair');

/**
 * Exposes a MetaDisk API client
 * @constructor
 * @param {String} uri - API base URI ('https://api.metadisk.org')
 * @param {Object} options
 * @param {KeyPair} options.keypair - KeyPair instance for request signing
 * @param {Object} options.basicauth
 * @param {String} options.basicauth.email - Email address for HTTP basic auth
 * @param {String} options.basicauth.password - Password for HTTP basic auth
 */
function Client(uri, options) {
  if (!(this instanceof Client)) {
    return new Client(uri, options);
  }

  this._options = options || {};
  this._options.baseURI = uri || 'https://api.metadisk.org';
}

/**
 * Get the remote MetaDisk API documentation and version as JSON
 * @returns {Promise}
 */
Client.prototype.getInfo = function() {
  return this._request('GET', '/', {});
};

/**
 * Registers a user account
 * @param {String} email - Email address for verification email
 * @param {String} password - Password to register (hashed automatically)
 * @param {String} redirect - URL to redirect to after verification
 * @param {String} pubkey - Optional ECDSA public key to register
 * @returns {Promise}
 */
Client.prototype.createUser = function(email, password, redirect, pubkey) {
  return this._request('POST', '/users', {
    email: email,
    password: this._sha256(password),
    redirect: redirect,
    pubkey: pubkey
  });
};

/**
 * Returns list of associated public keys
 * @returns {Promise}
 */
Client.prototype.getPublicKeys = function() {
  return this._request('GET', '/keys', {});
};

/**
 * Registers a public key for the caller
 * @param {String} pubkey - Hex encoded ECDSA (secp256k1) public key
 * @returns {Promise}
 */
Client.prototype.addPublicKey = function(pubkey) {
  return this._request('POST', '/keys', { key: pubkey });
};

/**
 * Disassociates the public key from the caller
 * @param {String} pubkey - Hex encoded ECDSA (secp256k1) public key
 * @returns {Promise}
 */
Client.prototype.destroyPublicKey = function(pubkey) {
  return this._request('DELETE', '/keys/' + pubkey, {});
};

/**
 * Lists the caller's file buckets
 * @returns {Promise}
 */
Client.prototype.getBuckets = function() {
  return this._request('GET', '/buckets', {});
};

/**
 * Returns the bucket information by ID
 * @param {String} id - Unique bucket ID
 * @returns {Promise}
 */
Client.prototype.getBucketById = function(id) {
  return this._request('GET', '/buckets/' + id, {});
};

/**
 * Creates a new file bucket
 * @param {Object} data - Bucket parameters for creation
 * @returns {Promise}
 */
Client.prototype.createBucket = function(data) {
  return this._request('POST', '/buckets', data || {});
};

/**
 * Removes the bucket
 * @param {String} id - Unique bucket ID
 * @returns {Promise}
 */
Client.prototype.destroyBucketById = function(id) {
  return this._request('DELETE', '/buckets/' + id, {});
};

/**
 * Updates the bucket
 * @param {String} id - Unique bucket ID
 * @param {Object} updates - Bucket update parameters
 * @returns {Promise}
 */
Client.prototype.updateBucketById = function(id, updates) {
  return this._request('PATCH', '/buckets/' + id, updates || {});
};

/**
 * Lists the files stored in a bucket
 * @param {String} id - Unique bucket ID
 * @returns {Promise}
 */
Client.prototype.listFilesInBucket = function(id) {
  return this._request('GET', '/buckets/' + id + '/files', {});
};

/**
 * Create bucket token
 * @param {String} id - Unique bucket ID
 * @param {String} operation - PUSH or PULL (file operation)
 * @returns {Promise}
 */
Client.prototype.createToken = function(id, operation) {
  return this._request('POST', '/buckets/' + id + '/tokens', {
    operation: operation
  });
};

/**
 * Removes a file from a bucket
 * @param {String} id - Unique bucket ID
 * @param {String} hash - Hash of the file to remove from bucket
 * @returns {Promise}
 */
Client.prototype.removeFileFromBucket = function(id, hash) {
  return this._request('DELETE', '/buckets/' + id + '/files/' + hash, {});
};

/**
 * Stores a file in the bucket
 * @param {String} id - Unique bucket ID
 * @param {String} token - Token from {@link Client#createToken}
 * @param {String|Buffer} file - Raw binary buffer or path to local file
 * @returns {Promise}
 */
Client.prototype.storeFileInBucket = function(id, token, file) {
  var self = this;
  var size = 0;

  assert(
    typeof window === 'undefined',
    'This method is not supported in the browser'
  );

  if (!Buffer.isBuffer(file)) {
    size = fs.statSync(file).size;
  } else {
    size = file.length;
  }

  return new Promise(function(resolve, reject) {
    request({
      method: 'PUT',
      baseUrl: self._options.baseURI,
      uri: '/buckets/' + id + '/files',
      json: true,
      headers: {
        'x-token': token,
        'x-filesize': size
      },
      formData: {
        data: Buffer.isBuffer(file) ? file : fs.createReadStream(file)
      }
    }, function(err, res, body) {
      if (err) {
        return reject(err);
      }

      if (res.statusCode !== 200 && res.statusCode !== 304) {
        return reject(new Error(body.error || body));
      }

      resolve(body);
    });
  });
};

/**
 * Retrieves a file pointer from the bucket
 * @param {String} bucket - Unique bucket ID
 * @param {String} token - Token from {@link Client#createToken}
 * @param {String} fileHash - The unique file pointer ID
 * @returns {Promise}
 */
Client.prototype.getFilePointer = function(bucket, token, fileHash) {
  var self = this;

  return new Promise(function(resolve, reject) {
    request({
      method: 'GET',
      baseUrl: self._options.baseURI,
      uri: '/buckets/' + bucket + '/files/' + fileHash,
      headers: {
        'x-token': token
      },
      json: true,
      timeout: ms('10m'),
    }, function(err, res, body) {
      if (err) {
        return reject(err);
      }

      if (res.statusCode !== 200 && res.statusCode !== 304) {
        return reject(new Error(body.error || body));
      }

      resolve(body);
    });
  });
};

/**
 * Open a series of data channels based on the returned value of
 * {@link Client#getFilePointer} to resolve all the shards and
 * reassemble them together as a binary stream
 * @param {Array} pointers - Result of {@link Client#getFilePointer}
 * @returns {ReadableStream}
 */
Client.prototype.resolveFileFromPointers = function(pointers) {
  var iteration = 0;
  var stream = new ReadableStream({
    read: function() {
      var self = this;
      var pointer = pointers[iteration];

      if (!pointers[iteration]) {
        return this.push(null);
      }

      var uri = pointer.channel;
      var client = new WebSocketClient(uri);

      client.onopen = function() {
        client.send(JSON.stringify({
          token: pointer.token,
          hash: pointer.hash,
          operation: pointer.operation
        }));
      };

      client.onmessage = function(e) {
        var json = null;
        var data = e.data;

        if (typeof Blob !== 'undefined' && e.data instanceof Blob) {
          data = new Buffer(e.data);
        }

        if (!Buffer.isBuffer(data)) {
          try {
            json = JSON.parse(data);
          } catch (err) {
            return self.emit('error', err);
          }

          if (json.code && json.code !== 200) {
            return self.emit('error', new Error(json.message));
          }
        }

        iteration++;
        self.push(data);
      };

      client.onclose = function() {
        /* noop */
      };

      client.onerror = function(err) {
        self.emit('error', err);
      };
    }
  });

  return stream;
};

/**
 * Returns the SHA-256 hash of the given input data
 * @private
 * @param {String} data
 * @returns {String}
 */
Client.prototype._sha256 = function(data) {
  return crypto.createHash('sha256').update(data).digest('hex');
};

/**
 * Sends a request to the metadisk-api
 * @private
 * @param {String} method - HTTP verb
 * @param {String} path - Endpoint path
 * @param {Object} params - Request parameters
 * @param {Boolean} stream - Return the raw response stream?
 * @returns {Promise}
 */
Client.prototype._request = function(method, path, params, stream) {
  var opts = {
    baseUrl: this._options.baseURI,
    uri: path,
    method: method
  };

  params.__nonce = Date.now();

  if (['GET', 'DELETE'].indexOf(method) !== -1) {
    opts.qs = params;
    opts.json = true;
  } else {
    opts.json = params;
  }

  this._authenticate(opts);

  if (stream) {
    return request(opts);
  }

  return new Promise(function(resolve, reject) {
    request(opts, function(err, res, body) {
      if (err) {
        return reject(err);
      }

      if (res.statusCode >= 400) {
        return reject(new Error(body.error || body));
      }

      resolve(body);
    });
  });
};

/**
 * Adds authentication headers to request object
 * @private
 * @param {Object} opts - Options parameter passed to request
 * @return {Object}
 */
Client.prototype._authenticate = function(opts) {
  if (this._options.keypair) {
    var payload = ['GET', 'DELETE'].indexOf(opts.method) !== -1 ?
                  querystring.stringify(opts.qs) :
                  JSON.stringify(opts.json);

    var contract = [opts.method, opts.uri, payload].join('\n');

    opts.headers = opts.headers || {};
    opts.headers['x-pubkey'] = this._options.keypair.getPublicKey();
    opts.headers['x-signature'] = this._options.keypair.sign(contract);
  } else if (this._options.basicauth) {
    opts.auth = {
      user: this._options.basicauth.email,
      pass: this._sha256(this._options.basicauth.password)
    };
  }

  return opts;
};

module.exports = Client;
 at SyntaxError: Unexpected token (6:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/metadisk-client/node_modules/metadisk-client/index.js. Coverage (Term): 63% Coverage (LOC): 100%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
