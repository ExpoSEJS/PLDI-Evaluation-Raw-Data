/root/Targets/sgBase
└── sgBase@0.1.0 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/sgBase/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 32% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0497 took 4.7057s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Deleting local variable in strict mode (150:6) on program 
/**
 *  @fileOverview The utilities file for SG.
 *  @version 0.1
 */

// Remember when we started
var startupTime = new Date();

var sys             = require('sys');
var _               = require('./underscore');

var fs              = require('fs');
var spawn           = require('child_process').spawn;
var querystring     = require('querystring');
var net             = require('net');

/** @ignore */
exports._ = _;

/** 
 *  The container for basic utilities.
 *
 *  @namespace
 */
var utils = {};

/** 
 *  Utilities that make it easier during the development phase.
 *
 *  @namespace 
 */
utils.developUtils = {};

/** 
 *  Utilities that help program against the languate (JavaScript).
 *
 *  @namespace 
 */
utils.languageUtils = {};

/** 
 *  Utilities that help dealing with network issues.
 *
 *  @namespace 
 */
utils.netUtils = {};






/**
 *  Returns true-ish if the process is running in debug mode.
 *
 *  Note that running in debug / development / relaese modes are slightly different
 *  than in other contexts.
 *
 *  Debug mode is meant to produce tons of information by which someone can 
 *  determine the current running system's behavior.
 */
utils.developUtils.debug = function()
{
  return process.env['SG_DEBUG'];
}
var debug = utils.developUtils.debug;

/**
 *  Returns true-ish if the process is running in release mode.
 */
utils.developUtils.release = function()
{
  return !debug();
}
var release = utils.developUtils.release;

/**
 *  Returns true-ish if the process is running in development mode.
 *
 *  Note that running in debug / development / relaese modes are slightly different
 *  than in other contexts.
 *
 *  Development mode is menat to be run during active development - the code is
 *  changing all the time.  The system runs in a mode that informs the developer
 *  of any anomolies as soon as they are detected.  It uses the 'fast fail' 
 *  paradigm.  The program will halt (hopefully with the offending stack trace)
 *  as soon as it detects something wrong.
 *
 */
utils.developUtils.development = function()
{
  return process.env['SG_DEVELOPMENT'];
}
var development = utils.developUtils.development;

/**
 *  Returns true-ish if the process is running in a hyper-strict development mode.
 *
 *  Note that running in debug / development / relaese modes are slightly different
 *  than in other contexts.
 *
 */
utils.developUtils.warningsAsErrors = function()
{
  return process.env['SG_FASTFAIL_WARNINGS'];
}
var warningsAsErrors = utils.developUtils.warningsAsErrors;

/** @ignore */
var replaceIt = function(o, name, replacement)
{
  o[name] = replacement;
  return o;
}

/** @ignore */
var debugReplace = exports.debugReplace = function(o, name, replacement)
{
  debug() && replaceIt.apply(this, arguments);
  return o;
}

/** @ignore */
var releaseReplace = exports.releaseReplace = function(o, name, replacement)
{
  !debug() && replaceIt.apply(this, arguments);
  return o;
}

/**
 *  @name say
 *  @function
 *
 *  @param {int} id The id of the log message.
 */

var saySocket;
var setupSaySocket = function()
{
//  sys.print('_');
  if (!saySocket) {
//    sys.print('+');
    saySocket = new net.Socket();
    saySocket.connect(1311, 'localhost', function() {});
    saySocket.setEncoding('utf8');
    saySocket.setNoDelay(true);
    saySocket.on('error', function() {
//      sys.print(':(');
      delete saySocket;
      saySocket = null;
    });
    saySocket.on('close', function() {
//      sys.print('!');
      delete saySocket;
      saySocket = null;
    });
  }
}
setupSaySocket();
setInterval(function() {setupSaySocket();}, 1000);

/** @ignore */
var Say = exports.say = function(mod)
{
  return function(id)
  {
    var msg = [mod + ' ' + id];
    Array.prototype.slice.call(arguments, 1).forEach(function(x) {
      msg.push(sys.inspect(x, false, null));
    });
    var msgStr = msg.join(',, ').replace(/\n/g, '');
    sys.puts(msgStr);
    
    if (saySocket) {
      saySocket.write(msgStr+'\n');
    }
  }
}

/** @ignore */
var Say_x = exports.say_x = function(mod)
{
  return function(id)
  {
    var msg = [mod + ' ' + id];
    Array.prototype.slice.call(arguments, 1).forEach(function(x) {
      msg.push(sys.inspect(x, false, null));
    });
    sys.puts(msg.join(',, ').replace(/\n/g, ''));
  }
}

/** @ignore */
var say_ = Say('utils');

/** @ignore */
function say()
{
  return;
  say_.apply(this, arguments);
}

/**
 *  Clone the objects that are passed in.
 *
 *  Generally, you pass objects as the parameters
 *
 *  @param {object|Array} a The first parameter.
 */
utils.languageUtils.clone = function()
{
  var num = arguments.length;
  if (num < 1)
    return {};
  
  // If the user passed in an array, ...
  if ('length' in arguments[0]) {
    // ... and it was only an array ...
    if (num === 1) {
      // ... treat it like apply
      return clone.apply(this, arguments);
    }
    
    // ... and it was an array and a count ...
    if (num === 2 && typeof arguments[1] === 'number') {
      // ... treat it like apply(slice())
      return clone.apply(this, _.toArray(arguments).slice(arguments[1]));
    }
  }

  if (num > 2 && typeof arguments[num-2] === 'boolean' && arguments[num-2]) {
    var options = arguments[num-1];
    options.ignoreNonData = ('ignoreNonData' in options) ? options.ignoreNonData : true;
    num -= 2;
  }
  else {
    options = {};
  }
  
  var ignoreNonData = options.ignoreNonData;
  
  var cl = {};
  for (var i = 0; i < num; i++) {
    for (var k in arguments[i]) {
      var property = arguments[i][k];
      
      // Determine if we want to ignore this.
      var isData = true;
      
      // Ignore functions unless they are really REs
      if (typeof property === 'function' && !(property instanceof RegExp))
        isData = false;
        
      if (ignoreNonData && !isData) {
        continue;
      }
      cl[k] = property;
    }
  }
  return cl;
}

var clone = utils.languageUtils.clone;

/**
 *  Makes a query-string out of an object, and sanitizes the object first.
 *
 *  @param {object} query The object to be stringified.
 */
utils.languageUtils.stringifyQuery = function(query)
{
  return querystring.stringify(clone(query, true));
}
var stringifyQuery = utils.languageUtils.stringifyQuery;

/**
 *  Returns an object from an HTTP body, or the passed-in body.
 */
utils.netUtils.httpBody = function(req, body_, chunksName_)
{
  if (body_ && typeof body_ === 'object')
    return body_;
  
  var body = body_;
  if (typeof body !== 'string') {
    if (!body) {
      var chunksName = chunksName_ || 'chunks';
      body = req[chunksName];
    }
    
    if (_.isArray(body)) {
      body = body.join('');
    }
  }
  
  // Body should be a string by this point.
  // @todo:"assert that it is a string"
  
  // We need to decode it appropriately - JSON or form-encoded
  sys.puts(sys.inspect(req.headers));
  var contentType = req.headers['content-type'] || 'guess';
//  if (contentType === 'guess') {
    // @todo:"make this more robust.  dont do this fall-thru processing"
    try {
      body = JSON.parse(body);
    } catch(e) {
      body = querystring.parse(body);
    }
    return body;
//  }
}
var httpBody = utils.netUtils.httpBody;

/**
 *  Displays a message, then halts the process if we are still starting up (10 sec).
 *
 *  NOTE: You do not want to call this function directly, unless you are 100% sure
 *  that you are in the startup phase of your process (like verifying command-line
 *  parameters.)  You should usually use assert() and verify() variants.
 *
 *  In development mode, causes a run-time error to show the call stack.
 */
utils.developUtils.fastFail = function(msg, exitCode)
{
  exitCode = exitCode || 1;
  sys.puts('Error(' + exitCode + '): ' + msg);
  
  var shouldHalt = debug() || development();
  if (release() && (new Date()) - startupTime > 10000)
    shouldHalt = false;
  
  // Halt, if we are still starting up (10 sec)
  if (shouldHalt) {
    if (development())
      var xyz = intentionallyFaultTheProcess;
    else
      process.exit(exitCode);
  }
}
var fastFail = utils.developUtils.fastFail;

/**
 *  Evaluates the condition and calls fastFail if the condition is true.
 *
 */
utils.developUtils.fastFailIf = function(condition, msg, exitCode)
{
  if (condition)
    return fastFail(msg, exitCode);
}
var fastFailIf = utils.developUtils.fastFailIf;

/**
 *  Evaluates the condition and calls fastFail if the condition is false.
 *
 */
utils.developUtils.fastFailIfNot = function(condition, msg, exitCode)
{
  if (!condition)
    return fastFail(msg, exitCode);
}
var fastFailIfNot = utils.developUtils.fastFailIfNot;

/**
 *  Call a constructor with an array as its arguments.
 *
 *  @param {function} ctor  The constructor to call.
 *  @param {Array}    args  The arguments to pass to the ctor.
 */
utils.languageUtils.construct = function(ctor, args)
{
  function F() {
    return ctor.apply(this, args);
  }
  F.prototype = ctor.prototype;
  return new F();
}
var construct = utils.languageUtils.construct;

/**
 *  A mixture between call() and apply().
 *
 *  @param {function} fn    The function to call.
 *  @param {object}   ctx   Will be the 'this' pointer for the call to fn.
 *  @param {Array}    ar    The first arguments to the call.  Like the 2nd parameter to apply()
 *  @param            b     [optional] The first argument after the last array item to the call.
 *  @param            c     [optional] The second argument after the last array item to the call.
 *  @param            z     [optional] Etc.
 */
utils.languageUtils.callify = function(fn, ctx, a)
{
  var args = [];
  
  var realArgsStart = 2;
  if (a && _.isArray(a)) {          // toodo:"See if isArguments works here, it would be better"
    args = _.toArray(a).slice();
    realArgsStart++;
  }
  
  args = args.concat(_.compact(_.toArray(arguments).slice(realArgsStart)));
  return fn.apply(ctx, args);
}
var callify = utils.languageUtils.callify;

// The callee wants an async function, but the passed-in function might not
// be a function at all.  Either pass it back, or return a noop function.
var noopUnless = exports.noopUnless = function(fn)
{
  // If it is, indeed a function already, just return it.
  if (fn && typeof fn === 'function')
    return fn;

  // Otherwise, build a noop-style function that behaves according to the Node.js
  // calling standard
  return function() {
    // My last arg should be a callback
    callback = _.last(arguments);
    if (typeof callback === 'function')
      callback(null);
  }
}

var noopSync = exports.noopSync = exports.noops = function() {}

var mkObject = exports.mkObject = function(str, options)
{
  // First, attempt a normal JSON parsing
  try {
    return JSON.parse(str);
  }
  catch(e) {
  }
  
  // That didnt work.  If the caller allows, try eval
  if (options.evalOk) {
    var x;
    eval('x=' + str);
    return x;
  }
  
  // Nothing worked
  return null;
}

var readJsonFile = exports.readJsonFile = function(filename/*, options, callback*/)
{
  var args = _.toArray(arguments);
  var callback = args.pop();
  var options = args.pop() || {};
  var encoding = options.encoding || 'utf-8';
  fs.readFile(filename, encoding, function(err, contents) {
    if (err) callback(err, {});
    else {
      var json = mkObject(contents, {evalOk:true});
      callback(json == null, json);
    }
  });
}

var eventSource = exports.eventSource = function(handler)
{
  var self = this;
  self.context = {};
  
  self.handlers = {};
  self.eventInterpreters = {};

  self.initEventSource = function()
  {
    if (handler) {
      self.handlers['default'] = handler;
      self.eventInterpreters['default'] = self.identityInterpreter;
    }
    
    self.defaultInterpreter = self.identityInterpreter;
  }

  self.on = function(event, handler)
  {
    self.handlers[event] = self.handlers[event] || {interpreter:self.findInterpreter(event), handlers:[]};
    self.handlers[event].handlers.push(handler);
  }
  
  // In derived class, set self.defaultInterpreter or override self.findInterpreter
  self.findInterpreter = function(event)
  {
    if (event in self.eventInterpreters) {
      return self.eventInterpreters[event];
    }
    self.defaultInterpreter(1,2,/a/);
    return self.defaultInterpreter;
  }
  
  self.identityInterpreter = function(event, item, handlerName)
  {
    return handlerName == event ? item : null;
  }
  
  self.equalityInterpreter = function(event, item, handlerName)
  {
    return item == event ? item : null;
  }
  
  self.reInterpreter = function(event, item, handlerName)
  {
    var re = RegExp(handlerName);
    var m = re.exec(item);
    if (m) {
      return m.slice(1);
      
//      return Array.prototype.slice.apply(m, 1);
    }
    return null;
  }
  
  self.setInterpreterType = self.setInterpreter = function(event, type)
  {
    if (typeof type === 'string') {
      switch (type) {
        case 'identity':  self.eventInterpreters[event] = self.identityInterpreter;   break;
        case 're':        self.eventInterpreters[event] = self.reInterpreter;         break;
      }
    }
    else if (typeof type === 'function') {
      self.eventInterpreters[event] = type;
    }
  }
  
  self.dispatchSync = function(event, item)
  {
    // Allow one parameter
    item = item || event;
    
    for (var handlerName in self.handlers) {
      var handlerSet = self.handlers[handlerName];

      var interpretation = handlerSet.interpreter(event, item, handlerName);
      if (interpretation && (typeof interpretation !== 'object' || (typeof interpretation === 'object' && !('length' in interpretation))))
        interpretation = [interpretation];
        
      if (interpretation) {
        var handlers = handlerSet.handlers;
        _.each(handlers, function(handler) {
          handler.apply(self.context, interpretation);
        });
      }
    }
  }
  
  self.initEventSource();
}

var StrSpooler = function(data)
{
  var self = this;
  self.data = data || '';

  eventSource.apply(this, _.toArray(arguments).slice(1));
  self.defaultInterpreter = self.reInterpreter;
  self.defaultInterpreter(1,2,/s/);

  self.run = self.spoolStr = function(/*data, callback*/)
  {
    var args = _.toArray(arguments);
    
    var str = self.data;
    if (args.length > 0 && typeof args[0] === 'string')
      str = args.shift();

    var callback = function() {};
    if (args.length > 0 && typeof args[0] === 'function')
      callback = args.shift();

    var count = 0;
    var lines = str.split('\n');
    _.each(lines, function(line) {
      self.dispatchSync(line);
      count++;
    });
    
    callback(null, count);
  }
}

exports.StrSpooler = function()
{
  return construct(StrSpooler, arguments);
}

var FileSpooler = exports.FileSpooler = function(files)
{
  var self = this;

  self.initFileSpooler = function() {}
  
  StrSpooler.apply(this);
  self.setInterpreterType('newfile', 'identity');

  var dispatchFiles = function(files, callback)
  {
    if (files.length > 0) {
      var filename = files.shift();
      fs.readFile(filename, 'utf-8', function(err, contents) {
        self.dispatchSync('newfile', filename);
        self.spoolStr(contents, function() {
          dispatchFiles(files, callback);
        });
      });
    }
    else {
      callback.call(self.context, null, self.context);
    }
  }
  
  self.run = self.spoolFiles = function(/*data, callback*/)
  {
    var args = _.toArray(arguments);
    
    var files = self.data;
    if (args.length > 0 && typeof args[0] !== 'function')
      files = args.shift();

    var callback = function() {};
    if (args.length > 0 && typeof args[0] === 'function')
      callback = args.shift();

    return dispatchFiles(files, callback);
  }
  
  self.initFileSpooler();
}

var cmd2list = exports.cmd2list = function(cmd, callback)
{
  exec(cmd, function(err, stdout) {
    callback(err, stdout.split('\n'));
  });
}

var set = exports.set = function(list)
{
  var ret = {};
  _.each(list, function(x) {
    ret[x] = true;
  });
  return ret;
}

// a-b -- Remove anything in b that is in a
var setDiff = exports.setDiff = function(a, b)
{
  var ret = clone(a);
  for (var k in b) {
    delete ret[k];
  }
  return ret;
}

var dumbLauncher = exports.dumbLauncher = function(cmd/*, args, callback*/)
{
  var args_ = _.toArray(arguments).slice(1);
  var callback = args_.pop();
  var args = args_.pop();
  
  if (!args) {
    args = cmd.split(' ');
    cmd = args.shift();
  }
  say(201, 'launching', cmd, args);
  
  var proc = spawn(cmd, args);
  
  proc.stdout.on('data', function(data) {
    sys.print(data);
  });  
  
  proc.stderr.on('data', function(data) {
    sys.print(data);
  });  
  
  proc.on('exit', function(code) {
    callback(code);
  });
}

var proxyDetails = exports.proxyDetails = function()
{
  var proxy = process.env.http_proxy
  if (proxy) {
    // Strip off any starting 'http://' part
    var m = /http.?:\/\/(.+)/.exec(proxy);
    if (m)
      proxy = m[1];
    
    // For good measure, strip off any path
    m = /^([^/]+)/.exec(proxy);
    if (m)
      proxy = m[1];
    
    parts = proxy.split(':');
    return {host:parts[0], port:parts[1] || 8080};
  }
  return null;
}

// Assumes the input object is correctly formatted for Node connect calls.
// Changes appropriate info to handle proxy traversal
var proxify = exports.proxify = function(server, options)
{
  say(204, options);
  if (!options.skipProxy) {
    var proxy = proxyDetails();
    if (proxy) {
      return clone(server, proxy, true);
    }
  }
  return server;
}

var renameAttr = exports.renameAttr = function(o, name1, name2)
{
  o[name2] = o[name1];
  delete o[name1];
  return o;
}

var urlLib2Connect = exports.urlLib2Connect = function(urlObj)
{
  var ret = clone(urlObj);
  delete ret.protocol;
  delete ret.slashes;
  delete ret.query;
  delete ret.href;
  ret = renameAttr(ret, 'pathname', 'path');
  if (ret.search) {
    ret.path += ret.search;
    delete ret.search;
  }
  return renameAttr(ret, 'hostname', 'host');
}

/**
 * Parse the headers, looking for cookies.
 *
 * @function
 * @param {Object} headers The HTTP response headers.
 */
var parseCookies = exports.parseCookies = function(headers)
{
  var ret = {};
  
  if ('set-cookie' in headers) {
    var setCookie = headers['set-cookie'];
    _.each(setCookie, function(cookie) {
      var m = /(.+)=(.+); Path=(.+)/.exec(cookie);
      if (m) {
        say(202, m);
        ret[m[1]] = {value:m[2], path:m[3]};
      }
    });
  }
  
  return ret;
}

var manageCookies = exports.manageCookies = function(oldCookies, response)
{
  return clone(oldCookies, parseCookies(response.headers), true);
}

// o uses errback, callback. make a wrapper so someone only has to tell the
// errback once
var sg2ErrWrapper = exports.sg2ErrWrapper = function(o, names)
{
  o.errback = null;
  
  _.each(names, function(name) {
    say(203, name);
    var oldname = name + '_';
    o[name] = function()
    {
      // I just need to append self.errback, but if its still null, just dup the final param.
      var args = _.toArray(arguments);
      args.push(o.errback || _.last(args));
      return o[oldname].apply(this, args);
    }
  });
  
  return o;
}

var keys = exports.keys = function(o)
{
  var ret = [];
  for (var k in o) {
    ret.push(k);
  }
  return ret;
}

var reFilter = exports.reFilter = function(re, str)
{
  var m = re.exec(str);
  if (m)
    return m[1];
  return null;
}

var NO = exports.NO = exports.error = function()
{
  _.last(arguments)(false);
}

utils.exportify = function(lib, exportsObj_)
{
  var exportsObj = exportsObj_ || exports;
  for (var k in lib) {
    if (!(k in exportsObj)) {
      exportsObj[k] = lib[k];
    }
  }
}

// Export our functions
utils.exportify(utils.developUtils);
utils.exportify(utils.languageUtils);
utils.exportify(utils.netUtils);
exports.exportify = utils.exportify;


 at SyntaxError: Deleting local variable in strict mode (150:6)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.parseMaybeUnary (/root/ExpoSE/lib/Tropigate/bin/Unary.js:31:155)
    at Parser.pp$3.parseExprOps (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1637:21)
    at Parser.pp$3.parseMaybeConditional (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1620:21)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1597:21)
    at Parser.pp$3.parseExpression (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1573:21)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:727:47)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseBlock (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:981:25)
    at Parser.pp$3.parseFunctionBody (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2105:24)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/sgBase/node_modules/sgBase/lib/sgBase.js. Coverage (Term): 16% Coverage (LOC): 24%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
