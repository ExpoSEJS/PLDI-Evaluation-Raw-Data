/root/Targets/descent
└── descent@0.0.3 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/descent/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 22% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0287 took 3.1368s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Octal literal in strict mode (377:44) on program 
/*!
 * descent - compiler
 * Copyright (c) 2011 LearnBoost <tj@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var utils = require('./utils');

/**
 * Compile the given ast `node` into
 * a recursive descent parser generator.
 *
 * Options:
 *
 *    - `debug`  enable debug output
 *
 * @param {Array} node
 * @param {Object} options
 * @return {String}
 * @api private
 */

module.exports = function(node, options) {
  var rules = {}
    , options = options || {}
    , indents = 0
    , debug = options.debug
    , begin = '(begin=pos, 1)'
    , end = '(end=pos, 1)'
    , prologue = ''
    , vars = []
    , start;

  return boilerplate(stmts(node));

  /**
   * Construct parser body with the given `js`.
   */

  function boilerplate(js) {
    var str = __name__.toString()
      .replace('__prologue__', prologue)
      .replace('__name__', 'parse')
      .replace('__start__', start)
      .replace('__body__', js.replace(/^/gm, '  '));
    if (debug) str = str.replace(/DEBUG: */g, '');
    else str = str.replace(/ *DEBUG:([^\n]+)\n/g, '');
    return str;
  }

  /**
   * Visit stmts.
   */

  function stmts(node) {
    return node.map(visit).join('');
  }

  /**
   * Visit the given `node`.
   */

  function visit(node) {
    switch (node[0]) {
      case 'prologue':
        prologue = node[1].trim();
        break;
      case 'expr-predicate': return exprPredicate(node);
      case 'named-rule': return namedRule(node);
      case 'rule-def': return ruleDef(node);
      case 'optional': return optional(node);
      case 'capture': return capture(node);
      case 'regexp': return regexp(node);
      case 'string': return string(node);
      case 'group': return group(node);
      case 'action': return action(node);
      case 'rule': return rule(node);
      case 'expr': return expr(node);
      case 'many': return many(node);
      case 'any': return any(node);
      case 'alt': return alt(node);
      case 'dot': return dot(node);
      case 'not': return not(node);
      default: throw new Error('failed to visit "' + node[0] + '"');
    }
  }

  /**
   * Negation.
   */

   function not(node) {
     return '(ts = state(), !(' + visit(node[1]) + ') || (restore(ts), 0))';
   }

  /**
   * Expression predicate.
   */

   function exprPredicate(node) {
     var src = node[1][1].trim();
     return '(' + src + ')';
   }

  /**
   * Produce text capture logic.
   */

  function capture(node) {
    var thunk = 'thunk(function(begin, end){ text = orig.slice(begin, end); })';
    return '(' +
      [begin, visit(node[1]), end, thunk].join('\n' + indent() + '&& ')
      + ')';
  }

  /**
   * Produce action thunk.
   */

  function action(node) {
    var buf = 'thunk(function(){\n';
    ++indents;
    if (vars.length) buf += variables() + '\n';
    buf += indent() + node[1].trim() + '\n';
    --indents;
    buf += indent() + '})';
    return buf;
  }

  /**
   * Return variable definitions to provide
   * named vstack values for a thunk.
   */

  function variables() {
    // vars
    var buf = indent() + 'var ' + vars.reverse().map(function(name){
      return name + ' = vstack.pop()';
    }).join('\n  ' + indent() + ', ') + ';';

    // debug
    if (debug) {
      buf += '\n';
      buf += vars.reverse().map(function(name){
        return 'console.error("' + name + ' = %j", ' + name + ')';
      }).join('\n  ' + indent() + ' DEBUG: ');
    }

    vars = [];
    return buf;
  }

  /**
   * Visit a named-rule.
   */

  function namedRule(node) {
    var name = node[1][1];
    vars.push(name);
    return visit(node[2]);
  }

  /**
   * Visit a rule.
   */

  function rule(node) {
    var name = utils.normalize(node[1]);
    return '_' + name + '()';
  }

  /**
   * Visit a group.
   */

  function group(node) {
    var buf = '';
    buf += '(function(){\n';
    ++indents;
    buf += indent() + 'var s = state();\n'
    buf += indent() + 'return ' + visit(node[1]) + ';\n'
    --indents;
    buf += indent() + '})()';
    return buf;
  }

  /**
   * Visit an optional sequence.
   */

  function optional(node) {
    return '(' + visit(node[1]) + ' || 1)';
  }

  /**
   * Visit zero or more aka "any" node.
   */

  function any(node) {
    // TODO: unwrap when the only alternative
    var buf = '(function(){\n'
    ++indents;
    buf += indent() + 'while (';
    buf += visit(node[1]);
    buf += ') ;\n'
    buf += indent() + 'return 1;\n';
    --indents;
    buf += indent() + '})()';
    return buf;
  }

  /**
   * Visit one or more aka "many" node.
   */

  function many(node) {
    var buf = '(function(){\n'
    ++indents;
    buf += indent() + 'if (!' + visit(node[1]) + ') return;\n';
    buf += indent() + 'while (' + visit(node[1]) + ') ;\n';
    buf += indent() + 'return 1;\n';
    --indents;
    buf += indent() + '})()';
    return buf;
  }

  /**
   * Visit rule-def node, producing a js
   * function, saving / restoring state on falure.
   */

  function ruleDef(node) {
    var name = node[1]
      , val = node[2]
      , buf = '';

    // TODO: ignore thunkpos when no actions are present
    ++indents;
    rules[name] = val;
    name = '_' + utils.normalize(name);
    start = start || name;
    buf += '\n';
    buf += 'function ' + name + '(){\n';
    buf += indent() + 'DEBUG: console.error("\\033[36m' + name + '\\033[0m")\n';
    buf += indent() + 'var s = state();\n';
    buf += indent();
    ++indents;
    buf += 'if (' + visit(val) + ') return 1;\n';
    --indents;
    buf += indent() + 'restore(s);\n';
    buf += '}\n';
    --indents;

    return buf;
  }

  /**
   * Visit alternatives, restoring state.
   */

  function alt(node) {
    // TODO: do not restore for primitive matches
    return '(' +
      visit(node[1]) + '\n' + indent()
      + '|| '
      + '(restore(s)\n'
      + indent() + ' && ' + visit(node[2])
      + '))';
  }

  /**
   * Visit expr, optimizing for a single value.
   */

  function expr(node) {
    if (1 == node[1].length) {
      return visit(node[1][0]);
    } else {
      return '(' +
        node[1].map(visit).join('\n' + indent() + '  && ')
        + ')';
    }
  }

  /**
   * Visit sequence.
   */

  function sequence(node) {
    var buf = '';
    buf += '\n' + indent();
    switch (node[0]) {
      case 'action':
        buf += visit(node);
        break;
      default:
        buf += 'if (!(' + visit(node) + ')) return;';
    }
    return buf;
  }

  /**
   * Visit regexp.
   */

  function regexp(node) {
    return 'pattern(/^' + node[1] + '/' + (node[2] || '') + ')';
  }

  /**
   * Visit string.
   */

  function string(node) {
    var val = node[1].replace(/"/g, '\\"');
    if (1 == node[1].length) return 'char("' + val + '")';
    return 'string("' + val + '")';
  }

  /**
   * Visit dot.
   */

   function dot() {
    return 'anyChar()';
   }

  /**
   * Produce indentation.
   */

  function indent() {
    return Array(indents + 1).join('  ');
  }
};

/**
 * Boilerplate parser function.
 */

function __name__(input) {
  var orig = input
    , thunks = []
    , vstack = []
    , rightmostPos = 0
    , pos = 0
    , begin = 0
    , end = 0
    , thunkpos
    , mark
    , text
    , tmp
    , ts
    , $;

  __prologue__;

  return __start__(), done();

  function done() {
    DEBUG: console.error('\nthunks: %d\nunparsed chars: %d', thunks.length, input.length)
    var len = thunks.length
      , thunk;
    for (var i = 0; i < len; ++i) {
      thunk = thunks[i];
      $ = undefined;
      thunk(thunk.begin, thunk.end);
      if (undefined !== $) vstack.push($);
      DEBUG: if (undefined !== $) console.error('pushed %j', $)
    }
    DEBUG: if (undefined != $) console.error('return %j', $)
    DEBUG: if (input.length) console.error('\033[31munparsed:\033[0m "%s"', inspect(input));
    if (input.length) error();
    return $;
  }

  function inspect(str) {
    return str
      .replace(/\\/g, '\\\\')
      .replace(/\r/g, '\\r')
      .replace(/\n/g, '\\n')
      .replace(/"/g, '\\"');
  }

  function state() {
    rightmostPos = pos;
    return {
        thunkpos: thunks.length
      , input: input
      , pos: pos
    };
  }

  function restore(state) {
    thunks.length = state.thunkpos;
    input = state.input;
    pos = state.pos;
    DEBUG: console.error('\033[90mrestore state to \033[0m"%s"', inspect(input.slice(0, 15)))
    return 1;
  }

  function thunk(fn) {
    fn.begin = begin;
    fn.end = end;
    thunks.push(fn);
    return 1;
  }

  function anyChar() {
    DEBUG: console.error('\033[90manyChar()\033[0m "%s"', inspect(input.slice(0, 15)))
    if (input.length) {
      DEBUG: console.error('\033[32mmatch "%s"\033[0m', inspect(input[0]));
      ++pos;
      input = input.substr(1);
      return 1;
    }
  }

  function char(c) {
    DEBUG: console.error('\033[90mchar("%s")\033[0m "%s"', inspect(c), inspect(input.slice(0, 15)))
    if (c == input[0]) {
      DEBUG: console.error('\033[32mmatch "%s"\033[0m', inspect(c))
      ++pos;
      input = input.substr(1);
      return 1;
    }
  }

  function string(str) {
    DEBUG: console.error('\033[90mstring("%s")\033[0m "%s"', inspect(str), inspect(input.slice(0, 15)))
    if (0 == input.indexOf(str)) {
      DEBUG: console.error('\033[32mmatch "%s"\033[0m', inspect(str))
      var len = str.length;
      pos += len;
      input = input.substr(len);
      return 1;
    }
  }

  function pattern(regexp) {
    var captures;
    DEBUG: console.error('\033[90mpattern(%s)\033[0m "%s"', regexp, inspect(input.slice(0, 15)))
    if (captures = regexp.exec(input)) {
      DEBUG: console.error('\033[32mmatch "%s"\033[0m', inspect(captures[0]))
      var len = captures[0].length;
      pos += len;
      input = input.substr(len);
      return 1;
    }
  }

  function errorPosition() {
    var lineno = 1;
    for (var i = 0; i < pos; ++i) {
      switch (orig[i]) {
        case '\n': ++lineno; break;
      }
    }
    return { line: lineno };
  }

  function error() {
    pos = rightmostPos;
    var prefix = 'parse error on line ' + errorPosition().line + ' near '
      , prefixlen = 'Error: '.length + prefix.length + 1
      , context = 10
      , start = Math.max(pos - context, 0)
      , len = orig.length
      , end = Math.min(pos + context, len)
      , mark = pos - start
      , tilde = Array(end - pos).join('~')
      , ellipsis = end == len ? '' : '...'
      , _context = orig.slice(start, end) + ellipsis
      , context = inspect(_context)
      , head = _context.slice(0, mark)
      , diff = inspect(head).length - head.length
      , mark = Array(prefixlen + 1 + diff + mark).join(' ') + '^' + tilde;
    throw new Error(prefix + '"' + context + '"' + '\n' + mark);
  }
  __body__
} at SyntaxError: Octal literal in strict mode (377:44)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$7.readEscapedChar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:3023:16)
    at Parser.pp$7.readString (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2935:23)
    at Parser.pp$7.getTokenFromCode (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2724:19)
    at Parser.pp$7.readToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2477:17)
    at Parser.readToken (/root/ExpoSE/lib/Tropigate/bin/Tokens.js:124:26)
    at Parser.pp$7.nextToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2468:15)
    at Parser.pp$7.next (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2413:10)
    at Parser.pp.eat (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:536:12)
    at Parser.pp$3.parseSubscripts (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1738:37)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/descent/node_modules/descent/index.js. Coverage (Term): 80% Coverage (LOC): 100%
*- File /root/Targets/descent/node_modules/descent/lib/descent.js. Coverage (Term): 89% Coverage (LOC): 100%
*- File /root/Targets/descent/node_modules/descent/lib/lexer.js. Coverage (Term): 4% Coverage (LOC): 7%
*- File /root/Targets/descent/node_modules/descent/lib/parser.js. Coverage (Term): 4% Coverage (LOC): 4%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
