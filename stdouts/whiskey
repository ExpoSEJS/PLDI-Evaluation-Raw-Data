/root/Targets/whiskey
└─┬ whiskey@0.8.4 
  ├─┬ async@2.5.0 
  │ └── lodash@4.17.4 
  ├── gex@0.0.1 
  ├─┬ istanbul@0.4.5 
  │ ├── abbrev@1.0.9 
  │ ├── async@1.5.2 
  │ ├─┬ escodegen@1.8.1 
  │ │ ├── estraverse@1.9.3 
  │ │ ├── esutils@2.0.2 
  │ │ ├─┬ optionator@0.8.2 
  │ │ │ ├── deep-is@0.1.3 
  │ │ │ ├── fast-levenshtein@2.0.6 
  │ │ │ ├── levn@0.3.0 
  │ │ │ ├── prelude-ls@1.1.2 
  │ │ │ └── type-check@0.3.2 
  │ │ └─┬ source-map@0.2.0 
  │ │   └── amdefine@1.0.1 
  │ ├── esprima@2.7.3 
  │ ├─┬ glob@5.0.15 
  │ │ ├── inflight@1.0.6 
  │ │ ├── inherits@2.0.3 
  │ │ ├─┬ minimatch@3.0.4 
  │ │ │ └─┬ brace-expansion@1.1.8 
  │ │ │   ├── balanced-match@1.0.0 
  │ │ │   └── concat-map@0.0.1 
  │ │ └── path-is-absolute@1.0.1 
  │ ├─┬ handlebars@4.0.10 
  │ │ ├── async@1.5.2 
  │ │ ├─┬ optimist@0.6.1 
  │ │ │ ├── minimist@0.0.10 
  │ │ │ └── wordwrap@0.0.3 
  │ │ ├── source-map@0.4.4 
  │ │ └─┬ uglify-js@2.8.29 
  │ │   ├── source-map@0.5.7 
  │ │   ├── uglify-to-browserify@1.0.2 
  │ │   └─┬ yargs@3.10.0 
  │ │     ├── camelcase@1.2.1 
  │ │     ├─┬ cliui@2.1.0 
  │ │     │ ├─┬ center-align@0.1.3 
  │ │     │ │ ├─┬ align-text@0.1.4 
  │ │     │ │ │ ├─┬ kind-of@3.2.2 
  │ │     │ │ │ │ └── is-buffer@1.1.5 
  │ │     │ │ │ ├── longest@1.0.1 
  │ │     │ │ │ └── repeat-string@1.6.1 
  │ │     │ │ └── lazy-cache@1.0.4 
  │ │     │ ├── right-align@0.1.3 
  │ │     │ └── wordwrap@0.0.2 
  │ │     ├── decamelize@1.2.0 
  │ │     └── window-size@0.1.0 
  │ ├─┬ js-yaml@3.10.0 
  │ │ ├─┬ argparse@1.0.9 
  │ │ │ └── sprintf-js@1.0.3 
  │ │ └── esprima@4.0.0 
  │ ├─┬ mkdirp@0.5.1 
  │ │ └── minimist@0.0.8 
  │ ├── nopt@3.0.6 
  │ ├─┬ once@1.4.0 
  │ │ └── wrappy@1.0.2 
  │ ├── resolve@1.1.7 
  │ ├─┬ supports-color@3.2.3 
  │ │ └── has-flag@1.0.0 
  │ ├─┬ which@1.3.0 
  │ │ └── isexe@2.0.0 
  │ └── wordwrap@1.0.0 
  ├── logmagic@0.1.4 
  ├── magic-templates@0.1.1 
  ├── rimraf@1.0.1 
  ├── simplesets@1.1.6 
  ├── sprintf@0.1.5 
  ├── terminal@0.1.3 
  └── underscore@1.8.3 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/whiskey/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","Object","call","binding","RegExp","join","getHostname","pow","sort"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0462 took 22.1133s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (29:4) on program /*
 * Licensed to Cloudkick, Inc ('Cloudkick') under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * Cloudkick licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

var path = require('path');
var net = require('net');
var util = require('util');

var sprintf = require('sprintf').sprintf;
var async = require('async');
var gex = require('gex');
var underscore = require('underscore');
var log = require('logmagic').local('whiskey.common');

var assert = require('./assert');
var constants = require('./constants');
var testUtil = require('./util');
var coverage = require('./coverage');
var scopeleaks = require('./scopeleaks');

var isValidTestFunctionName = function(name) {
  return name.indexOf('test') === 0;
};


// foo.bar.test.* -> [ foo/bar/test.js, '*' ]
// test. -> [ 'test.js', '*']
// some.path.foo.test_bar* -> [ 'some/path/foo.js', 'test_bar*' ]
function getTestFilePathAndPattern(patternString) {
  if (/\.js$/.test(patternString)) {
    return [ patternString, '*' ];
  }

  var split = patternString.split('.');
  var len = split.length;
  var testFile, basePath, testPath, pattern;

  testFile = sprintf('%s.js', split[len - 2]);
  pattern = split[len - 1] || '*';
  basePath = split.splice(0, len - 2).join('/');
  testPath = path.join(basePath, testFile);

  return [ testPath, pattern ];
}

function SkipError(test, msg) {
  this.test = test;
  this.msg = msg || '';
  Error.call(this, 'skipped');
}

util.inherits(SkipError, Error);

var runInitFunction = function(filePath, callback) {
  var testObj;
  var initModule = null;

  try {
    initModule = require(filePath);
  }
  catch (err) {
    // Invalid init file path provided
    callback();
    return;
  }

  if (initModule) {
    if (initModule.hasOwnProperty(constants.INIT_FUNCTION_NAME)) {
      try {
        initModule[constants.INIT_FUNCTION_NAME](callback);
        return;
      }
      catch (err2) {
        callback();
        return;
      }
    }
  }

  callback();
};

function Test(testName, testFunction, scopeLeaks) {
  this._testName = testName;
  this._testFunction = testFunction;

  this._finished = false;
  this._testObj = null;
  this._assertObj = null;

  this._timeStart = null;
  this._timeEnd = null;
  this._status = null; // 'success' or 'failure'
  this._err = null; // only populated if _status = 'failure'
  this._skipMsg = null;
  this._scopeLeaks = scopeLeaks || false;
  this._leakedVariables = null; // a list of variables which leaked into
                                // global scope
}

Test.prototype._getScopeSnapshot = function(scope) {
  if (!this._scopeLeaks) {
    return null;
  }

  return scopeleaks.getSnapshot(scope);
};

Test.prototype._getLeakedVariables = function(scopeBefore, scopeAfter) {
  if (!this._scopeLeaks) {
    return null;
  }

  return scopeleaks.getDifferences(scopeBefore, scopeAfter);
};

Test.prototype.run = function(callback) {
  var self = this;
  var scopeBefore, scopeAfter, err;
  var finishCallbackCalled = false;

  function finishCallback() {
    callback(self.getResultObject());
  }

  function finishFunc() {
    if (finishCallbackCalled) {
      // someone called .finish() twice.
      log.infof('test.finish in [bold]${name}[/bold] has been called twice' +
                ', possible double callback in your code!',
                {'name': self._testName});
      return;
    }

    if (!self._status) {
      scopeAfter = self._getScopeSnapshot(global);
      self._leakedVariables = self._getLeakedVariables(scopeBefore, scopeAfter);

      self._markAsSucceeded();
    }

    self._timeEnd = new Date().getTime();
    finishCallbackCalled = true;
    finishCallback();
  }

  this._testObj = this._getTestObject(finishFunc);
  this._assertObj = this._getAssertObject();

  self._timeStart = new Date().getTime();

  try {
    scopeBefore = this._getScopeSnapshot(global);
    this._testFunction(this._testObj, this._assertObj);

  }
  catch (actualErr) {
    if ((actualErr instanceof Error)) {
      err = actualErr;
    }
    else if (underscore.isString(actualErr)) {
      err = {};
      err.message = actualErr;
    }
    else if (!actualErr.hasOwnProperty('message') && actualErr.toString &&
             typeof actualErr.toString === 'function') {
       err = {};
       err.message = actualErr.toString();
    }
    else {
      err = actualErr;
    }

    scopeAfter = this._getScopeSnapshot(global);
    this._leakedVariables = this._getLeakedVariables(scopeBefore, scopeAfter);

    if (err instanceof SkipError) {
      this._markAsSkipped(err.msg);
    }
    else {
      this._markAsFailed(err);
    }

    finishFunc();
    return;
  }
};

Test.prototype._getTestObject = function(finishFunc) {
  var self = this;
  var testObj = function test() {
    return finishFunc.apply(undefined, arguments);
  };

  function skipFunc(msg) {
    throw new SkipError(self, msg);
  }

  testObj.finish = finishFunc;
  testObj.skip = skipFunc;
  testObj.spy = new SpyOn();

  return testObj;
};

Test.prototype._getAssertObject = function() {
  return assert.getAssertModule(this);
};

Test.prototype._markAsSucceeded = function() {
  this._finished = true;
  this._status = 'success';
};

Test.prototype._markAsFailed = function(err) {
  var stack;

  if (err.hasOwnProperty('test')) {
    delete err.test;
  }

  if (err.stack) {
    // zomg, hacky, but in a later versions of V8 it looks like stack is some
    // kind of special attribute which can't be serialized.
    stack = err.stack.toString();
    delete err.stack;
    err.stack = stack;
  }

  this._finished = true;
  this._err = err;
  this._status = 'failure';
};

Test.prototype._markAsSkipped = function(msg) {
  this._finished = true;
  this._status = 'skipped';
  this._skipMsg = msg;
};

Test.prototype.isRunning = function() {
  return !this._finished;
};

Test.prototype.beforeExit = function(handler) {
  this._beforeExitHandler = handler;
};

Test.prototype.getResultObject = function() {
  var resultObj = {
    'name': this._testName,
    'status': this._status,
    'error': this._err,
    'skip_msg': this._skipMsg,
    'leaked_variables': this._leakedVariables,
    'time_start': this._timeStart,
    'time_end': this._timeEnd
  };

  return resultObj;
};

function TestFile(filePath, options, chdir) {
  this._filePath = filePath;
  this._pattern = options['pattern'];
  this._chdir = chdir;

  this._socketPath = options['socket_path'];
  this._fileName = path.basename(this._filePath);
  this._testInitFile = options['init_file'];
  this._timeout = options['timeout'];
  this._concurrency = options['concurrency'];
  this._scopeLeaks = options['scope_leaks'];

  this._tests = [];
  this._uncaughtExceptions = [];

  this._runningTest = null;
}

TestFile.prototype.addTest = function(test) {
  this._tests.push(test);
};

TestFile.prototype.runTests = function(callback) {
  var self = this;
  var i, test, exportedFunctions, exportedFunctionsNames, errName;
  var initializeFunc, finalizeFunc;
  var setUpFunc, tearDownFunc;
  var testName, testFunc, testsLen;
  var callbackCalled = false;
  var testModule = this._filePath.replace(/\.js$/, '');

  function handleEnd() {
    var resultObj;
    if (callbackCalled) {
      return;
    }

    callbackCalled = true;
    callback();
  }

  function onTestDone(test, callback) {
    var resultObj = test.getResultObject();

    self.addTest(test);
    self._reportTestResult(resultObj);
    callback();
  }

  async.series([
    // Obtain the connection
    function(callback) {
      self._getConnection(function(err, connection) {
        if (err) {
          callback(new Error('Unable to establish connection with the master ' +
                             'process'));
          return;
        }

        self._connection = connection;
        callback();
      });
    },

    // if test init file is present, run init function in it
    function(callback) {
      if (!self._testInitFile) {
        callback();
        return;
      }

      runInitFunction(self._testInitFile, callback);
    },

    // Require the test file
    function(callback) {
      var errName;
      try {
        exportedFunctions = require(testModule);
      }
      catch (err) {
        if (err.message.indexOf(testModule) !== -1 &&
            err.message.match(/cannot find module/i)) {
            errName = 'file_does_not_exist';
          }
          else {
            errName = 'uncaught_exception';
          }

          test = new Test(errName, null);
          test._markAsFailed(err);
          self._reportTestResult(test.getResultObject());
          callback(err);
          return;
      }

      exportedFunctionsNames = Object.keys(exportedFunctions);
      exportedFunctionsNames = exportedFunctionsNames.filter(isValidTestFunctionName);
      testsLen = exportedFunctionsNames.length;
      initializeFunc = exportedFunctions[constants.TEST_FILE_INITIALIZE_FUNCTION_NAME];
      finalizeFunc = exportedFunctions[constants.TEST_FILE_FINALIZE_FUNCTION_NAME];
      setUpFunc = exportedFunctions[constants.SETUP_FUNCTION_NAME];
      tearDownFunc = exportedFunctions[constants.TEARDOWN_FUNCTION_NAME];

      callback();
    },

    function(callback) {
      // If an init function is present, run it
      if (!initializeFunc) {
        callback();
        return;
      }

      var test = new Test(constants.TEST_FILE_INITIALIZE_FUNCTION_NAME, initializeFunc,
                          self._scopeLeaks);
      test.run(onTestDone.bind(null, test, callback));
    },

    // Run the tests
    function(callback) {
      var queue;

      if (exportedFunctionsNames.length === 0) {
        callback();
        return;
      }

      function taskFunc(task, callback) {
        var setUpFunc = task.setUpFunc, tearDownFunc = task.tearDownFunc;

        async.waterfall([
          function runSetUp(callback) {
            if (!setUpFunc) {
              callback();
              return;
            }

            var test = new Test(constants.SETUP_FUNCTION_NAME, setUpFunc,
                                self._scopeLeaks);
            test.run(onTestDone.bind(null, test, callback));
          },

          function runTest(callback) {
            var test = task.test;
            self._runningTest = test;
            test.run(onTestDone.bind(null, test, callback));
          },

          function runTearDown(callback) {
           if (!tearDownFunc) {
              callback();
              return;
            }

            var test = new Test(constants.TEARDOWN_FUNCTION_NAME, tearDownFunc,
                                self._scopeLeaks);
            test.run(onTestDone.bind(null, test, callback));
          }
        ], callback);
      }

      function onDrain() {
        callback();
      }

      queue = async.queue(taskFunc, self._concurrency);
      queue.drain = onDrain;

      for (i = 0; i < testsLen; i++) {
        testName = exportedFunctionsNames[i];
        testFunc = exportedFunctions[testName];

        if (!gex(self._pattern).on(testName)) {
          continue;
        }

        test = new Test(testName, testFunc, self._scopeLeaks);
        queue.push({'test': test, 'setUpFunc': setUpFunc, 'tearDownFunc': tearDownFunc});
      }

      if (queue.length() === 0) {
        // No test matched the provided pattern
        callback();
      }
    },

    function(callback) {
      // If a finalize function is present, run it
      if (!finalizeFunc) {
        callback();
        return;
      }

      var test = new Test(constants.TEST_FILE_FINALIZE_FUNCTION_NAME, finalizeFunc,
                          self._scopeLeaks);
      test.run(onTestDone.bind(null,  test, callback));
    }
  ],

  function(err) {
    handleEnd();
  });
};

TestFile.prototype._getConnection = function(callback) {
  var connection = net.createConnection(this._socketPath);

  connection.on('connect', function onConnect() {
    callback(null, connection);
  });

  connection.on('error', function onError(err) {
    callback(err, null);
  });
};

TestFile.prototype._reportTestResult = function(resultObj) {
  var payload;
  payload = sprintf('%s%s%s%s%s\n', constants.TEST_START_MARKER, this._filePath,
                    constants.DELIMITER, JSON.stringify(resultObj),
                    constants.TEST_END_MARKER);
  this._connection.write(payload);
};

TestFile.prototype._reportTestCoverage = function(coverageObj) {
  this._connection.write(sprintf('%s%s%s%s\n',
                                 this._filePath,
                                 constants.DELIMITER,
                                 coverage.stringifyCoverage(coverageObj, this._chdir),
                                 constants.COVERAGE_END_MARKER));
};

TestFile.prototype._reportTestFileEnd = function() {
  this._connection.end(sprintf('%s%s\n', this._filePath,
                               constants.TEST_FILE_END_MARKER));
};

TestFile.prototype.addUncaughtException = function(err) {
  var test = err.test;

  if (test) {
    if (err instanceof SkipError) {
      test._markAsSkipped(err.msg);
      test._testObj.finish();
    }
    else {
      test._markAsFailed(err);
      test._testObj.finish();
    }

    this.addTest(test);
  }
  else if (this._runningTest) {
    // User did not use our assert module or uncaughtException was thrown
    // somewhere in the async code.
    // Check which test is still running, mark it as failed and finish it.
    test = this._runningTest;
    test._markAsFailed(err);
    test._testObj.finish();
    this.addTest(test);
  }
  else {
    // Can't figure out the origin, just add it to the _uncaughtExceptions
    // array.
    this._uncaughtExceptions.push(err);
  }
};

TestFile.prototype.getResultObject = function(errObj) {
  var i, test, result, name, uncaughtException;
  var testsLen = this._tests.length;
  var uncaughtExceptionsLen = this._uncaughtExceptions.length;

  var resultObj = {
    'file_path': this._filePath,
    'file_name': this._fileName,
    'error': null,
    'timeout': false,
    'stdout': '',
    'stderr': '',
    'tests': {}
  };

  if (errObj) {
    resultObj.error = errObj;
    return resultObj;
  }

  for (i = 0; i < testsLen; i++) {
    test = this._tests[i];
    result = test.getResultObject();
    resultObj.tests[result.name] = result;
  }

  for (i = 0; i < uncaughtExceptionsLen; i++) {
    name = sprintf('uncaught_exception_%d', i + 1);
    uncaughtException = this._uncaughtExceptions[i];
    test = new Test(name, null);
    test._markAsFailed(uncaughtException);
    resultObj.tests[name] = test.getResultObject();
  }

  return resultObj;
};

function registerCustomAssertionFunctions(functions) {
  assert.merge(null, functions);
}

exports.Test = Test;
exports.TestFile = TestFile;
exports.getTestFilePathAndPattern = getTestFilePathAndPattern;

exports.registerCustomAssertionFunctions = registerCustomAssertionFunctions;

/**
 * @constructor
 */
function SpyOn (){
  /**
   * This tracks the arguments a function has been called with.
   * @param {Object.<Array>}
   * @private
   */
  this._calls = {};
  /**
   * This tracks the function to call
   * @param {Object.<Function>}
   * @private
   */
  this._funcMap = {};
}

/**
 * @param {string} funcName The key to use for tracking call counts.
 * @param {Object} context The context in which the function should execute.
 * @param {Function} optFunc The optional function to call in wrapper. If not
 * provided, original function will be called.
 */
SpyOn.prototype.on = function (funcName, context, optFunc) {
  var wrapper, func;
  if (optFunc) {
    func = optFunc;
  } else {
    func = context[funcName];
  }
  if (this._calls.hasOwnProperty(funcName)) {
    throw "Function already being tracked.";
  }
  this.reset(funcName);
  wrapper = (function () {
    this._calls[funcName].push(Array.prototype.slice.call(arguments));
    return func.apply(context, arguments);
  }).bind(this);
  context[funcName] = wrapper;
  this._funcMap[funcName] = func;
  return this;
};

/**
 * @param {string} funcName The key to clear.
 * @param {Object} context The context in which the function should execute.
 * @param {Function} optFunc The optional function to reapply to the context.
 */
SpyOn.prototype.clear = function (funcName, context, optFunc) {
  if (optFunc) {
    context[funcName] = optFunc;
  } else {
    context[funcName] = this._funcMap[funcName];
  }
  delete this._calls[funcName];
  delete this._funcMap[funcName];
  return this;
};

/**
 * Reset a call count.
 * @param {string} funcName The name of the function.
 */
SpyOn.prototype.reset = function (funcName) {
  this._calls[funcName] = [];
};

/**
 * Get the call count for a spied on function.
 * @param {string} funcName
 */
SpyOn.prototype.called = function (funcName) {
  var calls = this._calls[funcName];

  // checks the actual args match the expected args
  var checkArgsMatch = function (actualArgs, expectedArgs) {
    var i;
    if (actualArgs.length !== expectedArgs.length) {
      return false;
    }
    for (i = 0; i < expectedArgs.length; i++) {
      if (actualArgs[i] !== expectedArgs[i]) {
        return false;
      }
    }
    return true;
  };

  return {
    valueOf: function () {
      return calls.length;
    },
    withArgs: function () {
      var i, j, match;
      var args = Array.prototype.slice.call(arguments);
      for (i = 0; i < calls.length; i++) {
        if (checkArgsMatch(calls[i], args)) {
          return true;
        }
      }
      return false;
    },
    with: function () {
      return this.withArgs.apply(this, arguments);
    }
  };
};
 at SyntaxError: Unexpected token (29:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/whiskey/node_modules/whiskey/index.js. Coverage (Term): 65% Coverage (LOC): 100%
*- File /root/Targets/whiskey/node_modules/whiskey/lib/bdd.js. Coverage (Term): 13% Coverage (LOC): 16%
*- File /root/Targets/whiskey/node_modules/sprintf/lib/sprintf.js. Coverage (Term): 40% Coverage (LOC): 46%
*- File /root/Targets/whiskey/node_modules/whiskey/lib/run.js. Coverage (Term): 5% Coverage (LOC): 4%
*- File /root/Targets/whiskey/node_modules/async/dist/async.js. Coverage (Term): 23% Coverage (LOC): 32%
*- File /root/Targets/whiskey/node_modules/logmagic/lib/logmagic.js. Coverage (Term): 26% Coverage (LOC): 44%
*- File /root/Targets/whiskey/node_modules/logmagic/lib/graylog.js. Coverage (Term): 23% Coverage (LOC): 31%
*- File /root/Targets/whiskey/node_modules/underscore/underscore.js. Coverage (Term): 19% Coverage (LOC): 33%
*- File /root/Targets/whiskey/node_modules/whiskey/lib/constants.js. Coverage (Term): 100% Coverage (LOC): 100%
*- File /root/Targets/whiskey/node_modules/whiskey/lib/parser.js. Coverage (Term): 17% Coverage (LOC): 17%
*- File /root/Targets/whiskey/node_modules/whiskey/lib/extern/optparse/lib/optparse.js. Coverage (Term): 12% Coverage (LOC): 20%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
