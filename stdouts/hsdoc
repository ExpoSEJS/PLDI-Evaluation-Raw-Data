/root/Targets/hsdoc
└─┬ hsdoc@0.14.2 
  ├── async@1.5.2 
  ├─┬ chalk@1.1.3 
  │ ├── ansi-styles@2.2.1 
  │ ├── escape-string-regexp@1.0.5 
  │ ├─┬ has-ansi@2.0.0 
  │ │ └── ansi-regex@2.1.1 
  │ ├── strip-ansi@3.0.1 
  │ └── supports-color@2.0.0 
  ├── coffee-script@1.12.7 
  ├── commander@2.11.0 
  ├─┬ glob@5.0.15 
  │ ├─┬ inflight@1.0.6 
  │ │ └── wrappy@1.0.2 
  │ ├── inherits@2.0.3 
  │ ├─┬ minimatch@3.0.4 
  │ │ └─┬ brace-expansion@1.1.8 
  │ │   ├── balanced-match@1.0.0 
  │ │   └── concat-map@0.0.1 
  │ ├── once@1.4.0 
  │ └── path-is-absolute@1.0.1 
  ├─┬ graceful-fs@3.0.11 
  │ └── natives@1.1.0 
  ├── highlight.js@8.9.1 
  ├─┬ jade@1.11.0 
  │ ├── character-parser@1.2.1 
  │ ├─┬ clean-css@3.4.28 
  │ │ ├─┬ commander@2.8.1 
  │ │ │ └── graceful-readlink@1.0.1 
  │ │ └─┬ source-map@0.4.4 
  │ │   └── amdefine@1.0.1 
  │ ├── commander@2.6.0 
  │ ├─┬ constantinople@3.0.2 
  │ │ └── acorn@2.7.0 
  │ ├─┬ jstransformer@0.0.2 
  │ │ ├── is-promise@2.1.0 
  │ │ └─┬ promise@6.1.0 
  │ │   └── asap@1.0.0 
  │ ├─┬ transformers@2.1.0 
  │ │ ├─┬ css@1.0.8 
  │ │ │ ├── css-parse@1.0.4 
  │ │ │ └── css-stringify@1.0.5 
  │ │ ├─┬ promise@2.0.0 
  │ │ │ └── is-promise@1.0.1 
  │ │ └─┬ uglify-js@2.2.5 
  │ │   ├─┬ optimist@0.3.7 
  │ │   │ └── wordwrap@0.0.3 
  │ │   └── source-map@0.1.43 
  │ ├─┬ uglify-js@2.8.29 
  │ │ ├── source-map@0.5.7 
  │ │ ├── uglify-to-browserify@1.0.2 
  │ │ └─┬ yargs@3.10.0 
  │ │   ├── camelcase@1.2.1 
  │ │   ├─┬ cliui@2.1.0 
  │ │   │ ├─┬ center-align@0.1.3 
  │ │   │ │ ├─┬ align-text@0.1.4 
  │ │   │ │ │ ├─┬ kind-of@3.2.2 
  │ │   │ │ │ │ └── is-buffer@1.1.5 
  │ │   │ │ │ ├── longest@1.0.1 
  │ │   │ │ │ └── repeat-string@1.6.1 
  │ │   │ │ └── lazy-cache@1.0.4 
  │ │   │ ├── right-align@0.1.3 
  │ │   │ └── wordwrap@0.0.2 
  │ │   ├── decamelize@1.2.0 
  │ │   └── window-size@0.1.0 
  │ ├── void-elements@2.0.1 
  │ └─┬ with@4.0.3 
  │   ├── acorn@1.2.2 
  │   └── acorn-globals@1.0.9 
  ├─┬ js-yaml@3.10.0 
  │ ├─┬ argparse@1.0.9 
  │ │ └── sprintf-js@1.0.3 
  │ └── esprima@4.0.0 
  ├── marked@0.3.6 
  ├─┬ mkdirp@0.5.1 
  │ └── minimist@0.0.8 
  ├── q@1.5.0 
  ├─┬ temp@0.8.3 
  │ ├── os-tmpdir@1.0.2 
  │ └── rimraf@2.2.8 
  ├── underscore@1.8.3 
  └─┬ watchr@2.6.0 
    ├─┬ eachr@3.2.0 
    │ └── editions@1.3.3 
    ├── extendr@3.2.2 
    ├── extract-opts@3.3.1 
    ├─┬ ignorefs@1.2.0 
    │ └── ignorepatterns@1.1.0 
    ├─┬ safefs@4.1.0 
    │ └── graceful-fs@4.1.11 
    ├─┬ scandirectory@2.5.0 
    │ ├── safefs@3.2.2 
    │ └─┬ taskgroup@4.3.1 
    │   └── csextends@1.1.1 
    ├─┬ taskgroup@5.0.1 
    │ └── ambi@2.5.0 
    └── typechecker@4.4.1 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/hsdoc/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0481 took 4.4402s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected character '#' (1:78) on program #!/usr/bin/env coffee

_             = require('underscore')
async         = require('async')
chalk         = require('chalk')
child_process = require('child_process')
commander     = require('commander')
fs            = require('graceful-fs')
glob          = require('glob')
hljs          = require('highlight.js')
jade          = require('jade')
marked        = require('marked')
mkdirp        = require('mkdirp')
path          = require('path')
Q             = require('q')
watchr        = require('watchr')
YAML          = require('js-yaml')

# Syncronously load a UTF file, return null if it doesn't exist,
# die if it errors some other way.
tryToLoadFile = (filename) ->
  try
    return fs.readFileSync filename, 'utf8'
  catch e
    if e.code is 'ENOENT'
      return null

    console.error e
    process.exit 1

tryToLoadTemplate = (name) ->
  localPath = "#{ __dirname }/resources/templates/#{ name }.jade"
  projPath = "./docs/resources/templates/#{ name }.jade"

  temp = tryToLoadFile(projPath) ? tryToLoadFile(localPath)

  if temp?
    jade.compile temp,
      filename: localPath

# Grab the templates early so we get a nice and simple error
# if it doesn't work
TEMPLATES = {}
for type in ['page', 'index', 'example', 'api']
  TEMPLATES[type] = tryToLoadTemplate(type) ? TEMPLATES.page

# Try to load the config file, return `{}` if it doesn't
# exist.
getConfig = ->
  # .hsdoc lets projects override command-line settings
  # and defaults.  This is gonna look in the cwd, so
  # right now hsdoc has to be run in the project's
  # root directory.
  config = tryToLoadFile '.hsdoc'

  if config
    # For some reason, YAML returns an array
    YAML.safeLoad(config)
  else
    {}

getFiles = (pattern, options) ->
  pro = Q.defer()

  if not pattern
    pro.resolve []
  else
    # Glob lets you do some fancy things with the pattern,
    # like using ! for negation if you care to.
    glob pattern, options, (err, files) ->
      if err
        pro.reject err

        console.error err
        process.exit 1

      pro.resolve files

  pro.promise

getRepoURL = ->
  pro = Q.defer()

  child_process.exec 'git config remote.origin.url', (err, stdout) ->
    if err
      console.error "Error getting git config"
      pro.reject err
      return

    pro.resolve stdout.trim()

  pro.promise

renderMarkdown = (options={}) ->
  pro = Q.defer()

  options.template ?= TEMPLATES.page

  options.context ?= {}

  filename = (options.filename ? path.basename(options.inputPath).replace(/\.(md|markdown)/i, ''))

  outPath = options.outputPath ? makeFolderPath path.join(options.output, filename)

  _.extend options.context, getFileContext(outPath, options)

  fs.readFile options.inputPath, (err, data) ->
    if err
      console.error "Error reading ", options.inputPath
      pro.reject err
      return

    if pro.promise.isPending()
      # Don't try to continue if another file errored
      data = marked data.toString('utf8'),
        highlight: (code, lang) ->
          try
            if lang and lang isnt 'html'
              # Letting html be automatched gives us a shot at having interpolated js and css
              # work.
              return hljs.highlight(lang, code).value
            else
              return hljs.highlightAuto(code).value
          catch e
            return code

      data = options.template _.extend {}, options.context,
        contents: data
        path: outPath
        index: options.index

      mkdirp path.dirname(outPath), ->
        fs.writeFile outPath, data, (err) ->
          if err
            console.error "Error writing ", outPath
            pro.reject err
            return

          pro.resolve outPath

  pro.promise

renderDoc = (file, options) ->
  pro = Q.defer()

  output = path.join(options.output, file.output)

  outDir = path.dirname(output)

  console.log "Rendering #{ file.input } to #{ output }"

  child_process.exec "mkdir -p #{ outDir }", (e) ->
    if e
      console.error "Error creating example output directory", outDir
      pro.reject e
      return

    template = TEMPLATES[file.group.replace(/\/$/, '').toLowerCase()] ? TEMPLATES['page']

    opts = _.extend {}, options, {
      template,
      context: options.context,
      filename: file.filename,
      link: file.link,
      inputPath: file.input,
      outputPath: output
    }

    renderMarkdown(opts).then pro.resolve, pro.reject

  pro.promise

renderDocs = (files, options) ->
  pro = Q.defer()
  remaining = 0

  options = _.clone options

  for file in files
    remaining++
    renderDoc(file, options).then ->
      remaining--
      if remaining is 0
        pro.resolve()

  unless files.length
    # Resolve immediatly, as we're never gonna go through the rendering
    pro.resolve()

  pro.promise

makeFolderPath = (filename) ->
  if not filename.match(/\.html$/g)
    path.join(filename, '/index.html')
  else
    filename

formatDocs = (files, options) ->
  listing = {}

  for {group, input, output, filename, display, link, order} in files
    listing[group] ?= []

    if filename is 'intro'
      continue

    listing[group].push
      order: order
      path: output
      fullPath: path.join(options.output, output)
      link: link
      displayPath: display

  for group of listing
    _.sortBy listing[group], 'order'

  listing

findIntro = (paths, options) ->
  pro = Q.defer()

  if not _.isArray paths
    paths = [paths]

  for file in paths
    if tryToLoadFile(file) isnt null
      pro.resolve file
      break

  if pro.promise.isPending()
    pro.resolve null

  pro.promise

renderIntro = (file, options) ->
  options = _.clone options

  options.inputPath = file
  options.outputPath = path.join options.output, 'docs/intro.html'
  renderMarkdown(options)

getSidebarContext = (docs, options) ->
  return {
    output: options.output
    root: pathToRootOfProject(options, options.output)
    docs: formatDocs docs, options
  }

getFileContext = (outPath, options) ->
  pathPrefix = ''

  rootPath = pathToRootOfProject(options, outPath)

  depth = rootPath.match(/\//g)?.length
  if depth
    for i in [0...depth]
      pathPrefix += '../'

  return {
    linkPrefix: pathPrefix
    name: options.name
  }

getPackageContext = (url, options={}) ->
  if /^https?/i.test url
    matches = /^https?:\/\/([^\/]+)\/([^\/]+)\/([^\.]+)\.git$/i.exec url
  else
    matches = /^git@([^\/:]+):([^\/]+)\/([^\.]+)\.git$/i.exec url

  if not matches
    throw new Error "Couldn't parse repo origin: #{ url }"

  [host, user, name] = matches[1..]

  packFile = tryToLoadFile 'package.json'
  if packFile
    pack = JSON.parse packFile

  pack = _.extend {}, pack, options.package
  pack.release ?= pack.version

  {
    name: options.name or pack.name or name,
    desc: options.desc or pack.description or '',
    package: pack,
    repo: {
      host,
      user,
      name
    }
  }

makeIndex = (intro, options={}) ->
  console.log "Writing Index"

  options = _.clone options

  options.template = TEMPLATES.index ? TEMPLATES.page
  options.outputPath = options.index ? 'index.html'
  options.inputPath = intro

  renderMarkdown(options)

copyResources = (options) ->
  pro = Q.defer()

  outDir = path.join(options.output, '/resources')

  child_process.exec "rm -r #{ outDir }", ->
    child_process.exec "cp -R #{ path.join(__dirname, '/resources') } #{ outDir }", (err) ->
      if err
        console.error "Error copying resources", err
        pro.reject err
        return

      pro.resolve()

  pro.promise

copyAssets = (options) ->
  pro = Q.defer()

  console.log "Copying Assets"

  getFiles(options.assets, options).then (files) ->
    async.mapLimit files, 50, (file, cb) ->
      out = path.join(options.output, file)

      child_process.exec "mkdir -p #{ path.dirname(out) }", (err) ->
        if err
          console.error "Error creating output directory for copied file"
          return cb(err)

        child_process.exec "cp -R #{ file } #{ out }", (err) ->
          if err
            console.error "Error copying asset", err
            return cb(err)

          cb()
    , (err) ->
      if err
        pro.reject(err)
      else
        pro.resolve()

writeCNAME = (options) ->
  return Q(true) unless options.domain
  console.log("Writing #{options.domain} to CNAME")

  Q.ninvoke fs, 'writeFile', path.join(options.output, 'CNAME'), "#{ options.domain }\n"

pathToRootOfProject = (options, outPath) ->
  path.relative(path.dirname(options.index), outPath)

CONTRACTIONS =
  'dont': "don't"

getDocs = (pattern, options) ->
  nameRe = /(?:([0-9]+)\-)?(.*)/
  index = {}

  getFiles(pattern, options).then (listing) ->
    for file in listing
      if file.indexOf(options.output) == 0
        # Don't try to render already built output
        continue

      dir = path.dirname(file).replace('docs/', '') + '/'
      name = path.basename(file)

      if name is 'intro.md'
        # The intro file has it's own purpose
        continue

      index[dir] ?= 0
      index[dir]++

      # Files can start with a number to enforce their ordering
      match = nameRe.exec(name)

      num = +match[1]
      if not num? or isNaN num
        num = index[dir]

      name = match[2]

      cleanName = name.replace(/\.(md|markdown)/i, '').replace(/-/g, ' ').replace(/\ /g, '_')

      titleCase = (str) ->
        str.replace /(^| )([a-z])([a-z]+)/g, (match, space, first, rest) ->
          "#{ space }#{ first.toUpperCase() }#{ rest }"

      displayPath = cleanName.replace(/_/g, ' ')

      for key, val of CONTRACTIONS
        displayPath = displayPath.replace(new RegExp(key, 'g'), val)

      displayPath = titleCase displayPath

      group = nameRe.exec(dir)

      groupNum = +group[1]
      if not groupNum? or isNaN groupNum
        groupName = dir
      else
        groupName = group[2]

      localPath = path.join(groupName, cleanName).toLowerCase()
      linkPath = pathToRootOfProject(options, path.join(options.output, localPath))
      output = path.join(localPath, '/index.html')

      {
        input: file
        output: output
        filename: name
        group: titleCase groupName.replace(/_/g, ' ').replace(/\/$/, '')
        link: linkPath
        display: displayPath
        order: num
      }

getOptions = (options) ->
  defaults =
    source: 'static/**/*.coffee'
    docs: 'docs/*/*.md'
    output: 'docs/build/'
    intro: ['docs/intro.md', 'README.md', 'README.markdown']
    index: 'index.html'
    assets: ''
    name: path.basename process.cwd()
    domain: ''
    watch: false

  defaults = _.extend {}, defaults, getConfig()

  commander
    .usage('(run it in the root of your project)')
    .option('-a, --auto')
    .option('-s, --source [pattern]', 'glob pattern of files to be ran through docco', defaults.source)
    .option('-d, --docs [pattern]', 'glob pattern of files to be compiled as documention', defaults.docs)
    .option('-o, --output [directory]', 'output directory of built files', defaults.output)
    .option('-i, --intro [path]', 'location of intro file', defaults.intro)
    .option('-n, --index [path]', 'location (with filename) to put the index file', defaults.index)
    .option('-m, --name [name]', 'the name of the project', defaults.name)
    .option('-t, --assets [path]', 'the location(s) of assets which should be copied to the output directory', defaults.assets)
    .option('-w, --watch', 'watch files for changes, recompiling as necessary', defaults.watch)
    .parse(process.argv)

  commanderOptions = _.compact(_.pick(commander, 'auto', 'source', 'docs', 'output', 'intro', 'index', 'name', 'assets', 'watch', 'domain'))

  _.extend {}, defaults, commanderOptions, options

build = (options) ->
  done = Q.defer()

  getRepoURL().then (url) ->
    child_process.exec "mkdir -p '#{ options.output }'", ->

      Q.all([writeCNAME(options), copyAssets(options)]).then ->

        docsListing = getDocs(options.docs, options)

        pages = docsListing.then (docs) ->
          packageContext = getPackageContext url, options
          sidebarContext = getSidebarContext docs, options
          options.context = _.extend {}, packageContext, sidebarContext

          docsPromise = renderDocs(docs, options)

          introPromise = findIntro(options.intro, options).then (intro) ->
            if intro?
              renderIntro(intro, options).then ->
                intro
            else
              Q(false)

          copyResources(options).then ->
            Q.all([introPromise, docsPromise]).spread (intro) ->
              makeIndex(intro, options).then ->
                console.log chalk.green('Done!')
                done.resolve()

            , (err) ->
              done.reject err
              console.error err.stack

        , (err) ->
          done.reject err
          console.error err

      , (err) ->
        done.reject err
        console.error "Error copying assets or writing CNAME", err.stack

  done.promise

watch = (options) ->
  console.log "Watching for changes..."

  enqueued = false
  maybeBuild = ->
    if not enqueued
      process.nextTick ->
        enqueued = false
        build options

      enqueued = true

  watchr.watch
    path: '.'
    listener: maybeBuild

run = (options) ->
  options = getOptions options

  build(options).then ->
    if options.watch
      watch options

# This file doesn't call run itself, in case you want to 'require' it somewhere else.
module.exports = {run}
 at SyntaxError: Unexpected character '#' (1:78)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$7.getTokenFromCode (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2756:10)
    at Parser.pp$7.readToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2477:17)
    at Parser.readToken (/root/ExpoSE/lib/Tropigate/bin/Tokens.js:124:26)
    at Parser.pp$7.nextToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2468:15)
    at Parser.pp$7.next (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2413:10)
    at Parser.pp.eat (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:536:12)
    at Parser.pp.semicolon (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:581:15)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:918:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
