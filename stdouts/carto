/root/Targets/carto
└─┬ carto@0.18.2 
  ├── chroma-js@1.3.4 
  ├── hsluv@0.0.1 
  ├─┬ js-yaml@3.8.4 
  │ ├─┬ argparse@1.0.9 
  │ │ └── sprintf-js@1.0.3 
  │ └── esprima@3.1.3 
  ├── lodash@4.17.4 
  ├── mapnik-reference@8.7.0 
  ├── semver@5.3.0 
  └─┬ yargs@8.0.2 
    ├── camelcase@4.1.0 
    ├─┬ cliui@3.2.0 
    │ ├─┬ string-width@1.0.2 
    │ │ ├── code-point-at@1.1.0 
    │ │ └─┬ is-fullwidth-code-point@1.0.0 
    │ │   └── number-is-nan@1.0.1 
    │ ├─┬ strip-ansi@3.0.1 
    │ │ └── ansi-regex@2.1.1 
    │ └─┬ wrap-ansi@2.1.0 
    │   └── string-width@1.0.2 
    ├── decamelize@1.2.0 
    ├── get-caller-file@1.0.2 
    ├─┬ os-locale@2.1.0 
    │ ├─┬ execa@0.7.0 
    │ │ ├─┬ cross-spawn@5.1.0 
    │ │ │ ├─┬ lru-cache@4.1.1 
    │ │ │ │ ├── pseudomap@1.0.2 
    │ │ │ │ └── yallist@2.1.2 
    │ │ │ ├─┬ shebang-command@1.2.0 
    │ │ │ │ └── shebang-regex@1.0.0 
    │ │ │ └─┬ which@1.3.0 
    │ │ │   └── isexe@2.0.0 
    │ │ ├── get-stream@3.0.0 
    │ │ ├── is-stream@1.1.0 
    │ │ ├─┬ npm-run-path@2.0.2 
    │ │ │ └── path-key@2.0.1 
    │ │ ├── p-finally@1.0.0 
    │ │ ├── signal-exit@3.0.2 
    │ │ └── strip-eof@1.0.0 
    │ ├─┬ lcid@1.0.0 
    │ │ └── invert-kv@1.0.0 
    │ └─┬ mem@1.1.0 
    │   └── mimic-fn@1.1.0 
    ├─┬ read-pkg-up@2.0.0 
    │ ├─┬ find-up@2.1.0 
    │ │ └─┬ locate-path@2.0.0 
    │ │   ├─┬ p-locate@2.0.0 
    │ │   │ └── p-limit@1.1.0 
    │ │   └── path-exists@3.0.0 
    │ └─┬ read-pkg@2.0.0 
    │   ├─┬ load-json-file@2.0.0 
    │   │ ├── graceful-fs@4.1.11 
    │   │ ├─┬ parse-json@2.2.0 
    │   │ │ └─┬ error-ex@1.3.1 
    │   │ │   └── is-arrayish@0.2.1 
    │   │ ├── pify@2.3.0 
    │   │ └── strip-bom@3.0.0 
    │   ├─┬ normalize-package-data@2.4.0 
    │   │ ├── hosted-git-info@2.5.0 
    │   │ ├─┬ is-builtin-module@1.0.0 
    │   │ │ └── builtin-modules@1.1.1 
    │   │ └─┬ validate-npm-package-license@3.0.1 
    │   │   ├─┬ spdx-correct@1.0.2 
    │   │   │ └── spdx-license-ids@1.2.2 
    │   │   └── spdx-expression-parse@1.0.4 
    │   └── path-type@2.0.0 
    ├── require-directory@2.1.1 
    ├── require-main-filename@1.0.1 
    ├── set-blocking@2.0.0 
    ├─┬ string-width@2.1.1 
    │ ├── is-fullwidth-code-point@2.0.0 
    │ └─┬ strip-ansi@4.0.0 
    │   └── ansi-regex@3.0.0 
    ├── which-module@2.0.0 
    ├── y18n@3.2.1 
    └── yargs-parser@7.0.0 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/carto/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 28.000000000000004% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","call","RegExp","join","binding","Object","WeakMap","create","Set","Array","ArrayBuffer","DataView","Map","resolve","max","now","apply"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.057 took 47.5556s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (2:4) on program (function(tree) {
var assert = require('assert'),
    _ = require('lodash');

// A definition is the combination of a selector and rules, like
// #foo {
//     polygon-opacity:1.0;
// }
//
// The selector can have filters
tree.Definition = function Definition(selector, rules) {
    this.elements = selector.elements;
    assert.ok(selector.filters instanceof tree.Filterset);
    this.rules = rules;
    this.ruleIndex = {};
    for (var i = 0; i < this.rules.length; i++) {
        if ('zoom' in this.rules[i]) this.rules[i] = this.rules[i].clone();
        this.rules[i].zoom = selector.zoom;
        this.ruleIndex[this.rules[i].updateID()] = true;
    }
    this.filters = selector.filters;
    this.zoom = selector.zoom;
    this.attachment = selector.attachment || '__default__';
    this.specificity = selector.specificity();
};

tree.Definition.prototype.toString = function() {
    var str = this.filters.toString();
    for (var i = 0; i < this.rules.length; i++) {
        str += '\n    ' + this.rules[i];
    }
    return str;
};

tree.Definition.prototype.clone = function(filters) {
    if (filters) assert.ok(filters instanceof tree.Filterset);
    var clone = Object.create(tree.Definition.prototype);
    clone.rules = this.rules.slice();
    clone.ruleIndex = _.clone(this.ruleIndex);
    clone.filters = filters ? filters : this.filters.clone();
    clone.attachment = this.attachment;
    return clone;
};

tree.Definition.prototype.addRules = function(rules) {
    var added = 0;

    // Add only unique rules.
    for (var i = 0; i < rules.length; i++) {
        if (!this.ruleIndex[rules[i].id]) {
            this.rules.push(rules[i]);
            this.ruleIndex[rules[i].id] = true;
            added++;
        }
    }

    return added;
};

// Determine whether this selector matches a given id,
// array of classes and zoom range, by determining whether
// all elements it contains match.
tree.Definition.prototype.appliesTo = function(id, classes, zoom) {
    if (typeof zoom === 'undefined' || (this.zoom & zoom) > 0) {
        for (var i = 0, l = this.elements.length; i < l; i++) {
            var elem = this.elements[i];
            if (!(elem.wildcard ||
                (elem.type === 'class' && classes[elem.clean]) ||
                (elem.type === 'id' && id === elem.clean))) return false;
        }
        return true;
    }
    return false;
};

function symbolizerName(symbolizer) {
    function capitalize(str) { return str[1].toUpperCase(); }
    return symbolizer.charAt(0).toUpperCase() +
           symbolizer.slice(1).replace(/\-./, capitalize) + 'Symbolizer';
}

// Get a simple list of the symbolizers, in order
function symbolizerList(sym_order) {
    return sym_order.sort(function(a, b) { return a[1] - b[1]; })
        .map(function(v) { return v[0]; });
}

tree.Definition.prototype.symbolizersToXML = function(env, symbolizers, zoom) {
    var xml = zoom.toXML(env).join('') + this.filters.toXML(env);

    // Sort symbolizers by the index of their first property definition
    var sym_order = [], indexes = [];
    for (var key in symbolizers) {
        indexes = [];
        for (var prop in symbolizers[key]) {
            indexes.push(symbolizers[key][prop].index);
        }
        var min_idx = Math.min.apply(Math, indexes);
        sym_order.push([key, min_idx]);
    }

    sym_order = symbolizerList(sym_order);
    var sym_count = 0;

    for (var i = 0; i < sym_order.length; i++) {
        var attributes = symbolizers[sym_order[i]];
        var symbolizer = sym_order[i].split('/').pop();

        // Skip the magical * symbolizer which is used for universal properties
        // which are bubbled up to Style elements intead of Symbolizer elements.
        if (symbolizer === '*') continue;
        sym_count++;

        var fail = tree.Reference.requiredProperties(symbolizer, attributes);
        if (fail) {
            var rule = attributes[Object.keys(attributes).shift()];
            env.error({
                message: fail,
                index: rule.index,
                filename: rule.filename
            });
        }

        var name = symbolizerName(symbolizer);

        var selfclosing = true, tagcontent;
        xml += '    <' + name;
        for (var j in attributes) {
            if (symbolizer === 'map') env.error({
                message: 'Map properties are not permitted in other rules',
                index: attributes[j].index,
                filename: attributes[j].filename
            });
            var x = tree.Reference.selector(attributes[j].name);
            if (x && x.serialization && x.serialization === 'content') {
                selfclosing = false;
                tagcontent = attributes[j].ev(env).toXML(env, true);
            } else if (x && x.serialization && x.serialization === 'tag') {
                selfclosing = false;
                tagcontent = attributes[j].ev(env).toXML(env, true);
            } else {
                var attr = attributes[j].ev(env);

                if (!(attr.value.value[0].is === 'keyword' && attr.value.value[0].value === 'none')) {
                    xml += ' ' + attr.toXML(env);
                }
                else {
                    if (!_.has(x, 'type')) {
                        xml += ' ' + attr.toXML(env);
                    }
                    else if (x.type === 'string' || x.type === 'uri') {
                        xml += ' ' + attr.toXML(env);
                    }
                }
            }
        }
        if (selfclosing) {
            xml += ' />\n';
        } else if (typeof tagcontent !== "undefined") {
            if (tagcontent.indexOf('<') != -1) {
                xml += '>' + tagcontent + '</' + name + '>\n';
            } else {
                xml += '><![CDATA[' + tagcontent + ']]></' + name + '>\n';
            }
        }
    }
    if (!sym_count || !xml) return '';
    return '  <Rule>\n' + xml + '  </Rule>\n';
};

// Take a zoom range of zooms and 'i', the index of a rule in this.rules,
// and finds all applicable symbolizers
tree.Definition.prototype.collectSymbolizers = function(zooms, i) {
    var symbolizers = {}, child;

    for (var j = i; j < this.rules.length; j++) {
        child = this.rules[j];
        var key = child.instance + '/' + child.symbolizer;
        if (zooms.current & child.zoom &&
           (!(key in symbolizers) ||
           (!(child.name in symbolizers[key])))) {
            zooms.current &= child.zoom;
            if (!(key in symbolizers)) {
                symbolizers[key] = {};
            }
            symbolizers[key][child.name] = child;
        }
    }

    if (Object.keys(symbolizers).length) {
        zooms.rule &= (zooms.available &= ~zooms.current);
        return symbolizers;
    }
};

// The tree.Zoom.toString function ignores the holes in zoom ranges and outputs
// scaledenominators that cover the whole range from the first to last bit set.
// This algorithm can produces zoom ranges that may have holes. However,
// when using the filter-mode="first", more specific zoom filters will always
// end up before broader ranges. The filter-mode will pick those first before
// resorting to the zoom range with the hole and stop processing further rules.
tree.Definition.prototype.toXML = function(env, existing) {
    var filter = this.filters.toString();
    if (!(filter in existing)) existing[filter] = tree.Zoom.all;

    var available = tree.Zoom.all, xml = '', symbolizers,
        zooms = { available: tree.Zoom.all };
    for (var i = 0; i < this.rules.length && available; i++) {
        zooms.rule = this.rules[i].zoom;
        if (!(existing[filter] & zooms.rule)) continue;

        do {
            zooms.current = zooms.rule & available;
            if (zooms.current) {
                symbolizers = this.collectSymbolizers(zooms, i);
                if (symbolizers) {
                    if (!(existing[filter] & zooms.current)) continue;
                    xml += this.symbolizersToXML(env, symbolizers,
                        (new tree.Zoom()).setZoom(existing[filter] & zooms.current));
                    existing[filter] &= ~zooms.current;
                }
            }
        }
        while (zooms.current);
    }

    return xml;
};

})(require('../tree'));
 at SyntaxError: Unexpected token (2:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseBlock (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:981:25)
    at Parser.pp$3.parseFunctionBody (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2105:24)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/carto/node_modules/carto/lib/carto/index.js. Coverage (Term): 15% Coverage (LOC): 17%
*- File /root/Targets/carto/node_modules/carto/lib/carto/parser.js. Coverage (Term): 1% Coverage (LOC): 1%
*- File /root/Targets/carto/node_modules/carto/lib/carto/tree.js. Coverage (Term): 31% Coverage (LOC): 36%
*- File /root/Targets/carto/node_modules/lodash/lodash.js. Coverage (Term): 22% Coverage (LOC): 35%
*- File /root/Targets/carto/node_modules/chroma-js/chroma.js. Coverage (Term): 12% Coverage (LOC): 31%
*- File /root/Targets/carto/node_modules/carto/lib/carto/renderer.js. Coverage (Term): 4% Coverage (LOC): 7%
*- File /root/Targets/carto/node_modules/carto/lib/carto/mml.js. Coverage (Term): 20% Coverage (LOC): 18%
*- File /root/Targets/carto/node_modules/js-yaml/index.js. Coverage (Term): 96% Coverage (LOC): 100%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml.js. Coverage (Term): 92% Coverage (LOC): 97%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/loader.js. Coverage (Term): 7% Coverage (LOC): 8%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/common.js. Coverage (Term): 27% Coverage (LOC): 42%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/exception.js. Coverage (Term): 27% Coverage (LOC): 38%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/mark.js. Coverage (Term): 12% Coverage (LOC): 20%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js. Coverage (Term): 98% Coverage (LOC): 100%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/schema.js. Coverage (Term): 66% Coverage (LOC): 65%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/type.js. Coverage (Term): 80% Coverage (LOC): 92%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/schema/core.js. Coverage (Term): 97% Coverage (LOC): 100%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/schema/json.js. Coverage (Term): 98% Coverage (LOC): 100%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js. Coverage (Term): 97% Coverage (LOC): 100%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/type/str.js. Coverage (Term): 67% Coverage (LOC): 89%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/type/seq.js. Coverage (Term): 67% Coverage (LOC): 89%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/type/map.js. Coverage (Term): 67% Coverage (LOC): 89%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/type/null.js. Coverage (Term): 33% Coverage (LOC): 66%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/type/bool.js. Coverage (Term): 26% Coverage (LOC): 67%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/type/int.js. Coverage (Term): 10% Coverage (LOC): 25%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/type/float.js. Coverage (Term): 17% Coverage (LOC): 24%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/type/timestamp.js. Coverage (Term): 23% Coverage (LOC): 28%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/type/merge.js. Coverage (Term): 68% Coverage (LOC): 90%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/type/binary.js. Coverage (Term): 10% Coverage (LOC): 21%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/type/omap.js. Coverage (Term): 27% Coverage (LOC): 36%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/type/pairs.js. Coverage (Term): 20% Coverage (LOC): 29%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/type/set.js. Coverage (Term): 42% Coverage (LOC): 52%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/schema/default_full.js. Coverage (Term): 98% Coverage (LOC): 100%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js. Coverage (Term): 55% Coverage (LOC): 79%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js. Coverage (Term): 17% Coverage (LOC): 33%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/type/js/function.js. Coverage (Term): 19% Coverage (LOC): 43%
*- File /root/Targets/carto/node_modules/esprima/dist/esprima.js. Coverage (Term): 14% Coverage (LOC): 24%
*- File /root/Targets/carto/node_modules/js-yaml/lib/js-yaml/dumper.js. Coverage (Term): 11% Coverage (LOC): 20%
*- File /root/Targets/carto/node_modules/carto/lib/carto/tree/call.js. Coverage (Term): 10% Coverage (LOC): 12%
*- File /root/Targets/carto/node_modules/carto/lib/carto/tree/color.js. Coverage (Term): 8% Coverage (LOC): 13%
*- File /root/Targets/carto/node_modules/hsluv/hsluv.js. Coverage (Term): 16% Coverage (LOC): 33%
*- File /root/Targets/carto/node_modules/carto/lib/carto/tree/comment.js. Coverage (Term): 47% Coverage (LOC): 69%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
