/root/Targets/kale
└─┬ kale@0.2.0 
  ├── assert-plus@0.1.5 
  └── underscore@1.5.2 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/kale/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 34% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0386 took 3.4634s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (4:4) on program var fs = require('fs');
var path = require('path');

var assert = require('assert-plus');
var _ = require('underscore');

var parser = require('./parser').parser;
parser.yy = require('./nodes');

var Compiler = require('./compiler');

// -----
//  Fields
// -----

var exports = module.exports = {};
var cache = {};
var builders = {};

// -----
//  Helpers
// -----

// getBuilder()
var getBuilder = function getBuilder(format) {
  var builder = builders[format];
  if ( builder == null ) {
    throw new Error('A builder with the name "' + format + '" does not exist!');
  }
  else {
    return builder;
  }
}; //- getBuilder()

// parseSync()
var parseSync = function parseSync(string, fileName) {
  try {
    var ast = null;

    if ( fileName != null && cache[fileName] != null ) {
      ast = cache[fileName];
    }
    else {
      ast = parser.parse(string);
      cache[fileName] = ast;
    }

    return ast;
  }
  catch ( error ) {
    throw error;
  }
}; //- parseSync()

// parse()
var parse = function parse(string, fileName, callback) {
  if ( _.isFunction(fileName) ) {
    callback = fileName;
    fileName = null;
  }

  process.nextTick(function parseNextTick() {
    var err = null;
    var ast = null;

    try {
      if ( fileName != null && cache[fileName] != null ) {
        ast = cache[fileName];
      }
      else {
        ast = parser.parse(string);
        cache[fileName] = ast;
      }
    }
    catch ( error ) {
      err = error;
    }

    if ( _.isFunction(callback) ) {
      return callback(err, ast);
    }
  });
}; //- parse()

// compile()
var compile = function compile(string, options) {
  options = options || {};

  var ast = parseSync(string, options.fileName);

  return function compile(format, locals, callback) {
    if ( _.isFunction(locals) ) {
      callback = locals;
      locals = {};
    }

    process.nextTick(function compileNextTick() {
      var builder = getBuilder(format);
      var compiler = new Compiler(ast, builder, parseSync);

      var err = null;
      var result = null;

      try {
        result = compiler.compile(locals);
      }
      catch ( error ) {
        err = error;
      }

      if ( _.isFunction(callback) ) {
        callback(err, result);
      }
    });
  };
}; //- compile()

// compileSync()
var compileSync = function compileSync(string, options) {
  options = options || {};

  var ast = parseSync(string, options.fileName);
  return function compileSync(format, locals) {
    var builder = getBuilder(format);
    var compiler = new Compiler(ast, builder, parseSync);

    return compiler.compile(locals);
  };
}; //- compileSync()

// compileFile()
var compileFile = function compileFile(fileName, options) {
  options = options || {};

  try {
    var data = fs.readFileSync(fileName, 'UTF8');
    return compile(data, options);
  }
  catch ( error ) {
    throw error;
  }
}; //- compileFile()

// compileFileSync()
var compileFileSync = function compileFileSync(fileName, options) {
  options = options || {};

  try {
    var data = fs.readFileSync(fileName, 'UTF8');
    return compileSync(data, options);
  }
  catch ( error ) {
    throw error;
  }
}; //- compileFileSync()

// -----
//  Exports
// -----

// registerBuilder()
exports.registerBuilder = function registerBuilder(name, builder) {
  builders[name] = builder;
}; //- registerBuilder()

// express()
exports.express = function(format) {
  return function kaleExpress(path, options, callback) {
    if ( _.isFunction(options) ) {
      callback = options;
      options = {};
    }

    var compile = compileFile(path, options);
    compile('json', options, callback);
  };
}; //- express()

exports.parse = parse;
exports.parseSync = parseSync;

exports.compile = compile;
exports.compileSync = compileSync;

exports.compileFile = compileFile;
exports.compileFileSync = compileFileSync;

// Register default builders
exports.registerBuilder('json', require('./builders/json')); at SyntaxError: Unexpected token (4:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/kale/node_modules/kale/index.js. Coverage (Term): 57% Coverage (LOC): 100%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
