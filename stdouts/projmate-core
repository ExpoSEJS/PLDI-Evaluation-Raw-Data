/root/Targets/projmate-core
└─┬ projmate-core@0.0.8 
  ├── async@0.2.10 
  ├── chokidar@0.5.3 
  ├── coffee-script@1.6.3 
  ├─┬ commander@1.1.1  (git://github.com/mgutz/commander.js.git#89d74ff1c304415e4d86e5e1564294571a369f3b)
  │ └── keypress@0.1.0 
  ├─┬ connect@2.7.11 
  │ ├── buffer-crc32@0.2.1 
  │ ├── bytes@0.2.0 
  │ ├── cookie@0.0.5 
  │ ├── cookie-signature@1.0.1 
  │ ├─┬ debug@3.1.0 
  │ │ └── ms@2.0.0 
  │ ├── formidable@1.0.14 
  │ ├── fresh@0.1.0 
  │ ├── pause@0.0.1 
  │ ├── qs@0.6.5 
  │ └─┬ send@0.1.1 
  │   ├── mime@1.2.11 
  │   └── range-parser@0.0.4 
  ├─┬ glob@3.1.21 
  │ ├── graceful-fs@1.2.3 
  │ └── inherits@1.0.2 
  ├── lodash@1.0.2 
  ├─┬ mgutz-logmagic@0.2.1 
  │ ├── mgutz-colors@0.1.2 
  │ ├── underscore@1.3.3 
  │ └── underscore.string@2.0.0 
  ├─┬ minimatch@0.2.14 
  │ ├── lru-cache@2.7.3 
  │ └── sigmund@1.0.1 
  ├── mkdirp@0.3.5 
  ├─┬ projmate-filters@0.0.8 
  │ ├── coffee-script@1.6.1  (git://github.com/jashkenas/coffee-script.git#0120db0efc166b4ed26a795ff59364bb312f81a4)
  │ ├── consolidate@0.8.0 
  │ ├── dustjs-linkedin@1.2.6 
  │ ├─┬ js-beautify@0.3.9 
  │ │ ├─┬ config-chain@1.1.11 
  │ │ │ ├── ini@1.3.4 
  │ │ │ └── proto-list@1.2.4 
  │ │ └─┬ nopt@2.1.2 
  │ │   └── abbrev@1.1.1 
  │ ├─┬ less@1.3.3 
  │ │ └── ycssmin@1.0.1 
  │ ├─┬ recess@1.1.9 
  │ │ ├── colors@1.1.2 
  │ │ └─┬ watch@1.0.2 
  │ │   ├─┬ exec-sh@0.2.1 
  │ │   │ └── merge@1.2.0 
  │ │   └── minimist@1.2.0 
  │ └─┬ uglify-js@2.2.5 
  │   ├─┬ optimist@0.3.7 
  │   │ └── wordwrap@0.0.3 
  │   └─┬ source-map@0.1.43 
  │     └── amdefine@1.0.1 
  ├─┬ projmate-shell@0.0.6 
  │ └── shelljs@0.1.4 
  ├─┬ read@1.0.7 
  │ └── mute-stream@0.0.7 
  ├── sandbox@0.8.6 
  ├── string@1.7.0  (git://github.com/mgutz/string.js.git#23ff7e93164e06ccd9ae13b0d09767b88a1b2c98)
  ├─┬ temp@0.5.1 
  │ └── rimraf@2.1.4 
  └── underscore.string@2.3.3 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/projmate-core/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 1 running / 1 errors / 18% coverage ] ****** [1 done /0 queued / 1 running / 1 errors / 18% coverage ] ****** [2 done /0 queued / 1 running / 1 errors / 18% coverage ] ****** [2 done /0 queued / 1 running / 1 errors / 18% coverage ] ****** [3 done /0 queued / 0 running / 1 errors / 18% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","toString","apply","bound ","bound warn"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0,"Switcher":false,"Target_Switch_Base":0} start 0.058 took 8.0876s
*-- Errors occured in test {"_bound":0,"Switcher":false,"Target_Switch_Base":0}
* Error: Tropigate failed because SyntaxError: Invalid number (312:30) on program 
/**
 * This module offers the internal "keypress" functionality from node-core's
 * `readline` module, for your own programs and modules to use.
 *
 * Usage:
 *
 *   require('keypress')(process.stdin);
 *
 *   process.stdin.on('keypress', function (ch, key) {
 *     console.log(ch, key);
 *     if (key.ctrl && key.name == 'c') {
 *       process.stdin.pause();
 *     }
 *   });
 *   proces.stdin.resume();
 */
var exports = module.exports = keypress;

exports.enableMouse = function (stream) {
  stream.write('\x1b' +'[?1000h')
}

exports.disableMouse = function (stream) {
  stream.write('\x1b' +'[?1000l')
}


/**
 * accepts a readable Stream instance and makes it emit "keypress" events
 */

function keypress(stream) {
  if (isEmittingKeypress(stream)) return;
  stream._emitKeypress = true;

  function onData(b) {
    if (stream.listeners('keypress').length > 0) {
      emitKey(stream, b);
    } else {
      // Nobody's watching anyway
      stream.removeListener('data', onData);
      stream.on('newListener', onNewListener);
    }
  }

  function onNewListener(event) {
    if (event == 'keypress') {
      stream.on('data', onData);
      stream.removeListener('newListener', onNewListener);
    }
  }

  if (stream.listeners('keypress').length > 0) {
    stream.on('data', onData);
  } else {
    stream.on('newListener', onNewListener);
  }
}

/**
 * Returns `true` if the stream is already emitting "keypress" events.
 * `false` otherwise.
 */

function isEmittingKeypress(stream) {
  var rtn = stream._emitKeypress;
  if (!rtn) {
    // hack: check for the v0.6.x "data" event
    stream.listeners('data').forEach(function (l) {
      if (l.name == 'onData' && /emitKey/.test(l.toString())) {
        rtn = true;
        stream._emitKeypress = true;
      }
    });
  }
  if (!rtn) {
    // hack: check for the v0.6.x "newListener" event
    stream.listeners('newListener').forEach(function (l) {
      if (l.name == 'onNewListener' && /keypress/.test(l.toString())) {
        rtn = true;
        stream._emitKeypress = true;
      }
    });
  }
  return rtn;
}


/*
  Some patterns seen in terminal key escape codes, derived from combos seen
  at http://www.midnight-commander.org/browser/lib/tty/key.c

  ESC letter
  ESC [ letter
  ESC [ modifier letter
  ESC [ 1 ; modifier letter
  ESC [ num char
  ESC [ num ; modifier char
  ESC O letter
  ESC O modifier letter
  ESC O 1 ; modifier letter
  ESC N letter
  ESC [ [ num ; modifier char
  ESC [ [ 1 ; modifier letter
  ESC ESC [ num char
  ESC ESC O letter

  - char is usually ~ but $ and ^ also happen with rxvt
  - modifier is 1 +
                (shift     * 1) +
                (left_alt  * 2) +
                (ctrl      * 4) +
                (right_alt * 8)
  - two leading ESCs apparently mean the same as one leading ESC
*/

// Regexes used for ansi escape code splitting
var metaKeyCodeRe = /^(?:\x1b)([a-zA-Z0-9])$/;
var functionKeyCodeRe =
    /^(?:\x1b+)(O|N|\[|\[\[)(?:(\d+)(?:;(\d+))?([~^$])|(?:1;)?(\d+)?([a-zA-Z]))/;

function emitKey(stream, s) {
  var ch,
      key = {
        name: undefined,
        ctrl: false,
        meta: false,
        shift: false
      },
      parts;

  if (Buffer.isBuffer(s)) {
    if (s[0] > 127 && s[1] === undefined) {
      s[0] -= 128;
      s = '\x1b' + s.toString(stream.encoding || 'utf-8');
    } else {
      s = s.toString(stream.encoding || 'utf-8');
    }
  }

  key.sequence = s;

  if (s === '\r' || s === '\n') {
    // enter
    key.name = 'enter';

  } else if (s === '\t') {
    // tab
    key.name = 'tab';

  } else if (s === '\b' || s === '\x7f' ||
             s === '\x1b\x7f' || s === '\x1b\b') {
    // backspace or ctrl+h
    key.name = 'backspace';
    key.meta = (s.charAt(0) === '\x1b');

  } else if (s === '\x1b' || s === '\x1b\x1b') {
    // escape key
    key.name = 'escape';
    key.meta = (s.length === 2);

  } else if (s === ' ' || s === '\x1b ') {
    key.name = 'space';
    key.meta = (s.length === 2);

  } else if (s <= '\x1a') {
    // ctrl+letter
    key.name = String.fromCharCode(s.charCodeAt(0) + 'a'.charCodeAt(0) - 1);
    key.ctrl = true;

  } else if (s.length === 1 && s >= 'a' && s <= 'z') {
    // lowercase letter
    key.name = s;

  } else if (s.length === 1 && s >= 'A' && s <= 'Z') {
    // shift+letter
    key.name = s.toLowerCase();
    key.shift = true;

  } else if (parts = metaKeyCodeRe.exec(s)) {
    // meta+character key
    key.name = parts[1].toLowerCase();
    key.meta = true;
    key.shift = /^[A-Z]$/.test(parts[1]);

  } else if (parts = functionKeyCodeRe.exec(s)) {
    // ansi escape sequence

    // reassemble the key code leaving out leading \x1b's,
    // the modifier key bitflag and any meaningless "1;" sequence
    var code = (parts[1] || '') + (parts[2] || '') +
               (parts[4] || '') + (parts[6] || ''),
        modifier = (parts[3] || parts[5] || 1) - 1;

    // Parse the key modifier
    key.ctrl = !!(modifier & 4);
    key.meta = !!(modifier & 10);
    key.shift = !!(modifier & 1);
    key.code = code;

    // Parse the key itself
    switch (code) {
      /* xterm/gnome ESC O letter */
      case 'OP': key.name = 'f1'; break;
      case 'OQ': key.name = 'f2'; break;
      case 'OR': key.name = 'f3'; break;
      case 'OS': key.name = 'f4'; break;

      /* xterm/rxvt ESC [ number ~ */
      case '[11~': key.name = 'f1'; break;
      case '[12~': key.name = 'f2'; break;
      case '[13~': key.name = 'f3'; break;
      case '[14~': key.name = 'f4'; break;

      /* from Cygwin and used in libuv */
      case '[[A': key.name = 'f1'; break;
      case '[[B': key.name = 'f2'; break;
      case '[[C': key.name = 'f3'; break;
      case '[[D': key.name = 'f4'; break;
      case '[[E': key.name = 'f5'; break;

      /* common */
      case '[15~': key.name = 'f5'; break;
      case '[17~': key.name = 'f6'; break;
      case '[18~': key.name = 'f7'; break;
      case '[19~': key.name = 'f8'; break;
      case '[20~': key.name = 'f9'; break;
      case '[21~': key.name = 'f10'; break;
      case '[23~': key.name = 'f11'; break;
      case '[24~': key.name = 'f12'; break;

      /* xterm ESC [ letter */
      case '[A': key.name = 'up'; break;
      case '[B': key.name = 'down'; break;
      case '[C': key.name = 'right'; break;
      case '[D': key.name = 'left'; break;
      case '[E': key.name = 'clear'; break;
      case '[F': key.name = 'end'; break;
      case '[H': key.name = 'home'; break;

      /* xterm/gnome ESC O letter */
      case 'OA': key.name = 'up'; break;
      case 'OB': key.name = 'down'; break;
      case 'OC': key.name = 'right'; break;
      case 'OD': key.name = 'left'; break;
      case 'OE': key.name = 'clear'; break;
      case 'OF': key.name = 'end'; break;
      case 'OH': key.name = 'home'; break;

      /* xterm/rxvt ESC [ number ~ */
      case '[1~': key.name = 'home'; break;
      case '[2~': key.name = 'insert'; break;
      case '[3~': key.name = 'delete'; break;
      case '[4~': key.name = 'end'; break;
      case '[5~': key.name = 'pageup'; break;
      case '[6~': key.name = 'pagedown'; break;

      /* putty */
      case '[[5~': key.name = 'pageup'; break;
      case '[[6~': key.name = 'pagedown'; break;

      /* rxvt */
      case '[7~': key.name = 'home'; break;
      case '[8~': key.name = 'end'; break;

      /* rxvt keys with modifiers */
      case '[a': key.name = 'up'; key.shift = true; break;
      case '[b': key.name = 'down'; key.shift = true; break;
      case '[c': key.name = 'right'; key.shift = true; break;
      case '[d': key.name = 'left'; key.shift = true; break;
      case '[e': key.name = 'clear'; key.shift = true; break;

      case '[2$': key.name = 'insert'; key.shift = true; break;
      case '[3$': key.name = 'delete'; key.shift = true; break;
      case '[5$': key.name = 'pageup'; key.shift = true; break;
      case '[6$': key.name = 'pagedown'; key.shift = true; break;
      case '[7$': key.name = 'home'; key.shift = true; break;
      case '[8$': key.name = 'end'; key.shift = true; break;

      case 'Oa': key.name = 'up'; key.ctrl = true; break;
      case 'Ob': key.name = 'down'; key.ctrl = true; break;
      case 'Oc': key.name = 'right'; key.ctrl = true; break;
      case 'Od': key.name = 'left'; key.ctrl = true; break;
      case 'Oe': key.name = 'clear'; key.ctrl = true; break;

      case '[2^': key.name = 'insert'; key.ctrl = true; break;
      case '[3^': key.name = 'delete'; key.ctrl = true; break;
      case '[5^': key.name = 'pageup'; key.ctrl = true; break;
      case '[6^': key.name = 'pagedown'; key.ctrl = true; break;
      case '[7^': key.name = 'home'; key.ctrl = true; break;
      case '[8^': key.name = 'end'; key.ctrl = true; break;

      /* misc. */
      case '[Z': key.name = 'tab'; key.shift = true; break;
      default: key.name = 'undefined'; break;

    }
  } else if (s.length > 1 && s[0] !== '\x1b') {
    // Got a longer-than-one string of characters.
    // Probably a paste, since it wasn't a control sequence.
    Array.prototype.forEach.call(s, function(c) {
      emitKey(stream, c);
    });
    return;
  }

  if (key.code == '[M') {
    key.name = 'mouse';
    var s = key.sequence;
    var b = s.charCodeAt(3);
    key.x = s.charCodeAt(4) - 040;
    key.y = s.charCodeAt(5) - 040;

    key.scroll = 0;

    key.ctrl  = !!(1<<4 & b);
    key.meta  = !!(1<<3 & b);
    key.shift = !!(1<<2 & b);

    key.release = (3 & b) === 3;

    if (1<<6 & b) { //scroll
      key.scroll = 1 & b ? 1 : -1;
    }

    if (!key.release && !key.scroll) {
      key.button = b & 3;
    }
  }

  // Don't emit a key if no name was found
  if (key.name === undefined) {
    key = undefined;
  }

  if (s.length === 1) {
    ch = s;
  }

  if (key && key.name == 'mouse') {
    stream.emit('mousepress', key)
  } else if (key || ch) {
    stream.emit('keypress', ch, key);
  }
}
 at SyntaxError: Invalid number (312:30)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$7.readNumber (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2896:52)
    at Parser.pp$7.getTokenFromCode (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2720:19)
    at Parser.pp$7.readToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2477:17)
    at Parser.readToken (/root/ExpoSE/lib/Tropigate/bin/Tokens.js:124:26)
    at Parser.pp$7.nextToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2468:15)
    at Parser.pp$7.next (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2413:10)
    at Parser.pp$3.parseExprOp (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1654:14)
    at Parser.pp$3.parseExprOps (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1639:17)
    at Parser.pp$3.parseMaybeConditional (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1620:21)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1597:21)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Test Case {"Switcher":false,"Target_Switch_Base":1,"_bound":1,"ExpandedSwitcher":0} start 8.2226 took 4.4217s
*-- Test Case {"Switcher":false,"Target_Switch_Base":2,"ExpandedSwitcher":0,"_bound":2} start 12.6618 took 4.0382s
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 82% Coverage (LOC): 86%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 19% Coverage (LOC): 37%
*- File /root/Targets/projmate-core/node_modules/projmate-core/index.js. Coverage (Term): 88% Coverage (LOC): 100%
*- File /root/Targets/projmate-core/node_modules/projmate-core/dist/cli/pm.js. Coverage (Term): 62% Coverage (LOC): 93%
*- File /root/Targets/projmate-core/node_modules/commander/index.js. Coverage (Term): 2% Coverage (LOC): 2%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 3 paths with 1 errors **
