/root/Targets/sinon-chrome
└─┬ sinon-chrome@2.2.1 
  ├── lodash@4.17.4 
  ├─┬ sinon@2.4.1 
  │ ├── diff@3.3.1 
  │ ├── formatio@1.2.0 
  │ ├── lolex@1.6.0 
  │ ├── native-promise-only@0.8.1 
  │ ├─┬ path-to-regexp@1.7.0 
  │ │ └── isarray@0.0.1 
  │ ├── samsam@1.2.1 
  │ ├── text-encoding@0.6.4 
  │ └── type-detect@4.0.3 
  └── urijs@1.18.12 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/sinon-chrome/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","call","RegExp","join","binding","Object","WeakMap","create","Set","Array","ArrayBuffer","DataView","Map","resolve","max","now","apply","entries","getPrototypeOf","values","[Symbol.iterator]"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0912 took 55.0509s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (92:7) on program "use strict";

var calledInOrder = require("./util/core/called-in-order");
var orderByFirstCall = require("./util/core/order-by-first-call");
var timesInWords = require("./util/core/times-in-words");
var format = require("./util/core/format");
var sinonMatch = require("./match");

var slice = Array.prototype.slice;

var assert;

function verifyIsStub() {
    var args = Array.prototype.slice.call(arguments);

    args.forEach(function (method) {
        if (!method) {
            assert.fail("fake is not a spy");
        }

        if (method.proxy && method.proxy.isSinonProxy) {
            verifyIsStub(method.proxy);
        } else {
            if (typeof method !== "function") {
                assert.fail(method + " is not a function");
            }

            if (typeof method.getCall !== "function") {
                assert.fail(method + " is not stubbed");
            }
        }
    });
}

function verifyIsValidAssertion(assertionMethod, assertionArgs) {
    switch (assertionMethod) {
        case "notCalled":
        case "called":
        case "calledOnce":
        case "calledTwice":
        case "calledThrice":
            if (assertionArgs.length !== 0) {
                assert.fail(assertionMethod +
                            " takes 1 argument but was called with " + (assertionArgs.length + 1) + " arguments");
            }
            break;
        default:
            break;
    }
}

function failAssertion(object, msg) {
    object = object || global;
    var failMethod = object.fail || assert.fail;
    failMethod.call(object, msg);
}

function mirrorPropAsAssertion(name, method, message) {
    if (arguments.length === 2) {
        message = method;
        method = name;
    }

    assert[name] = function (fake) {
        verifyIsStub(fake);

        var args = slice.call(arguments, 1);
        var failed = false;

        verifyIsValidAssertion(name, args);

        if (typeof method === "function") {
            failed = !method(fake);
        } else {
            failed = typeof fake[method] === "function" ?
                !fake[method].apply(fake, args) : !fake[method];
        }

        if (failed) {
            failAssertion(this, (fake.printf || fake.proxy.printf).apply(fake, [message].concat(args)));
        } else {
            assert.pass(name);
        }
    };
}

function exposedName(prefix, prop) {
    return !prefix || /^fail/.test(prop) ? prop :
        prefix + prop.slice(0, 1).toUpperCase() + prop.slice(1);
}

assert = {
    failException: "AssertError",

    fail: function fail(message) {
        var error = new Error(message);
        error.name = this.failException || assert.failException;

        throw error;
    },

    pass: function pass() {},

    callOrder: function assertCallOrder() {
        verifyIsStub.apply(null, arguments);
        var expected = "";
        var actual = "";

        if (!calledInOrder(arguments)) {
            try {
                expected = [].join.call(arguments, ", ");
                var calls = slice.call(arguments);
                var i = calls.length;
                while (i) {
                    if (!calls[--i].called) {
                        calls.splice(i, 1);
                    }
                }
                actual = orderByFirstCall(calls).join(", ");
            } catch (e) {
                // If this fails, we'll just fall back to the blank string
            }

            failAssertion(this, "expected " + expected + " to be " +
                        "called in order but were called as " + actual);
        } else {
            assert.pass("callOrder");
        }
    },

    callCount: function assertCallCount(method, count) {
        verifyIsStub(method);

        if (method.callCount !== count) {
            var msg = "expected %n to be called " + timesInWords(count) +
                " but was called %c%C";
            failAssertion(this, method.printf(msg));
        } else {
            assert.pass("callCount");
        }
    },

    expose: function expose(target, options) {
        if (!target) {
            throw new TypeError("target is null or undefined");
        }

        var o = options || {};
        var prefix = typeof o.prefix === "undefined" && "assert" || o.prefix;
        var includeFail = typeof o.includeFail === "undefined" || !!o.includeFail;
        var instance = this;

        Object.keys(instance).forEach(function (method) {
            if (method !== "expose" && (includeFail || !/^(fail)/.test(method))) {
                target[exposedName(prefix, method)] = instance[method];
            }
        });

        return target;
    },

    match: function match(actual, expectation) {
        var matcher = sinonMatch(expectation);
        if (matcher.test(actual)) {
            assert.pass("match");
        } else {
            var formatted = [
                "expected value to match",
                "    expected = " + format(expectation),
                "    actual = " + format(actual)
            ];

            failAssertion(this, formatted.join("\n"));
        }
    }
};

mirrorPropAsAssertion("called", "expected %n to have been called at least once but was never called");
mirrorPropAsAssertion("notCalled", function (spy) {
    return !spy.called;
}, "expected %n to not have been called but was called %c%C");
mirrorPropAsAssertion("calledOnce", "expected %n to be called once but was called %c%C");
mirrorPropAsAssertion("calledTwice", "expected %n to be called twice but was called %c%C");
mirrorPropAsAssertion("calledThrice", "expected %n to be called thrice but was called %c%C");
mirrorPropAsAssertion("calledOn", "expected %n to be called with %1 as this but was called with %t");
mirrorPropAsAssertion(
    "alwaysCalledOn",
    "expected %n to always be called with %1 as this but was called with %t"
);
mirrorPropAsAssertion("calledWithNew", "expected %n to be called with new");
mirrorPropAsAssertion("alwaysCalledWithNew", "expected %n to always be called with new");
mirrorPropAsAssertion("calledWith", "expected %n to be called with arguments %D");
mirrorPropAsAssertion("calledWithMatch", "expected %n to be called with match %D");
mirrorPropAsAssertion("alwaysCalledWith", "expected %n to always be called with arguments %D");
mirrorPropAsAssertion("alwaysCalledWithMatch", "expected %n to always be called with match %D");
mirrorPropAsAssertion("calledWithExactly", "expected %n to be called with exact arguments %D");
mirrorPropAsAssertion("alwaysCalledWithExactly", "expected %n to always be called with exact arguments %D");
mirrorPropAsAssertion("neverCalledWith", "expected %n to never be called with arguments %*%C");
mirrorPropAsAssertion("neverCalledWithMatch", "expected %n to never be called with match %*%C");
mirrorPropAsAssertion("threw", "%n did not throw exception%C");
mirrorPropAsAssertion("alwaysThrew", "%n did not always throw exception%C");

module.exports = assert;
 at SyntaxError: Unexpected token (92:7)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$3.parseExprAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1822:12)
    at Parser.parseExprAtom (/root/ExpoSE/lib/Tropigate/bin/Expression.js:28:30)
    at Parser.pp$3.parseExprSubscripts (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1715:21)
    at Parser.parseMaybeUnary (/root/ExpoSE/lib/Tropigate/bin/Unary.js:34:29)
    at Parser.pp$3.parseExprOps (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1637:21)
    at Parser.pp$3.parseMaybeConditional (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1620:21)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1597:21)
    at Parser.pp$3.parseExpression (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1573:21)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/sinon-chrome/node_modules/sinon-chrome/index.js. Coverage (Term): 37% Coverage (LOC): 54%
*- File /root/Targets/sinon-chrome/node_modules/sinon-chrome/extensions/index.js. Coverage (Term): 67% Coverage (LOC): 83%
*- File /root/Targets/sinon-chrome/node_modules/sinon-chrome/api/index.js. Coverage (Term): 8% Coverage (LOC): 8%
*- File /root/Targets/sinon-chrome/node_modules/lodash/lodash.js. Coverage (Term): 22% Coverage (LOC): 35%
*- File /root/Targets/sinon-chrome/node_modules/sinon-chrome/api/stub.js. Coverage (Term): 10% Coverage (LOC): 13%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon.js. Coverage (Term): 33% Coverage (LOC): 41%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/match.js. Coverage (Term): 24% Coverage (LOC): 38%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/deep-equal.js. Coverage (Term): 12% Coverage (LOC): 16%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/every.js. Coverage (Term): 32% Coverage (LOC): 36%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/function-name.js. Coverage (Term): 35% Coverage (LOC): 50%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/iterable-to-string.js. Coverage (Term): 16% Coverage (LOC): 24%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/typeOf.js. Coverage (Term): 95% Coverage (LOC): 100%
*- File /root/Targets/sinon-chrome/node_modules/type-detect/index.js. Coverage (Term): 45% Coverage (LOC): 29%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/value-to-string.js. Coverage (Term): 46% Coverage (LOC): 56%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/deprecated.js. Coverage (Term): 57% Coverage (LOC): 65%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/index.js. Coverage (Term): 99% Coverage (LOC): 100%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/called-in-order.js. Coverage (Term): 19% Coverage (LOC): 23%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/log_error.js. Coverage (Term): 16% Coverage (LOC): 18%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/default-config.js. Coverage (Term): 97% Coverage (LOC): 100%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/extend.js. Coverage (Term): 60% Coverage (LOC): 72%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/format.js. Coverage (Term): 71% Coverage (LOC): 91%
*- File /root/Targets/sinon-chrome/node_modules/formatio/lib/formatio.js. Coverage (Term): 14% Coverage (LOC): 27%
*- File /root/Targets/sinon-chrome/node_modules/samsam/lib/samsam.js. Coverage (Term): 7% Coverage (LOC): 14%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/function-to-string.js. Coverage (Term): 26% Coverage (LOC): 29%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/get-config.js. Coverage (Term): 35% Coverage (LOC): 43%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/get-property-descriptor.js. Coverage (Term): 37% Coverage (LOC): 50%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/order-by-first-call.js. Coverage (Term): 23% Coverage (LOC): 42%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/restore.js. Coverage (Term): 28% Coverage (LOC): 41%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/walk.js. Coverage (Term): 15% Coverage (LOC): 25%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/times-in-words.js. Coverage (Term): 60% Coverage (LOC): 91%
*- File /root/Targets/sinon-chrome/node_modules/sinon/lib/sinon/util/core/wrap-method.js. Coverage (Term): 9% Coverage (LOC): 11%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
