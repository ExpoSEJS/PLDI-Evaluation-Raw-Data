/root/Targets/carotte-loader
└── carotte-loader@0.5.1 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/carotte-loader/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0399 took 3.0376s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (108:28) on program const fs = require('fs');
const { join } = require('path');

const { name: serviceName } = require(join(process.env.PWD, 'package.json'));

const REGEX_FUNCTION_FOLDER = /^([*a-z\-.0-9]+):v([0-9]+)$/;
const REGEX_WILD_CARD = /\*:v([0-9]+)/g;
const DEFAULT_OPTIONS = {};

if (process.env.AMQP_PREFETCH) {
    DEFAULT_OPTIONS.prefetch = parseInt(process.env.AMQP_PREFETCH, 10);
}


function readDir(folder, pattern) {
    folder = join(process.env.PWD, folder);
    if (!fs.existsSync(folder)) return [];

    return fs.readdirSync(folder)
        .reduce((memo, name) => {
            const path = join(folder, name);

            const stats = fs.statSync(path);
            if (stats.isDirectory()) {
                memo.push({ path, name });
            }

            return memo;
        }, [])
        .map(fn => readFunction(fn, pattern));
}

function readFunction(fn, pattern) {
    const mod = require(fn.path);
    fn.errors = [];

    // check exports
    if (!mod.meta) fn.errors.push('No meta exported');
    if (!mod.handler) fn.errors.push('No handler exported');
    if (fn.errors.length) return fn;

    // check meta keys and function name
    const nameParts = fn.name.match(REGEX_FUNCTION_FOLDER);
    if (!nameParts) {
        fn.errors.push(`Invalid folder name ${fn.name}, example: my.function.name:v23`);
    }
    if (mod.meta.name) {
        fn.errors.push('meta.name should not be defined, it will be inferred from path');
    }
    if (mod.meta.version) {
        fn.errors.push('meta.version should not be defined, it will be inferred from path');
    }
    if (fn.errors.length) return fn;

    // all good, compute carotte qualifier
    const key = pattern.replace(/%/g, fn.name);

    const options = Object.assign({}, DEFAULT_OPTIONS, mod.options);

    return Object.assign(fn, {
        key,
        handler: mod.handler,
        meta: Object.assign({}, mod.meta, {
            name: key,
            version: parseInt(nameParts[2], 10)
        }),
        options
    });
}

module.exports = function (carotte, logger = console) {
    logger.info('Service started');

    const functions = Array.prototype.concat(
        readDir('src/lambdas', 'direct/%'),
        readDir('src/controllers', 'direct/controller.%'),
        readDir('src/listeners', `topic/%/${serviceName}.%`)
    );

    // print errors
    if (!functions.length) {
        logger.error(`No function detected in ${serviceName}`);
        return exitDelay();
    }

    const message = functions.reduce((str, fn) => {
        if (fn.errors.length) {
            str += '\n';
            str += fn.path.replace(process.env.PWD, '.');
            str += fn.errors.reduce((memo, err) => `${memo}  - ${err}\n`, '\n');
        }
        return str;
    }, '');

    if (message) {
        logger.error(message);
        return exitDelay();
    }

    const promises = functions.map(fn => {
        if (fn.key.match(REGEX_WILD_CARD)) {
            fn.key = fn.key.replace(REGEX_WILD_CARD, '*');
        }

        return carotte.subscribe(fn.key, fn.options, fn.handler, fn.meta);
    });

    carotte.onError = async err => {
        logger.error(err);
        await exitDelay();
    };

    process.on('uncaughtException', async err => {
        logger.error('Uncaught Exception', err);
        await exitDelay();
    });

    process.on('unhandledRejection', async (reason, p) => {
        logger.error('Unhandled Rejection', { p, reason });
        await exitDelay();
    });

    ['SIGTERM', 'SIGINT'].forEach(signal => {
        process.on(signal, async () => {
            logger.warn(`signal: ${signal}`, { signal });
            await exitDelay();
        });
    });

    return Promise.all(promises)
        .catch(async err => {
            logger.error('Could not subscribe to amqp broker', err);
            return exitDelay();
        });
};

async function exitDelay() {
    await new Promise(resolve =>
        setTimeout(resolve, Number(process.env.LOG_EXIT_DELAY || 100)));
    return process.exit(1);
}
 at SyntaxError: Unexpected token (108:28)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp.semicolon (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:581:61)
    at Parser.pp$1.parseExpressionStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:966:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:730:24)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseBlock (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:981:25)
    at Parser.pp$3.parseFunctionBody (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2105:24)
    at Parser.parseFunctionBody (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:14:32)
    at Parser.pp$1.parseFunction (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1065:10)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
