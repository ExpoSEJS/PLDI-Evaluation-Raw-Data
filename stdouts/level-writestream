/root/Targets/level-writestream
└─┬ level-writestream@0.1.3 
  ├── batch-write-stream@0.1.6 
  ├─┬ concat-stream@1.6.0 
  │ ├── inherits@2.0.3 
  │ ├─┬ readable-stream@2.3.3 
  │ │ ├── core-util-is@1.0.2 
  │ │ ├── isarray@1.0.0 
  │ │ ├── process-nextick-args@1.0.7 
  │ │ ├── safe-buffer@5.1.1 
  │ │ ├── string_decoder@1.0.3 
  │ │ └── util-deprecate@1.0.2 
  │ └── typedarray@0.0.6 
  └── xtend@4.0.1 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/level-writestream/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 28.000000000000004% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0657 took 4.3797s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (7:4) on program var setImmediate = global.setImmediate || process.nextTick;

exports = module.exports = BatchObjectWriteStream;
BatchObjectWriteStream.WritableState = WritableState;

var util = require('util');
var assert = require('assert');
var Stream = require('stream');

util.inherits(BatchObjectWriteStream, Stream);

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 100000;

  // max number of concurrent batch writes
  this.maxConcurrentBatches = options.maxConcurrentBatches || 1;

  // time to wait for when scheduling a flush
  this.flushWait = options.flushWait || 10;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // if we have a flush scheduled
  this.scheduled = false;

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = 0;

  this.buffer = [];
  this.callbacks = [];
}

function BatchObjectWriteStream(options) {
  if (!(this instanceof BatchObjectWriteStream) && !(this instanceof Stream.Duplex))
    return new BatchObjectWriteStream(options);

  var state = this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;
  this.readable = false;

  var stream = this;
  this._flushFn = function() {
    flush(stream, state);
  };

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
BatchObjectWriteStream.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  setImmediate(function() { cb(er); });
}

BatchObjectWriteStream.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (! this.writable) return;

  if (arguments.length < 3) {
    cb = encoding;
    encoding = undefined;
  }

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else {
    state.length += 1;

    ret = state.length < state.highWaterMark;
    state.needDrain = !ret;

    if (encoding && ! chunk.encoding) chunk.encoding = encoding;

    chunk = this._map(chunk);

    state.buffer.push(chunk);
    if (cb) {
      state.callbacks.push(cb);
    }

    scheduleFlushMaybe(this, state);
  }

  return ret;
};

function scheduleFlushMaybe(stream, state) {
  if (! state.scheduled) {
    state.scheduled = true;
    setTimeout(stream._flushFn, stream.flushWait);
  }
}


function flush(stream, state) {
  state.scheduled = false;
  var buffer = state.buffer;
  if ((state.writing < state.maxConcurrentBatches) && buffer.length && stream.writable) {
    var callbacks = state.callbacks;
    state.buffer = [];
    state.callbacks = [];

    state.writing ++;
    stream._writeBatch(buffer, onWrite);

    function onWrite(err) {
      state.writing --;
      state.length -= buffer.length;
      onwrite(stream, state, err, callbacks);
    }
  }
}

function onwriteError(stream, state, er, cbs) {
  var cb;
  for(var i = 0 ; i < cbs.length; i ++) {
    cb = cbs[i];
    cb(er);
  }

  stream.emit('error', er);
}

function onwrite(stream, state, er, cbs) {

  if (er)
    onwriteError(stream, state, er, cbs);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && state.buffer.length)
      scheduleFlushMaybe(stream, state);

    afterWrite(stream, state, finished, cbs);
  }
}

function afterWrite(stream, state, finished, cbs) {
  if (!finished && state.length == 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
  for (var i = 0 ; i < cbs.length; i ++) {
    cbs[i]();
  }
  if (finished)
    finishMaybe(stream, state);
}

BatchObjectWriteStream.prototype._writeBatch = function(batch, cb) {
  cb(new Error('not implemented'));
};

BatchObjectWriteStream.prototype._map = function(d) {
  return d;
};

BatchObjectWriteStream.prototype.end = function(chunk, cb) {
  var state = this._writableState;

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};

BatchObjectWriteStream.prototype.destroy = function destroy() {
  var state = this._writableState;

  var stream = this;
  state.writing = 0;
  this.writable = false;

  setImmediate(function() {
    state.finished = true;
    stream.emit('finish');
  });

  this.end();
};

BatchObjectWriteStream.prototype.destroySoon = function destroySoon() {
  this.end();
};

function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing &&
          !state.scheduled);
}

function finishMaybe(stream, state) {
  if (needFinish(stream, state)) {
    state.finished = true;
    stream.writable = false;
    stream.emit('finish');
  }
}

function endWritable(stream, state, cb) {
  state.ending = true;
  flush(stream, state);
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      setImmediate(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
} at SyntaxError: Unexpected token (7:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/level-writestream/node_modules/level-writestream/index.js. Coverage (Term): 42% Coverage (LOC): 57%
*- File /root/Targets/level-writestream/node_modules/level-writestream/write_stream.js. Coverage (Term): 9% Coverage (LOC): 12%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
