/root/Targets/gcc-explorer
└─┬ gcc-explorer@0.0.3 
  ├─┬ body-parser@1.14.2 
  │ ├── bytes@2.2.0 
  │ ├── content-type@1.0.4 
  │ ├─┬ debug@2.2.0 
  │ │ └── ms@0.7.1 
  │ ├── depd@1.1.1 
  │ ├─┬ http-errors@1.3.1 
  │ │ ├── inherits@2.0.3 
  │ │ └── statuses@1.3.1 
  │ ├── iconv-lite@0.4.13 
  │ ├─┬ on-finished@2.3.0 
  │ │ └── ee-first@1.1.1 
  │ ├── qs@5.2.0 
  │ ├─┬ raw-body@2.1.7 
  │ │ ├── bytes@2.4.0 
  │ │ └── unpipe@1.0.0 
  │ └─┬ type-is@1.6.15 
  │   ├── media-typer@0.3.0 
  │   └── mime-types@2.1.17 
  ├─┬ compression@1.6.2 
  │ ├─┬ accepts@1.3.4 
  │ │ └── negotiator@0.6.1 
  │ ├── bytes@2.3.0 
  │ ├─┬ compressible@2.0.11 
  │ │ └── mime-db@1.30.0 
  │ ├── on-headers@1.0.1 
  │ └── vary@1.1.1 
  ├─┬ express@4.13.4 
  │ ├─┬ accepts@1.2.13 
  │ │ └── negotiator@0.5.3 
  │ ├── array-flatten@1.1.1 
  │ ├── content-disposition@0.5.1 
  │ ├── cookie@0.1.5 
  │ ├── cookie-signature@1.0.6 
  │ ├── escape-html@1.0.3 
  │ ├── etag@1.7.0 
  │ ├── finalhandler@0.4.1 
  │ ├── fresh@0.3.0 
  │ ├── merge-descriptors@1.0.1 
  │ ├── methods@1.1.2 
  │ ├── parseurl@1.3.2 
  │ ├── path-to-regexp@0.1.7 
  │ ├─┬ proxy-addr@1.0.10 
  │ │ ├── forwarded@0.1.2 
  │ │ └── ipaddr.js@1.0.5 
  │ ├── qs@4.0.0 
  │ ├── range-parser@1.0.3 
  │ ├─┬ send@0.13.1 
  │ │ ├── destroy@1.0.4 
  │ │ ├── mime@1.3.4 
  │ │ └── statuses@1.2.1 
  │ ├── utils-merge@1.0.0 
  │ └── vary@1.0.1 
  ├─┬ fs-extra@0.26.7 
  │ ├── graceful-fs@4.1.11 
  │ ├── jsonfile@2.4.0 
  │ ├── klaw@1.3.1 
  │ ├── path-is-absolute@1.0.1 
  │ └─┬ rimraf@2.6.2 
  │   └─┬ glob@7.1.2 
  │     ├── fs.realpath@1.0.0 
  │     ├─┬ inflight@1.0.6 
  │     │ └── wrappy@1.0.2 
  │     ├─┬ minimatch@3.0.4 
  │     │ └─┬ brace-expansion@1.1.8 
  │     │   ├── balanced-match@1.0.0 
  │     │   └── concat-map@0.0.1 
  │     └── once@1.4.0 
  ├─┬ http-proxy@1.12.1 
  │ ├── eventemitter3@1.2.0 
  │ └── requires-port@1.0.0 
  ├── lru-cache@2.7.3 
  ├─┬ morgan@1.6.1 
  │ ├── basic-auth@1.0.4 
  │ └── depd@1.0.1 
  ├─┬ nopt@3.0.6 
  │ └── abbrev@1.1.0 
  ├─┬ promise@7.0.4 
  │ └── asap@2.0.6 
  ├── promise-queue@2.1.2 
  ├─┬ serve-favicon@2.3.2 
  │ └── ms@0.7.2 
  ├─┬ serve-static@1.10.3 
  │ └─┬ send@0.13.2 
  │   └── statuses@1.2.1 
  └─┬ temp@0.8.3 
    ├── os-tmpdir@1.0.2 
    └── rimraf@2.2.8 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/gcc-explorer/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0667 took 2.192s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected character '#' (1:78) on program #!/usr/bin/env node

// Copyright (c) 2012-2016, Matt Godbolt
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without 
// modification, are permitted provided that the following conditions are met:
// 
//     * Redistributions of source code must retain the above copyright notice, 
//       this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright 
//       notice, this list of conditions and the following disclaimer in the 
//       documentation and/or other materials provided with the distribution.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
// POSSIBILITY OF SUCH DAMAGE.

// load external and internal libraries (will load more internal binaries later)
var nopt = require('nopt'),
    os = require('os'),
    props = require('./lib/properties'),
    compileHandler = require('./lib/compile').compileHandler,
    buildDiffHandler = require('./lib/diff').buildDiffHandler,
    express = require('express'),
    child_process = require('child_process'),
    path = require('path'),
    fs = require('fs-extra'),
    http = require('http'),
    https = require('https'),
    url = require('url'),
    Promise = require('promise');

// Parse arguments from command line 'node ./app.js args...'
var opts = nopt({
    'env': [String, Array],
    'rootDir': [String],
    'language': [String],
    'host': [String],
    'port': [Number],
    'propDebug': [Boolean]
});

// Set default values for ommited arguments
var rootDir = opts.rootDir || './etc';
var language = opts.language || "C++";
var env = opts.env || ['dev'];
var hostname = opts.host || os.hostname();
var port = opts.port || 10240;

var propHierarchy = ['defaults'].concat(env).concat([language, os.hostname()]);
console.log("properties hierarchy: " + propHierarchy);

// Propagate debug mode if need be
if (opts.propDebug) props.setDebug(true);

// *All* files in config dir are parsed 
props.initialize(rootDir + '/config', propHierarchy);

// Instantiate a function to access records concerning "gcc-explorer" 
// in hidden object props.properties
var gccProps = props.propsFor("gcc-explorer");

// Read from gccexplorer's config the wdiff configuration
// that will be used to configure lib/diff.js
var wdiffConfig = {
    wdiffExe: gccProps('wdiff', "wdiff"),
    maxOutput: gccProps("max-diff-output", 100000)
};

// Instantiate a function to access records concerning the chosen language
// in hidden object props.properties
var compilerPropsFunc = props.propsFor(language.toLowerCase());

// If no option for the compiler ... use gcc's options (??)
function compilerProps(property, defaultValue) {
    // My kingdom for ccs... [see Matt's github page]
    var forCompiler = compilerPropsFunc(property, undefined);
    if (forCompiler !== undefined) return forCompiler;
    return gccProps(property, defaultValue); // gccProps comes from lib/compile.js
}
require('./lib/compile').initialise(gccProps, compilerProps);
var staticMaxAgeMs = gccProps('staticMaxAgeMs', 0);

// function to load internal binaries (i.e. lib/source/*.js)
function loadSources() {
    var sourcesDir = "lib/sources";
    var sources = fs.readdirSync(sourcesDir)
        .filter(function (file) {
            return file.match(/.*\.js$/);
        })
        .map(function (file) {
            return require("./" + path.join(sourcesDir, file));
        });
    return sources;
}

// load effectively
var fileSources = loadSources();
var sourceToHandler = {};
fileSources.forEach(function (source) {
    sourceToHandler[source.urlpart] = source;
});

// auxiliary function used in clientOptionsHandler
function compareOn(key) {
    return function (xObj, yObj) {
        var x = xObj[key];
        var y = yObj[key];
        if (x < y) return -1;
        if (x > y) return 1;
        return 0;
    };
}

// instantiate a function that generate javascript code,
// this code will be embedded gcc-explorer-website/client-options.js
function clientOptionsHandler(compilers, fileSources) {
    var sources = fileSources.map(function (source) {
        return {name: source.name, urlpart: source.urlpart};
    });
    console.log("sources: " + JSON.stringify(sources)); // debug
    // sort source file alphabetically
    sources = sources.sort(compareOn("name"));
    var options = {
        googleAnalyticsAccount: gccProps('clientGoogleAnalyticsAccount', 'UA-55180-6'),
        googleAnalyticsEnabled: gccProps('clientGoogleAnalyticsEnabled', false),
        sharingEnabled: gccProps('clientSharingEnabled', true),
        githubEnabled: gccProps('clientGitHubRibbonEnabled', true),
        gapiKey: gccProps('googleApiKey', ''),
        googleShortLinkRewrite: gccProps('googleShortLinkRewrite', '').split('|'),
        defaultSource: gccProps('defaultSource', ''),
        language: language,
        compilers: compilers,
        sourceExtension: compilerProps('compileFilename').split('.', 2)[1],
        defaultCompiler: compilerProps('defaultCompiler', ''),
        compileOptions: compilerProps("options"),
        supportsBinary: !!compilerProps("supportsBinary"),
        postProcess: compilerProps("postProcess"),
        sources: sources
    };
    var text = JSON.stringify(options);
    return function getClientOptions(req, res) {
        res.set('Content-Type', 'application/json');
        res.set('Cache-Control', 'public, max-age=' + staticMaxAgeMs);
        res.end(text);
    };
}

// function used to enable loading and saving source code from web interface
function getSource(req, res, next) {
    var bits = req.url.split("/");
    var handler = sourceToHandler[bits[1]];
    if (!handler) {
        next();
        return;
    }
    var action = bits[2];
    if (action == "list") action = handler.list;
    else if (action == "load") action = handler.load;
    else if (action == "save") action = handler.save;
    else action = null;
    if (action === null) {
        next();
        return;
    }
    action.apply(handler, bits.slice(3).concat(function (err, response) {
        res.set('Cache-Control', 'public, max-age=' + staticMaxAgeMs);
        if (err) {
            res.end(JSON.stringify({err: err}));
        } else {
            res.end(JSON.stringify(response));
        }
    }));
}

function retryPromise(promiseFunc, name, maxFails, retryMs) {
    return new Promise(function (resolve, reject) {
        var fails = 0;

        function doit() {
            var promise = promiseFunc();
            promise.then(function (arg) {
                resolve(arg);
            }, function (e) {
                fails++;
                if (fails < maxFails) {
                    console.log("Failed " + name + " : " + e + ", retrying");
                    setTimeout(doit, retryMs);
                } else {
                    console.log("Too many retries for " + name + " : " + e);
                    reject(e);
                }
            });
        }

        doit();
    });
}

// Auxiliary function to findCompilers()
function configuredCompilers() {
    // read config (file already read) (':' are used to separate compilers names)
    var exes = compilerProps("compilers", "/usr/bin/g++").split(":");
    var ndk = compilerProps('androidNdk');
    if (ndk) {
        var toolchains = fs.readdirSync(ndk + "/toolchains");
        toolchains.forEach(function (v, i, a) {
            var path = ndk + "/toolchains/" + v + "/prebuilt/linux-x86_64/bin/";
            if (fs.existsSync(path)) {
                var cc = fs.readdirSync(path).filter(function (filename) {
                    return filename.indexOf("g++") != -1;
                });
                a[i] = path + cc[0];
            } else {
                a[i] = null;
            }
        });
        toolchains = toolchains.filter(function (x) {
            return x !== null;
        });
        exes.push.apply(exes, toolchains);
    }
    // Map any named compilers to their executable
    return Promise.all(exes.map(function (name) {
        if (name.indexOf("@") !== -1) {
            var bits = name.split("@");
            var host = bits[0];
            var port = parseInt(bits[1]);
            console.log("Fetching compilers from remote source " + host + ":" + port);
            return retryPromise(function () {
                    return new Promise(function (resolve, reject) {
                        http.get({
                            hostname: host,
                            port: port,
                            path: "/api/compilers"
                        }, function (res) {
                            var str = '';
                            res.on('data', function (chunk) {
                                str += chunk;
                            });
                            res.on('end', function () {
                                var compilers = JSON.parse(str).map(function (compiler) {
                                    compiler.exe = null;
                                    compiler.remote = "http://" + host + ":" + port;
                                    return compiler;
                                });
                                resolve(compilers);
                            });
                        }).on('error', function (e) {
                            reject(e);
                        });
                    });
                },
                host + ":" + port,
                gccProps('proxyRetries', 20),
                gccProps('proxyRetryMs', 500));
        }
        var base = "compiler." + name;
        var exe = compilerProps(base + ".exe", "");
        if (!exe) {
            return Promise.resolve({id: name, exe: name, name: name});
        }
        function props(name, def) {
            return compilerProps(base + "." + name, compilerProps(name, def));
        }

        return Promise.resolve({
            id: name,
            exe: exe,
            name: props("name", name),
            alias: props("alias"),
            options: props("options"),
            versionFlag: props("versionFlag"),
            is6g: !!props("is6g", false),
            intelAsm: props("intelAsm", ""),
            needsMulti: !!props("needsMulti", true),
            supportsBinary: !!props("supportsBinary", true),
            postProcess: props("postProcess", "")
        });
    }));
}

// Auxiliary function to findCompilers()
function getCompilerInfo(compilerInfo) {
    if (Array.isArray(compilerInfo)) {
        return Promise.resolve(compilerInfo);
    }
    return new Promise(function (resolve) {
        var compiler = compilerInfo.exe;
        var versionFlag = compilerInfo.versionFlag || '--version';
        // fill field compilerInfo.version,
        // assuming the compiler returns it's version on 1 line
        child_process.exec(compiler + ' ' + versionFlag, function (err, output) {
            if (err) return resolve(null);
            compilerInfo.version = output.split('\n')[0];
            if (compilerInfo.intelAsm) {
                return resolve(compilerInfo);
            }

            // get informations on the compiler's options
            child_process.exec(compiler + ' --target-help', function (err, output) {
                var options = {};
                if (!err) {
                    var splitness = /--?[-a-zA-Z]+( ?[-a-zA-Z]+)/;
                    output.split('\n').forEach(function (line) {
                        var match = line.match(splitness);
                        if (!match) return;
                        options[match[0]] = true;
                    });
                }
                if (options['-masm']) {
                    compilerInfo.intelAsm = "-masm=intel";
                }

                // debug (seems to be displayed multiple times):
                if (opts.propDebug) console.log("compiler options: " + JSON.stringify(options, null, 4));

                resolve(compilerInfo);
            });
        });
    });
}

function findCompilers() {
    return configuredCompilers()
        .then(function (compilers) {
            return Promise.all(compilers.map(getCompilerInfo));
        })
        .then(function (compilers) {
            compilers = Array.prototype.concat.apply([], compilers);
            compilers = compilers.filter(function (x) {
                return x !== null;
            });
            compilers = compilers.sort(compareOn("name"));
            console.log("Compilers:");
            compilers.forEach(function (c) {
                console.log(c.id + " : " + c.name + " : " + (c.exe || c.remote));
            });
            return compilers;
        });
}

// Instantiate a function that write informations on compiler,
// in JSON format (on which page ?)
function apiHandler(compilers) {
    var reply = JSON.stringify(compilers);
    return function apiHandler(req, res, next) {
        var bits = req.url.split("/");
        if (bits.length !== 2 || req.method !== "GET") return next();
        switch (bits[1]) {
            default:
                next();
                break;

            case "compilers":
                res.set('Content-Type', 'application/json');
                res.end(reply);
                break;
        }
    };
}

function shortUrlHandler(req, res, next) {
    var bits = req.url.split("/");
    if (bits.length !== 2 || req.method !== "GET") return next();
    var key = process.env.GOOGLE_API_KEY;
    var googleApiUrl = 'https://www.googleapis.com/urlshortener/v1/url?shortUrl=http://goo.gl/'
        + encodeURIComponent(bits[1]) + '&key=' + key;
    https.get(googleApiUrl, function (response) {
        var responseText = '';
        response.on('data', function (d) {
            responseText += d;
        });
        response.on('end', function () {
            if (response.statusCode != 200) {
                console.log("Failed to resolve short URL " + bits[1] + " - got response "
                    + response.statusCode + " : " + responseText);
                return next();
            }

            var resultObj = JSON.parse(responseText);
            var parsed = url.parse(resultObj.longUrl);
            var allowedRe = new RegExp(gccProps('allowedShortUrlHostRe'));
            if (parsed.host.match(allowedRe) === null) {
                console.log("Denied access to short URL " + bits[1] + " - linked to " + resultObj.longUrl);
                return next();
            }
            res.writeHead(301, {
                Location: resultObj.id,
                'Cache-Control': 'public'
            });
            res.end();
        });
    }).on('error', function (e) {
        res.end("TODO: error " + e.message);
    });
}

findCompilers().then(function (compilers) {
    var webServer = express(),
        sFavicon = require('serve-favicon'),
        sStatic = require('serve-static'),
        bodyParser = require('body-parser'),
        logger = require('morgan'),
        compression = require('compression'),
        restreamer = require('./lib/restreamer'),
        diffHandler = buildDiffHandler(wdiffConfig);

    webServer
        .use(logger('combined'))
        .use(compression())
        .use(sFavicon('static/favicon.ico'))
        .use(sStatic('out/dist', {maxAge: staticMaxAgeMs}))
        .use(sStatic('static', {maxAge: staticMaxAgeMs}))
        .use(bodyParser.json())
        .use(restreamer())
        .get('/client-options.json', clientOptionsHandler(compilers, fileSources))
        .use('/source', getSource)
        .use('/api', apiHandler(compilers))
        .use('/g', shortUrlHandler)
        .post('/compile', compileHandler(compilers)) // used inside static/compiler.js
        .post('/diff', diffHandler); // used inside static/compiler.js

    // GO!
    console.log("=======================================");
    console.log("Listening on http://" + hostname + ":" + port + "/");
    console.log("=======================================");
    webServer.listen(port, hostname);
}).catch(function (err) {
    console.log("Error: " + err.stack);
});
 at SyntaxError: Unexpected character '#' (1:78)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$7.getTokenFromCode (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2756:10)
    at Parser.pp$7.readToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2477:17)
    at Parser.readToken (/root/ExpoSE/lib/Tropigate/bin/Tokens.js:124:26)
    at Parser.pp$7.nextToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2468:15)
    at Parser.pp$7.next (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2413:10)
    at Parser.pp.eat (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:536:12)
    at Parser.pp.semicolon (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:581:15)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:918:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
