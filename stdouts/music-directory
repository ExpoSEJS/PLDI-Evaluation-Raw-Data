/root/Targets/music-directory
└─┬ music-directory@0.2.0 
  ├─┬ access-log@0.3.9 
  │ └── strftime@0.6.2 
  ├─┬ easyreq@0.1.3 
  │ └── cleanse@0.0.3 
  ├── ejs@0.8.8 
  ├─┬ latest@0.2.0 
  │ └─┬ npm@2.15.12 
  │   ├── abbrev@1.0.9 
  │   ├── ansi@0.3.1 
  │   ├── ansi-regex@2.0.0 
  │   ├── ansicolors@0.3.2 
  │   ├── ansistyles@0.1.3 
  │   ├── archy@1.0.0 
  │   ├── async-some@1.0.2 
  │   ├── block-stream@0.0.9 
  │   ├── char-spinner@1.0.1 
  │   ├── chmodr@1.0.2 
  │   ├── chownr@1.0.1 
  │   ├── cmd-shim@2.0.2 
  │   ├─┬ columnify@1.5.4 
  │   │ └─┬ wcwidth@1.0.0 
  │   │   └─┬ defaults@1.0.3 
  │   │     └── clone@1.0.2 
  │   ├─┬ config-chain@1.1.10 
  │   │ └── proto-list@1.2.4 
  │   ├─┬ dezalgo@1.0.3 
  │   │ └── asap@2.0.3 
  │   ├── editor@1.0.0 
  │   ├── fs-vacuum@1.2.9 
  │   ├─┬ fs-write-stream-atomic@1.0.8 
  │   │ └── iferr@0.1.5 
  │   ├── fstream@1.0.10 
  │   ├─┬ fstream-npm@1.1.1 
  │   │ └── fstream-ignore@1.0.5 
  │   ├── github-url-from-git@1.4.0 
  │   ├── github-url-from-username-repo@1.0.2 
  │   ├─┬ glob@7.0.6 
  │   │ ├── fs.realpath@1.0.0 
  │   │ └── path-is-absolute@1.0.0 
  │   ├── graceful-fs@4.1.6 
  │   ├── hosted-git-info@2.1.5 
  │   ├── imurmurhash@0.1.4 
  │   ├── inflight@1.0.5 
  │   ├── inherits@2.0.3 
  │   ├── ini@1.3.4 
  │   ├─┬ init-package-json@1.9.4 
  │   │ ├─┬ glob@6.0.4 
  │   │ │ └── path-is-absolute@1.0.0 
  │   │ └── promzard@0.3.0 
  │   ├── lockfile@1.0.1 
  │   ├─┬ lru-cache@4.0.1 
  │   │ ├── pseudomap@1.0.2 
  │   │ └── yallist@2.0.0 
  │   ├─┬ minimatch@3.0.3 
  │   │ └─┬ brace-expansion@1.1.6 
  │   │   ├── balanced-match@0.4.2 
  │   │   └── concat-map@0.0.1 
  │   ├─┬ mkdirp@0.5.1 
  │   │ └── minimist@0.0.8 
  │   ├─┬ node-gyp@3.6.0 
  │   │ └── semver@5.3.0 
  │   ├── nopt@3.0.6 
  │   ├── normalize-git-url@3.0.2 
  │   ├─┬ normalize-package-data@2.3.5 
  │   │ └─┬ is-builtin-module@1.0.0 
  │   │   └── builtin-modules@1.1.0 
  │   ├── npm-cache-filename@1.0.2 
  │   ├── npm-install-checks@1.0.7 
  │   ├── npm-package-arg@4.1.0 
  │   ├─┬ npm-registry-client@7.2.1 
  │   │ ├─┬ concat-stream@1.5.2 
  │   │ │ ├─┬ readable-stream@2.0.6 
  │   │ │ │ ├── core-util-is@1.0.2 
  │   │ │ │ ├── isarray@1.0.0 
  │   │ │ │ ├── process-nextick-args@1.0.7 
  │   │ │ │ ├── string_decoder@0.10.31 
  │   │ │ │ └── util-deprecate@1.0.2 
  │   │ │ └── typedarray@0.0.6 
  │   │ └── retry@0.10.0 
  │   ├── npm-user-validate@0.1.5 
  │   ├─┬ npmlog@2.0.4 
  │   │ ├─┬ are-we-there-yet@1.1.2 
  │   │ │ └── delegates@1.0.0 
  │   │ └─┬ gauge@1.2.7 
  │   │   ├── has-unicode@2.0.0 
  │   │   ├─┬ lodash.pad@4.4.0 
  │   │   │ ├── lodash._baseslice@4.0.0 
  │   │   │ ├── lodash._basetostring@4.12.0 
  │   │   │ └── lodash.tostring@4.1.4 
  │   │   ├── lodash.padend@4.5.0 
  │   │   └── lodash.padstart@4.5.0 
  │   ├── once@1.4.0 
  │   ├── opener@1.4.1 
  │   ├─┬ osenv@0.1.3 
  │   │ ├── os-homedir@1.0.0 
  │   │ └── os-tmpdir@1.0.1 
  │   ├── path-is-inside@1.0.1 
  │   ├─┬ read@1.0.7 
  │   │ └── mute-stream@0.0.5 
  │   ├─┬ read-installed@4.0.3 
  │   │ ├── debuglog@1.0.1 
  │   │ ├── readdir-scoped-modules@1.0.2 
  │   │ └── util-extend@1.0.1 
  │   ├─┬ read-package-json@2.0.4 
  │   │ ├─┬ glob@6.0.4 
  │   │ │ └── path-is-absolute@1.0.0 
  │   │ └─┬ json-parse-helpfulerror@1.0.3 
  │   │   └── jju@1.3.0 
  │   ├─┬ readable-stream@2.1.5 
  │   │ ├── buffer-shims@1.0.0 
  │   │ ├── core-util-is@1.0.2 
  │   │ ├── isarray@1.0.0 
  │   │ ├── process-nextick-args@1.0.7 
  │   │ ├── string_decoder@0.10.31 
  │   │ └── util-deprecate@1.0.2 
  │   ├── realize-package-specifier@3.0.1 
  │   ├─┬ request@2.74.0 
  │   │ ├── aws-sign2@0.6.0 
  │   │ ├── aws4@1.4.1 
  │   │ ├─┬ bl@1.1.2 
  │   │ │ └─┬ readable-stream@2.0.6 
  │   │ │   ├── core-util-is@1.0.2 
  │   │ │   ├── isarray@1.0.0 
  │   │ │   ├── process-nextick-args@1.0.7 
  │   │ │   ├── string_decoder@0.10.31 
  │   │ │   └── util-deprecate@1.0.2 
  │   │ ├── caseless@0.11.0 
  │   │ ├─┬ combined-stream@1.0.5 
  │   │ │ └── delayed-stream@1.0.0 
  │   │ ├── extend@3.0.0 
  │   │ ├── forever-agent@0.6.1 
  │   │ ├─┬ form-data@1.0.0-rc4 
  │   │ │ └── async@1.5.2 
  │   │ ├─┬ har-validator@2.0.6 
  │   │ │ ├─┬ chalk@1.1.3 
  │   │ │ │ ├── ansi-styles@2.2.1 
  │   │ │ │ ├── escape-string-regexp@1.0.5 
  │   │ │ │ ├── has-ansi@2.0.0 
  │   │ │ │ └── supports-color@2.0.0 
  │   │ │ ├─┬ commander@2.9.0 
  │   │ │ │ └── graceful-readlink@1.0.1 
  │   │ │ ├─┬ is-my-json-valid@2.13.1 
  │   │ │ │ ├── generate-function@2.0.0 
  │   │ │ │ ├─┬ generate-object-property@1.2.0 
  │   │ │ │ │ └── is-property@1.0.2 
  │   │ │ │ ├── jsonpointer@2.0.0 
  │   │ │ │ └── xtend@4.0.1 
  │   │ │ └─┬ pinkie-promise@2.0.1 
  │   │ │   └── pinkie@2.0.4 
  │   │ ├─┬ hawk@3.1.3 
  │   │ │ ├── boom@2.10.1 
  │   │ │ ├── cryptiles@2.0.5 
  │   │ │ ├── hoek@2.16.3 
  │   │ │ └── sntp@1.0.9 
  │   │ ├─┬ http-signature@1.1.1 
  │   │ │ ├── assert-plus@0.2.0 
  │   │ │ ├─┬ jsprim@1.3.0 
  │   │ │ │ ├── extsprintf@1.0.2 
  │   │ │ │ ├── json-schema@0.2.2 
  │   │ │ │ └── verror@1.3.6 
  │   │ │ └─┬ sshpk@1.9.2 
  │   │ │   ├── asn1@0.2.3 
  │   │ │   ├── assert-plus@1.0.0 
  │   │ │   ├── dashdash@1.14.0 
  │   │ │   ├── ecc-jsbn@0.1.1 
  │   │ │   ├── getpass@0.1.6 
  │   │ │   ├── jodid25519@1.0.2 
  │   │ │   ├── jsbn@0.1.0 
  │   │ │   └── tweetnacl@0.13.3 
  │   │ ├── is-typedarray@1.0.0 
  │   │ ├── isstream@0.1.2 
  │   │ ├── json-stringify-safe@5.0.1 
  │   │ ├─┬ mime-types@2.1.11 
  │   │ │ └── mime-db@1.23.0 
  │   │ ├── node-uuid@1.4.7 
  │   │ ├── oauth-sign@0.8.2 
  │   │ ├── qs@6.2.1 
  │   │ ├── stringstream@0.0.5 
  │   │ ├── tough-cookie@2.3.1 
  │   │ └── tunnel-agent@0.4.3 
  │   ├── retry@0.10.0 
  │   ├── rimraf@2.5.4 
  │   ├── semver@5.1.0 
  │   ├─┬ sha@2.0.1 
  │   │ └─┬ readable-stream@2.0.2 
  │   │   ├── core-util-is@1.0.1 
  │   │   ├── isarray@0.0.1 
  │   │   ├── process-nextick-args@1.0.3 
  │   │   ├── string_decoder@0.10.31 
  │   │   └── util-deprecate@1.0.1 
  │   ├── slide@1.1.6 
  │   ├── sorted-object@2.0.0 
  │   ├── spdx-license-ids@1.2.2 
  │   ├── strip-ansi@3.0.1 
  │   ├── tar@2.2.1 
  │   ├── text-table@0.2.0 
  │   ├── uid-number@0.0.6 
  │   ├── umask@1.1.0 
  │   ├─┬ validate-npm-package-license@3.0.1 
  │   │ ├── spdx-correct@1.0.2 
  │   │ └─┬ spdx-expression-parse@1.0.2 
  │   │   └── spdx-exceptions@1.0.4 
  │   ├─┬ validate-npm-package-name@2.2.2 
  │   │ └── builtins@0.0.7 
  │   ├─┬ which@1.2.11 
  │   │ └── isexe@1.1.2 
  │   ├── wrappy@1.0.2 
  │   └── write-file-atomic@1.1.4 
  ├─┬ log-timestamp@0.1.2 
  │ └── log-prefix@0.0.0 
  ├── mime@1.2.11 
  ├─┬ musicmetadata@0.2.7 
  │ ├── buffer-equal@0.0.0 
  │ ├── drag-and-drop-files@0.0.1 
  │ ├── filereader-stream@0.0.1 
  │ ├── strtok2@1.0.4 
  │ └── through@2.3.8 
  ├── posix-getopt@1.0.0 
  ├── routes@0.1.1 
  └─┬ static-route@0.1.2 
    └── he@0.4.1 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/music-directory/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 72% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","create","reverse","RegExp","toString"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0556 took 21.1922s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (3:4) on program // A fast streaming parser library.

var assert = require('assert');
var Buffer = require('buffer').Buffer;

// Buffer for parse() to handle types that span more than one buffer
var SPANNING_BUF = new Buffer(1024);

// Possibly call flush()
var maybeFlush = function(b, o, len, flush) {
    if (o + len > b.length) {
        if (typeof(flush) !== 'function') {
            throw new Error(
                'Buffer out of space and no valid flush() function found'
            );
        }

        flush(b, o);

        return 0;
    }

    return o;
};

// Sentinel types

var DEFER = {};
exports.DEFER = DEFER;

var DONE = {};
exports.DONE = DONE;

// Primitive types

var UINT8 = {
    len : 1,
    get : function(buf, off) {
        return buf[off];
    },
    put : function(b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= 0 && v <= 0xff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);

        var no = maybeFlush(b, o, this.len, flush);
        b[no] = v & 0xff;

        return (no - o) + this.len;
    }
};
exports.UINT8 = UINT8;

var UINT16_LE = {
    len : 2,
    get : function(buf, off) {
        return buf[off] | (buf[off + 1] << 8);
    },
    put : function(b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= 0 && v <= 0xffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);

        var no = maybeFlush(b, o, this.len, flush);
        b[no] = v & 0xff;
        b[no + 1] = (v >>> 8) & 0xff;

        return (no - o) + this.len;
    }
};
exports.UINT16_LE = UINT16_LE;

var UINT16_BE = {
    len : 2,
    get : function(buf, off) {
        return (buf[off] << 8) | buf[off + 1];
    },
    put : function(b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= 0 && v <= 0xffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);

        var no = maybeFlush(b, o, this.len, flush);
        b[no] = (v >>> 8) & 0xff;
        b[no + 1] = v & 0xff;

        return (no - o) + this.len;
    }
};
exports.UINT16_BE = UINT16_BE;

var UINT24_LE = {
    len : 3,
    get : function(buf, off) {
        return buf[off] | (buf[off + 1] << 8) | (buf[off + 2] << 16);
    },
    put : function(b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= 0 && v <= 0xffffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);

        var no = maybeFlush(b, o, this.len, flush);
        b[no] = v & 0xff;
        b[no + 1] = (v >>> 8) & 0xff;
        b[no + 2] = (v >>> 16) & 0xff;

        return (no - o) + this.len;
    }
};
exports.UINT24_LE = UINT24_LE;

var UINT24_BE = {
    len : 3,
    get : function (buf, off) {
        return (((buf[off] << 8) + buf[off + 1]) << 8) + buf[off + 2]
    },
    put : function(b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= 0 && v <= 0xffffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);

        var no = maybeFlush(b, o, this.len, flush);
        b[no] = (v >>> 16) & 0xff;
        b[no + 1] = (v >>> 8) & 0xff;
        b[no + 2] = v & 0xff;

        return (no - o) + this.len;
    }
};
exports.UINT24_BE = UINT24_BE;

var UINT32_LE = {
    len : 4,
    get : function(buf, off) {
        // Shifting the MSB by 24 directly causes it to go negative if its
        // last bit is high, so we instead shift by 23 and multiply by 2.
        // Also, using binary OR to count the MSB if its last bit is high
        // causes the value to go negative. Use addition there.
        return (buf[off] | (buf[off + 1] << 8) | (buf[off + 2] << 16)) +
               ((buf[off + 3] << 23) * 2);
    },
    put : function(b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= 0 && v <= 0xffffffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);

        var no = maybeFlush(b, o, this.len, flush);
        b[no] = v & 0xff;
        b[no + 1] = (v >>> 8) & 0xff;
        b[no + 2] = (v >>> 16) & 0xff;
        b[no + 3] = (v >>> 24) & 0xff;

        return (no - o) + this.len;
    }
};
exports.UINT32_LE = UINT32_LE;

var UINT32_BE = {
    len : 4,
    get : function(buf, off) {
        // See comments in UINT32_LE.get()
        return ((buf[off] << 23) * 2) +
               ((buf[off + 1] << 16) | (buf[off + 2] << 8) | buf[off + 3]);
    },
    put : function(b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= 0 && v <= 0xffffffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);

        var no = maybeFlush(b, o, this.len, flush);
        b[no] = (v >>> 24) & 0xff;
        b[no + 1] = (v >>> 16) & 0xff;
        b[no + 2] = (v >>> 8) & 0xff;
        b[no + 3] = v & 0xff;

        return (no - o) + this.len;
    }
};
exports.UINT32_BE = UINT32_BE;

var INT8 = {
    len : 1,
    get : function(buf, off)  {
        var v = UINT8.get(buf, off);
        return ((v & 0x80) === 0x80) ?
            (-128 + (v & 0x7f)) :
            v;
    },
    put : function(b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= -128 && v <= 127);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);

        var no = maybeFlush(b, o, this.len, flush);
        b[no] = v & 0xff;

        return (no - o) + this.len;
    }
};
exports.INT8 = INT8;

var INT16_BE = {
    len : 2,
    get : function(buf, off)  {
        var v = UINT16_BE.get(buf, off);
        return ((v & 0x8000) === 0x8000) ?
            (-32768 + (v & 0x7fff)) :
            v;
    },
    put : function(b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= -32768 && v <= 32767);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);

        var no = maybeFlush(b, o, this.len, flush);
        b[no] = ((v & 0xffff) >>> 8) & 0xff;
        b[no + 1] = v & 0xff;

        return (no - o) + this.len;
    }
};
exports.INT16_BE = INT16_BE;

var INT24_BE = {
    len : 3,
    get : function(buf, off)  {
       var v = UINT24_BE.get(buf, off);
        return ((v & 0x800000) === 0x800000) ?
          (-0x800000 + (v & 0x7fffff)) : v;
    },
    put : function(b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= -0x800000 && v <= 0x7fffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);

        var no = maybeFlush(b, o, this.len, flush);
        b[no] = (v >>> 16) & 0xff;
        b[no + 1] = (v >>> 8) & 0xff;
        b[no + 2] = v & 0xff;

        return (no - o) + this.len;
    }
};
exports.INT24_BE = INT24_BE;

var INT32_BE = {
    len : 4,
    get : function(buf, off)  {
        // We cannot check for 0x80000000 directly, as this always returns
        // false. Instead, check for the two's-compliment value, which
        // behaves as expected. Also, we cannot subtract our value all at
        // once, so do it in two steps to avoid sign busting.
        var v = UINT32_BE.get(buf, off);
        return ((v & 0x80000000) === -2147483648) ?
            ((v & 0x7fffffff) - 1073741824 - 1073741824) :
            v;
    },
    put : function(b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= -2147483648 && v <= 2147483647);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);

        var no = maybeFlush(b, o, this.len, flush);
        b[no] = (v >>> 24) & 0xff;
        b[no + 1] = (v >>> 16) & 0xff;
        b[no + 2] = (v >>> 8) & 0xff;
        b[no + 3] = v & 0xff;

        return (no - o) + this.len;
    }
};
exports.INT32_BE = INT32_BE;

// Complex types
//
// These types are intended to allow callers to re-use them by manipulating
// the 'len' and other properties directly.

var IgnoreType = function(l) {
  this.len = l;
  this.get = function() {
    return null;
  };
};
exports.IgnoreType = IgnoreType;


var BufferType = function(l) {
    var self = this;

    self.len = l;

    self.get = function(buf, off) {
        return buf.slice(off, off + this.len);
    };
};
exports.BufferType = BufferType;

var StringType = function(l, e) {
    var self = this;

    self.len = l;

    self.encoding = e;

    self.get = function(buf, off) {
        return buf.toString(e, off, off + this.len);
    };
};
exports.StringType = StringType;

// Parse a stream
var parse = function(s, cb) {
    // Type of data that we're to parse next; if DEFER, we're awaiting
    // an invocation of typeCallback
    var type = DEFER;

    // Data that we've seen but not yet processed / handed off to cb; first
    // valid byte to process is always bufs[0][bufOffset]
    var bufs = [];
    var bufsLen = 0;
    var bufOffset = 0;
    var ignoreLen = 0;

    // Callback for FSM to tell us what type to expect next
    var typeCallback = function(t) {
        if (type !== DEFER) {
            throw new Error('refusing to overwrite non-DEFER type');
        }

        type = t;

        emitData();
    };

    // Process data that we have accumulated so far, emitting any type(s)
    // collected. This is the main parsing loop.
    //
    // Out strategy for handling buffers is to shift them off of the bufs[]
    // array until we have enough accumulated to account for type.len bytes.
    var emitData = function() {
        var b;
        while (type !== DONE && type !== DEFER && bufsLen >= type.len) {
            b = bufs[0];
            var bo = bufOffset;

            assert.ok(bufOffset >= 0 && bufOffset < b.length);

            if ((b.length - bufOffset) < type.len) {
                if (SPANNING_BUF.length < type.len) {
                    SPANNING_BUF = new Buffer(
                        Math.pow(2, Math.ceil(Math.log(type.len) / Math.log(2)))
                    );
                }

                b = SPANNING_BUF;
                bo = 0;

                var bytesCopied = 0;
                while (bytesCopied < type.len && bufs.length > 0) {
                    var bb = bufs[0];
                    var copyLength = Math.min(type.len - bytesCopied, bb.length - bufOffset);

                    // TODO: Manually copy bytes if we don't need many of them.
                    //       Bouncing down into C++ land to invoke
                    //       Buffer.copy() is expensive enough that we
                    //       shouldnt' do it unless we have a lot of dato to
                    //       copy.
                    bb.copy(
                        b,
                        bytesCopied,
                        bufOffset,
                        bufOffset + copyLength
                    );

                    bytesCopied += copyLength;

                    if (copyLength < (bb.length - bufOffset)) {
                        assert.equal(bytesCopied, type.len);
                        bufOffset += copyLength;
                    } else {
                        assert.equal(bufOffset + copyLength, bb.length);
                        bufs.shift();
                        bufOffset = 0;
                    }
                }

                assert.equal(bytesCopied, type.len);
            } else if ((b.length - bufOffset) === type.len) {
                bufs.shift();
                bufOffset = 0;
            } else {
                bufOffset += type.len;
            }

            bufsLen -= type.len;
            type = cb(type.get(b, bo), typeCallback);
            if (type instanceof IgnoreType) {
              ignoreLen += type.len;
              if (ignoreLen >= bufsLen) {
                // clear all buffers
                ignoreLen -= bufsLen;
                bufsLen = 0;
                bufs = [];
                bufOffset = 0;
              } else if (ignoreLen < bufs[0].length - bufOffset) {
                // set bufOffset correctly
                bufsLen -= ignoreLen;
                bufOffset += ignoreLen;
                ignoreLen = 0;
              } else if (bufsLen > 0) {
                // shift some buffers and set bufOffset correctly.
                bufsLen -= ignoreLen;
                ignoreLen += bufOffset;
                while (ignoreLen >= bufs[0].length) {
                  ignoreLen -= bufs.shift().length;
                }
                bufOffset = ignoreLen;
                ignoreLen = 0;
              }
              type = cb(type.get(), typeCallback);
            }
        }

        if (type === DONE) {
            s.removeListener('data', dataListener);

            // Pump all of the buffers that we already saw back through the
            // stream; the protocol layer will have set up listeners for this
            // event if it cares about the remaining data.
            while (bufs.length > 0) {
                b = bufs.shift();

                if (bufOffset > 0) {
                    b = b.slice(bufOffset, b.length);
                    bufOffset = 0;
                }

                s.emit('data', b);
            }
        }
    };

    // Listen for data from our stream
    var dataListener = function(d) {
        if (d.length <= ignoreLen) {
          // ignore this data
          assert.strictEqual(bufsLen, 0);
          assert.strictEqual(bufs.length, 0);
          ignoreLen -= d.length;
        } else if (ignoreLen > 0) {
          assert.strictEqual(bufsLen, 0);
          bufsLen = d.length - ignoreLen;
          bufs.push(d.slice(ignoreLen));
          ignoreLen = 0;
          emitData();
        } else {
          bufs.push(d);
          bufsLen += d.length;
          emitData();
        }
    };

    // Get the initial type
    type = cb(undefined, typeCallback);
    if (type !== DONE) {
        s.on('data', dataListener);
    }
};
exports.parse = parse;
 at SyntaxError: Unexpected token (3:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/music-directory/node_modules/music-directory/server.js. Coverage (Term): 19% Coverage (LOC): 24%
*- File /root/Targets/music-directory/node_modules/access-log/index.js. Coverage (Term): 9% Coverage (LOC): 11%
*- File /root/Targets/music-directory/node_modules/strftime/strftime.js. Coverage (Term): 10% Coverage (LOC): 19%
*- File /root/Targets/music-directory/node_modules/easyreq/easyreq.js. Coverage (Term): 13% Coverage (LOC): 15%
*- File /root/Targets/music-directory/node_modules/cleanse/cleanse.js. Coverage (Term): 23% Coverage (LOC): 23%
*- File /root/Targets/music-directory/node_modules/music-directory/router.js. Coverage (Term): 74% Coverage (LOC): 88%
*- File /root/Targets/music-directory/node_modules/routes/index.js. Coverage (Term): 41% Coverage (LOC): 58%
*- File /root/Targets/music-directory/node_modules/music-directory/routes/index.js. Coverage (Term): 54% Coverage (LOC): 63%
*- File /root/Targets/music-directory/node_modules/music-directory/routes/static.js. Coverage (Term): 75% Coverage (LOC): 92%
*- File /root/Targets/music-directory/node_modules/static-route/static-route.js. Coverage (Term): 11% Coverage (LOC): 13%
*- File /root/Targets/music-directory/node_modules/he/he.js. Coverage (Term): 85% Coverage (LOC): 97%
*- File /root/Targets/music-directory/node_modules/mime/mime.js. Coverage (Term): 77% Coverage (LOC): 92%
*- File /root/Targets/music-directory/node_modules/music-directory/routes/media.js. Coverage (Term): 7% Coverage (LOC): 7%
*- File /root/Targets/music-directory/node_modules/ejs/lib/ejs.js. Coverage (Term): 10% Coverage (LOC): 13%
*- File /root/Targets/music-directory/node_modules/ejs/lib/utils.js. Coverage (Term): 35% Coverage (LOC): 80%
*- File /root/Targets/music-directory/node_modules/ejs/lib/filters.js. Coverage (Term): 20% Coverage (LOC): 54%
*- File /root/Targets/music-directory/node_modules/musicmetadata/lib/index.js. Coverage (Term): 5% Coverage (LOC): 4%
*- File /root/Targets/music-directory/node_modules/musicmetadata/lib/common.js. Coverage (Term): 2% Coverage (LOC): 1%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
