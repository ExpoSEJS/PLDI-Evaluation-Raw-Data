/root/Targets/terminal-recorder
└── terminal-recorder@0.1.3 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/terminal-recorder/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.045 took 7.1573s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected character '#' (1:78) on program #!/usr/bin/env node
var program = require('commander');
var pack = require('./package.json');
var fs = require('fs');
var path = require('path');
var colors = require('colors');
var ncp = require('ncp').ncp;

program
  .version(pack.version)
  .option('-o, --outpath [path]', 'Add the specified [path] to place the recorded html', '.')
  .parse(process.argv);


if (program.outpath === '.'){
    console.log('[Info] Using current path as default'.yellow);
    console.log('Remember you can specify the output path. In example:'.yellow);
    console.log('\n   $ terminal-recorder -o ./your-path/should-be-here/ \n'.yellow);
}

var fname = 'terminal-recorder-html';
var folderout = program.outpath;
var folderdest = folderout+'/'+fname;
var dirString = path.dirname(fs.realpathSync(__filename));

fs.mkdir(folderout+'/'+fname, function(err){
    ncp(dirString+'/template/', folderdest, function (err) {
        //console.log('copied');
    
    });
});

var stdin = process.stdin,
    keypress = require('keypress'),
    Handlebars = require('handlebars'),
    pty = require('pty.js');

var end, start = new Date(), milestones = [];

var log = function(data, cb){
  fs.appendFile('./logs.txt', data, cb);
}

var logAction = function(data, cb){
  fs.appendFile('./actions.txt', data, cb);
}

var createMilestone = function(data, cb){
  end = new Date();
  milestones.push({
    time: (end - start),
    content: data.replace(/\\/g, '\\\\').replace(/\"/g,'\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r')
  });
  if(cb) { cb(); }
}

var createTemplate = function(cb){
  var tplpath = folderdest+'/js/events.js.hbs';
  var tpldest = folderdest+'/js/events.js';
  fs.readFile(tplpath, 'utf8', function (err, source) {
    //console.log("file read");
    var template = Handlebars.compile(source);
    var data = {
        totaltime: milestones[milestones.length-1]['time'],
        marks: milestones    
    }
    var result = template(data);
    fs.writeFile(tpldest, result, function(err){
        //console.log("file write");
        //console.log(result);
        if(cb) { cb(); }
    });
  });
}

process.on('uncaughtException', function(err) {
    //console.log('Caught exception: ' + err);
});


console.log("----------------- Welcome to terminal-recorder ----------------------".grey);
console.log("[Warning] We are saving all your keystrokes, donnot enter any password".red);
console.log("Remember: Hit ctrl+c to quit".grey);
console.log("---------------------------------------------------------------------".grey);
//console.log("title", process.title);

var term = pty.spawn('bash', [], {
  name: 'xterm-color',
  cols: 90,
  rows: 30,
  stdio: [ 'pipe', 'pipe', 'pipe'],
  cwd: process.env.HOME,
  //cwd: process.cwd(),
  env: process.env
});

// without this, we would only get streams once enter is pressed
stdin.setRawMode( true );

// resume stdin in the parent process (node app won't quit all by itself
// unless an error or process.exit() happens)
stdin.resume();

// i don't want binary, do you?
stdin.setEncoding( 'utf8' );

term.on('data', function(data) {
  //log('c-out: '+data+'\r', function (err) {
  log(data, function (err) {
    createMilestone(data, function(){
        process.stdout.write(data);
    }); 
  });
});



keypress(process.stdin);

// on any data into stdin
stdin.on( 'keypress', function( ch, key ){
  // ctrl-c ( end of text )
  if ( ch === '\u0003' ) {
    //console.log(milestones);
    // save envents
    createTemplate(function(){
        console.log("\n----------------- See the exported files in ----------------------".grey);
        console.log(("[Info] Destination folder: "+folderdest+" ").yellow);
        console.log("Credits: @cortezcristian www.cortezcristian.com".grey);
        console.log("------------------------- Bye :P ---------------------------------\n".grey);
        process.exit();
    });
  } else {
    if (typeof ch !== 'undefined' ) {
      term.write( ch );
    } else {
      term.write( key.sequence );
    }
  }
  //});
  //}
});
 at SyntaxError: Unexpected character '#' (1:78)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$7.getTokenFromCode (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2756:10)
    at Parser.pp$7.readToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2477:17)
    at Parser.readToken (/root/ExpoSE/lib/Tropigate/bin/Tokens.js:124:26)
    at Parser.pp$7.nextToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2468:15)
    at Parser.pp$7.next (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2413:10)
    at Parser.pp.eat (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:536:12)
    at Parser.pp.semicolon (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:581:15)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:918:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
