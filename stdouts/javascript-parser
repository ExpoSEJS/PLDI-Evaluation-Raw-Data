/root/Targets/javascript-parser
└─┬ javascript-parser@0.0.23 
  ├── co@4.6.0 
  ├── inherits@2.0.3 
  ├─┬ js-log@0.4.1 
  │ └─┬ winston@2.3.1 
  │   ├── async@1.0.0 
  │   ├── colors@1.0.3 
  │   ├── cycle@1.0.3 
  │   ├── eyes@0.1.8 
  │   ├── isstream@0.1.2 
  │   └── stack-trace@0.0.10 
  ├── lodash@4.17.4 
  ├── map-stream@0.0.7 
  ├─┬ sanitize-html@1.14.1 
  │ ├─┬ htmlparser2@3.9.2 
  │ │ ├── domelementtype@1.3.0 
  │ │ ├── domhandler@2.4.1 
  │ │ ├─┬ domutils@1.6.2 
  │ │ │ └─┬ dom-serializer@0.1.0 
  │ │ │   └── domelementtype@1.1.3 
  │ │ ├── entities@1.1.1 
  │ │ └─┬ readable-stream@2.3.3 
  │ │   ├── core-util-is@1.0.2 
  │ │   ├── isarray@1.0.0 
  │ │   ├── process-nextick-args@1.0.7 
  │ │   ├── safe-buffer@5.1.1 
  │ │   ├── string_decoder@1.0.3 
  │ │   └── util-deprecate@1.0.2 
  │ ├── regexp-quote@0.0.0 
  │ └── xtend@4.0.1 
  └── thunkify@2.1.2 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/javascript-parser/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 35% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","join","RegExp","create"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0301 took 8.4495s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (8:4) on program // circular require BodyParser <- BbtagParser <- BodyParser
// when I require BodyParser it will get the unfinished export
// that's why I assign it here, before require('./bbtagParser')
module.exports = BodyParser;

var inherits = require('inherits');
var _ = require('lodash');
var assert = require('assert');
var StringSet = require('../util/stringSet');
var StringMap = require('../util/stringMap');
var Parser = require('./parser');
var BbtagParser = require('./bbtagParser');
var BodyLexer = require('./bodyLexer');
var ReferenceNode = require('../node/referenceNode');
var TagNode = require('../node/tagNode');
var EscapedTag = require('../node/escapedTag');
var CompositeTag = require('../node/compositeTag');
var BbtagAttrsParser = require('./bbtagAttrsParser');
var ErrorTag = require('../node/errorTag');
var CommentNode = require('../node/commentNode');
var HeaderTag = require('../node/headerTag');
var VerbatimText = require('../node/verbatimText');
var TreeWalkerSync = require('../transformer/treeWalkerSync');
var HREF_PROTOCOL_REG = require('../consts').HREF_PROTOCOL_REG;
var makeAnchor = require('../util/makeAnchor');
var TextNode = require('../node/textNode');

/**
 * BodyParser creates node objects from general text.
 * Node attrs will *not* be checked by sanitizers, they can contain anything like `onclick=`
 * This provides maximal freedom to the parser.
 *
 * Parser knows about current trust mode, so it must make sure that these attributes are safe.
 *
 * Parser builds a tree structure, parsing all text and if needed, transforming it on the fly,
 * so that a traversal may reach all descendants.
 *
 * The final node.toHtml call MAY generate more text, but MAY NOT generate more nodes in the process.
 *
 * @constructor
 */
function BodyParser(text, options) {
  if (!options.metadata) {
    options.metadata = {};
  }
  if (!options.metadata.refs) {
    options.metadata.refs = new StringSet();
  }
  if (!options.metadata.libs) {
    options.metadata.libs = new StringSet();
  }
  if (!options.metadata.head) {
    options.metadata.head = [];
  }
  if (!options.metadata.headers) {
    options.metadata.headers = [];
  }
  if (!options.metadata.headersAnchorMap) {
    options.metadata.headersAnchorMap = new StringMap();
  }

  Parser.call(this, options);

  this.lexer = new BodyLexer(text);
}

inherits(BodyParser, Parser);

BodyParser.prototype.validateOptions = function(options) {

  if (!("trusted" in options)) {
    throw new Error("Must have trusted option");
  }

};

//  Каждый вызов parse возвращает не узел, а массив узлов,
//  например [online] ... [/online] возвращает своё содержимое с учетом вложенных тегов
//  или пустой тег, если экспорт-режим
//  Это должен быть valid html
BodyParser.prototype.parse = function() {
  var buffer = '';
  var children = [];

  while (!this.lexer.isEof()) {

    var nodes = this.parseNodes();

    if (nodes) {

      if (nodes.length === undefined) {
        nodes = [nodes];
      }

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];

        if (buffer) {
          children.push(new TextNode(buffer));
          buffer = "";
        }
        children.push(node);
      }

    } else {
      buffer += this.lexer.consumeChar();
    }

  }

  if (buffer) {
    children.push(new TextNode(buffer));
  }

  return children;
};


/**
 * @returns tokens array or (most often, for perf reasons) null if no token found
 */
BodyParser.prototype.parseNodes = function() {

  var token = null;

  // perf optimization for most chars
  switch (this.lexer.getChar()) {
  case '[':
    token = this.lexer.consumeLink() || this.lexer.consumeBbtagSelfClose() || this.lexer.consumeBbtagNeedClose();
    break;
  case '`':
    token = this.lexer.consumeSource() || this.lexer.consumeCode();
    break;
  case '~':
    token = this.lexer.consumeStrike();
    break;
  case '*':
    token = this.lexer.consumeBold() || this.lexer.consumeItalic();
    break;
  case '<':
    token = this.lexer.consumeImg() || this.lexer.consumeComment() || this.lexer.consumeVerbatimTag();
    break;
  case '#':
    token = this.lexer.consumeHeader();
    break;
  }

  if (token === null) return null;

  var methodName = 'parse' + token.type[0].toUpperCase() + token.type.slice(1);
  if (!this[methodName]) {
    throw new Error("Unknown token: " + JSON.stringify(token));
  }

  var node = this[methodName](token);

  return node;
};

/**
 * This does several things
 * 1) Parses header (must not contain external stuff)
 * 2) Checks header structure (and builds headers array)
 * @param token
 * @returns {*}
 */
BodyParser.prototype.parseHeader = function(token) {
  var p = new BodyParser(token.title, this.options);
  var titleNode = p.parseAndWrap();

  var level = token.level;

  // There should be no ()[#references] or other external nodes inside header text,
  // because we may need to extract title/navigation from the content
  // and we'd like to do that without having to use DB for refs
  // ...anyway, reference inside a header has *no use*
  var checkWalker = new TreeWalkerSync(titleNode);
  checkWalker.walk(function(node) {
    if (node.isExternal()) {
      return new TextNode(''); // kill external nodes!
    }
  }.bind(this));

  // ---- Проверить уровень ----
  // Уровень ограничен 3, так как
  // во-первых, 3 должно быть достаточно
  // во-вторых, при экспорте h3 становится h5
  if (level > 3) {
    return new ErrorTag('div', "Заголовок " + token.title + " слишком глубоко вложен (более чем 3 уровня)");
  }

  var headers = this.options.metadata.headers;

  if (headers.length === 0 && level != 1) {
    return new ErrorTag('div', "Первый заголовок должен иметь уровень 1, а не " + level);
  }

  if (headers.length > 0) {
    var prevLevel = headers[headers.length - 1].level;
    if (level > prevLevel + 1) {
      return new ErrorTag('div', "Некорректная вложенность заголовков (уровень " + level + " после " + prevLevel + ")");
    }
  }

  // проверить, нет ли уже заголовка с тем же названием
  // при фиксированном anchor к нему нельзя добавить -1 -2 -3
  // так что это ошибка
  if (token.anchor) {
    if (this.options.metadata.refs.has(token.anchor)) {
      return new ErrorTag('div', '[#' + token.anchor + '] уже существует');
    }
  }

  // Проверить якорь, при необходимости добавить anchor-1, anchor-2
  var anchor = token.anchor || makeAnchor(token.title);

  var headersAnchorMap = this.options.metadata.headersAnchorMap;

  if (headersAnchorMap.has(anchor)) {
    // если якорь использовался ранее, обычно к нему прибавляется номер,
    // но если он явно [#назначен] в заголовке - не имею права его менять, жёсткая ошибка
    if (token.anchor) {
      return new ErrorTag('div', '[#' + token.anchor + '] используется в другом заголовке');
    }
    // иначе просто добавляю -2, -3 ...
    headersAnchorMap.set(anchor, headersAnchorMap.has(anchor) + 1);
    anchor = anchor + '-' + headersAnchorMap.get(anchor);
  } else {
    headersAnchorMap.set(anchor, 1);
  }

  // получим HTML заголовка для метаданных
  var titleHtml = titleNode.toHtml({contextTypography: true}).trim();

  // ------- Ошибок точно нет, можно запоминать заголовок и reference ------

  headers.push({ level: level, title: titleHtml, anchor: anchor});

  // ---- сохранить reference ---
  if (token.anchor) {
    this.options.metadata.refs.add(anchor);
  }

  // в заголовок отдаём не уже полученный HTML, а titleNode,
  // чтобы внешний анализатор мог поискать в них ошибки
  return new HeaderTag(level, anchor, titleNode.getChildren());
};


/**
 * The parser is synchronous, we don't query DB here.
 *
 * Links in the form [](task/my-task) or [](mylesson) require title from DB
 * links in the form [](#ref) require reference from DB
 *  [ref] *may* exist later in this document, so we need parse it full before resolving
 * FIXME: move all link processing into second pass (single place)
 */
BodyParser.prototype.parseLink = function(token) {
  var href = token.href || token.title; // [http://ya.ru]() is fine
  var title = token.title; // [](http://ya.ru) is fine, but [](#test) - see below

  var protocol = href.replace(/[\x00-\x20]/g, '').match(HREF_PROTOCOL_REG);
  if (protocol) {
    protocol = protocol[1].trim();
  }

  var titleParsed = new BodyParser(title, this.options).parse();

  // external link goes "as is"
  if (protocol) {
    if (!this.trusted && !~["http", "ftp", "https", "mailto"].indexOf(protocol.toLowerCase())) {
      return new ErrorTag("span", "Protocol " + protocol + " is not allowed");
    }

    return new CompositeTag("a", titleParsed, {href: href});
  }

  if (href[0] == '/') {
    // absolute link with title goes "as is", without title - we'll try to resolve the title on 2nd pass
    if (!title) {
      return new ReferenceNode(href, titleParsed);
    }
    return new CompositeTag("a", titleParsed, {href: href});
  }

  if (href[0] == '#') { // Reference, need second pass to resolve it
    return new ReferenceNode(href, titleParsed);
  }

  // relative link
  return new ErrorTag("span", "относительные ссылки могут быть легко ломаться, используйте #метки или абсолютные URL вместо " + href);
};

/*
 BodyParser.prototype.parseLink = function(token) {
 var href = token.href || token.title; // [http://ya.ru]() is fine
 var title = token.title || token.href; // [](http://ya.ru) is fine too

 var protocol = href.replace(/[\x00-\x20]/g, '').match(HREF_PROTOCOL_REG);
 if (protocol) {
 protocol = protocol[1].trim();
 }

 var titleParsed = new BodyParser(title, this.options).parse();

 // external link goes "as is"
 if (protocol) {
 if (!this.trusted && !~["http", "ftp", "https", "mailto"].indexOf(protocol.toLowerCase())) {
 return new ErrorTag("span", "Протокол " + protocol + " не разрешён");
 }

 return new CompositeTag("a", titleParsed, {href: href});
 }

 if (href[0] == '/' || href[0] == '#') {
 return new CompositeTag("a", titleParsed, {href: href});
 }

 // relative link
 if (this.options.resourceWebRoot) {
 var resolver = new SrcResolver(href, this.options);
 return new CompositeTag("a", titleParsed, {href: resolver.getWebPath()});
 } else {
 return new ErrorTag("span", "относительная ссылка в материале без точного URL: " + href);
 }
 };
 */
BodyParser.prototype.parseBbtag = function(token) {
  return new BbtagParser(token, this.options).parse();
};

BodyParser.prototype.parseBold = function(token) {
  return new BodyParser(token.body, this.options).parseAndWrap("strong");
};

BodyParser.prototype.parseItalic = function(token) {
  var parser = new BodyParser(token.body, this.options);
  return parser.parseAndWrap("em");
};

BodyParser.prototype.parseStrike = function(token) {
  var parser = new BodyParser(token.body, this.options);
  return parser.parseAndWrap("strike");
};

BodyParser.prototype.parseCode = function(token) {
  return new EscapedTag("code", token.body);
};

BodyParser.prototype.parseComment = function(token) {
  return new CommentNode(token.body);
};

BodyParser.prototype.parseVerbatim = function(token) {
  return new VerbatimText(token.body);
};
 at SyntaxError: Unexpected token (8:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/index.js. Coverage (Term): 91% Coverage (LOC): 100%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/consts.js. Coverage (Term): 99% Coverage (LOC): 100%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/node/commentNode.js. Coverage (Term): 60% Coverage (LOC): 79%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/node/textNode.js. Coverage (Term): 49% Coverage (LOC): 65%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/node/node.js. Coverage (Term): 31% Coverage (LOC): 56%
*- File /root/Targets/javascript-parser/node_modules/inherits/inherits.js. Coverage (Term): 74% Coverage (LOC): 88%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/node/compositeTag.js. Coverage (Term): 21% Coverage (LOC): 35%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/node/tagNode.js. Coverage (Term): 35% Coverage (LOC): 45%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/util/sanitize.js. Coverage (Term): 58% Coverage (LOC): 33%
*- File /root/Targets/javascript-parser/node_modules/sanitize-html/index.js. Coverage (Term): 8% Coverage (LOC): 21%
*- File /root/Targets/javascript-parser/node_modules/htmlparser2/lib/index.js. Coverage (Term): 24% Coverage (LOC): 52%
*- File /root/Targets/javascript-parser/node_modules/htmlparser2/lib/Parser.js. Coverage (Term): 22% Coverage (LOC): 46%
*- File /root/Targets/javascript-parser/node_modules/htmlparser2/lib/Tokenizer.js. Coverage (Term): 24% Coverage (LOC): 21%
*- File /root/Targets/javascript-parser/node_modules/entities/lib/decode_codepoint.js. Coverage (Term): 24% Coverage (LOC): 26%
*- File /root/Targets/javascript-parser/node_modules/domhandler/index.js. Coverage (Term): 16% Coverage (LOC): 25%
*- File /root/Targets/javascript-parser/node_modules/domelementtype/index.js. Coverage (Term): 54% Coverage (LOC): 93%
*- File /root/Targets/javascript-parser/node_modules/domhandler/lib/node.js. Coverage (Term): 45% Coverage (LOC): 68%
*- File /root/Targets/javascript-parser/node_modules/domhandler/lib/element.js. Coverage (Term): 70% Coverage (LOC): 80%
*- File /root/Targets/javascript-parser/node_modules/xtend/immutable.js. Coverage (Term): 32% Coverage (LOC): 33%
*- File /root/Targets/javascript-parser/node_modules/regexp-quote/regexp-quote.js. Coverage (Term): 57% Coverage (LOC): 80%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/util/wrapTagAround.js. Coverage (Term): 25% Coverage (LOC): 31%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/util/escapeHtmlAttr.js. Coverage (Term): 47% Coverage (LOC): 80%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/typography/charTypography.js. Coverage (Term): 31% Coverage (LOC): 43%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/typography/contextTypography.js. Coverage (Term): 12% Coverage (LOC): 17%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/node/cutNode.js. Coverage (Term): 64% Coverage (LOC): 79%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/node/errorTag.js. Coverage (Term): 64% Coverage (LOC): 82%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/node/escapedTag.js. Coverage (Term): 58% Coverage (LOC): 72%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/util/escapeHtmlText.js. Coverage (Term): 43% Coverage (LOC): 80%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/node/headerTag.js. Coverage (Term): 33% Coverage (LOC): 42%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/node/referenceNode.js. Coverage (Term): 52% Coverage (LOC): 61%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/node/imgTag.js. Coverage (Term): 46% Coverage (LOC): 58%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/node/sourceTag.js. Coverage (Term): 24% Coverage (LOC): 28%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/util/source/stripIndents.js. Coverage (Term): 22% Coverage (LOC): 40%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/util/source/extractHighlight.js. Coverage (Term): 5% Coverage (LOC): 8%
*- File /root/Targets/javascript-parser/node_modules/javascript-parser/node/verbatimText.js. Coverage (Term): 53% Coverage (LOC): 60%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
