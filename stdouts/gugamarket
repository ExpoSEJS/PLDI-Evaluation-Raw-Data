
> kerberos@0.0.3 install /root/Targets/gugamarket/node_modules/kerberos
> (node-gyp rebuild 2> builderror.log) || (exit 0)

make: Entering directory '/root/Targets/gugamarket/node_modules/kerberos/build'
  SOLINK_MODULE(target) Release/obj.target/kerberos.node
  COPY Release/kerberos.node
make: Leaving directory '/root/Targets/gugamarket/node_modules/kerberos/build'

> bson@0.0.4 install /root/Targets/gugamarket/node_modules/mongoose-nested-set/node_modules/bson
> node install.js

================================================================================
=                                                                              =
=  To install with C++ bson parser do <npm install mongodb --mongodb:native>   =
=                                                                              =
================================================================================

> bson@0.2.9 install /root/Targets/gugamarket/node_modules/bson
> (node-gyp rebuild 2> builderror.log) || (exit 0)

make: Entering directory '/root/Targets/gugamarket/node_modules/bson/build'
  CXX(target) Release/obj.target/bson/ext/bson.o
bson.target.mk:92: recipe for target 'Release/obj.target/bson/ext/bson.o' failed
make: Leaving directory '/root/Targets/gugamarket/node_modules/bson/build'
/root/Targets/gugamarket
└─┬ gugamarket@1.0.7 
  ├── async@0.9.0 
  ├─┬ body-parser@1.5.2 
  │ ├── bytes@1.0.0 
  │ ├── depd@0.4.4 
  │ ├── iconv-lite@0.4.4 
  │ ├── media-typer@0.2.0 
  │ ├── qs@0.6.6 
  │ ├── raw-body@1.3.0 
  │ └── type-is@1.3.2 
  ├─┬ connect@3.1.0 
  │ ├─┬ debug@1.0.4 
  │ │ └── ms@0.6.2 
  │ ├── finalhandler@0.1.0 
  │ ├── parseurl@1.2.0 
  │ └── utils-merge@1.0.0 
  ├─┬ cookie-parser@1.3.2 
  │ ├── cookie@0.1.2 
  │ └── cookie-signature@1.0.4 
  ├── cors@2.4.1 
  ├── date-utils@1.2.16 
  ├─┬ emailjs@0.3.11 
  │ ├── bufferjs@1.1.0 
  │ ├─┬ mimelib@0.2.14 
  │ │ ├── addressparser@0.2.1 
  │ │ └─┬ encoding@0.1.12 
  │ │   └── iconv-lite@0.4.19 
  │ └── moment@1.7.0 
  ├─┬ express@4.7.2 
  │ ├─┬ accepts@1.0.7 
  │ │ └── negotiator@0.4.7 
  │ ├── buffer-crc32@0.2.3 
  │ ├── escape-html@1.0.1 
  │ ├── fresh@0.2.2 
  │ ├── merge-descriptors@0.0.2 
  │ ├── methods@1.1.0 
  │ ├── path-to-regexp@0.1.3 
  │ ├─┬ proxy-addr@1.0.1 
  │ │ └── ipaddr.js@0.1.2 
  │ ├── range-parser@1.0.0 
  │ ├─┬ send@0.7.2 
  │ │ └── mime@1.2.11 
  │ ├─┬ serve-static@1.4.4 
  │ │ └── send@0.7.4 
  │ └── vary@0.1.0 
  ├─┬ express-error-handler@0.5.4 
  │ ├── connect-domain@0.5.0 
  │ └── mout@0.7.1 
  ├─┬ express-session@1.7.2 
  │ ├── on-headers@0.0.0 
  │ └─┬ uid-safe@1.0.1 
  │   ├── base64-url@1.3.3 
  │   └─┬ mz@1.3.0 
  │     ├── native-or-bluebird@1.2.0 
  │     ├─┬ thenify@3.3.0 
  │     │ └── any-promise@1.3.0 
  │     └── thenify-all@1.6.0 
  ├─┬ jade@1.5.0 
  │ ├── character-parser@1.2.0 
  │ ├── commander@2.1.0 
  │ ├─┬ constantinople@2.0.1 
  │ │ └─┬ uglify-js@2.4.24 
  │ │   ├── async@0.2.10 
  │ │   ├─┬ source-map@0.1.34 
  │ │   │ └── amdefine@1.0.1 
  │ │   ├── uglify-to-browserify@1.0.2 
  │ │   └─┬ yargs@3.5.4 
  │ │     ├── camelcase@1.2.1 
  │ │     ├── decamelize@1.2.0 
  │ │     ├── window-size@0.1.0 
  │ │     └── wordwrap@0.0.2 
  │ ├─┬ mkdirp@0.5.1 
  │ │ └── minimist@0.0.8 
  │ ├─┬ monocle@1.1.51 
  │ │ └─┬ readdirp@0.2.5 
  │ │   └─┬ minimatch@3.0.4 
  │ │     └─┬ brace-expansion@1.1.8 
  │ │       ├── balanced-match@1.0.0 
  │ │       └── concat-map@0.0.1 
  │ ├─┬ transformers@2.1.0 
  │ │ ├─┬ css@1.0.8 
  │ │ │ ├── css-parse@1.0.4 
  │ │ │ └── css-stringify@1.0.5 
  │ │ ├─┬ promise@2.0.0 
  │ │ │ └── is-promise@1.0.1 
  │ │ └─┬ uglify-js@2.2.5 
  │ │   └── optimist@0.3.7 
  │ └── with@3.0.1 
  ├── method-override@2.1.2 
  ├─┬ mocha@1.21.3 
  │ ├── commander@2.0.0 
  │ ├── diff@1.0.7 
  │ ├─┬ glob@3.2.3 
  │ │ ├── graceful-fs@2.0.3 
  │ │ ├── inherits@2.0.3 
  │ │ └─┬ minimatch@0.2.14 
  │ │   ├── lru-cache@2.7.3 
  │ │   └── sigmund@1.0.1 
  │ ├── growl@1.8.1 
  │ ├─┬ jade@0.26.3 
  │ │ ├── commander@0.6.1 
  │ │ └── mkdirp@0.3.0 
  │ └── mkdirp@0.3.5 
  ├─┬ mongodb@1.4.7 
  │ ├─┬ bson@0.2.9 
  │ │ └── nan@1.0.0 
  │ ├── kerberos@0.0.3 
  │ └─┬ readable-stream@2.3.3 
  │   ├── core-util-is@1.0.2 
  │   ├── isarray@1.0.0 
  │   ├── process-nextick-args@1.0.7 
  │   ├── safe-buffer@5.1.1 
  │   ├── string_decoder@1.0.3 
  │   └── util-deprecate@1.0.2 
  ├─┬ mongoose@3.8.14 
  │ ├── hooks@0.2.1 
  │ ├── mpath@0.1.1 
  │ ├── mpromise@0.4.3 
  │ ├─┬ mquery@0.8.0 
  │ │ └── debug@0.7.4 
  │ ├── ms@0.1.0 
  │ ├── muri@0.3.1 
  │ ├── regexp-clone@0.0.1 
  │ └── sliced@0.0.5 
  ├─┬ mongoose-nested-set@0.0.5 
  │ ├── async@0.1.22 
  │ └─┬ mongoose@2.5.14 
  │   ├── hooks@0.2.0 
  │   └─┬ mongodb@0.9.9-7 
  │     └── bson@0.0.4 
  ├─┬ morgan@1.2.2 
  │ ├── basic-auth@1.0.0 
  │ └─┬ finished@1.2.2 
  │   └── ee-first@1.0.3 
  ├── oauth@0.9.12 
  ├─┬ passport@0.2.0 
  │ ├── passport-strategy@1.0.0 
  │ └── pause@0.0.1 
  ├─┬ passport-facebook@1.0.3 
  │ └─┬ passport-oauth2@1.4.0 
  │   └── uid2@0.0.3 
  ├─┬ passport-google-oauth@0.1.5 
  │ ├─┬ passport-oauth@0.1.15 
  │ │ └── passport@0.1.18 
  │ └── pkginfo@0.2.3 
  ├── passport-local@1.0.0 
  ├─┬ passport-twitter@1.0.2 
  │ ├── passport-oauth1@1.1.0 
  │ └─┬ xtraverse@0.1.0 
  │   └── xmldom@0.1.27 
  ├─┬ passwordless@0.1.4 
  │ └── node-uuid@1.4.8 
  ├── passwordless-mongostore-openshift@0.0.3 
  ├── passwordless-tokenstore@0.0.8 
  ├─┬ request@2.39.0 
  │ ├── aws-sign2@0.5.0 
  │ ├── forever-agent@0.5.2 
  │ ├─┬ form-data@0.1.4 
  │ │ └─┬ combined-stream@0.0.7 
  │ │   └── delayed-stream@0.0.5 
  │ ├─┬ hawk@1.1.1 
  │ │ ├── boom@0.4.2 
  │ │ ├── cryptiles@0.2.2 
  │ │ ├── hoek@0.9.1 
  │ │ └── sntp@0.2.4 
  │ ├─┬ http-signature@0.10.1 
  │ │ ├── asn1@0.1.11 
  │ │ ├── assert-plus@0.1.5 
  │ │ └── ctype@0.5.3 
  │ ├── json-stringify-safe@5.0.1 
  │ ├── mime-types@1.0.2 
  │ ├── oauth-sign@0.3.0 
  │ ├── stringstream@0.0.5 
  │ ├─┬ tough-cookie@2.3.2 
  │ │ └── punycode@1.4.1 
  │ └── tunnel-agent@0.4.3 
  ├── serve-favicon@2.0.1 
  ├─┬ supertest@0.13.0 
  │ ├── methods@1.0.0 
  │ └─┬ superagent@0.18.0 
  │   ├── component-emitter@1.1.2 
  │   ├── cookiejar@1.3.2 
  │   ├── debug@0.7.4 
  │   ├── extend@1.2.1 
  │   ├─┬ form-data@0.1.2 
  │   │ ├── async@0.2.10 
  │   │ └── mime@1.2.11 
  │   ├── formidable@1.0.14 
  │   ├── methods@0.0.1 
  │   ├── mime@1.2.5 
  │   ├─┬ readable-stream@1.0.27-1 
  │   │ ├── isarray@0.0.1 
  │   │ └── string_decoder@0.10.31 
  │   └── reduce-component@1.0.1 
  ├── supervisor@0.6.0 
  ├─┬ swagger-node-express@2.1.0 
  │ └── lodash@1.3.1 
  └─┬ url@0.10.1 
    └── punycode@1.2.4 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/gugamarket/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 30% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","cwd","max","captureStackTrace","getFileName","getLineNumber","getColumnNumber","isEval","getFunctionName","create","Int32Array","call","RegExp","toUpperCase","getOwnPropertyDescriptor","randomBytes","toString"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0857 took 41.9667s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Octal literal in strict mode (430:57) on program /*
 * SMTP class written using python's (2.7) smtplib.py as a base
 */
var net = require('net');
var crypto = require('crypto');
var os = require('os');
var tls = require('tls');
var util = require('util');
var events = require('events');
var starttls = require('./tls');

var SMTPResponse = require('./response');
var SMTPError = require('./error');

var SMTP_PORT = 25;
var SMTP_SSL_PORT = 465;
var SMTP_TLS_PORT = 587;
var CRLF = "\r\n";
var AUTH_METHODS = {
  PLAIN: 'PLAIN',
  CRAM_MD5: 'CRAM-MD5',
  LOGIN: 'LOGIN',
  XOAUTH2: 'XOAUTH2'
};
var TIMEOUT = 5000;
var DEBUG = 0;

var log = function() {
  if (DEBUG) {
    Array.prototype.slice.call(arguments).forEach(function(d) {
      console.log(d);
    });
  }
};

var quotedata = function(data) {
  // Quote data for email.
  // Double leading '.', and change Unix newline '\\n', or Mac '\\r' into
  // Internet CRLF end-of-line.

  return data.replace(/(?:\r\n|\n|\r(?!\n))/g, CRLF).replace(/^\./gm, '..');
};

var caller = function(callback) {
  if (typeof(callback) == 'function') {
    var args = Array.prototype.slice.call(arguments);
    args.shift();

    callback.apply(null, args);
  }
};

var SMTPState = {
  NOTCONNECTED: 0,
  CONNECTING: 1,
  CONNECTED: 2
};

var SMTP = function(options) {
  events.EventEmitter.call(this);

  options = options || {};

  this.sock = null;
  this.timeout = options.timeout || TIMEOUT;
  this.features = null;
  this._state = SMTPState.NOTCONNECTED;
  this._secure = false;
  this.loggedin = (options.user && options.password) ? false : true;
  this.domain = options.domain || os.hostname();
  this.host = options.host || 'localhost';
  this.port = options.port || (options.ssl ? SMTP_SSL_PORT : options.tls ? SMTP_TLS_PORT : SMTP_PORT);
  this.ssl = options.ssl || false;
  this.tls = options.tls || false;
  this.monitor = null;

  // keep these strings hidden when quicky debugging/logging
  this.user = function() {
    return options.user;
  };
  this.password = function() {
    return options.password;
  };
};

SMTP.prototype = {
  debug: function(level) {
    DEBUG = level;
  },

  state: function() {
    return this._state;
  },

  authorized: function() {
    return this.loggedin;
  },

  connect: function(callback, port, host, options) {
    options = options || {};

    var self = this;

    self.host = host || self.host;
    self.port = port || self.port;
    self.ssl = options.ssl || self.ssl;

    if (self._state != SMTPState.NOTCONNECTED) {
      self.quit(function() {
        self.connect(callback, port, host, options);
      });
      return;
    }

    var connected = function(err) {
      if (!err) {
        log("connected: " + self.host + ":" + self.port);

        if (self.ssl && !self.tls) {
          // if key/ca/cert was passed in, check if connection is authorized
          if (typeof(self.ssl) != 'boolean' && !self.sock.authorized) {
            self.close(true);
            caller(callback, SMTPError('could not establish an ssl connection', SMTPError.CONNECTIONAUTH, err));
          } else self._secure = true;
        }
      } else {
        self.close(true);
        caller(callback, SMTPError("could not connect", SMTPError.COULDNOTCONNECT, err));
      }
    };

    var response = function(err, msg) {
      if (err) {
        self.close(true);
        caller(callback, err);
      } else if (msg.code == '220') {
        log(msg.data);

        // might happen first, so no need to wait on connected()
        self._state = SMTPState.CONNECTED;
        caller(callback, null, msg.data);
      } else {
        log("response (data): " + msg.data);
        self.quit(function() {
          caller(callback, SMTPError("bad response on connection", SMTPError.BADRESPONSE, err, msg.data));
        });
      }
    };

    self._state = SMTPState.CONNECTING;
    log("connecting: " + self.host + ":" + self.port);

    if (self.ssl) {
      self.sock = tls.connect(self.port, self.host, self.ssl, connected);
    } else {
      self.sock = new net.Socket();
      self.sock.connect(self.port, self.host, connected);
    }

    self.monitor = SMTPResponse.monitor(self.sock, self.timeout, function() {
      self.close(true);
    });
    self.sock.once('response', response);
    self.sock.once('error', response); // the socket could reset or throw, so let's handle it and let the user know
  },

  send: function(str, callback) {
    var self = this;

    if (self.sock && self._state == SMTPState.CONNECTED) {
      log(str);

      var response = function(err, msg) {
        if (err) {
          caller(callback, err);
        } else {
          log(msg.data);
          caller(callback, null, msg);
        }
      };

      self.sock.once('response', response);
      self.sock.write(str);
    } else {
      self.close(true);
      caller(callback, SMTPError('no connection has been established', SMTPError.NOCONNECTION));
    }
  },

  command: function(cmd, callback, codes, failed) {
    codes = Array.isArray(codes) ? codes : typeof(codes) == 'number' ? [codes] : [250];

    var response = function(err, msg) {
      if (err) {
        caller(callback, err);
      } else {
        if (codes.indexOf(Number(msg.code)) != -1) caller(callback, err, msg.data, msg.message);

        else caller(callback, SMTPError("bad response on command '" + cmd.split(' ')[0] + "'", SMTPError.BADRESPONSE, null, msg.data));
      }
    };

    this.send(cmd + CRLF, response);
  },

  helo: function(callback, domain) {
    /*
     * SMTP 'helo' command.
     * Hostname to send for self command defaults to the FQDN of the local
     * host.
     */

    var self = this,

      response = function(err, data) {
        if (err) {
          caller(callback, err);
        } else {
          self.parse_smtp_features(data);
          caller(callback, err, data);
        }
      };

    this.command("helo " + (domain || this.domain), response);
  },

  starttls: function(callback) {
    var self = this,

      response = function(err, msg) {
        if (err) {
          err.message += " while establishing a starttls session";
          caller(callback, err);
        } else {
          var secured_socket = null;
          var secured = function() {
            self._secure = true;
            self.sock = secured_socket;

            var error = function(err) {
              self.close(true);
              caller(callback, err);
            };

            SMTPResponse.monitor(self.sock, self.timeout, function() {
              self.close(true);
            });
            caller(callback, msg.data);
          };

          secured_socket = starttls.secure(self.sock, self.tls, secured);
        }
      };

    this.command("starttls", response, [220]);
  },

  parse_smtp_features: function(data) {
    var self = this;

    //  According to RFC1869 some (badly written)
    //  MTA's will disconnect on an ehlo. Toss an exception if
    //  that happens -ddm

    data.split("\n").forEach(function(ext) {
      var parse = ext.match(/^(?:\d+[\-=]?)\s*?([^\s]+)(?:\s+(.*)\s*?)?$/);

      // To be able to communicate with as many SMTP servers as possible,
      // we have to take the old-style auth advertisement into account,
      // because:
      // 1) Else our SMTP feature parser gets confused.
      // 2) There are some servers that only advertise the auth methods we
      // support using the old style.

      if (parse) {
        // RFC 1869 requires a space between ehlo keyword and parameters.
        // It's actually stricter, in that only spaces are allowed between
        // parameters, but were not going to check for that here.  Note
        // that the space isn't present if there are no parameters.
        self.features[parse[1].toLowerCase()] = parse[2] || true;
      }
    });

    return;
  },

  ehlo: function(callback, domain) {
    var self = this,

      response = function(err, data) {
        if (err) {
          caller(callback, err);
        } else {
          self.parse_smtp_features(data);

          if (self.tls && !self._secure) {
            self.starttls(function() {
              self.ehlo(callback, domain);
            });
          } else {
            caller(callback, err, data);
          }
        }
      };

    this.features = {};
    this.command("ehlo " + (domain || this.domain), response);
  },

  has_extn: function(opt) {
    return this.features[opt.toLowerCase()] === undefined;
  },

  help: function(callback, args) {
    // SMTP 'help' command, returns text from the server
    this.command(args ? "help " + args : "help", callback, [211, 214]);
  },

  rset: function(callback) {
    this.command("rset", callback);
  },

  noop: function(callback) {
    this.send("noop", callback);
  },

  mail: function(callback, from) {
    this.command("mail FROM:" + from, callback);
  },

  rcpt: function(callback, to) {
    this.command("RCPT TO:" + to, callback, [250, 251]);
  },

  data: function(callback) {
    this.command("data", callback, [354]);
  },

  data_end: function(callback) {
    this.command(CRLF + ".", callback);
  },

  message: function(data) {
    log(data);
    this.sock.write(data);
  },

  verify: function(address, callback) {
    // SMTP 'verify' command -- checks for address validity."""
    this.command("vrfy " + address, callback, [250, 251, 252]);
  },

  expn: function(address, callback) {
    // SMTP 'expn' command -- expands a mailing list.
    this.command("expn " + address, callback);
  },

  ehlo_or_helo_if_needed: function(callback, domain) {
    // Call self.ehlo() and/or self.helo() if needed.                                 
    // If there has been no previous EHLO or HELO command self session, self
    //  method tries ESMTP EHLO first.
    var self = this;

    if (!this.features) {
      var response = function(err, data) {
        caller(callback, err, data);
      };

      var attempt = function(err, data) {
        if (err) self.helo(response, domain);
        else caller(callback, err, data);
      };

      self.ehlo(attempt, domain);
    }
  },

  login: function(callback, user, password, options) {
    var self = this,

      login = {
        user: user ? function() {
          return user;
        } : self.user,
        password: password ? function() {
          return password;
        } : self.password,
        method: options && options.method ? options.method.toUpperCase() : ''
      },

      domain = options && options.domain ? options.domain : this.domain,

      initiate = function(err, data) {
        if (err) {
          caller(callback, err);
          return;
        }

        /* 
         * Log in on an SMTP server that requires authentication.
         *
         * The arguments are:
         *     - user:     The user name to authenticate with.
         *     - password: The password for the authentication.
         *
         * If there has been no previous EHLO or HELO command self session, self
         * method tries ESMTP EHLO first.
         *
         * This method will return normally if the authentication was successful.
         */

        var method = null,

          encode_cram_md5 = function(challenge) {
            challenge = (new Buffer(challenge, "base64")).toString("ascii");

            var hmac = crypto.createHmac('md5', login.password());
            hmac.update(challenge);

            return (new Buffer(login.user() + " " + hmac.digest('hex')).toString("base64"));
          },

          encode_plain = function() {
            return (new Buffer("\0" + login.user() + "\0" + login.password())).toString("base64");
          },

          encode_xoauth2 = function() {
            // console.log("user=" + login.user() + "\1auth=Bearer " + login.password()+"\1\1"); 
            // see: https://developers.google.com/gmail/xoauth2_protocol
            return (new Buffer("user=" + login.user() + "\1auth=Bearer " + login.password() + "\1\1")).toString("base64");
          };

        // List of authentication methods we support: from preferred to
        // less preferred methods.
        if (!method) {
          var preferred = [AUTH_METHODS.CRAM_MD5, AUTH_METHODS.LOGIN, AUTH_METHODS.PLAIN, AUTH_METHODS.XOAUTH2];

          for (var i = 0; i < preferred.length; i++) {
            if ((self.features.auth || "").indexOf(preferred[i]) != -1) {
              method = preferred[i];
              break;
            }
          }
        }

        // handle bad responses from command differently
        var failed = function(err, data) {
          self.loggedin = false;
          self.close(); // if auth is bad, close the connection, it won't get better by itself
          caller(callback, SMTPError('authorization.failed', SMTPError.AUTHFAILED, err, data));
        };

        var response = function(err, data) {
          if (err) {
            failed(err, data);
          } else {
            self.loggedin = true;
            caller(callback, err, data);
          }
        };

        var attempt = function(err, data, msg) {
          if (err) {
            failed(err, data);
          } else {
            if (method == AUTH_METHODS.CRAM_MD5) {
              self.command(encode_cram_md5(msg), response, [235, 503]);
            } else if (method == AUTH_METHODS.LOGIN) {
              self.command((new Buffer(login.password())).toString("base64"), response, [235, 503]);
            }
          }
        };

        var attempt_user = function(err, data, msg) {
          if (err) {
            failed(err, data);
          } else {
            if (method == AUTH_METHODS.LOGIN) {
              self.command((new Buffer(login.user())).toString("base64"), attempt, [334]);
            }
          }
        };

        if (method == AUTH_METHODS.CRAM_MD5) self.command("AUTH " + AUTH_METHODS.CRAM_MD5, attempt, [334]);

        else if (method == AUTH_METHODS.LOGIN) self.command("AUTH " + AUTH_METHODS.LOGIN, attempt_user, [334]);

        else if (method == AUTH_METHODS.PLAIN) self.command("AUTH " + AUTH_METHODS.PLAIN + " " + encode_plain(login.user(), login.password()), response, [235, 503]);

        else if (method == AUTH_METHODS.XOAUTH2) self.command("AUTH " + AUTH_METHODS.XOAUTH2 + " " + encode_xoauth2(login.user(), login.password()), response, [235, 503]);

        else if (!method) caller(callback, SMTPError('no form of authorization supported', SMTPError.AUTHNOTSUPPORTED, null, data));
      };

    self.ehlo_or_helo_if_needed(initiate, domain);
  },

  close: function(force) {
    if (this.sock) {
      if (force) {
        log("smtp connection destroyed!");
        this.sock.destroy();
      } else {
        log("smtp connection closed.");
        this.sock.end();
      }
    }

    if (this.monitor) {
      this.monitor.stop();
      this.monitor = null;
    }

    this._state = SMTPState.NOTCONNECTED;
    this._secure = false;
    this.sock = null;
    this.features = null;
    this.loggedin = !(this.user() && this.password());
  },

  quit: function(callback) {
    var self = this,
      response = function(err, data) {
        caller(callback, err, data);
        self.close();
      };

    this.command("quit", response, [221, 250]);
  }
};

for (var each in events.EventEmitter.prototype) {
  SMTP.prototype[each] = events.EventEmitter.prototype[each];
}

exports.SMTP = SMTP;
exports.state = SMTPState;
 at SyntaxError: Octal literal in strict mode (430:57)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$7.readEscapedChar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:3023:16)
    at Parser.pp$7.readString (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2935:23)
    at Parser.pp$7.getTokenFromCode (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2724:19)
    at Parser.pp$7.readToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2477:17)
    at Parser.readToken (/root/ExpoSE/lib/Tropigate/bin/Tokens.js:124:26)
    at Parser.pp$7.nextToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2468:15)
    at Parser.pp$7.next (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2413:10)
    at Parser.pp$3.parseExprOp (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1654:14)
    at Parser.pp$3.parseExprOp (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1658:21)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/gugamarket/node_modules/gugamarket/app.js. Coverage (Term): 21% Coverage (LOC): 15%
*- File /root/Targets/gugamarket/node_modules/express/index.js. Coverage (Term): 95% Coverage (LOC): 100%
*- File /root/Targets/gugamarket/node_modules/express/lib/express.js. Coverage (Term): 66% Coverage (LOC): 74%
*- File /root/Targets/gugamarket/node_modules/utils-merge/index.js. Coverage (Term): 40% Coverage (LOC): 40%
*- File /root/Targets/gugamarket/node_modules/express/lib/application.js. Coverage (Term): 18% Coverage (LOC): 27%
*- File /root/Targets/gugamarket/node_modules/finalhandler/index.js. Coverage (Term): 15% Coverage (LOC): 17%
*- File /root/Targets/gugamarket/node_modules/debug/node.js. Coverage (Term): 37% Coverage (LOC): 62%
*- File /root/Targets/gugamarket/node_modules/debug/debug.js. Coverage (Term): 35% Coverage (LOC): 42%
*- File /root/Targets/gugamarket/node_modules/ms/index.js. Coverage (Term): 15% Coverage (LOC): 22%
*- File /root/Targets/gugamarket/node_modules/escape-html/index.js. Coverage (Term): 35% Coverage (LOC): 80%
*- File /root/Targets/gugamarket/node_modules/express/lib/router/index.js. Coverage (Term): 8% Coverage (LOC): 11%
*- File /root/Targets/gugamarket/node_modules/express/lib/router/route.js. Coverage (Term): 17% Coverage (LOC): 22%
*- File /root/Targets/gugamarket/node_modules/express/lib/router/layer.js. Coverage (Term): 14% Coverage (LOC): 18%
*- File /root/Targets/gugamarket/node_modules/path-to-regexp/index.js. Coverage (Term): 8% Coverage (LOC): 16%
*- File /root/Targets/gugamarket/node_modules/methods/index.js. Coverage (Term): 56% Coverage (LOC): 22%
*- File /root/Targets/gugamarket/node_modules/express/lib/utils.js. Coverage (Term): 16% Coverage (LOC): 25%
*- File /root/Targets/gugamarket/node_modules/send/index.js. Coverage (Term): 95% Coverage (LOC): 100%
*- File /root/Targets/gugamarket/node_modules/send/lib/send.js. Coverage (Term): 15% Coverage (LOC): 19%
*- File /root/Targets/gugamarket/node_modules/depd/index.js. Coverage (Term): 43% Coverage (LOC): 49%
*- File /root/Targets/gugamarket/node_modules/range-parser/index.js. Coverage (Term): 10% Coverage (LOC): 15%
*- File /root/Targets/gugamarket/node_modules/mime/mime.js. Coverage (Term): 77% Coverage (LOC): 92%
*- File /root/Targets/gugamarket/node_modules/fresh/index.js. Coverage (Term): 14% Coverage (LOC): 16%
*- File /root/Targets/gugamarket/node_modules/finished/index.js. Coverage (Term): 20% Coverage (LOC): 19%
*- File /root/Targets/gugamarket/node_modules/ee-first/index.js. Coverage (Term): 8% Coverage (LOC): 13%
*- File /root/Targets/gugamarket/node_modules/send/lib/utils.js. Coverage (Term): 30% Coverage (LOC): 54%
*- File eval. Coverage (Term): 43% Coverage (LOC): 60%
*- File /root/Targets/gugamarket/node_modules/buffer-crc32/index.js. Coverage (Term): 70% Coverage (LOC): 94%
*- File /root/Targets/gugamarket/node_modules/proxy-addr/index.js. Coverage (Term): 9% Coverage (LOC): 19%
*- File /root/Targets/gugamarket/node_modules/ipaddr.js/lib/ipaddr.js. Coverage (Term): 34% Coverage (LOC): 61%
*- File /root/Targets/gugamarket/node_modules/qs/index.js. Coverage (Term): 9% Coverage (LOC): 16%
*- File /root/Targets/gugamarket/node_modules/media-typer/index.js. Coverage (Term): 12% Coverage (LOC): 17%
*- File /root/Targets/gugamarket/node_modules/parseurl/index.js. Coverage (Term): 22% Coverage (LOC): 31%
*- File /root/Targets/gugamarket/node_modules/express/lib/middleware/init.js. Coverage (Term): 21% Coverage (LOC): 29%
*- File /root/Targets/gugamarket/node_modules/express/lib/middleware/query.js. Coverage (Term): 34% Coverage (LOC): 35%
*- File /root/Targets/gugamarket/node_modules/express/lib/view.js. Coverage (Term): 30% Coverage (LOC): 43%
*- File /root/Targets/gugamarket/node_modules/express/lib/request.js. Coverage (Term): 29% Coverage (LOC): 46%
*- File /root/Targets/gugamarket/node_modules/accepts/index.js. Coverage (Term): 21% Coverage (LOC): 28%
*- File /root/Targets/gugamarket/node_modules/negotiator/lib/negotiator.js. Coverage (Term): 68% Coverage (LOC): 75%
*- File /root/Targets/gugamarket/node_modules/negotiator/lib/charset.js. Coverage (Term): 7% Coverage (LOC): 12%
*- File /root/Targets/gugamarket/node_modules/negotiator/lib/encoding.js. Coverage (Term): 6% Coverage (LOC): 9%
*- File /root/Targets/gugamarket/node_modules/negotiator/lib/language.js. Coverage (Term): 6% Coverage (LOC): 10%
*- File /root/Targets/gugamarket/node_modules/negotiator/lib/mediaType.js. Coverage (Term): 6% Coverage (LOC): 9%
*- File /root/Targets/gugamarket/node_modules/mime-types/lib/index.js. Coverage (Term): 43% Coverage (LOC): 48%
*- File /root/Targets/gugamarket/node_modules/type-is/index.js. Coverage (Term): 11% Coverage (LOC): 17%
*- File /root/Targets/gugamarket/node_modules/express/lib/response.js. Coverage (Term): 11% Coverage (LOC): 16%
*- File /root/Targets/gugamarket/node_modules/cookie-signature/index.js. Coverage (Term): 19% Coverage (LOC): 40%
*- File /root/Targets/gugamarket/node_modules/cookie/index.js. Coverage (Term): 14% Coverage (LOC): 16%
*- File /root/Targets/gugamarket/node_modules/vary/index.js. Coverage (Term): 10% Coverage (LOC): 14%
*- File /root/Targets/gugamarket/node_modules/serve-static/index.js. Coverage (Term): 17% Coverage (LOC): 21%
*- File /root/Targets/gugamarket/node_modules/serve-static/node_modules/send/index.js. Coverage (Term): 95% Coverage (LOC): 100%
*- File /root/Targets/gugamarket/node_modules/serve-static/node_modules/send/lib/send.js. Coverage (Term): 15% Coverage (LOC): 19%
*- File /root/Targets/gugamarket/node_modules/serve-static/node_modules/send/lib/utils.js. Coverage (Term): 30% Coverage (LOC): 54%
*- File /root/Targets/gugamarket/node_modules/gugamarket/routes/index.js. Coverage (Term): 9% Coverage (LOC): 14%
*- File /root/Targets/gugamarket/node_modules/express-error-handler/error-handler.js. Coverage (Term): 16% Coverage (LOC): 23%
*- File /root/Targets/gugamarket/node_modules/mout/object/mixIn.js. Coverage (Term): 33% Coverage (LOC): 40%
*- File /root/Targets/gugamarket/node_modules/mout/object/forOwn.js. Coverage (Term): 46% Coverage (LOC): 55%
*- File /root/Targets/gugamarket/node_modules/mout/object/hasOwn.js. Coverage (Term): 54% Coverage (LOC): 80%
*- File /root/Targets/gugamarket/node_modules/mout/object/forIn.js. Coverage (Term): 18% Coverage (LOC): 18%
*- File /root/Targets/gugamarket/node_modules/serve-favicon/index.js. Coverage (Term): 14% Coverage (LOC): 20%
*- File /root/Targets/gugamarket/node_modules/body-parser/index.js. Coverage (Term): 50% Coverage (LOC): 51%
*- File /root/Targets/gugamarket/node_modules/method-override/index.js. Coverage (Term): 19% Coverage (LOC): 32%
*- File /root/Targets/gugamarket/node_modules/cookie-parser/index.js. Coverage (Term): 34% Coverage (LOC): 37%
*- File /root/Targets/gugamarket/node_modules/cookie-parser/lib/parse.js. Coverage (Term): 16% Coverage (LOC): 30%
*- File /root/Targets/gugamarket/node_modules/express-session/index.js. Coverage (Term): 11% Coverage (LOC): 9%
*- File /root/Targets/gugamarket/node_modules/uid-safe/index.js. Coverage (Term): 34% Coverage (LOC): 45%
*- File /root/Targets/gugamarket/node_modules/base64-url/index.js. Coverage (Term): 30% Coverage (LOC): 75%
*- File /root/Targets/gugamarket/node_modules/on-headers/index.js. Coverage (Term): 13% Coverage (LOC): 20%
*- File /root/Targets/gugamarket/node_modules/express-session/session/session.js. Coverage (Term): 23% Coverage (LOC): 40%
*- File /root/Targets/gugamarket/node_modules/express-session/session/memory.js. Coverage (Term): 21% Coverage (LOC): 38%
*- File /root/Targets/gugamarket/node_modules/express-session/session/store.js. Coverage (Term): 29% Coverage (LOC): 33%
*- File /root/Targets/gugamarket/node_modules/express-session/session/cookie.js. Coverage (Term): 20% Coverage (LOC): 26%
*- File /root/Targets/gugamarket/node_modules/morgan/index.js. Coverage (Term): 25% Coverage (LOC): 36%
*- File /root/Targets/gugamarket/node_modules/basic-auth/index.js. Coverage (Term): 17% Coverage (LOC): 19%
*- File /root/Targets/gugamarket/node_modules/bytes/index.js. Coverage (Term): 9% Coverage (LOC): 21%
*- File /root/Targets/gugamarket/node_modules/passport/lib/index.js. Coverage (Term): 98% Coverage (LOC): 100%
*- File /root/Targets/gugamarket/node_modules/passport/lib/authenticator.js. Coverage (Term): 24% Coverage (LOC): 32%
*- File /root/Targets/gugamarket/node_modules/passport/lib/strategies/session.js. Coverage (Term): 32% Coverage (LOC): 26%
*- File /root/Targets/gugamarket/node_modules/pause/index.js. Coverage (Term): 13% Coverage (LOC): 14%
*- File /root/Targets/gugamarket/node_modules/passport-strategy/lib/index.js. Coverage (Term): 97% Coverage (LOC): 100%
*- File /root/Targets/gugamarket/node_modules/passport-strategy/lib/strategy.js. Coverage (Term): 68% Coverage (LOC): 86%
*- File /root/Targets/gugamarket/node_modules/passport/lib/framework/connect.js. Coverage (Term): 95% Coverage (LOC): 100%
*- File /root/Targets/gugamarket/node_modules/passport/lib/middleware/initialize.js. Coverage (Term): 19% Coverage (LOC): 27%
*- File /root/Targets/gugamarket/node_modules/passport/lib/middleware/authenticate.js. Coverage (Term): 4% Coverage (LOC): 3%
*- File /root/Targets/gugamarket/node_modules/passport/lib/errors/authenticationerror.js. Coverage (Term): 43% Coverage (LOC): 50%
*- File /root/Targets/gugamarket/node_modules/passport/lib/http/request.js. Coverage (Term): 17% Coverage (LOC): 20%
*- File /root/Targets/gugamarket/node_modules/gugamarket/controller/Passport.js. Coverage (Term): 30% Coverage (LOC): 26%
*- File /root/Targets/gugamarket/node_modules/gugamarket/controller/User.js. Coverage (Term): 6% Coverage (LOC): 10%
*- File /root/Targets/gugamarket/node_modules/date-utils/lib/date-utils.js. Coverage (Term): 15% Coverage (LOC): 39%
*- File /root/Targets/gugamarket/node_modules/passwordless/index.js. Coverage (Term): 95% Coverage (LOC): 100%
*- File /root/Targets/gugamarket/node_modules/passwordless/lib/index.js. Coverage (Term): 97% Coverage (LOC): 100%
*- File /root/Targets/gugamarket/node_modules/passwordless/lib/passwordless/passwordless.js. Coverage (Term): 7% Coverage (LOC): 11%
*- File /root/Targets/gugamarket/node_modules/node-uuid/uuid.js. Coverage (Term): 22% Coverage (LOC): 33%
*- File /root/Targets/gugamarket/node_modules/emailjs/email.js. Coverage (Term): 50% Coverage (LOC): 80%
*- File /root/Targets/gugamarket/node_modules/emailjs/smtp/client.js. Coverage (Term): 3% Coverage (LOC): 3%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
