/root/Targets/csslike
└── csslike@0.0.2 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/csslike/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 27% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0312 took 3.5801s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (6:4) on program /**
 * csslike - Lexer
 * Copyright (c) 2011, Christopher Jeffrey. (MIT Licensed)
 */

var assert = require('assert').ok;

/**
 * States:
 *  inside
 *    refers to the "inside" of rules and at rules.
 *    rules and at-rules are becoming more and more
 *    syntactically similar every day - they can now
 *    contain both properties and/or rules.
 *  at_rule
 *    the "header" of an at-rule.
 *  single_string
 *    a single quoted string.
 *  double_string
 *    a double quoted string.
 *  comment
 *    a multiline comment.
 *  value
 *    a rule's or at-rule's property's value.
 */

var lexer = function(css) {
  css = css.replace(/\r\n|\r/g, '\n');

  var i = 0
    , l = css.length
    , ch
    , buff = ''
    , key
    , line = 1
    , offset = 0
    , tokens = []
    , stack = [];

  var state = function() {
    return stack[stack.length-1];
  };

  for (; i < l; i++) {
    ch = css[i];
    offset++;

    switch (ch) {
      case '\\':
        buff += ch;
        buff += css[++i];
        break;
      case '\n':
        offset = 0;
        line++;
        ; // FALL-THROUGH
      case '\t':
        switch (state()) {
          case 'single_string':
          case 'double_string':
          case 'comment':
            buff += ch;
            break;
          default:
            break;
        }
        ; // FALL-THROUGH
      case ' ':
        // need this to get at-rule
        // names, store them in `key`
        if (state() === 'at_rule' && !key) {
          key = buff;
          buff = '';
        }
        buff += ch;
        break;
      case '{':
        switch (state()) {
          case 'single_string':
          case 'double_string':
          case 'comment':
            buff += ch;
            break;
          case 'at_rule':
            tokens.push({
              type: 'nested_at',
              name: key,
              params: buff.trim(),
              line: line
            });
            key = '';
            buff = '';
            stack.pop();
            stack.push('inside');
            break;
          case 'value':
            // we were inside a
            // selector instead
            // of a property like
            // we originally thought
            stack.pop();
            buff = key + ':' + buff;
            key = '';
            ; // FALL-THROUGH
          case 'inside':
          default:
            tokens.push({
              type: 'rule',
              selector: buff.trim(),
              line: line
            });
            buff = '';
            stack.push('inside');
            break;
        }
        break;
      case '}':
        switch (state()) {
          case 'value':
            assert(key !== '');
            tokens.push({
              type: 'property',
              key: key.trim(),
              val: buff.trim(),
              line: line
            });
            key = '';
            buff = '';
            stack.pop();
            assert(state() === 'inside');
            ; // FALL-THROUGH
          case 'inside':
            tokens.push({
              type: 'end',
              line: line
            });
            buff = '';
            break;
        }
        switch (state()) {
          case 'single_string':
          case 'double_string':
          case 'comment':
            buff += ch;
            break;
          default:
            stack.pop();
            break;
        }
        break;
      case ':':
        switch (state()) {
          case 'inside':
            // at this point were
            // either inside a selector
            // or a property, we dont
            // really know. well assume
            // its a property for now,
            // and if we hit a curly
            // brace later, we can
            // change the state token
            // to a rule
            key = buff;
            buff = '';
            stack.push('value');
            break;
          default:
            buff += ch;
            break;
        }
        break;
      case ';':
        switch (state()) {
          case 'value':
            // a useless semicolon
            if (!key) break;
            tokens.push({
              type: 'property',
              key: key.trim(),
              val: buff.trim(),
              line: line
            });
            key = '';
            buff = '';
            stack.pop();
            break;
          case 'at_rule':
            tokens.push({
              type: 'at',
              name: key,
              params: buff.trim(),
              line: line
            });
            key = '';
            buff = '';
            stack.pop();
            break;
          default:
            buff += ch;
            break;
        }
        break;
      case '/':
        switch (state()) {
          case 'single_string':
          case 'double_string':
          case 'comment':
            buff += ch;
            break;
          default:
            if (css[i+1] === '*') {
              i++;
              stack.push('comment');
            } else {
              buff += ch;
            }
            break;
        }
        break;
      case '*':
        switch (state()) {
          case 'comment':
            if (css[i+1] === '/') {
              i++;
              tokens.push({
                type: 'comment',
                text: buff,
                line: line
              });
              buff = '';
              stack.pop();
            } else {
              buff += ch;
            }
            break;
          default:
            buff += ch;
            break;
        }
        break;
      case '@':
        switch (state()) {
          case 'single_string':
          case 'double_string':
          case 'comment':
            buff += ch;
            break;
          default:
            assert(buff.trim() === '');
            buff = '';
            buff += ch;
            stack.push('at_rule');
            break;
        }
        break;
      case '"':
        switch (state()) {
          case 'comment':
          case 'single_string':
            break;
          case 'double_string':
            stack.pop();
            break;
          default:
            stack.push('double_string');
            break;
        }
        buff += ch;
        break;
      case '\'':
        switch (state()) {
          case 'comment':
          case 'double_string':
            break;
          case 'single_string':
            stack.pop();
            break;
          default:
            stack.push('single_string');
            break;
        }
        buff += ch;
        break;
      default:
        if (ch < ' ') {
          throw new
            Error('Control character found.'
                  + '\nLine: ' + line
                  + '\nOffset: ' + offset);
        }
        buff += ch;
        break;
    }
  }

  return tokens;
};

/**
 * Expose
 */

module.exports = lexer;
 at SyntaxError: Unexpected token (6:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/csslike/node_modules/csslike/index.js. Coverage (Term): 80% Coverage (LOC): 100%
*- File /root/Targets/csslike/node_modules/csslike/lib/csslike.js. Coverage (Term): 8% Coverage (LOC): 7%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
