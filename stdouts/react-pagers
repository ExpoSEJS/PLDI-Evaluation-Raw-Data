/root/Targets/react-pagers
└─┬ react-pagers@2.0.2 
  ├── classnames@2.2.5 
  ├── jquery@2.2.4 
  ├─┬ react@0.14.9 
  │ ├─┬ envify@3.4.1 
  │ │ ├─┬ jstransform@11.0.3 
  │ │ │ ├── base62@1.2.0 
  │ │ │ ├─┬ commoner@0.10.8 
  │ │ │ │ ├── commander@2.11.0 
  │ │ │ │ ├─┬ detective@4.5.0 
  │ │ │ │ │ ├── acorn@4.0.13 
  │ │ │ │ │ └── defined@1.0.0 
  │ │ │ │ ├─┬ glob@5.0.15 
  │ │ │ │ │ ├─┬ inflight@1.0.6 
  │ │ │ │ │ │ └── wrappy@1.0.2 
  │ │ │ │ │ ├── inherits@2.0.3 
  │ │ │ │ │ ├─┬ minimatch@3.0.4 
  │ │ │ │ │ │ └─┬ brace-expansion@1.1.8 
  │ │ │ │ │ │   ├── balanced-match@1.0.0 
  │ │ │ │ │ │   └── concat-map@0.0.1 
  │ │ │ │ │ ├── once@1.4.0 
  │ │ │ │ │ └── path-is-absolute@1.0.1 
  │ │ │ │ ├── graceful-fs@4.1.11 
  │ │ │ │ ├── iconv-lite@0.4.19 
  │ │ │ │ ├─┬ mkdirp@0.5.1 
  │ │ │ │ │ └── minimist@0.0.8 
  │ │ │ │ ├── private@0.1.7 
  │ │ │ │ ├── q@1.5.0 
  │ │ │ │ └─┬ recast@0.11.23 
  │ │ │ │   ├── ast-types@0.9.6 
  │ │ │ │   ├── esprima@3.1.3 
  │ │ │ │   └── source-map@0.5.7 
  │ │ │ ├── esprima-fb@15001.1.0-dev-harmony-fb 
  │ │ │ ├── object-assign@2.1.1 
  │ │ │ └─┬ source-map@0.4.4 
  │ │ │   └── amdefine@1.0.1 
  │ │ └── through@2.3.8 
  │ └─┬ fbjs@0.6.1 
  │   ├── core-js@1.2.7 
  │   ├─┬ loose-envify@1.3.1 
  │   │ └── js-tokens@3.0.2 
  │   ├─┬ promise@7.3.1 
  │   │ └── asap@2.0.6 
  │   ├── ua-parser-js@0.7.14 
  │   └── whatwg-fetch@0.9.0 
  ├── react-dom@0.14.9 
  └── underscore@1.8.3 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/react-pagers/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0498 took 4.6575s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (213:6) on program /**
 * Paginator for React.JS
 *
 * @github https://github.com/code-artisan/react-pagers
 * @author artisan.
 * @Date(2015-11-16).
 */

import $ from 'jquery';
import React from 'react';
import _ from 'underscore';
import classnames from 'classnames';
import ReactPagersItem from './react-pagers-item.jsx';
import ReactPagersJumper from './react-pagers-jumper.jsx';

class ReactPagers extends React.Component {

  /**
   * Constructor
   *
   * @param  {object} props Default props
   * @return {undefined}
   */
  constructor(props) {
    super(props);

    this.state = {
      useHash: !!props.useHash,
      active : props.active || 1,
      between: []
    };

    this.matcher = /page\/([0-9]+)/;

    this.displayName = 'ReactPagers';

    this.handleHashChange = this.handleHashChange.bind(this);
  }

  /**
   * 修正 active 值，比如：<ReactPagers active={-1} /> 则需要修正
   *
   * @param  {number} active   当前页码
   * @return {number}          修正后的页码
   */
  active(active) {
    var total = Math.max(1, this.props.total);
    return Math.min(Math.max(active, 1), total);
  }

  /**
   * 根据 active 值填充页码
   *
   * @param  {number} active 当前页码
   * @return {array}          填充好的页码数组
   */
  filler(active) {
    let {
          total,
          number
        } = this.props,

        // 显示页码总数的一半
        half = Math.floor(number / 2),

        // 计算开始页码
        min = active - half,

        // 计算结束页码
        max = active + half,

        // 存储生成的页码元素
        between = [];

        max = Math.max(max, number);

    total = Math.max(1, total); // 修正总页码数，有可能传入0或负数
    max   = Math.min(max, total);
    min   = Math.max(max - number + 1, 1);

    for (; min <= max; min++) {
      let option = {
        value : min,
        unique: min,
        active: active === min // Is active.
      };
      between.push( option );
    }

    return between;
  }

  /**
   * 触发回调函数.
   *
   * @return {undefined}
   */
  handleChange() {
    let { onChange } = this.props;

    if (_.isFunction(onChange)) {
      onChange(this.state.active);
    }
  }

  /**
   * 获取hash中的页码.
   *
   * @return {Number}
   */
  getHashPage() {
    let hash = location.hash,
        result = hash.match(this.matcher);
    return $.isArray(result) ? +result[1] : 0;
  }

  /**
   * 根据 active值 跳转到相应的页码并触发回掉函数
   *
   * @param  {number} active 当前页码
   * @return {undefined}
   */
  handleRedirectTo(active, init) {
    if (this.state.useHash) {
      active = this.getHashPage();
    }

    this.state.useHash = false;
    active = this.active(active);

    if (active !== this.state.active || init) {
      let { between } = this.state;

      if ( this.props.visible ) {
        between = this.filler(active);
      }

      let handleChange = init ? null : this.handleChange;

      this.setState({
        active : active,
        between: between
      }, handleChange);
    }
  }

  /**
   * Set location hash.
   *
   * @param {Number} active active page.
   */
  setQueryString(active) {
    var [hash, query] = location.hash.split('?'),
        result = hash.match(this.matcher);

    if (_.isArray(result)) {
      hash = hash.replace(this.matcher, ($0, $1) => {
        return `page/${active}`;
      });
    } else {
      hash += /\/$/.test(hash) ? `page/${active}` : `/page/${active}`;
    }

    window.location.hash = hash + (_.isString(query) ? '?' + query : '');
  }

  handleHashChange(event) {
    let active = this.getHashPage();
    this.handleRedirectTo(active);

    // Prevent default event.
    event.preventDefault();
  }

  componentWillMount() {
    this.handleRedirectTo(this.props.active, true);
  }

  componentDidMount() {
    if (this.props.useHash) {
      $(window).on('hashchange', this.handleHashChange);
    }
  }

  componentDidUpdate() {
    if (this.props.useHash) {
      this.setQueryString(this.state.active);
    }
  }

  componentWillUnmount() {
    $(window).off('hashchange', this.handleHashChange);
  }

  componentWillReceiveProps(props) {
    this.props = props;
    this.state.useHash = !!props.useHash;
    this.handleRedirectTo(this.props.active, true);
  }

  render() {
    let { active, between } = this.state,
        {
          size,
          total,
          className,
          language,
          visible,
          jumper
        } = this.props;

    return (
      <div className={ classnames('react-paginator', className.container) }>
        <ul className={ this.props.visible ? `pagination pagination-${size}` : 'pager'}>
          { // 如果 page no 为 false，则不显示第一页 / 最后一页
            visible ? <ReactPagersItem value={ language.first } disabled={ active === 1 } className={ className.first } callback={ this.handleRedirectTo.bind(this, 1) } /> : null
          }
          <ReactPagersItem value={ language.prev } callback={ this.handleRedirectTo.bind(this, active - 1) } className={ className.prev } disabled={ active === 1 } />
          { // 是否需要生成页码
            visible ? between.map((option, key) => {
              return <ReactPagersItem key={ key } {...option} callback={ this.handleRedirectTo.bind(this) } />
            }) : null
          }
          <ReactPagersItem value={ language.next } callback={ this.handleRedirectTo.bind(this, active + 1) } className={ className.next } disabled={ active === total } />
          {
            visible ? <ReactPagersItem value={ language.last } disabled={ active === total } className={ className.last } callback={ this.handleRedirectTo.bind(this, total) } /> : null
          }
          {
            visible && jumper ? <ReactPagersJumper size={ size } value={ active } onChange={ this.handleRedirectTo.bind(this) } /> : null
          }
        </ul>
      </div>
    );
  }
}

ReactPagers.defaultProps = {
  total: 1,
  active: 1,
  number: 9,
  useHash: true,
  visible: true,
  language: {
    last: "Last",
    prev: 'Previous',
    next: 'Next',
    first: "First"
  },
  onChange: null,
  className: {
    prev: null,
    next: null,
    last: null,
    first: null,
    container: null
  },
  jumper: false,
  size: 'md'
};

ReactPagers.propTypes = {
  total: React.PropTypes.number.isRequired,
  active: React.PropTypes.number.isRequired,
  number: React.PropTypes.number,
  useHash: React.PropTypes.bool,
  visible: React.PropTypes.bool,
  language: React.PropTypes.object,
  onChange: React.PropTypes.func,
  className: React.PropTypes.object,
  jumper: React.PropTypes.bool,
  size: React.PropTypes.oneOf([
    'sm', 'md', 'lg'
  ])
};

export default ReactPagers;
 at SyntaxError: Unexpected token (213:6)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$3.parseExprAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1822:12)
    at Parser.parseExprAtom (/root/ExpoSE/lib/Tropigate/bin/Expression.js:28:30)
    at Parser.pp$3.parseExprSubscripts (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1715:21)
    at Parser.parseMaybeUnary (/root/ExpoSE/lib/Tropigate/bin/Unary.js:34:29)
    at Parser.pp$3.parseExprOps (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1637:21)
    at Parser.pp$3.parseMaybeConditional (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1620:21)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1597:21)
    at Parser.pp$3.parseParenAndDistinguishExpression (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1861:32)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
