
> deasync@0.1.10 install /root/Targets/didi-postpackager-fontmin/node_modules/deasync
> node ./build.js

`linux-x64-node-7` exists; testing
Binary is fine; exiting
/root/Targets/didi-postpackager-fontmin
└─┬ didi-postpackager-fontmin@1.0.2 
  ├─┬ cheerio@0.18.0 
  │ ├─┬ CSSselect@0.4.1 
  │ │ ├── CSSwhat@0.4.7 
  │ │ └── domutils@1.4.3 
  │ ├─┬ dom-serializer@0.0.1 
  │ │ └── domelementtype@1.1.3 
  │ ├── entities@1.1.1 
  │ ├─┬ htmlparser2@3.8.3 
  │ │ ├── domelementtype@1.3.0 
  │ │ ├── domhandler@2.3.0 
  │ │ ├── domutils@1.5.1 
  │ │ ├── entities@1.0.0 
  │ │ └─┬ readable-stream@1.1.14 
  │ │   ├── isarray@0.0.1 
  │ │   └── string_decoder@0.10.31 
  │ └── lodash@2.4.2 
  ├── cssom@0.3.2 
  ├─┬ deasync@0.1.10 
  │ ├── bindings@1.2.1 
  │ └── nan@2.7.0 
  ├─┬ fontmin@0.9.6 
  │ ├── b3b@0.0.1 
  │ ├─┬ buffer-to-vinyl@1.1.0 
  │ │ ├── file-type@3.9.0 
  │ │ ├─┬ readable-stream@2.3.3 
  │ │ │ ├── isarray@1.0.0 
  │ │ │ ├── process-nextick-args@1.0.7 
  │ │ │ ├── safe-buffer@5.1.1 
  │ │ │ ├── string_decoder@1.0.3 
  │ │ │ └── util-deprecate@1.0.2 
  │ │ ├── uuid@2.0.3 
  │ │ └─┬ vinyl@1.2.0 
  │ │   ├── clone@1.0.2 
  │ │   └── clone-stats@0.0.1 
  │ ├─┬ concat-stream@1.6.0 
  │ │ ├─┬ readable-stream@2.3.3 
  │ │ │ ├── isarray@1.0.0 
  │ │ │ └── string_decoder@1.0.3 
  │ │ └── typedarray@0.0.6 
  │ ├─┬ fonteditor-core@0.0.21 
  │ │ └── xmldom@0.1.27 
  │ ├── get-stdin@5.0.1 
  │ ├── is-otf@0.1.2 
  │ ├── is-svg@1.1.1 
  │ ├── is-ttf@0.2.2 
  │ ├── lodash@4.17.4 
  │ ├─┬ meow@3.7.0 
  │ │ ├─┬ camelcase-keys@2.1.0 
  │ │ │ └── camelcase@2.1.1 
  │ │ ├── decamelize@1.2.0 
  │ │ ├─┬ loud-rejection@1.6.0 
  │ │ │ ├─┬ currently-unhandled@0.4.1 
  │ │ │ │ └── array-find-index@1.0.2 
  │ │ │ └── signal-exit@3.0.2 
  │ │ ├── map-obj@1.0.1 
  │ │ ├── minimist@1.2.0 
  │ │ ├─┬ normalize-package-data@2.4.0 
  │ │ │ ├── hosted-git-info@2.5.0 
  │ │ │ ├─┬ is-builtin-module@1.0.0 
  │ │ │ │ └── builtin-modules@1.1.1 
  │ │ │ ├── semver@5.4.1 
  │ │ │ └─┬ validate-npm-package-license@3.0.1 
  │ │ │   ├─┬ spdx-correct@1.0.2 
  │ │ │   │ └── spdx-license-ids@1.2.2 
  │ │ │   └── spdx-expression-parse@1.0.4 
  │ │ ├── object-assign@4.1.1 
  │ │ ├─┬ read-pkg-up@1.0.1 
  │ │ │ ├─┬ find-up@1.1.2 
  │ │ │ │ ├── path-exists@2.1.0 
  │ │ │ │ └─┬ pinkie-promise@2.0.1 
  │ │ │ │   └── pinkie@2.0.4 
  │ │ │ └─┬ read-pkg@1.1.0 
  │ │ │   ├─┬ load-json-file@1.1.0 
  │ │ │   │ ├─┬ parse-json@2.2.0 
  │ │ │   │ │ └─┬ error-ex@1.3.1 
  │ │ │   │ │   └── is-arrayish@0.2.1 
  │ │ │   │ └── pify@2.3.0 
  │ │ │   └── path-type@1.1.0 
  │ │ ├─┬ redent@1.0.0 
  │ │ │ ├─┬ indent-string@2.1.0 
  │ │ │ │ └─┬ repeating@2.0.1 
  │ │ │ │   └─┬ is-finite@1.0.2 
  │ │ │ │     └── number-is-nan@1.0.1 
  │ │ │ └─┬ strip-indent@1.0.1 
  │ │ │   └── get-stdin@4.0.1 
  │ │ └── trim-newlines@1.0.0 
  │ ├── pako@1.0.6 
  │ ├── replace-ext@0.0.1 
  │ ├─┬ stream-combiner@0.2.2 
  │ │ ├── duplexer@0.1.1 
  │ │ └── through@2.3.8 
  │ ├─┬ through2@2.0.1 
  │ │ ├─┬ readable-stream@2.0.6 
  │ │ │ └── isarray@1.0.0 
  │ │ └── xtend@4.0.1 
  │ └─┬ vinyl-fs@2.4.3 
  │   ├─┬ duplexify@3.5.1 
  │   │ ├── end-of-stream@1.4.0 
  │   │ ├─┬ readable-stream@2.3.3 
  │   │ │ ├── isarray@1.0.0 
  │   │ │ └── string_decoder@1.0.3 
  │   │ └── stream-shift@1.0.0 
  │   ├─┬ glob-stream@5.3.5 
  │   │ ├── extend@3.0.1 
  │   │ ├─┬ glob@5.0.15 
  │   │ │ ├── minimatch@3.0.4 
  │   │ │ └── path-is-absolute@1.0.1 
  │   │ ├─┬ glob-parent@3.1.0 
  │   │ │ ├─┬ is-glob@3.1.0 
  │   │ │ │ └── is-extglob@2.1.1 
  │   │ │ └── path-dirname@1.0.2 
  │   │ ├─┬ micromatch@2.3.11 
  │   │ │ ├─┬ arr-diff@2.0.0 
  │   │ │ │ └── arr-flatten@1.1.0 
  │   │ │ ├── array-unique@0.2.1 
  │   │ │ ├─┬ braces@1.8.5 
  │   │ │ │ ├─┬ expand-range@1.8.2 
  │   │ │ │ │ └─┬ fill-range@2.2.3 
  │   │ │ │ │   ├── is-number@2.1.0 
  │   │ │ │ │   ├─┬ isobject@2.1.0 
  │   │ │ │ │   │ └── isarray@1.0.0 
  │   │ │ │ │   ├─┬ randomatic@1.1.7 
  │   │ │ │ │   │ ├─┬ is-number@3.0.0 
  │   │ │ │ │   │ │ └── kind-of@3.2.2 
  │   │ │ │ │   │ └── kind-of@4.0.0 
  │   │ │ │ │   └── repeat-string@1.6.1 
  │   │ │ │ ├── preserve@0.2.0 
  │   │ │ │ └── repeat-element@1.1.2 
  │   │ │ ├─┬ expand-brackets@0.1.5 
  │   │ │ │ └── is-posix-bracket@0.1.1 
  │   │ │ ├─┬ extglob@0.3.2 
  │   │ │ │ └── is-extglob@1.0.0 
  │   │ │ ├── filename-regex@2.0.1 
  │   │ │ ├── is-extglob@1.0.0 
  │   │ │ ├── is-glob@2.0.1 
  │   │ │ ├─┬ kind-of@3.2.2 
  │   │ │ │ └── is-buffer@1.1.5 
  │   │ │ ├─┬ normalize-path@2.1.1 
  │   │ │ │ └── remove-trailing-separator@1.1.0 
  │   │ │ ├─┬ object.omit@2.0.1 
  │   │ │ │ ├─┬ for-own@0.1.5 
  │   │ │ │ │ └── for-in@1.0.2 
  │   │ │ │ └── is-extendable@0.1.1 
  │   │ │ ├─┬ parse-glob@3.0.4 
  │   │ │ │ ├─┬ glob-base@0.3.0 
  │   │ │ │ │ ├── glob-parent@2.0.0 
  │   │ │ │ │ └─┬ is-glob@2.0.1 
  │   │ │ │ │   └── is-extglob@1.0.0 
  │   │ │ │ ├── is-dotfile@1.0.3 
  │   │ │ │ ├── is-extglob@1.0.0 
  │   │ │ │ └── is-glob@2.0.1 
  │   │ │ └─┬ regex-cache@0.4.4 
  │   │ │   └─┬ is-equal-shallow@0.1.3 
  │   │ │     └── is-primitive@2.0.0 
  │   │ ├─┬ ordered-read-streams@0.3.0 
  │   │ │ ├── is-stream@1.1.0 
  │   │ │ └─┬ readable-stream@2.3.3 
  │   │ │   ├── isarray@1.0.0 
  │   │ │   └── string_decoder@1.0.3 
  │   │ ├─┬ through2@0.6.5 
  │   │ │ └── readable-stream@1.0.34 
  │   │ ├─┬ to-absolute-glob@0.1.1 
  │   │ │ └── extend-shallow@2.0.1 
  │   │ └─┬ unique-stream@2.2.1 
  │   │   └─┬ json-stable-stringify@1.0.1 
  │   │     └── jsonify@0.0.0 
  │   ├── graceful-fs@4.1.11 
  │   ├─┬ gulp-sourcemaps@1.12.0 
  │   │ ├─┬ @gulp-sourcemaps/map-sources@1.0.0 
  │   │ │ └─┬ through2@2.0.3 
  │   │ │   └─┬ readable-stream@2.3.3 
  │   │ │     ├── isarray@1.0.0 
  │   │ │     └── string_decoder@1.0.3 
  │   │ ├── acorn@4.0.13 
  │   │ ├── convert-source-map@1.5.0 
  │   │ ├─┬ css@2.2.1 
  │   │ │ ├─┬ source-map@0.1.43 
  │   │ │ │ └── amdefine@1.0.1 
  │   │ │ ├─┬ source-map-resolve@0.3.1 
  │   │ │ │ ├── atob@1.1.3 
  │   │ │ │ ├── resolve-url@0.2.1 
  │   │ │ │ └── source-map-url@0.3.0 
  │   │ │ └── urix@0.1.0 
  │   │ ├─┬ debug-fabulous@0.0.4 
  │   │ │ ├─┬ debug@2.6.9 
  │   │ │ │ └── ms@2.0.0 
  │   │ │ ├── lazy-debug-legacy@0.0.1 
  │   │ │ └── object-assign@4.1.0 
  │   │ ├── detect-newline@2.1.0 
  │   │ └── source-map@0.6.1 
  │   ├── is-valid-glob@0.3.0 
  │   ├─┬ lazystream@1.0.0 
  │   │ └─┬ readable-stream@2.3.3 
  │   │   ├── isarray@1.0.0 
  │   │   └── string_decoder@1.0.3 
  │   ├── lodash.isequal@4.5.0 
  │   ├─┬ merge-stream@1.0.1 
  │   │ └─┬ readable-stream@2.3.3 
  │   │   ├── isarray@1.0.0 
  │   │   └── string_decoder@1.0.3 
  │   ├─┬ mkdirp@0.5.1 
  │   │ └── minimist@0.0.8 
  │   ├─┬ readable-stream@2.3.3 
  │   │ ├── isarray@1.0.0 
  │   │ └── string_decoder@1.0.3 
  │   ├─┬ strip-bom@2.0.0 
  │   │ └── is-utf8@0.2.1 
  │   ├─┬ strip-bom-stream@1.0.0 
  │   │ └── first-chunk-stream@1.0.0 
  │   ├── through2-filter@2.0.0 
  │   └── vali-date@1.0.0 
  ├─┬ glob@4.5.3 
  │ ├─┬ inflight@1.0.6 
  │ │ └── wrappy@1.0.2 
  │ ├── inherits@2.0.3 
  │ ├─┬ minimatch@2.0.10 
  │ │ └─┬ brace-expansion@1.1.8 
  │ │   ├── balanced-match@1.0.0 
  │ │   └── concat-map@0.0.1 
  │ └── once@1.4.0 
  ├── ignore@2.2.19 
  ├─┬ promise@6.1.0 
  │ └── asap@1.0.0 
  └─┬ verror@1.10.0 
    ├── assert-plus@1.0.0 
    ├── core-util-is@1.0.2 
    └── extsprintf@1.3.0 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/didi-postpackager-fontmin/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0697 took 2.7181s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected character '#' (1:78) on program #!/usr/bin/env node

'use strict';

var fs = require('fs');
var path = require('path');
var FontSpider = require('./src');
var Promise = require('promise');
var deasync = require('deasync');

var options = {
    resourceLoad: function (file) {
        writeln('Load:', color('cyan', file), color('green', '<OK>'));
    },

    resourceError: function () {
        writeln('');
    },

    spiderLoad: function () {
        writeln('Loading ..');
    },
    backup: false
};




var _isDebug = false;;

// writeln('Loading ..');


function onerror (errors) {
    writeln('');

    var message = 'Error: ' + errors.message;
    var stack = errors.stack.toString();

    stack = stack.split('\n');
    stack.shift();
    stack = stack.join('\n');

    if (process.stderr.isTTY) {
        message = color('red', message);
        stack = color('grey', stack);
    }

    process.stderr.write(message + '\n');
    process.stderr.write(stack + '\n');

    // 可能有异步 http 任务运行，强制中断
    process.exit(1);
}
/**
 * 打包阶段插件接口
 * @param  {Object} ret      一个包含处理后源码的结构
 * @param  {Object} conf     一般不需要关心，自动打包配置文件
 * @param  {Object} settings 插件配置属性
 * @param  {Object} opt      命令行参数
 * @return {undefined}          
 */
/**
 * ret=>
 * src 源文件
 * pkg 打包的文件
 */

module.exports = function (ret, conf, settings, opt) { //打包后处理

    var files = [];
    var includeCssFileMaps = {};
    var includeCssContentMaps = {};
    var urlMap = [];
    var _allProcessDone = false;
    var allCSSList = [];
    _isDebug = opt.verbose === true;
    if(!opt.optimize){
        return;
    }
    var fontFileSum = 0;
    fis.util.map(ret.src, function (subpath, file) {
        if (file.isHtmlLike && file.useCompile && file.release && file.autoloadDependencies) {
        /**
         * file.autoloadDependencies = {
                cssList: cssList,
                jsList: jsList,
                asyncList: asyncList
            }；
         */
         // debugger;
            var realpath = file.realpath;
            files.push(realpath);
            var filemaps = file.autoloadDependencies.cssList.map(function(val){
                //获取文件对象
                var cssFile, srcFile, srcKey;  
                for(srcKey in ret.src ){
                    srcFile = ret.src[srcKey] 
                    if(srcFile.id === val.id){
                        cssFile = srcFile;
                        break;
                    }
                }
                for(srcKey in ret.pkg ){
                    srcFile = ret.pkg[srcKey] 
                    // pkg文件没有id
                    if(srcFile.getUrl(opt.hash, opt.domain) === val.uri){
                        cssFile = srcFile;
                        break;
                    }
                }
                allCSSList.push(cssFile); 
                //映射css的地址和真实文件地址
                urlMap.push([val.uri, cssFile.realpath]);
                return cssFile.realpath;
            })
            //该html文件需要被引入的文件
            includeCssFileMaps[realpath] = filemaps;
        }


        if(file.ext.toLowerCase() === '.ttf'){
            urlMap.push([file.getUrl(opt.hash, opt.domain), file.realpath]); 
        }


    });
    if(files.length === 0){
        return;
    }
    write(files);
    options.includeCssFileMaps = includeCssFileMaps;
    options.includeCssContentMaps = includeCssContentMaps;
    options.map = urlMap;
    makeTimePoint('A');
    new FontSpider.Spider(files, options, getContentOfRealpath)
    .then(function (webFonts) {
        //过滤掉空字符的选择器
        webFonts = webFonts.filter(function(webFont){
            return webFont.chars.replace(/\s+/, '') !== ''; 
        });
        if (webFonts.length === 0) {
            write('<web font not found>');
            return;
        }
        var json = JSON.stringify(webFonts, null, 4);
        write(json + '\n');
        writeln('Loading ...');
        makeTimePoint('B');

  

        return Promise.all(webFonts.map(function (webFont, index) {
            return new FontSpider.Compress(webFont, options)
            .then(function (webFont) {
                writeln('');
                makeTimePoint('C'+(index));
                write('Font name:', color('green', webFont.name));
                write('Original size:', color('green', webFont.originalSize / 1000 + ' KB'));
                write('Include chars:', webFont.chars);
                write('Font id:', webFont.id);
                write('CSS selector:', webFont.selectors.join(', '));
                write('Font files:');
                function byteCount(s) {
                    return (encodeURI(s).split(/%..|./).length - 1);
                }
                fontFileSum = webFont.outs.length;
                webFont.outs.forEach(function (fileInfo) {
                    var file = fileInfo[0];
                    write('File', color('cyan', file),
                        'created:', color('green', + byteCount(fileInfo[1]) + ' bytes'));
                    var fileInstance = getFileOfRealpath(file);
                    if(fileInstance == null){
                        // create new font-file
                        fileInstance = fis.file(file);
                        fileInstance.setContent(fileInfo[1]);
                        ret.pkg[fileInstance.subpath] = fileInstance;
                    }else{
                        fileInstance.setContent(fileInfo[1]);
                    }
                });

                write('');

                return webFont;
            });
        }));

    }).then(function(){
        if(fontFileSum > 0){
            allCSSList.forEach(standardCSS);
        }
        function standardCSS(file){
            var path = file.realpath,
            content = file.getContent();
            content = fis.compile.extCss(content);
            content = content.replace(map.reg, function(all, type, value){
                var retu = value, info;
                try {
                    switch(type){
                        case 'uri':
                            value = value.replace(/\?.+$/, '');
                            info = fis.uri(value, file.dirname);
                            for(var k in ret.pkg){
                                if((file.dirname + '/' + value) == ret.pkg[k].realpath){
                                    info.file = ret.pkg[k];
                                    break;
                                }
                            }
                            if(info.file){
                                retu = info.file.getUrl(opt.hash, opt.domain);
                            }else{
                            }
                            break;

                    }
                } catch (e) {
                    e.message = e.message + ' in [' + file.subpath + ']';
                    throw  e;
                }
                return retu;
            });
            file.setContent(content);
        }
        _allProcessDone = true;
    })
    .catch(onerror);
    //Turns async function into sync
    var pointQueue = ['.'];
    write('\nIn the Fontmin processing');
    while(_allProcessDone === false){
        pointQueue.push('.');
        writeln(pointQueue.join('') );
        deasync.sleep(30);    
    }


    function getContentOfRealpath(realpath){
        var file = getFileOfRealpath(realpath); 
        return file ? file.getContent() : null;
    }
    function getFileOfRealpath(realpath){
        for(var i in ret.src){
            if(ret.src[i].realpath === realpath){
                return ret.src[i];
            }
        }
        for(var i in ret.pkg){
            if(ret.pkg[i].realpath === realpath){
                return ret.pkg[i];
            }
        }
        return null;
    }

    

}
function write () {
    if(_isDebug === false){
        return;
    }
    var stream = process.stdout;

    if (stream.isTTY) {
        stream.write('[FONTMING]====>' + Array.prototype.join.call(arguments, ' ') + '\n');
    }
}


function writeln () {
    if(_isDebug === false){
        return;
    }
    var stream = process.stdout;

    if (stream.isTTY) {
        stream.clearLine();
        stream.cursorTo(0);
        stream.write(Array.prototype.join.call(arguments, ' '));
    }
}

function color (name, string) {
    var c = color.colors[name];
    if (c && typeof string === 'string') {
        return c[0] + string + c[1];
    } else {
        return string;
    }
}

color.colors = {
    // styles
    'bold'      : ['\x1B[1m',  '\x1B[22m'],
    'italic'    : ['\x1B[3m',  '\x1B[23m'],
    'underline' : ['\x1B[4m',  '\x1B[24m'],
    'inverse'   : ['\x1B[7m',  '\x1B[27m'],
    // colors
    'white'     : ['\x1B[37m', '\x1B[39m'],
    'grey'      : ['\x1B[90m', '\x1B[39m'],
    'black'     : ['\x1B[30m', '\x1B[39m'],
    'blue'      : ['\x1B[34m', '\x1B[39m'],
    'cyan'      : ['\x1B[36m', '\x1B[39m'],
    'green'     : ['\x1B[32m', '\x1B[39m'],
    'magenta'   : ['\x1B[35m', '\x1B[39m'],
    'red'       : ['\x1B[31m', '\x1B[39m'],
    'yellow'    : ['\x1B[33m', '\x1B[39m']
};



var _map = {};
var _last;
function makeTimePoint(name){
    _map[name] = Date.now();
    var line = '\n---------------------------------------------------------------------------------------------------------------------------------->';
    if(_last){
        write(line ,[name , _last].join(' - ') ,_map[name] - _map[_last]);
    }
    _last = name;
}




var map = exports.lang = (function(){
    var keywords = ['require', 'embed', 'uri', 'dep', 'jsEmbed'],
        LD = '<<<', RD = '>>>',
        qLd = fis.util.escapeReg(LD),
        qRd = fis.util.escapeReg(RD),
        map = {
            reg : new RegExp(
                qLd + '(' + keywords.join('|') + '):([\\s\\S]+?)' + qRd,
                'g'
            )
        };
    keywords.forEach(function(key){
        map[key] = {};
        map[key]['ld'] = LD + key + ':';
        map[key]['rd'] = RD;
    });
    return map;
})();




 at SyntaxError: Unexpected character '#' (1:78)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$7.getTokenFromCode (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2756:10)
    at Parser.pp$7.readToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2477:17)
    at Parser.readToken (/root/ExpoSE/lib/Tropigate/bin/Tokens.js:124:26)
    at Parser.pp$7.nextToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2468:15)
    at Parser.pp$7.next (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2413:10)
    at Parser.pp.eat (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:536:12)
    at Parser.pp.semicolon (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:581:15)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:918:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
