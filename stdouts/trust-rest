/root/Targets/trust-rest
└─┬ trust-rest@2.0.1 
  ├─┬ blanket@1.2.3 
  │ ├── acorn@1.2.2 
  │ ├── falafel@1.2.0 
  │ ├── foreach@2.0.5 
  │ ├── isarray@0.0.1 
  │ ├── object-keys@1.0.11 
  │ └── xtend@4.0.1 
  ├─┬ chai@1.10.0 
  │ ├── assertion-error@1.0.0 
  │ └─┬ deep-eql@0.1.3 
  │   └── type-detect@0.1.1 
  ├─┬ coveralls@2.13.3 
  │ ├─┬ js-yaml@3.6.1 
  │ │ ├─┬ argparse@1.0.9 
  │ │ │ └── sprintf-js@1.0.3 
  │ │ └── esprima@2.7.3 
  │ ├── lcov-parse@0.0.10 
  │ ├── log-driver@1.2.5 
  │ ├── minimist@1.2.0 
  │ └─┬ request@2.79.0 
  │   ├── aws-sign2@0.6.0 
  │   ├── aws4@1.6.0 
  │   ├── caseless@0.11.0 
  │   ├─┬ combined-stream@1.0.5 
  │   │ └── delayed-stream@1.0.0 
  │   ├── extend@3.0.1 
  │   ├── forever-agent@0.6.1 
  │   ├─┬ form-data@2.1.4 
  │   │ └── asynckit@0.4.0 
  │   ├─┬ har-validator@2.0.6 
  │   │ ├─┬ chalk@1.1.3 
  │   │ │ ├── ansi-styles@2.2.1 
  │   │ │ ├── escape-string-regexp@1.0.5 
  │   │ │ ├─┬ has-ansi@2.0.0 
  │   │ │ │ └── ansi-regex@2.1.1 
  │   │ │ ├── strip-ansi@3.0.1 
  │   │ │ └── supports-color@2.0.0 
  │   │ ├── commander@2.11.0 
  │   │ ├─┬ is-my-json-valid@2.16.1 
  │   │ │ ├── generate-function@2.0.0 
  │   │ │ ├─┬ generate-object-property@1.2.0 
  │   │ │ │ └── is-property@1.0.2 
  │   │ │ └── jsonpointer@4.0.1 
  │   │ └─┬ pinkie-promise@2.0.1 
  │   │   └── pinkie@2.0.4 
  │   ├─┬ hawk@3.1.3 
  │   │ ├── boom@2.10.1 
  │   │ ├── cryptiles@2.0.5 
  │   │ ├── hoek@2.16.3 
  │   │ └── sntp@1.0.9 
  │   ├─┬ http-signature@1.1.1 
  │   │ ├── assert-plus@0.2.0 
  │   │ ├─┬ jsprim@1.4.1 
  │   │ │ ├── assert-plus@1.0.0 
  │   │ │ ├── extsprintf@1.3.0 
  │   │ │ ├── json-schema@0.2.3 
  │   │ │ └─┬ verror@1.10.0 
  │   │ │   └── assert-plus@1.0.0 
  │   │ └─┬ sshpk@1.13.1 
  │   │   ├── asn1@0.2.3 
  │   │   ├── assert-plus@1.0.0 
  │   │   ├── bcrypt-pbkdf@1.0.1 
  │   │   ├─┬ dashdash@1.14.1 
  │   │   │ └── assert-plus@1.0.0 
  │   │   ├── ecc-jsbn@0.1.1 
  │   │   ├─┬ getpass@0.1.7 
  │   │   │ └── assert-plus@1.0.0 
  │   │   ├── jsbn@0.1.1 
  │   │   └── tweetnacl@0.14.5 
  │   ├── is-typedarray@1.0.0 
  │   ├── isstream@0.1.2 
  │   ├── json-stringify-safe@5.0.1 
  │   ├─┬ mime-types@2.1.17 
  │   │ └── mime-db@1.30.0 
  │   ├── oauth-sign@0.8.2 
  │   ├── qs@6.3.2 
  │   ├── stringstream@0.0.5 
  │   ├─┬ tough-cookie@2.3.3 
  │   │ └── punycode@1.4.1 
  │   ├── tunnel-agent@0.4.3 
  │   └── uuid@3.1.0 
  ├─┬ mocha@2.5.3 
  │ ├── commander@2.3.0 
  │ ├─┬ debug@2.2.0 
  │ │ └── ms@0.7.1 
  │ ├── diff@1.4.0 
  │ ├── escape-string-regexp@1.0.2 
  │ ├─┬ glob@3.2.11 
  │ │ ├── inherits@2.0.3 
  │ │ └─┬ minimatch@0.3.0 
  │ │   ├── lru-cache@2.7.3 
  │ │   └── sigmund@1.0.1 
  │ ├── growl@1.9.2 
  │ ├─┬ jade@0.26.3 
  │ │ ├── commander@0.6.1 
  │ │ └── mkdirp@0.3.0 
  │ ├─┬ mkdirp@0.5.1 
  │ │ └── minimist@0.0.8 
  │ ├── supports-color@1.2.0 
  │ └── to-iso-string@0.0.2 
  ├── mocha-lcov-reporter@0.0.2 
  ├── q@1.5.0 
  ├─┬ supertest@2.0.1 
  │ ├── methods@1.1.2 
  │ └─┬ superagent@2.3.0 
  │   ├── component-emitter@1.2.1 
  │   ├── cookiejar@2.1.1 
  │   ├─┬ form-data@1.0.0-rc4 
  │   │ └── async@1.5.2 
  │   ├── formidable@1.1.1 
  │   ├── mime@1.4.1 
  │   └─┬ readable-stream@2.3.3 
  │     ├── core-util-is@1.0.2 
  │     ├── isarray@1.0.0 
  │     ├── process-nextick-args@1.0.7 
  │     ├── safe-buffer@5.1.1 
  │     ├── string_decoder@1.0.3 
  │     └── util-deprecate@1.0.2 
  └── underscore@1.8.3 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/trust-rest/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 34% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0418 took 3.2359s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (8:8) on program /**
 * Created by Michael Lyons (mdl0394@gmail.com)
 */

(function() {
    var supertest = require ( 'supertest' ),
        chai = require ( 'chai' ),
        assert = chai.assert,
        _ = require( 'underscore' ),
        q = require( 'q' );

    function ValidationError ( message ) {
        Error.captureStackTrace ( this, ValidationError );

        this.name = 'ValidationError';
        this.message = message;
    }
    ValidationError.prototype = Object.create ( Error.prototype );

    module.exports = function( url ) {
        url = url || 'http://127.0.0.1/';
        var request = supertest ( url );

        /**
         * Validates the given request_options
         * @param request_options The request_options to validate
         * @private
         */
        var _validateRequestOptions = function( request_options ) {
            return q.try( function() {
                assert.isDefined( request_options, 'request_options: request_options not defined' );

                assert.property( request_options, 'method', new ValidationError( 'request_options: method not specified' ) );
                assert.isString( request_options.method, new ValidationError( 'request_options: method not a string' ) );
                assert.include( [ 'get', 'put', 'post', 'delete' ], request_options.method, new ValidationError( 'request_options: method not valid method' ) );

                assert.property( request_options, 'path', new ValidationError( 'request_options: path not specified' ) );
                assert.isString( request_options.path, new ValidationError( 'request_options: path not a string' ) );
                assert.match( request_options.path, /\//, new ValidationError( 'request_options: path doesn\'t start with /' ) );

                if( _.contains( [ 'get', 'delete' ], request_options.method ) ) {
                    assert.notProperty( request_options, 'body', new ValidationError( 'request_options: should not contain body if method is get or delete' ) );
                }

                if( request_options.body ) {
                    if( !( _.isObject( request_options.body ) || _.isArray( request_options.body ) ) )
                        throw new Error( 'request_options: body should be an object' );
                }
            } );
        };

        /**
         * Validates the given response_options
         * @param response_options {Object} The response_options to validate
         * @private
         */
        var _validateResponseOptions = function( response_options ) {
            return q.try( function() {
                if( response_options.code ) {
                    var valid_response_codes = [ 100, 101, 200, 201, 202, 203, 204, 205, 206, 207, 300, 301, 302, 303, 304, 305, 307, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 500, 501, 502, 503, 504, 505 ];

                    assert.include( valid_response_codes, response_options.code, 'response_options: code not a valid http response code' );
                }

                if( response_options.body ) {
                    assert.isObject( response_options.body, new ValidationError( 'response_options: body should be an object' ) );

                    _.each( response_options.body, function( options, key ) {
                        if( options.hasOwnProperty( 'value' ) && options.hasOwnProperty( 'type' ) ) {
                            assert.typeOf( options.value, options.type, 'response_options: body expected value should be same as expected type' );
                        }
                    } );
                }
            } );
        };

        var _prepareRequest = function( request_options ) {
            var prepared_request = request
                [ request_options.method ]( request_options.path );

            if( request_options.headers ) {
                _.each ( request_options.headers, function( header_value, header_name ) {
                    prepared_request.set( header_name, header_value );
                } );
            }

            if( request_options.body ) {
                prepared_request.send( request_options.body );
            }

            return prepared_request;
        };

        var _validateDictionary = function( response_body, response_options_body, allow_unspecified_keys ) {
            if( response_options_body ) {
                assert.isDefined( response_body, new ValidationError( 'response_validation: body should not be null' ) );

                if( !allow_unspecified_keys ) {
                    // Validate that all response_body keys are contained in response_options_body
                    _.each( response_body, function( response_value, response_key ) {
                        assert.property( response_options_body, response_key, new ValidationError( 'response_validation: body should not contain a key not specified in validation body' ) );
                    } );
                }

                // Validate values / requiredness of keys
                _.each( response_options_body, function( expected_options, expected_key ) {
                    // If it's required, make sure that we have it
                    if( !expected_options.hasOwnProperty( 'required' ) || expected_options.required ) {
                        assert.property( response_body, expected_key, new ValidationError( 'response_validation: body should contain required key' ) );
                    }

                    // If we have an expected_value, and a value: make sure they match
                    if( expected_options.hasOwnProperty( 'value' ) && response_body.hasOwnProperty( expected_key ) ) {
                        assert.propertyVal( response_body, expected_key, expected_options.value, new ValidationError( 'response_validation: incorrect value for key in body' ) );
                    }

                    // If we have an expected_type, and a value: make sure they match
                    if( expected_options.hasOwnProperty( 'type' ) && response_body.hasOwnProperty( expected_key ) ) {
                        if( !( expected_options.allow_null === true && response_body[ expected_key ] === null ) ) {
                            assert.typeOf( response_body[ expected_key ], expected_options.type, new ValidationError( 'response_validation: incorrect type in response body' ) );
                        }    
                    }

                    if( expected_options.hasOwnProperty( 'nested' ) && response_body.hasOwnProperty( expected_key ) ) {
                        if( expected_options.type === 'object' ) {
                            _validateDictionary( response_body[ expected_key ], expected_options.nested );
                        } else if( expected_options.type === 'array' ) {
                            _.each( response_body[ expected_key ], function( response_body_array_i ) {
                                _validateDictionary( response_body_array_i, expected_options.nested );
                            } );
                        }
                    }
                } );
            } else {
                if( !allow_unspecified_keys ) {
                    // If there is no response_options_body, that means that we should have no body as well
                    assert.isUndefined( response_body, new ValidationError( 'response_validation: body should be null' ) );
                }
            }
        };

        var _addValidations = function( request, response_options, completion_handler ) {
            if( !completion_handler ) completion_handler = function() { console.error( 'trust: Should specify a completion handler' ) };
            request
                .end( function( err, res ) {
                    if( err ) return completion_handler( err );

                    try {
                        assert.propertyVal( res, 'statusCode', response_options.code || 200, 'response_validation: http response code invalid' );

                        assert.property( res, 'headers', 'response_validation: should have headers in response' );
                        assert.property( res.headers, 'content-type', 'response_validation: should have content type in resposne' );
                        assert.match( res.headers[ 'content-type' ], response_options.content_type || /json/, 'response_validation: content type should match'  );

                        assert.typeOf( res.body, response_options.type || 'object', 'response_validation: should be specified type' );

                        if( response_options.type === 'array' ) {
                            _.each( res.body, function( body_array_i ) {
                                _validateDictionary( body_array_i, response_options.body );
                            } );
                        } else if( typeof res.body === 'object' ) {
                            _validateDictionary( res.body, response_options.body, false );
                        }
                        _validateDictionary( res.headers, response_options.headers, true );
                    } catch( err ) {
                        if( response_options.after_handler ) return response_options.after_handler( err, res, completion_handler );
                        return completion_handler( err );
                    }

                    if( response_options.after_handler ) return response_options.after_handler( null, res, completion_handler );
                    return completion_handler();
                } );
        };

        var _nonPromiseTrust = function( request_options, response_options, done ) {
            // Validate the arguments
            return _validateRequestOptions ( request_options )
                .then( _validateResponseOptions ( response_options ) )
                .then( function() {
                    q.try( function() {
                        _addValidations( _prepareRequest( request_options ), response_options, done );
                    } );
                } )
                .catch( function( err ) {
                    if( done !== undefined ) {
                        done( err );
                    }
                } );
        }

        var _promiseTrust = function() {
            var _this = this,
                _arguments = arguments;

            return q.Promise( function( resolve, reject ) {
                var return_value;

                var finished = function( err ) {
                    if( err ) return reject( err );
                    resolve( return_value );
                };

                var old_after_handler = _arguments[ 1 ].after_handler;

                _arguments[ 1 ].after_handler = function( err, res, done ) {
                    if( err ) return done( err );

                    return_value = res.body;

                    if( old_after_handler ) {
                        old_after_handler( err, res, done );
                    } else {
                        done();
                    }
                };

                _nonPromiseTrust( _arguments[ 0 ], _arguments[ 1 ], finished );
            } );
        }

        /**
         * Takes an input option body, and an output option body. Runs the specified webrequest, then validates it according
         * to the specified options
         *
         * @param request_options {Object} Contains options for the web request that will be sent
         * @param request_options.path {String} Path to send request to, will be appended to base_url specified on trust creation
         * @param request_options.method {String} [get, put, post, delete] request type to be sent
         * @param request_options.body {Object} body to be sent in request
         * @param request_options.headers {Object} headers to be sent in request
         * @param response_options Contains options for the validation of the response
         * @param response_options.body.KEY.required {boolean} [response_options.body.KEY.required=true] Whether or not KEY is required in the response body
         * @param response_options.body.KEY.value {Object} The expected value of KEY in the response body
         * @param reqponse_options.body.KEY.nested {Object} nested body validation, should match format of body validations
         * @param response_options.header.KEY.require {boolean} [response_options.header.KEY.required=true] Whether or not KEY is required in the response headers
         * @param response_options.header.KEY.value {Object} The expected value of KEY in the response headers
         * @param response_options.content_type {String} [response_options.content_type=application/json] Expected content type of response
         * @param response_options.code {Number} [response_options.code=200] Expect response code of the response
         * @param response_options.type {String} [response_options.type='object'] Expected response object type, should be 'object' or 'array'
         * @param response_options.after_handler {Function} Function to be run after the request function( err, res, done )
         * @param done {Function} Completion function to be called, will be called with error when fail
         */
        return function _trust( request_options, response_options, done ) {
            if( done ) {
                return _nonPromiseTrust( request_options, response_options, done );
            } else {
                console.log( 'Promise' );
                return _promiseTrust( request_options, response_options );
            }
        }
    };
}) ();
 at SyntaxError: Unexpected token (8:8)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseBlock (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:981:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/trust-rest/node_modules/trust-rest/index.js. Coverage (Term): 74% Coverage (LOC): 100%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
