/root/Targets/ddp-dump
└─┬ ddp-dump@0.1.6 
  ├─┬ async@2.5.0 
  │ └── lodash@4.17.4 
  ├─┬ ddp@0.12.1 
  │ ├── ddp-ejson@0.8.1-3 
  │ ├── ddp-underscore-patched@0.8.1-2 
  │ ├─┬ faye-websocket@0.11.0 
  │ │ └─┬ websocket-driver@0.7.0 
  │ │   ├── http-parser-js@0.4.8 
  │ │   └── websocket-extensions@0.1.2 
  │ └─┬ request@2.74.0 
  │   ├── aws-sign2@0.6.0 
  │   ├── aws4@1.6.0 
  │   ├─┬ bl@1.1.2 
  │   │ └─┬ readable-stream@2.0.6 
  │   │   ├── core-util-is@1.0.2 
  │   │   ├── inherits@2.0.3 
  │   │   ├── isarray@1.0.0 
  │   │   ├── process-nextick-args@1.0.7 
  │   │   ├── string_decoder@0.10.31 
  │   │   └── util-deprecate@1.0.2 
  │   ├── caseless@0.11.0 
  │   ├─┬ combined-stream@1.0.5 
  │   │ └── delayed-stream@1.0.0 
  │   ├── extend@3.0.1 
  │   ├── forever-agent@0.6.1 
  │   ├── form-data@1.0.1 
  │   ├─┬ har-validator@2.0.6 
  │   │ ├─┬ chalk@1.1.3 
  │   │ │ ├── ansi-styles@2.2.1 
  │   │ │ ├── escape-string-regexp@1.0.5 
  │   │ │ ├─┬ has-ansi@2.0.0 
  │   │ │ │ └── ansi-regex@2.1.1 
  │   │ │ ├── strip-ansi@3.0.1 
  │   │ │ └── supports-color@2.0.0 
  │   │ ├── commander@2.11.0 
  │   │ ├─┬ is-my-json-valid@2.16.1 
  │   │ │ ├── generate-function@2.0.0 
  │   │ │ ├─┬ generate-object-property@1.2.0 
  │   │ │ │ └── is-property@1.0.2 
  │   │ │ ├── jsonpointer@4.0.1 
  │   │ │ └── xtend@4.0.1 
  │   │ └─┬ pinkie-promise@2.0.1 
  │   │   └── pinkie@2.0.4 
  │   ├─┬ hawk@3.1.3 
  │   │ ├── boom@2.10.1 
  │   │ ├── cryptiles@2.0.5 
  │   │ ├── hoek@2.16.3 
  │   │ └── sntp@1.0.9 
  │   ├─┬ http-signature@1.1.1 
  │   │ ├── assert-plus@0.2.0 
  │   │ ├─┬ jsprim@1.4.1 
  │   │ │ ├── assert-plus@1.0.0 
  │   │ │ ├── extsprintf@1.3.0 
  │   │ │ ├── json-schema@0.2.3 
  │   │ │ └─┬ verror@1.10.0 
  │   │ │   └── assert-plus@1.0.0 
  │   │ └─┬ sshpk@1.13.1 
  │   │   ├── asn1@0.2.3 
  │   │   ├── assert-plus@1.0.0 
  │   │   ├── bcrypt-pbkdf@1.0.1 
  │   │   ├─┬ dashdash@1.14.1 
  │   │   │ └── assert-plus@1.0.0 
  │   │   ├── ecc-jsbn@0.1.1 
  │   │   ├─┬ getpass@0.1.7 
  │   │   │ └── assert-plus@1.0.0 
  │   │   ├── jsbn@0.1.1 
  │   │   └── tweetnacl@0.14.5 
  │   ├── is-typedarray@1.0.0 
  │   ├── isstream@0.1.2 
  │   ├── json-stringify-safe@5.0.1 
  │   ├─┬ mime-types@2.1.17 
  │   │ └── mime-db@1.30.0 
  │   ├── node-uuid@1.4.8 
  │   ├── oauth-sign@0.8.2 
  │   ├── qs@6.2.3 
  │   ├── stringstream@0.0.5 
  │   ├─┬ tough-cookie@2.3.3 
  │   │ └── punycode@1.4.1 
  │   └── tunnel-agent@0.4.3 
  └─┬ nopt@4.0.1 
    ├── abbrev@1.1.1 
    └─┬ osenv@0.1.4 
      ├── os-homedir@1.0.2 
      └── os-tmpdir@1.0.2 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/ddp-dump/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0194 took 1.5382s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected character '#' (1:78) on program #!/usr/bin/env node
'use strict';

var fs = require('fs');
var util = require('util');
var url = require('url');
var async = require('async');
var nopt = require('nopt');
var DDPClient = require('ddp');

var log = console.log;
var error = console.error;

var defaultTimeout = 800;

var options;
var ddp;
var pathToCollectionMapping;

/* Command line related functions */

var cmdOptions = {
  'url': String,
  'host': String,
  'port': Number,
  'ssl': Boolean,
  'user': String,
  'password': String,
  'output': [String, Array],
  'all': Boolean,
  'timeout': Number,
  'compress': Boolean,
  'ddpv': ['1', 'pre2', 'pre1'],
  'sockjs': Boolean,
  'verbose': Boolean,
  'debug': Boolean,
  'version': Boolean,
  'help': Boolean
};

var shorthands = {
  'u': ['--url'],
  'h': ['--host'],
  'p': ['--port'],
  's': ['--ssl'],
  'U': ['--user'],
  'P': ['--password'],
  'o': ['--output'],
  'a': ['--all'],
  't': ['--timeout'],
  'c': ['--compress'],
  'd': ['--ddpv'],
  'S': ['--sockjs'],
  'v': ['--verbose'],
  'V': ['--version'],
  '?': ['--help']
};

function usage(){
  log('Usage: ddp-dump [options] [collection(s) to subscribe ...]');
}

function printOptions(){
  log('\nDumps Meteor collections by using Meteor\'s DDP (' +
    'Distributed Data Protocol).');

  log('\nOptions:');
  log('  -u, --url       Websocket endpoint URL');
  log('  -h, --host      Hostname - default: localhost');
  log('  -p, --port      Port - default: 80 or 433 if SSL is true');
  log('  -s, --ssl       SSL - default: false');
  log('  -U, --user      Username');
  log('  -P, --password  Password');
  log('  -a, --all       Include all collections that are received');
  log('  -o, --output    Output JSON file(s), otherwise will dump to stdout');
  log('                  Note: %s will be replaced by the collection name');
  log('                  and multiple collections will be merged to one');
  log('                  big JSON structure when only one file is given');
  log('  -t, --timeout   How long to wait for data after the last');
  log('                  message (in ms) - default: ' + defaultTimeout);
  log('                  if -all is set, otherwise 0');
  log('  -c, --compress  Compress JSON - default: false');
  log('  -d, --ddpv      DDP Protocol Version (1, pre2, pre1) - default: 1');
  log('  -S, --sockjs    Use the SockJs protocol - default: false');
  log('  -?, --help      Display a help message and exit.');
  log('  -v, --verbose   Verbose mode.');
  log('      --debug     Debug mode.');
  log('  -V, --version   Display version information and exit.');

  log('\nExamples:');
  log('  Dump all collections of the local Meteor WebSocket server:');
  log('    ddp-dump --all');
  log('    ddp-dump --all > all_collections.json');
  log('    ddp-dump --all -o col_%s.json');
  log('');
  log('  Dump a specific collection:');
  log('    ddp-dump cats > cats.json');
  log('    ddp-dump -h localhost -p 80 cats > cats.json');
  log('    ddp-dump -u ws://local cats --all -o cats_and_others.json');
  log('    ddp-dump -h example.org --ssl dogs > dogs.json');
  log('    ddp-dump -u wss://example.org lizards -o %s.json');
  log('');
  log('  Merge multiple collections to one JSON:');
  log('    ddp-dump -h meteor.local cats dogs lizards > cute_animals.json');
  log('    ddp-dump -h meteor.local cats dogs lizards -o cute_animals.json');
  log('');
  log('  Save collections to separate JSON files:');
  log('    ddp-dump -h meteor.local -o cats.json -o birds.json cats birds');
  log('    ddp-dump -h meteor.local -o %s.json cats birds');
}

function info(){
  log(util.format.apply(null, arguments));
}

function processWebsocketUrl(wsUrl, o){
  var u = url.parse(wsUrl);
  if (u.protocol !== 'wss:' && u.protocol !== 'ws:'){
    o.error = util.format('Unknown protocol "%s"', u.protocol);
    return false;
  }
  o.ssl = (u.protocol === 'wss:');
  o.port = u.port;
  o.host = u.hostname;
  return true;
}

function processCliOptions(o){
  // Apply data from an websocket URL
  // (URLs override host and port options)
  if (o.url){
    if (!processWebsocketUrl(o.url, o)){
      return;
    }
  }

  // Set defaults
  o.host = o.host ? o.host : 'localhost';

  if (!o.port) {
    o.port = o.ssl ? 443 : 80;
  }

  if (!o.timeout) {
    o.timeout = o.all ? defaultTimeout : 0;
  }

  o.ddpv = o.ddpv ? o.ddpv : '1';

  // Process output file settings
  o.files = o.output ? o.output : [];
  o.saveToFile = o.files.length > 0;
  o.mergeCollections = true;
}

function processFileOutputOptions(o){

  if (o.files[0].indexOf('%s') !== -1){
    // Handle '%s' output options
    o.mergeCollections = false;

    if (o.files.length > 1){
      o.error = 'Only one output option is supported when using "%s".';
      return;
    }

    // Fill files array with '%s' entry if collections are given
    if (o.colls.length > 0){
      o.files = o.colls.map(function(){
        return o.files[0];
      });
    }

  } else if (o.files.length === o.colls.length) {
    // Write every collection to the matching file
    o.mergeCollections = false;

  } else if (o.files.length > 1){
    o.error = 'More output files then collections given.';
    return;
  }
  // else => only one filepath without %s given
}

function printConnectionInfo(o){
  var ws = {
    protocol: o.ssl ? 'wss:' : 'ws:',
    slashes: true,
    port: o.port,
    hostname: o.host
  };

  info(
    'Connecting to: %s (DDP Version %s)%s',
    url.format(ws),
    o.ddpv,
    o.sockjs ? ' (SockJS enabled)' : ''
  );
}

/* I/O functions */

function stringify(v, compress){
  if (compress){
    return JSON.stringify(v);
  }
  return JSON.stringify(v, null, 2);
}

function writeLog(path, data, compress, cb){
  log(stringify(data, compress));
  cb();
}

function writeJSON(path, data, compress, cb){

  if (Object.keys(data).length === 0){
    info('Skipped empty file "%s"', path);
    cb();
    return;
  }

  info('Writing data to file "%s"', path);
  fs.writeFile(path, stringify(data, compress), cb);
}

function formatPath(filename, name){
  if (typeof filename === 'undefined' || filename === ''){
    filename = '%s.json';
  }
  if (filename.indexOf('%') !== -1){
    filename = util.format(filename, name);
  }
  return filename;
}

function generateFilename(collName, i){
  // null == Console output
  var path = null;
  if (options.saveToFile){
    path = formatPath(
      options.mergeCollections ? options.files[0] : options.files[i],
      collName
    );
  }
  return path;
}

/* Main functions */

function addPathToMapping(mapping, path, collName){
  if (!mapping[path]){
    mapping[path] = [];
  }

  mapping[path].push(collName);
  return mapping;
}

function subscribeToCollection(name, callback){
  info('Subscribing to collection: %s', name);
  ddp.subscribe(name, [], function (err) {
    callback(null, { name: name, err: err });
  });
}

// We need to wait a bit because there is no 'all-data-received' event
// or something similar. So if the user wants to capture all the data
// that the Meteor server sends after connecting this was the only
// solution I found. You are welcome to suggest a better way.
function waitForTimeout(){
  setTimeout(function(){
    var now = new Date();
    if (now.getTime() - options.lastMessageDate.getTime() > options.timeout){
      receivedLastDDPMessage();
    } else {
      waitForTimeout();
    }
  }, options.timeout);
}

function processSubResults(err, results){
  results.map(function(r){
    if (r.err !== undefined){
      // Exit here?
      error(
        'Error: Could not subscribe to collection "%s":\n%s',
        r.name,
        r.err.message
      );
    } else {
      var rowCount = Object.keys(ddp.collections[r.name] || {}).length;
      info('Subscription of "%s" was successful (%s rows)', r.name, rowCount);
    }
  });

  waitForTimeout();
}

function receivedLastDDPMessage(){
  if (options.all && Object.keys(ddp.collections).length > 0){
    // Add all unknown and new collections to our mapping
    Object.keys(ddp.collections).map(function(collName){
      if (options.colls.indexOf(collName) === -1){
        var rowCount = Object.keys(ddp.collections[collName] || {}).length;
        info('Received unknown collection "%s" (%s rows)', collName, rowCount);
        var path = generateFilename(collName, 0);
        addPathToMapping(pathToCollectionMapping, path, collName);
        options.colls.push(collName);
      }
    });
  }

  var filepaths = Object.keys(pathToCollectionMapping);
  if (filepaths.length === 0){
    info('No collections received');
  }

  if (options.saveToFile){
    info('Writing collections to file(s):');
  }

  async.map(filepaths, writeData, finish);
}

function writeData(path, callback){

  var buffer = pathToCollectionMapping[path].reduce(function(data, col){

    if (ddp.collections[col] === undefined){
      // info('Warning: Collection "%s" doesn\'t exist.', col);
      // (Removed because the subscribe command will probably
      // also fail and output a message to the user)
      return data;
    }

    data[col] = ddp.collections[col];
    return data;
  }, {});

  var writer = options.saveToFile ? writeJSON : writeLog;
  writer(path, buffer, options.compress, callback);
}

function finish(err){
  if (err){
    log('An error occured during saving of files:');
    log(err);
  }
  ddp.close();
}

function login(user, password, cb){
  var loginData = {
    user: { username: user },
    password: password
  };

  info('Trying to login as user "%s"', user);

  ddp.call('login', [ loginData ], function (err, result) {
    if (err !== undefined){
      cb('Login error', err);
    } else {
      cb(null, result);
    }
  });
}

/* Main application logic */

options = nopt(cmdOptions, shorthands);

if (!options.verbose){
  // Silence messages ;)
  info = function(){};
}

if (options.version){
  log(require('./package').version);
  return process.exit(0);
}

if (options.help){
  usage();
  printOptions();
  return process.exit(0);
}

options.colls = options.argv.remain;

if (options.colls.length === 0 && !options.all){
  error('Error: Please specify at least one collection');
  error('or use the --all option.\n');
  usage();
  log('\nTry `ddp-dump --help´ for more information.');
  return process.exit(1);
}

processCliOptions(options);

if (options.saveToFile){
  processFileOutputOptions(options);
}

if (options.error){
  error('Error: %s', options.error);
  return process.exit(1);
}

// Create a 'JSON output path' => [collections...] mapping to
// simplify the export code
pathToCollectionMapping = options.colls.reduce(function(mapping, collName, i){
  var path = generateFilename(collName, i);
  addPathToMapping(mapping, path, collName);
  return mapping;
}, {});

if (options.verbose){
  printConnectionInfo(options);
}

/* Etablish DDP connection */

options.lastMessageDate = new Date();

ddp = new DDPClient({
  host: options.host,
  port: options.port,
  ssl: options.ssl || false,
  maintainCollections: true,
  ddpVersion: options.ddpv,
  useSockJs: options.sockjs && true
});

ddp.on('message', function(msg) {
  options.lastMessageDate = new Date();
  if (options.debug){
    log('Received DDP message: ', msg);
  }
});

// Connect to the Meteor Server
ddp.connect(function(ddpErr) {

  if (ddpErr) {
    info('Error: DDP connection failed');
    return;
  }

  info('DDP connection was successful');

  var run = function(){
    if (options.colls.length === 0){
      // Wait for DDP to send some collection data
      waitForTimeout();
    } else {
      // Subscribe to all collections given by the user
      async.map(options.colls, subscribeToCollection, processSubResults);
    }
  };

  if (options.user && options.password){
    login(options.user, options.password, function(err, data){
      if (err){
        error(err);
        error(data);
        finish();
      } else {
        info('Login was successful');
        info('Received authentication token "%s"', data.token);
        run();
      }
    });

  } else {
    run();
  }
});

if (options.verbose){
  ddp.on('socket-close', function(code, message) {
    log('Connection closed: %s %s', code, message);
  });
}

ddp.on('socket-error', function(err) {
  log(err.message);
});
 at SyntaxError: Unexpected character '#' (1:78)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$7.getTokenFromCode (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2756:10)
    at Parser.pp$7.readToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2477:17)
    at Parser.readToken (/root/ExpoSE/lib/Tropigate/bin/Tokens.js:124:26)
    at Parser.pp$7.nextToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2468:15)
    at Parser.pp$7.next (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2413:10)
    at Parser.pp.eat (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:536:12)
    at Parser.pp.semicolon (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:581:15)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:918:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
