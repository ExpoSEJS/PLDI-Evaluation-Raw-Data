/root/Targets/animated-text-input
└── animated-text-input@1.0.2 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/animated-text-input/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0924 took 2.6112s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (168:12) on program 'use strict';

import React from 'react';
import BlinkingCursor from './BlinkingCursor';

export default React.createClass ({
    _textIndex: 0,
    _charIndex: 0,
    _deleting: false,

    propTypes: {
        // The texts to animate.
        texts: React.PropTypes.array,

        // The pause time for 'typing' each letter in ms.
        typeInterval: React.PropTypes.number,

        // The pause time for 'pressing delete key' in ms.
        deleteInterval: React.PropTypes.number,

        // The pause time before deleting, and before typing new text in ms.
        interTextInterval: React.PropTypes.number,

        // The interval for the blinking cursor to blink
        blinkInterval: React.PropTypes.number,

        // The variations for typeInterval.
        // The final type pause time will be in the range of
        // [typeInterval - speedVariation, typeInterval + speedVariation]
        speedVariation: React.PropTypes.number,

        // Loop through the texts again & again
        loop: React.PropTypes.bool
    },

    getDefaultProps () {
        return {
            texts: [''],
            typeInterval: 125,
            deleteInterval: 80,
            interTextInterval: 1000,
            blinkInterval: 500,
            speedVariation: 100,
            loop: false
        };
    },

    getInitialState () {
        return {
            text: 'this._getFirstLetter()'
        };
    },

    componentDidMount () {
        this.letterInterval = setInterval(this._tick, this._getFinalTypeInterval());
    },

    componentWillUnMount () {
        clearInterval(this.letterInterval);
    },

    _tick () {
        clearInterval(this.letterInterval);

        if (this._deleting) {
            this.letterInterval = setInterval(this._tick, this.props.deleteInterval);
            this._delete();
        }
        else {
            this.letterInterval = setInterval(this._tick, this._getFinalTypeInterval());
            this._type();
        }
    },

    _type () {
        let textCharCount = this.props.texts[this._textIndex].length;
        let displayText;
        let toNewText = false;

        this._charIndex++;

        if (this._charIndex >= textCharCount) {
            this._charIndex--;

            if (this._textIndex >= this.props.texts.length - 1) {    // Complete one loop
                if (this.props.loop) {
                    toNewText = true;
                }
                else {  // End
                    clearInterval(this.letterInterval);
                    return ;
                }
            }
            else {  // Complete one text, and move to next
                toNewText = true;
            }
        }
        else {
            displayText = this._getDisplayText(this._charIndex);
        }

        if (toNewText) {
            this._deleting = true;
            this._onInterText();
        }
        else {
            this.setState({
                text: displayText
            });
        }
    },

    _delete () {
        this._charIndex--;
        let displayText;

        if (this._charIndex < 0) {    // Can move to new text
            this._deleting = false;
            this._charIndex = 0;
            this._textIndex++;

            if (this._textIndex >= this.props.texts.length) {
                this._textIndex = 0;
            }

            this._onInterText();

            displayText = '';
        }
        else {  // Keep deleting
            displayText = this._getDisplayText(this._charIndex);
        }

        this.setState({
            text: displayText
        });
    },

    _getDisplayText (nextIndex) {
        let targetText = this.props.texts[this._textIndex];
        return targetText.substring(0, nextIndex+1);
    },

    _onInterText () {
        clearInterval(this.letterInterval);

        let interTextInterval = setInterval(() => {
            this.letterInterval = setInterval(this._tick, this.props.typeInterval);
            clearInterval(interTextInterval);

            this.setState({
                text: this._getDisplayText(this._charIndex)
            });
        }, this.props.interTextInterval);
    },

    _getFirstLetter () {
        return this.props.texts[this._textIndex][0];
    },

    _getFinalTypeInterval () {
        return this.props.typeInterval + (Math.random() - 0.5) * this.props.speedVariation;
    },

    render () {
        let {style, blinkInterval} = this.props;
        return (
            <span>
                <span {...this.props}>{this.state.text}</span>
                <BlinkingCursor
                    style = {style}
                    interval = {blinkInterval}
                    />
            </span>
        );
    }
});
 at SyntaxError: Unexpected token (168:12)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$3.parseExprAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1822:12)
    at Parser.parseExprAtom (/root/ExpoSE/lib/Tropigate/bin/Expression.js:28:30)
    at Parser.pp$3.parseExprSubscripts (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1715:21)
    at Parser.parseMaybeUnary (/root/ExpoSE/lib/Tropigate/bin/Unary.js:34:29)
    at Parser.pp$3.parseExprOps (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1637:21)
    at Parser.pp$3.parseMaybeConditional (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1620:21)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1597:21)
    at Parser.pp$3.parseParenAndDistinguishExpression (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1861:32)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
