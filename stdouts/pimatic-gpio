
> epoll@0.1.22 install /root/Targets/pimatic-gpio/node_modules/epoll
> node-gyp rebuild

make: Entering directory '/root/Targets/pimatic-gpio/node_modules/epoll/build'
  CXX(target) Release/obj.target/epoll/src/epoll.o
  SOLINK_MODULE(target) Release/obj.target/epoll.node
  COPY Release/epoll.node
make: Leaving directory '/root/Targets/pimatic-gpio/node_modules/epoll/build'
/root/Targets/pimatic-gpio
├── UNMET PEER DEPENDENCY pimatic@>=0.9.0 <1.0.0
└─┬ pimatic-gpio@0.9.0 
  └─┬ onoff@1.1.7 
    └─┬ epoll@0.1.22 
      ├── bindings@1.2.1 
      └── nan@2.6.2 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/pimatic-gpio/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0423 took 1.5559s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (1:102) on program module.exports = (env) ->

  # * pimatic imports.
  Promise = env.require 'bluebird'
  assert = env.require 'cassert'
  _ = env.require 'lodash'

  Gpio = env.Gpio or require('onoff').Gpio
  Promise.promisifyAll(Gpio.prototype)

  class GpioPlugin extends env.plugins.Plugin

    init: (app, @framework, @config) ->

      deviceConfigDef = require("./device-config-schema")

      @framework.deviceManager.registerDeviceClass("GpioPresence", {
        configDef: deviceConfigDef.GpioPresence, 
        createCallback: (config, lastState) => new GpioPresence(config, lastState)
      })

      @framework.deviceManager.registerDeviceClass("GpioContact", {
        configDef: deviceConfigDef.GpioContact, 
        createCallback: (config, lastState) => new GpioContact(config, lastState)
      })

      @framework.deviceManager.registerDeviceClass("GpioSwitch", {
        configDef: deviceConfigDef.GpioSwitch, 
        createCallback: (config, lastState) => new GpioSwitch(config, lastState)
      })


  plugin = new GpioPlugin

  class GpioSwitch extends env.devices.PowerSwitch

    constructor: (@config, lastState) ->
      @name = @config.name
      @id = @config.id

      if @config.defaultState?
        @_state = @config.defaultState
      else
        @_state = lastState?.state?.value or false

      stateToSet = (if @config.inverted then not @_state else @_state)
      options =
        debounceTimeout: @config.debounceTimeout if @config.debounceTimeout?
      @gpio = new Gpio @config.gpio, (if stateToSet then "high" else "low"), options
      super()

    destroy: () ->
      @gpio.unwatchAll()
      @gpio.unexport()
      super()

    getState: () ->
      if @_state? then Promise.resolve @_state
      @gpio.readAsync().then( (value) =>
        _state = (if value is 1 then yes else no)
        if @config.inverted then @_state = not _state
        else @_state = _state
        return @_state
      )

        
    changeStateTo: (state) ->
      assert state is on or state is off
      if @config.inverted then _state = not state
      else _state = state
      @gpio.writeAsync(if _state then 1 else 0).then( () =>
        @_setState(state)
      )

  # ##GpioContact Sensor
  class GpioContact extends env.devices.ContactSensor

    constructor: (@config, lastState) ->
      @id = @config.id
      @name = @config.name
      options =
        debounceTimeout: @config.debounceTimeout if @config.debounceTimeout?
      @gpio = new Gpio(@config.gpio, 'in', 'both', options)
      @_contact = lastState?.contact?.value or false

      @_readContactValue().catch( (error) =>
        env.logger.error error.message
        env.logger.debug error.stack
      )

      @gpio.watch (err, value) =>
        if err?
          env.logger.error err.message
          env.logger.debug err.stack
        else
          @_setContactValue value
      super()

    destroy: () ->
      @gpio.unwatchAll()
      @gpio.unexport()
      super()

    _setContactValue: (value) ->
      assert value is 1 or value is 0
      state = (if value is 1 then yes else no)
      if @config.inverted then state = not state
      @_setContact state

    _readContactValue: ->
      @gpio.readAsync().then( (value) =>
        @_setContactValue value
        return @_contact 
      )

    getContact: () -> if @_contact? then Promise.resolve(@_contact) else @_readContactValue()

  # ##GpioPresence Sensor
  class GpioPresence extends env.devices.PresenceSensor

    constructor: (@config, lastState) ->
      @id = @config.id
      @name = @config.name
      options =
        debounceTimeout: @config.debounceTimeout if @config.debounceTimeout?
      @gpio = new Gpio(@config.gpio, 'in', 'both', options)
      @_presence = lastState?.presence?.value or false

      @_readPresenceValue().catch( (error) =>
        env.logger.error error.message
        env.logger.debug error.stack
      )

      @gpio.watch (err, value) =>
        if err?
          env.logger.error err.message
          env.logger.debug err.stack
        else
          @_setPresenceValue value
      super()

    destroy: () ->
      @gpio.unwatchAll()
      @gpio.unexport()
      super()

    _setPresenceValue: (value) ->
      assert value is 1 or value is 0
      state = (if value is 1 then yes else no)
      if @config.inverted then state = not state
      @_setPresence state

    _readPresenceValue: ->
      @gpio.readAsync().then( (value) =>
        @_setPresenceValue value
        return @_presence 
      )

    getPresence: () -> if @_presence? then Promise.resolve(@_presence) else @_readPresenceValue()


  # For testing...
  plugin.GpioSwitch = GpioSwitch
  plugin.GpioPresence = GpioPresence

  return plugin at SyntaxError: Unexpected token (1:102)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$3.parseExprAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1822:12)
    at Parser.parseExprAtom (/root/ExpoSE/lib/Tropigate/bin/Expression.js:28:30)
    at Parser.pp$3.parseExprSubscripts (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1715:21)
    at Parser.parseMaybeUnary (/root/ExpoSE/lib/Tropigate/bin/Unary.js:34:29)
    at Parser.pp$3.parseExprOp (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1656:43)
    at Parser.pp$3.parseExprOps (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1639:17)
    at Parser.pp$3.parseMaybeConditional (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1620:21)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1597:21)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
