
> secp256k1@2.0.10 install /root/Targets/bitmessage/node_modules/secp256k1
> npm run rebuild


> secp256k1@2.0.10 rebuild /root/Targets/bitmessage/node_modules/secp256k1
> node-gyp rebuild

make: Entering directory '/root/Targets/bitmessage/node_modules/secp256k1/build'
  CXX(target) Release/obj.target/secp256k1/src/addon.o
  CXX(target) Release/obj.target/secp256k1/src/secretkey.o
  CXX(target) Release/obj.target/secp256k1/src/publickey.o
  CXX(target) Release/obj.target/secp256k1/src/signature.o
  CXX(target) Release/obj.target/secp256k1/src/sign.o
  CXX(target) Release/obj.target/secp256k1/src/verify.o
  CXX(target) Release/obj.target/secp256k1/src/recover.o
  CXX(target) Release/obj.target/secp256k1/src/ecdh.o
  CC(target) Release/obj.target/secp256k1/src/secp256k1-src/src/secp256k1.o
  CC(target) Release/obj.target/secp256k1/src/secp256k1-src/contrib/lax_der_privatekey_parsing.o
  SOLINK_MODULE(target) Release/obj.target/secp256k1.node
  COPY Release/secp256k1.node
make: Leaving directory '/root/Targets/bitmessage/node_modules/secp256k1/build'

> bignum@0.11.0 install /root/Targets/bitmessage/node_modules/bignum
> node-gyp configure build

make: Entering directory '/root/Targets/bitmessage/node_modules/bignum/build'
  CXX(target) Release/obj.target/bignum/bignum.o
  SOLINK_MODULE(target) Release/obj.target/bignum.node
  COPY Release/bignum.node
make: Leaving directory '/root/Targets/bitmessage/node_modules/bignum/build'

> eccrypto@1.0.3 install /root/Targets/bitmessage/node_modules/eccrypto
> node-gyp rebuild || exit 0

make: Entering directory '/root/Targets/bitmessage/node_modules/eccrypto/build'
  CXX(target) Release/obj.target/ecdh/ecdh.o
  SOLINK_MODULE(target) Release/obj.target/ecdh.node
  COPY Release/ecdh.node
make: Leaving directory '/root/Targets/bitmessage/node_modules/eccrypto/build'

> bitmessage@0.6.6 install /root/Targets/bitmessage/node_modules/bitmessage
> node-gyp rebuild || exit 0

make: Entering directory '/root/Targets/bitmessage/node_modules/bitmessage/build'
  CXX(target) Release/obj.target/worker/src/worker.o
  CXX(target) Release/obj.target/worker/src/pow.o
  SOLINK_MODULE(target) Release/obj.target/worker.node
  COPY Release/worker.node
make: Leaving directory '/root/Targets/bitmessage/node_modules/bitmessage/build'
/root/Targets/bitmessage
└─┬ bitmessage@0.6.6 
  ├── bignum@0.11.0 
  ├── bn.js@3.3.0 
  ├── bs58@2.0.1 
  ├── buffer-equal@0.0.2 
  ├─┬ eccrypto@1.0.3 
  │ ├─┬ elliptic@6.4.0 
  │ │ ├── bn.js@4.11.8 
  │ │ ├── brorand@1.1.0 
  │ │ ├── hmac-drbg@1.0.1 
  │ │ └── minimalistic-crypto-utils@1.0.1 
  │ └─┬ secp256k1@2.0.10 
  │   ├── bindings@1.3.0 
  │   ├── bluebird@3.5.1 
  │   ├── bn.js@4.11.8 
  │   └── object-assign@4.1.1 
  ├── es6-promise@3.3.1 
  ├─┬ hash.js@1.1.3 
  │ ├── inherits@2.0.3 
  │ └── minimalistic-assert@1.0.0 
  ├── nan@2.7.0 
  ├── object-assign@2.1.1 
  ├─┬ sha.js@2.4.9 
  │ └── safe-buffer@5.1.1 
  └── webworkify@1.4.0 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/bitmessage/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0939 took 4.6779s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (6:4) on program // NOTE(Kagami): End-users shouldn't import this module. While it
// exports some helper routines, its API is _not_ stable.

"use strict";

var assert = exports.assert = function(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
};

exports.PROTOCOL_VERSION = 3;

// Missing methods to read/write 64 bits integers from/to buffers.
// TODO(Kagami): Use this helpers in structs, pow, platform.

var MAX_SAFE_INTEGER = exports.MAX_SAFE_INTEGER = 9007199254740991;

exports.readUInt64BE = function(buf, offset, noAssert) {
  offset = offset || 0;
  var hi = buf.readUInt32BE(offset, noAssert);
  var lo = buf.readUInt32BE(offset + 4, noAssert);
  // Max safe number = 2^53 - 1 =
  // 0b0000000000011111111111111111111111111111111111111111111111111111
  // = 2097151*(2^32) + (2^32 - 1).
  // So it's safe until hi <= 2097151. See
  // <http://mdn.io/issafeinteger>, <https://stackoverflow.com/q/307179>
  // for details.
  assert(noAssert || hi <= 2097151, "Unsafe integer");
  return hi * 4294967296 + lo;
};

var readTimestamp64BE = exports.readTimestamp64BE = function(buf, offset) {
  offset = offset || 0;
  var timeHi = buf.readUInt32BE(offset);
  var timeLo = buf.readUInt32BE(offset + 4);
  // JavaScript's Date object can't work with timestamps higher than
  // 8640000000000 (~2^43, ~275760 year). Hope JavaScript will support
  // 64-bit numbers up to this date.
  assert(timeHi <= 2011, "Time is too high");
  assert(timeHi !== 2011 || timeLo <= 2820767744, "Time is too high");
  return timeHi * 4294967296 + timeLo;
};

exports.readTime64BE = function(buf, offset) {
  var timestamp = readTimestamp64BE(buf, offset);
  return new Date(timestamp * 1000);
};

function writeUInt64BE(buf, value, offset, noAssert) {
  buf = buf || new Buffer(8);
  offset = offset || 0;
  assert(noAssert || value <= MAX_SAFE_INTEGER, "Unsafe integer");
  buf.writeUInt32BE(Math.floor(value / 4294967296), offset, noAssert);
  buf.writeUInt32BE(value % 4294967296, offset + 4, noAssert);
  return buf;
}
exports.writeUInt64BE = writeUInt64BE;

exports.writeTime64BE = function(buf, time, offset, noAssert) {
  var timestamp = Math.floor(time.getTime() / 1000);
  return writeUInt64BE(buf, timestamp, offset, noAssert);
};

exports.tnow = function() {
  var time = new Date();
  return Math.floor(time.getTime() / 1000);
};

var DEFAULT_TRIALS_PER_BYTE = exports.DEFAULT_TRIALS_PER_BYTE = 1000;
var DEFAULT_EXTRA_BYTES = exports.DEFAULT_EXTRA_BYTES = 1000;

exports.getTrials = function(opts) {
  var nonceTrialsPerByte = opts.nonceTrialsPerByte;
  // Automatically raise lower values per spec.
  if (!nonceTrialsPerByte || nonceTrialsPerByte < DEFAULT_TRIALS_PER_BYTE) {
    nonceTrialsPerByte = DEFAULT_TRIALS_PER_BYTE;
  }
  return nonceTrialsPerByte;
};

exports.getExtraBytes = function(opts) {
  var payloadLengthExtraBytes = opts.payloadLengthExtraBytes;
  // Automatically raise lower values per spec.
  if (!payloadLengthExtraBytes ||
      payloadLengthExtraBytes < DEFAULT_EXTRA_BYTES) {
    payloadLengthExtraBytes = DEFAULT_EXTRA_BYTES;
  }
  return payloadLengthExtraBytes;
};

exports.popkey = function(obj, key) {
  var value = obj[key];
  delete obj[key];
  return value;
};

// See https://en.wikipedia.org/wiki/IPv6#IPv4-mapped_IPv6_addresses
var IPv4_MAPPING = new Buffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255]);
exports.IPv4_MAPPING = IPv4_MAPPING;

// Very simple inet_pton(3) equivalent.
exports.inet_pton = function(str) {
  var buf = new Buffer(16);
  buf.fill(0);
  // IPv4-mapped IPv6.
  if (str.slice(0, 7) === "::ffff:") {
    str = str.slice(7);
  }
  // IPv4.
  if (str.indexOf(":") === -1) {
    IPv4_MAPPING.copy(buf);
    var octets = str.split(/\./g).map(function(o) {
      assert(/^\d+$/.test(o), "Bad octet");
      return parseInt(o, 10);
    });
    // Support short form from inet_aton(3) man page.
    if (octets.length === 1) {
      buf.writeUInt32BE(octets[0], 12);
    } else {
      // Check against 1000.bad.addr
      octets.forEach(function(octet) {
        assert(octet >= 0, "Bad IPv4 address");
        assert(octet <= 255, "Bad IPv4 address");
      });
      if (octets.length === 2) {
        buf[12] = octets[0];
        buf[15] = octets[1];
      } else if (octets.length === 3) {
        buf[12] = octets[0];
        buf[13] = octets[1];
        buf[15] = octets[2];
      } else if (octets.length === 4) {
        buf[12] = octets[0];
        buf[13] = octets[1];
        buf[14] = octets[2];
        buf[15] = octets[3];
      } else {
        throw new Error("Bad IPv4 address");
      }
    }
  // IPv6.
  } else {
    var dgroups = str.split(/::/g);
    // Check against 1::1::1
    assert(dgroups.length <= 2, "Bad IPv6 address");
    var groups = [];
    var i;
    if (dgroups[0]) {
      groups.push.apply(groups, dgroups[0].split(/:/g));
    }
    if (dgroups.length === 2) {
      if (dgroups[1]) {
        var splitted = dgroups[1].split(/:/g);
        var fill = 8 - (groups.length + splitted.length);
        // Check against 1:1:1:1::1:1:1:1
        assert(fill > 0, "Bad IPv6 address");
        for (i = 0; i < fill; i++) {
          groups.push(0);
        }
        groups.push.apply(groups, splitted);
      } else {
        // Check against 1:1:1:1:1:1:1:1::
        assert(groups.length <= 7, "Bad IPv6 address");
      }
    } else {
      // Check against 1:1:1
      assert(groups.length === 8, "Bad IPv6 address");
    }
    for (i = 0; i < Math.min(groups.length, 8); i++) {
      // Check against parseInt("127.0.0.1", 16) -> 295
      assert(/^[0-9a-f]+$/.test(groups[i]), "Bad group");
      buf.writeUInt16BE(parseInt(groups[i], 16), i * 2);
    }
  }
  return buf;
};
 at SyntaxError: Unexpected token (6:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/bitmessage/node_modules/bitmessage/lib/index.js. Coverage (Term): 28% Coverage (LOC): 45%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
