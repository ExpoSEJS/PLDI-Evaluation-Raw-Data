/root/Targets/pipeish
└── pipeish@0.0.1 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/pipeish/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 34% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0563 took 3.1216s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Assigning to arguments in strict mode (85:10) on program // Autocurry: Thanks fitzgen!
;(function(glob) {
  var toArray = function(arr, from) {
        return Array.prototype.slice.call(arr, from || 0);
      }

    , curry = function(fn) {
        var args = toArray(arguments, 1);
        return function() {
          return fn.apply(this, args.concat(toArray(arguments)));
        };
      }

   , autoCurry = function (fn, numArgs) {
      numArgs = numArgs || fn.length;
      var f = function () {
        if (arguments.length < numArgs) {
          return numArgs - arguments.length > 0 ?
            autoCurry(curry.apply(this, [fn].concat(toArray(arguments))),
            numArgs - arguments.length) :
            curry.apply(this, [fn].concat(toArray(arguments)));
        } else {
          return fn.apply(this, arguments);
        }
      };
      f.toString = function(){ return fn.toString(); };
      f.curried = true;
      f.arity = fn.length; // can't seem to set .length of f
      return f;
    }

  Function.prototype.autoCurry = function(n) {
    return autoCurry(this, n);
  };
})(this);


// Partial application, thanks osteele!
(function() {

  if (!Array.slice) { // mozilla already supports this
      Array.slice = (function(slice) {
          return function(object) {
              return slice.apply(object, slice.call(arguments, 1));
          };
      })(Array.prototype.slice);
  }     

  var _ = Function._ = {};

  Function.prototype.partial = function(/*args*/) {
      var fn = this;
      var _ = Function._;
      var args = Array.slice(arguments, 0);
      //substitution positions
      var subpos = [], value;
      for (var i = 0; i < arguments.length; i++)
          arguments[i] == _ && subpos.push(i);
      return function() {
          var specialized = args.concat(Array.slice(arguments, subpos.length));
          for (var i = 0; i < Math.min(subpos.length, arguments.length); i++)
              specialized[subpos[i]] = arguments[i];
          for (var i = 0; i < specialized.length; i++)
              if (specialized[i] == _)
                  return fn.partial.apply(fn, specialized);
          return fn.apply(this, specialized);
      }
  }
})();

// compose slightly altered to juggle args a little better.
// Really helps w/ applicatives, but true goal would be something like:
// compose(f, g, x) :: (b -> c) -> (a -> b) -> a -> c
// compose(map, map)(f, [[x]]) == map(map(f, [x]), [[x]])
var compose = function() {
      var fns = arguments,
          arglen = fns.length;
          
      return function(){
        for(var i=arglen;--i>=0;) {
          var fn = fns[i]
            , args = fn.length ? Array.prototype.slice.call(arguments, 0, fn.length) : arguments
            , next_args = Array.prototype.slice.call(arguments, (fn.length || 1)); //not right with *args
          next_args.unshift(fn.apply(this,args));
          arguments = next_args;
        }
        return arguments[0];
      }
    }

    parallel =function(){
      var fns = arguments
      , arglen = fns.length;
      return function(x){
        for(var i=arglen;--i>=0;) {
          setTimeout(fns[i].partial(x), 0);
        }

        return arguments[0];
      }
    }

  , dot = function( param, obj ){
      return obj[param];
    }.autoCurry()

  , invoke = function(methodName/*, arguments*/) {
      var args = Array.slice(arguments, 1);
      return function(object) {
        return object[methodName].apply(object, Array.slice(arguments, 1).concat(args));
      }
    }

  , flip = function( fn ){
      return function(){
        var args = Array.slice(arguments, 0).reverse();
        return fn.apply( null, args );
      }.autoCurry(fn.arity || fn.length);
    }

  , multiply = function( x, y ) {
      return x * y;
    }.autoCurry()

  , div = function( x, y ) {
      return x / y;
    }.autoCurry()

  , add = function( x, y ) {
      return x + y;
    }.autoCurry()

  , subtract = function( x, y ) {
      return x - y;
    }.autoCurry()

  , mod = function(x,y) {
      return x % y;
    }.autoCurry()

  , gt = function( x, y ) {
      return x > y;
    }.autoCurry()

  , gte = function( x, y ) {
      return x >= y;
    }.autoCurry()

  , lt = function( x, y ) {
      return x < y;
    }.autoCurry()

  , lte = function( x, y ) {
      return x <= y;
    }.autoCurry()

  , equal = function( x, y ) {
      return x === y;
    }.autoCurry()

  , eq = function( x, y ) {
      return x == y;
    }.autoCurry()

  , S = function(f, g) {
      return function() {
        return f.apply(this, [g.apply(this, arguments)].concat(Array.slice(arguments, 0)));
      }
    }

  , K = function(x){ return function(){ return x; }; }

  , I = function(x){ return x; }
  ;
 at SyntaxError: Assigning to arguments in strict mode (85:10)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$2.checkLVal (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1472:14)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1606:12)
    at Parser.pp$3.parseExpression (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1573:21)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:727:47)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseBlock (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:981:25)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:709:33)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseFor (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1004:22)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/pipeish/node_modules/pipeish/index.js. Coverage (Term): 68% Coverage (LOC): 100%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
