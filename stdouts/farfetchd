/root/Targets/farfetchd
└─┬ farfetchd@0.0.3 
  ├── es6-promise@3.3.1 
  ├─┬ follow-redirects@0.0.7 
  │ ├─┬ debug@2.6.8 
  │ │ └── ms@2.0.0 
  │ └── stream-consume@0.1.0 
  ├── get-headers@1.0.5 
  ├─┬ isomorphic-form-data@0.0.1 
  │ └─┬ form-data@1.0.1 
  │   ├── async@2.5.0 
  │   ├─┬ combined-stream@1.0.5 
  │   │ └── delayed-stream@1.0.0 
  │   └─┬ mime-types@2.1.17 
  │     └── mime-db@1.30.0 
  ├── lodash@4.17.4 
  └─┬ url-parse@1.1.9 
    ├── querystringify@1.0.0 
    └── requires-port@1.0.0 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/farfetchd/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 35% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","call","RegExp","join","binding","Object","WeakMap","create","Set","Array","ArrayBuffer","DataView","Map","resolve","max","now","apply","random","toString","setPrototypeOf"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0624 took 20.8899s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (4:4) on program 'use strict';
var url = require('url');
var debug = require('debug')('follow-redirects');
var assert = require('assert');
var consume = require('stream-consume');

module.exports = function(_nativeProtocols) {
  var nativeProtocols = {};

  var publicApi = {
    maxRedirects: 5
  };

  for (var p in _nativeProtocols) {
    /* istanbul ignore else */
    if (_nativeProtocols.hasOwnProperty(p)) {
      // http://www.ietf.org/rfc/rfc2396.txt - Section 3.1
      assert(/^[A-Z][A-Z\+\-\.]*$/i.test(p), JSON.stringify(p) + ' is not a valid scheme name');
      generateWrapper(p, _nativeProtocols[p]);
    }
  }

  return publicApi;

  function execute(options) {
    var clientRequest;
    var fetchedUrls = [];

    return (clientRequest = cb());

    function cb(res) {
      // skip the redirection logic on the first call.
      if (res) {
        var fetchedUrl = url.format(options);
        fetchedUrls.unshift(fetchedUrl);

        if (!isRedirect(res)) {
          res.fetchedUrls = fetchedUrls;
          return options.userCallback(res);
        }

        // we are going to follow the redirect, but in node 0.10 we must first attach a data listener
        // to consume the stream and send the 'end' event
        consume(res);

        // need to use url.resolve() in case location is a relative URL
        var redirectUrl = url.resolve(fetchedUrl, res.headers.location);
        debug('redirecting to', redirectUrl);

        // clean all the properties related to the old url away, and copy from the redirect url
        wipeUrlProps(options);
        extend(options, url.parse(redirectUrl));
      }

      if (fetchedUrls.length > options.maxRedirects) {
        var err = new Error('Max redirects exceeded.');
        return forwardError(err);
      }

      options.nativeProtocol = nativeProtocols[options.protocol];
      options.defaultRequest = defaultMakeRequest;

      var req = (options.makeRequest || defaultMakeRequest)(options, cb, res);

      if (res) {
        req.on('error', forwardError);
      }
      return req;
    }

    function defaultMakeRequest(options, cb, res) {
      if (res) {
        // This is a redirect, so use only GET methods
        options.method = 'GET';
      }

      var req = options.nativeProtocol.request(options, cb);

      if (res) {
        // We leave the user to call `end` on the first request
        req.end();
      }

      return req;
    }

    // bubble errors that occur on the redirect back up to the initiating client request
    // object, otherwise they wind up killing the process.
    function forwardError (err) {
      clientRequest.emit('error', err);
    }
  }

  function generateWrapper (scheme, nativeProtocol) {
    var wrappedProtocol = scheme + ':';
    var H = function() {};
    H.prototype = nativeProtocols[wrappedProtocol] = nativeProtocol;
    H = new H();
    publicApi[scheme] = H;

    H.request = function(options, callback) {
      return execute(parseOptions(options, callback, wrappedProtocol));
    };

    // see https://github.com/joyent/node/blob/master/lib/http.js#L1623
    H.get = function(options, callback) {
      options = parseOptions(options, callback, wrappedProtocol);
      var req = execute(options);
      req.end();
      return req;
    };
  }

  // returns a safe copy of options (or a parsed url object if options was a string).
  // validates that the supplied callback is a function
  function parseOptions (options, callback, wrappedProtocol) {
    assert.equal(typeof callback, 'function', 'callback must be a function');
    if ('string' === typeof options) {
      options = url.parse(options);
      options.maxRedirects = publicApi.maxRedirects;
    } else {
      options = extend({
        maxRedirects: publicApi.maxRedirects,
        protocol: wrappedProtocol
      }, options);
    }
    assert.equal(options.protocol, wrappedProtocol, 'protocol mismatch');
    options.protocol = wrappedProtocol;
    options.userCallback = callback;

    debug('options', options);
    return options;
  }
};

// copies source's own properties onto destination and returns destination
function extend(destination, source) {
  for (var i in source) {
    if (source.hasOwnProperty(i)) {
      destination[i] = source[i];
    }
  }
  return destination;
}

// to redirect the result must have
// a statusCode between 300-399
// and a `Location` header
function isRedirect (res) {
  return (res.statusCode >= 300 && res.statusCode <= 399 &&
  'location' in res.headers);
}

// nulls all url related properties on the object.
// required on node <10
function wipeUrlProps(options) {
  for (var i = 0, l = urlProps.length; i < l; ++i) {
    options[urlProps[i]] = null;
  }
}
var urlProps = ['protocol', 'slashes', 'auth', 'host', 'port', 'hostname',
  'hash', 'search', 'query', 'pathname', 'path', 'href'];
 at SyntaxError: Unexpected token (4:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/farfetchd/node_modules/farfetchd/lib/fetch.js. Coverage (Term): 61% Coverage (LOC): 65%
*- File /root/Targets/farfetchd/node_modules/lodash/lodash.js. Coverage (Term): 22% Coverage (LOC): 35%
*- File /root/Targets/farfetchd/node_modules/farfetchd/lib/body.js. Coverage (Term): 40% Coverage (LOC): 59%
*- File /root/Targets/farfetchd/node_modules/isomorphic-form-data/lib/index.js. Coverage (Term): 95% Coverage (LOC): 100%
*- File /root/Targets/farfetchd/node_modules/form-data/lib/form_data.js. Coverage (Term): 13% Coverage (LOC): 19%
*- File /root/Targets/farfetchd/node_modules/combined-stream/lib/combined_stream.js. Coverage (Term): 17% Coverage (LOC): 27%
*- File /root/Targets/farfetchd/node_modules/delayed-stream/lib/delayed_stream.js. Coverage (Term): 23% Coverage (LOC): 33%
*- File /root/Targets/farfetchd/node_modules/mime-types/index.js. Coverage (Term): 48% Coverage (LOC): 51%
*- File /root/Targets/farfetchd/node_modules/mime-db/index.js. Coverage (Term): 95% Coverage (LOC): 100%
*- File /root/Targets/farfetchd/node_modules/async/dist/async.js. Coverage (Term): 23% Coverage (LOC): 32%
*- File /root/Targets/farfetchd/node_modules/form-data/lib/populate.js. Coverage (Term): 33% Coverage (LOC): 50%
*- File /root/Targets/farfetchd/node_modules/es6-promise/dist/es6-promise.js. Coverage (Term): 18% Coverage (LOC): 26%
*- File /root/Targets/farfetchd/node_modules/farfetchd/lib/headers.js. Coverage (Term): 36% Coverage (LOC): 61%
*- File /root/Targets/farfetchd/node_modules/farfetchd/lib/request.js. Coverage (Term): 45% Coverage (LOC): 62%
*- File /root/Targets/farfetchd/node_modules/farfetchd/lib/constants.js. Coverage (Term): 97% Coverage (LOC): 100%
*- File /root/Targets/farfetchd/node_modules/farfetchd/lib/response.js. Coverage (Term): 42% Coverage (LOC): 59%
*- File /root/Targets/farfetchd/node_modules/farfetchd/lib/util.js. Coverage (Term): 71% Coverage (LOC): 86%
*- File /root/Targets/farfetchd/node_modules/farfetchd/lib/http/node.js. Coverage (Term): 8% Coverage (LOC): 8%
*- File /root/Targets/farfetchd/node_modules/follow-redirects/index.js. Coverage (Term): 57% Coverage (LOC): 67%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
