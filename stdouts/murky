/root/Targets/murky
└─┬ murky@1.0.1 
  ├─┬ chalk@1.1.3 
  │ ├── ansi-styles@2.2.1 
  │ ├── escape-string-regexp@1.0.5 
  │ ├── has-ansi@2.0.0 
  │ ├── strip-ansi@3.0.1 
  │ └── supports-color@2.0.0 
  ├── error-shortener@1.0.2 
  ├── filesize@3.5.10 
  ├── is-negative-zero@2.0.0 
  ├── lodash@4.17.4 
  ├─┬ pretty-large-ms@1.0.2 
  │ ├─┬ clear-require@1.0.1 
  │ │ ├─┬ caller-path@0.1.0 
  │ │ │ └── callsites@0.2.0 
  │ │ └── resolve-from@1.0.1 
  │ ├── parse-large-ms@1.0.2 
  │ └── pluralize@2.0.0 
  ├── str2num@1.0.4 
  ├─┬ string-render@1.0.5 
  │ └── ansi-regex@2.1.1 
  ├── string-true-oneline@1.0.0 
  ├─┬ string-width@1.0.2 
  │ ├── code-point-at@1.1.0 
  │ └─┬ is-fullwidth-code-point@1.0.0 
  │   └── number-is-nan@1.0.1 
  ├─┬ supports-color@3.2.3 
  │ └── has-flag@1.0.0 
  └─┬ uncolor@0.4.0 
    └─┬ readable-stream@1.1.14 
      ├── core-util-is@1.0.2 
      ├── inherits@2.0.3 
      ├── isarray@0.0.1 
      └── string_decoder@0.10.31 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/murky/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.119 took 6.7337s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (7:4) on program 'use strict';
var handlers_1 = require('./handlers');
var util_1 = require('util');
var lodash_1 = require('lodash');
var uncolor = require('uncolor');
var supportsColor = require('supports-color');
var assert = require('assert');
var murky = function () {
    // like util.format without arguments
    if (arguments.length === 0)
        return '';
    // rawReplacers & fmtStr may be redefined in case if fmtStr is missed
    // look "like util.format without fmtStr" code block
    //
    // fmtStr may be extended in case if count(placeholders(fmtStr)) < rawReplacers.length
    // look "check psInfo and rawReplacer size" code block size
    var args = lodash_1.toArray(arguments);
    var fmtStr = args[0];
    var rawReplacers = args.slice(1);
    if (!lodash_1.isString(fmtStr)) {
        // like util.format without fmtStr
        rawReplacers = args;
        fmtStr = lodash_1.fill(new Array(rawReplacers.length), '%s').join(' ');
    }
    // get placeholders info
    // psInfo may be
    // - truncated in case if psInfo.length gt rawReplacers.length
    // - extended  in case if psInfo.length lt rawReplacer.length
    var psInfo = extractAllPInfo(fmtStr);
    // check psInfo and rawReplacer size
    if (psInfo.length > rawReplacers.length) {
        // murky('%s %s', 123)
        psInfo = psInfo.slice(0, rawReplacers.length);
    }
    else if (psInfo.length < rawReplacers.length) {
        // murky('%s', 123, 345)
        var missedCount = rawReplacers.length - psInfo.length;
        var missedPlaceholders = lodash_1.fill(new Array(missedCount), '%s').join(' ');
        fmtStr = fmtStr + ' ' + missedPlaceholders;
        psInfo = extractAllPInfo(fmtStr);
    }
    // calc result string
    var replacers = [];
    var positions = [];
    var resStr = fmtStr;
    rawReplacers.forEach(function (rawReplacer, index) {
        var pInfo = psInfo[index];
        // calc current replacer position
        var rsLength = replacers
            .slice(0, index)
            .reduce(function (acc, replacer) { return acc + replacer.length; }, 0);
        var psLength = psInfo
            .slice(0, index)
            .reduce(function (acc, pInfo) { return acc + pInfo.placeholder.length; }, 0);
        var fmtPartLength = pInfo.indexStart;
        var position = fmtPartLength - psLength + rsLength;
        // get current replacer
        var replacer = handlers_1.default.processOne(resStr, pInfo, rawReplacer, position);
        // store for next iterations
        replacers.push(replacer);
        positions.push(position);
        // update result string
        var prev = resStr.substring(0, position);
        var post = resStr.substring(position + pInfo.length);
        resStr = prev + replacer + post;
    });
    // normalize resStr
    resStr = resStr.replace(/%%/g, '%');
    // check replacers
    var rsOrderErrors = positions.map(function (posA, indexA) {
        return positions.slice(0, indexA).map(function (posB, indexB) {
            return { posB: posB, indexB: indexB };
        }).filter(function (_a) {
            var posB = _a.posB;
            return posA !== posB;
        }).filter(function (_a) {
            var posB = _a.posB;
            return posA <= posB;
        }).map(function (_a) {
            var posB = _a.posB, indexB = _a.indexB;
            return "wrong replacers order: A should be placed after B:        \n\t A index: " + indexA + "        \n\t B index: " + indexB + "        \n\t A data: " + util_1.inspect(posA) + "        \n\t B data: " + util_1.inspect(posB);
        });
    }).reduce(function (acc, part) { return acc.concat(part); }, []);
    var rsTypeErrors = replacers.map(function (replacer, index) {
        return { replacer: replacer, index: index };
    }).filter(function (_a) {
        var replacer = _a.replacer;
        return !lodash_1.isString(replacer);
    }).map(function (_a) {
        var replacer = _a.replacer, index = _a.index;
        return "replacer must be a string:\n      \n\t index: " + index + "      \n\t type: " + typeof replacer + "      \n\t data: " + util_1.inspect(replacer);
    });
    var rsErrors = rsOrderErrors.concat(rsTypeErrors);
    assert.ok(rsErrors.length === 0, "murky: internal problem: \n " + rsErrors.join('\n '));
    // return result string
    return resStr;
};
// helpers
function extractAllPInfo(fmtStr) {
    // placeholder finders may has problems with %%
    // tmpStr used only to get info about placeholders
    var tmpStr = fmtStr.replace(/%%/g, '  ');
    var psInfo = handlers_1.default.findAll(tmpStr);
    // check placeholders info
    var psInfoOrderErrors = psInfo.map(function (pInfoA, indexA) {
        return psInfo.slice(0, indexA).map(function (pInfoB, indexB) {
            return { pInfoB: pInfoB, indexB: indexB };
        }).filter(function (_a) {
            var pInfoB = _a.pInfoB;
            return pInfoA !== pInfoB;
        }).filter(function (_a) {
            var pInfoB = _a.pInfoB;
            return pInfoA.indexStart <= pInfoB.indexStart;
        }).map(function (_a) {
            var pInfoB = _a.pInfoB, indexB = _a.indexB;
            return "wrong order of found placeholders: A should be placed after B:        \n\t A index: " + indexA + "        \n\t B index: " + indexB + "        \n\t A data: " + util_1.inspect(pInfoA) + "        \n\t B data: " + util_1.inspect(pInfoB);
        });
    }).reduce(function (acc, part) { return acc.concat(part); }, []);
    var psInfoCrossErrors = psInfo.map(function (pInfoA, indexA) {
        return psInfo.map(function (pInfoB, indexB) {
            return { pInfoB: pInfoB, indexB: indexB };
        }).filter(function (_a) {
            var pInfoB = _a.pInfoB;
            return pInfoA !== pInfoB;
        }).filter(function (_a) {
            var pInfoB = _a.pInfoB;
            return !(false
                || (pInfoA.indexEnd < pInfoB.indexStart)
                || (pInfoB.indexEnd < pInfoA.indexStart));
        }).map(function (_a) {
            var pInfoB = _a.pInfoB, indexB = _a.indexB;
            return "placeholder A should not cross placeholder B:        \n\t A index: " + indexA + "        \n\t B index: " + indexB + "        \n\t A data: " + util_1.inspect(pInfoA) + "        \n\t B data: " + util_1.inspect(pInfoB);
        });
    }).reduce(function (acc, part) { return acc.concat(part); }, []);
    var psInfoErrors = psInfoOrderErrors.concat(psInfoCrossErrors);
    assert.ok(psInfoErrors.length === 0, "murky: internal problem!\n " + psInfoErrors.join('\n '));
    return psInfo;
}
// it's required for the *.d.ts formation
exports.nocolor = function () {
    return uncolor(murky.apply(null, arguments));
};
exports.color = murky;
var auto = function () {
    return supportsColor
        ? exports.color.apply(null, arguments)
        : exports.nocolor.apply(null, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = auto;
// ES6 Modules default exports interop with CommonJS
module.exports = auto;
module.exports.default = auto;
module.exports.color = exports.color;
module.exports.nocolor = exports.nocolor;
//# sourceMappingURL=index.js.map at SyntaxError: Unexpected token (7:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
