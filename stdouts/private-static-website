/root/Targets/private-static-website
└─┬ private-static-website@1.4.0 
  ├── cookie@0.1.2 
  ├─┬ cookies@0.6.2 
  │ ├── depd@1.1.1 
  │ └── keygrip@1.0.2 
  ├─┬ dom-classes@0.0.1 
  │ └── indexof@0.0.1 
  ├── domready@1.0.7 
  ├─┬ ecstatic@2.1.0 
  │ ├── he@0.5.0 
  │ ├── mime@1.4.1 
  │ ├── minimist@1.2.0 
  │ └── url-join@1.1.0 
  ├── hidden@1.0.0 
  ├─┬ just-login-core@2.0.1 
  │ ├── key-master@1.2.0 
  │ ├── mutexify@1.2.0 
  │ ├── random-uuid-v4@0.0.5 
  │ ├─┬ safe-json-parse@4.0.0 
  │ │ └─┬ rust-result@1.0.0 
  │ │   └── individual@2.0.0 
  │ ├─┬ tiny-level-ttl@3.1.5 
  │ │ └── level-lock@1.0.1 
  │ └── xtend@4.0.1 
  ├─┬ just-login-debouncer@1.3.2 
  │ ├── debouncer@1.1.2 
  │ ├── ms@0.7.3 
  │ └── run-parallel@1.1.6 
  ├─┬ just-login-emailer@2.0.1 
  │ └─┬ nodemailer@1.11.0 
  │   ├─┬ libmime@1.2.0 
  │   │ ├── iconv-lite@0.4.19 
  │   │ ├── libbase64@0.1.0 
  │   │ └── libqp@1.1.0 
  │   ├─┬ mailcomposer@2.1.0 
  │   │ └─┬ buildmail@2.0.0 
  │   │   ├── addressparser@0.3.2 
  │   │   └── needle@0.10.0 
  │   ├─┬ needle@0.11.0 
  │   │ └─┬ debug@2.6.9 
  │   │   └── ms@2.0.0 
  │   ├─┬ nodemailer-direct-transport@1.1.0 
  │   │ └── smtp-connection@1.3.8 
  │   └─┬ nodemailer-smtp-transport@1.1.0 
  │     ├── clone@1.0.2 
  │     └── nodemailer-wellknown@0.1.10 
  ├─┬ just-login-session-state@2.0.1 
  │ ├── expire-unused-keys@1.4.0 
  │ ├─┬ level-spaces@2.0.1 
  │ │ ├─┬ level-updown@2.0.2 
  │ │ │ ├─┬ abstract-leveldown@0.12.4 
  │ │ │ │ └── xtend@3.0.0 
  │ │ │ └── externr@1.0.0 
  │ │ └─┬ levelup@0.19.1 
  │ │   ├── bl@0.8.2 
  │ │   ├── deferred-leveldown@0.2.0 
  │ │   ├── errno@0.1.4 
  │ │   ├── prr@0.0.0 
  │ │   ├─┬ readable-stream@1.0.34 
  │ │   │ ├── core-util-is@1.0.2 
  │ │   │ ├── inherits@2.0.3 
  │ │   │ └── string_decoder@0.10.31 
  │ │   ├── semver@5.1.1 
  │ │   └── xtend@3.0.0 
  │ └── random-uuid-v4@0.0.5 
  ├─┬ level-mem@0.18.0 
  │ ├─┬ level-packager@0.18.0 
  │ │ └─┬ levelup@0.18.6 
  │ │   ├── semver@2.3.2 
  │ │   └── xtend@3.0.0 
  │ └─┬ memdown@0.6.0 
  │   ├─┬ abstract-leveldown@0.11.4 
  │   │ └─┬ xtend@2.1.2 
  │   │   └── object-keys@0.4.0 
  │   └─┬ bops@0.1.1 
  │     ├── base64-js@0.0.2 
  │     └── to-utf8@0.0.1 
  ├── random-uuid-v4@0.0.6 
  ├─┬ socket.io@1.7.2 
  │ ├─┬ debug@2.3.3 
  │ │ └── ms@0.7.2 
  │ ├─┬ engine.io@1.8.2 
  │ │ ├─┬ accepts@1.3.3 
  │ │ │ ├─┬ mime-types@2.1.17 
  │ │ │ │ └── mime-db@1.30.0 
  │ │ │ └── negotiator@0.6.1 
  │ │ ├── base64id@1.0.0 
  │ │ ├── cookie@0.3.1 
  │ │ ├─┬ debug@2.3.3 
  │ │ │ └── ms@0.7.2 
  │ │ ├─┬ engine.io-parser@1.3.2 
  │ │ │ ├── after@0.8.2 
  │ │ │ ├── arraybuffer.slice@0.0.6 
  │ │ │ ├── base64-arraybuffer@0.1.5 
  │ │ │ ├── blob@0.0.4 
  │ │ │ └── wtf-8@1.0.0 
  │ │ └─┬ ws@1.1.1 
  │ │   ├── options@0.0.6 
  │ │   └── ultron@1.0.2 
  │ ├─┬ has-binary@0.1.7 
  │ │ └── isarray@0.0.1 
  │ ├── object-assign@4.1.0 
  │ ├─┬ socket.io-adapter@0.5.0 
  │ │ └─┬ debug@2.3.3 
  │ │   └── ms@0.7.2 
  │ └─┬ socket.io-parser@2.3.1 
  │   ├── component-emitter@1.1.2 
  │   ├─┬ debug@2.2.0 
  │   │ └── ms@0.7.1 
  │   └── json3@3.3.2 
  └─┬ socket.io-client@1.7.2 
    ├── backo2@1.0.2 
    ├── component-bind@1.0.0 
    ├── component-emitter@1.2.1 
    ├─┬ debug@2.3.3 
    │ └── ms@0.7.2 
    ├─┬ engine.io-client@1.8.2 
    │ ├── component-emitter@1.2.1 
    │ ├── component-inherit@0.0.3 
    │ ├─┬ debug@2.3.3 
    │ │ └── ms@0.7.2 
    │ ├── has-cors@1.1.0 
    │ ├── parsejson@0.0.3 
    │ ├── parseqs@0.0.5 
    │ ├── xmlhttprequest-ssl@1.5.3 
    │ └── yeast@0.1.2 
    ├── object-component@0.0.3 
    ├─┬ parseuri@0.0.5 
    │ └─┬ better-assert@1.0.2 
    │   └── callsite@1.0.0 
    └── to-array@0.1.4 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/private-static-website/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0462 took 3.8897s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: The keyword 'public' is reserved (16:20) on program const ecstatic = require('ecstatic')
const socketio = require('socket.io')
const Cookie = require('cookies')
const uuid = require('random-uuid-v4')
const JustLoginCore = require('just-login-core')
const justLoginDebouncer = require('just-login-debouncer')
const levelmem = require('level-mem')
const emailer = require('just-login-emailer')
const SessionState = require('just-login-session-state')

const http = require('http')
const path = require('path')

const publicPath = '/public'
const sessionCookieId = 'sweetSessionIdentifier'
const tokenPrefix = public('auth?token=')

function public(str) {
	return path.join(publicPath, str)
}

function checkFor(obj, property) {
	if (!obj || typeof obj[property] === 'undefined') {
		throw new Error(`Options must have "${property}" property`)
	}
}

module.exports = function(options, server) {
	checkFor(options, 'privateContentPath')
	checkFor(options, 'transportOptions')
	checkFor(options, 'defaultMailOptions')
	checkFor(options, 'getEmailText')
	checkFor(options, 'domain')

	server = server || http.createServer()

	const jlc = JustLoginCore(options.db || levelmem('jlcDb'))
	const sessionState = SessionState(jlc, levelmem('jlcSessions'))
	const debounceDb = levelmem('debouncing')
	let usersWithAccess = {}

	justLoginDebouncer(jlc, debounceDb)

	emailer(jlc, {
		createHtmlEmail: options.getEmailText,
		transport: options.transportOptions,
		mail: options.defaultMailOptions
	}).on('error', err => {
		console.error('Error sending email!', err && err.message)
	})

	function userHasAccess(emailAddress) {
		return !!usersWithAccess[emailAddress.toLowerCase()]
	}

	const serveContentFromRepo = ecstatic({
		root: options.privateContentPath,
		autoIndex: true,
		handleError: true,
		cache: 'private, max-age=3600, must-revalidate',
		gzip: true
	})
	const servePublicContent = ecstatic({
		root: __dirname + '/public',
		baseDir: publicPath,
		handleError: true,
		autoIndex: true
	})

	const io = socketio(server)

	server.on('request', (req, res) => {
		if (!req.url.startsWith('/socket.io/')) {
			httpHandler({ serveContentFromRepo, servePublicContent, io, jlc, sessionState, userHasAccess, domain: options.domain }, req, res)
		}
	})
	io.on('connection', socket => socketHandler({ jlc, sessionState, userHasAccess, socket }))

	server.updateUsers = function updateUsers(contents) {
		try {
			const userEmailAddresses = Array.isArray(contents) ? contents : JSON.parse(contents)

			usersWithAccess = userEmailAddresses.map(function lc(str) {
				return str.toLowerCase()
			}).reduce(function(o, address) {
				o[address] = true
				return o
			}, {})
		} catch (e) {
			console.error('Error parsing JSON', contents, e.msg || e)
		}
	}

	return server
}

function httpHandler({ serveContentFromRepo, servePublicContent, io, jlc, sessionState, userHasAccess, domain }, req, res) {
	const cookies = new Cookie(req, res)
	const sessionIdInRequestCookie = cookies.get(sessionCookieId)

	function getSessionIdAndSetIfNecessary() {
		if (sessionIdInRequestCookie) {
			return sessionIdInRequestCookie
		} else {
			console.log('Setting session id while responding to ', req.url)
			const sessionId = uuid()
			cookies.set(sessionCookieId, sessionId, {
				domain: domain,
				httpOnly: false
			})

			return sessionId
		}
	}

	function redirectTo(publicLocation) {
		res.writeHead(303, {
			'Location': public(publicLocation)
		})
		res.end()
	}

	// routing
	if (req.url === public('session.js')) {
		res.setHeader('Content-Type', 'text/javascript')
		res.end(`${sessionCookieId}="${getSessionIdAndSetIfNecessary()}"`)
	} else if (req.url.startsWith(tokenPrefix)) {
		const token = req.url.substr(tokenPrefix.length)

		jlc.authenticate(token, function(err, credentials) {
			if (err) {
				console.error('Someone had an error authenticating at the token endpoint', err.message || err)
				redirectTo('index.html')
			} else {
				const sessionSocket = io.to(credentials.sessionId)
				sendAuthenticationMessageToClient(userHasAccess, sessionSocket.emit.bind(sessionSocket), credentials.contactAddress)
				redirectTo('success.html')
			}
		})
	} else if (req.url === '/public' || req.url.startsWith('/public/')) {
		getSessionIdAndSetIfNecessary()
		servePublicContent(req, res)
	} else if (sessionIdInRequestCookie) {
		sessionState.isAuthenticated(sessionIdInRequestCookie, function(err, emailAddress) {
			if (err) {
				console.error('Error checking isAuthenticated', err, err.stack)
				res.writeHead(500)
				res.end(err.message || err)
			} else if (emailAddress && userHasAccess(emailAddress)) {
				serveContentFromRepo(req, res)
			} else {
				redirectTo('index.html')
			}
		})
	} else {
		redirectTo('index.html')
	}
}

function socketHandler({ jlc, sessionState, userHasAccess, socket }) {
	const sessionId = new Cookie(socket.request).get(sessionCookieId)
	if (sessionId) {
		socket.join(sessionId)
	} else {
		console.error('socket connection happened without a session! BORKED')
	}

	sessionState.isAuthenticated(sessionId, function(err, emailAddress) {
		if (!err && emailAddress) {
			sendAuthenticationMessageToClient(userHasAccess, socket.emit.bind(socket), emailAddress)
		}
	})

	socket.on('beginAuthentication', function(sessionId, emailAddress) {
		if (sessionId && emailAddress) {
			jlc.beginAuthentication(sessionId, emailAddress, function(err, credentials) {
				if (err) {
					if (err.debounce) {
						socket.emit('warning', `Too many login requests! Please wait ${Math.round(credentials.remaining / 1000)}  seconds.`)
					} else {
						console.error('error?!?!?!', err.message || err)
					}
				}
			})
		}
	})
}

function sendAuthenticationMessageToClient(userHasAccess, emit, emailAddress) {
	if (userHasAccess(emailAddress)) {
		emit('authenticated', emailAddress)
	} else {
		emit('warning', `You are authenticated as ${emailAddress} but that user doesn't have access`)
	}
}
 at SyntaxError: The keyword 'public' is reserved (16:20)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$3.parseIdent (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2182:14)
    at Parser.pp$3.parseExprAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1774:21)
    at Parser.parseExprAtom (/root/ExpoSE/lib/Tropigate/bin/Expression.js:28:30)
    at Parser.pp$3.parseExprSubscripts (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1715:21)
    at Parser.parseMaybeUnary (/root/ExpoSE/lib/Tropigate/bin/Unary.js:34:29)
    at Parser.pp$3.parseExprOps (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1637:21)
    at Parser.pp$3.parseMaybeConditional (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1620:21)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1597:21)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1034:28)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
