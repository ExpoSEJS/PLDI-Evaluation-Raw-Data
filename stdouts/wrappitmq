/root/Targets/wrappitmq
└─┬ wrappitmq@1.0.4 
  └─┬ amqplib@0.5.1 
    ├── bitsyntax@0.0.4 
    ├── bluebird@3.5.0 
    ├── buffer-more-ints@0.0.2 
    └─┬ readable-stream@1.1.14 
      ├── core-util-is@1.0.2 
      ├── inherits@2.0.3 
      ├── isarray@0.0.1 
      └── string_decoder@0.10.31 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/wrappitmq/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 34% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0431 took 4.0184s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (28:8) on program const amqp = require('amqplib');
const EventEmitter = require('events').EventEmitter;

class Client extends EventEmitter {

  /**
   * (Optional) Gives you the opportunity to override defaults.
   */
  constructor(config) {
    super();
    this.config = Object.assign({
      // How many messages to consume asynchronously.
      // A falsey value indicates no limit.
      prefetch: 1,
      // Passed to connect()
      // http://www.squaremobius.net/amqp.node/channel_api.html#connect
      socket: {
        // Hearbeat in seconds to check connection liveness.
        // If dead the connection will emit an error and close.
        heartbeat: 30,
      },
    }, config);
  }

  /**
   * Establish connection to queue.
   */
  async connect(url) {
    if (url) {
      this.config.url = url;
    }
    // Connect!
    this.connection = await amqp.connect(this.config.url, this.config.socket);
    this.connection.on('close', (err) => {
      // Err will only be set if connection was closed due to an error.
      if (!this.connection) return;
      this.emit('close', err);
      this.connection = null;
    });
    this.connection.on('error', (err) => {
      // Close will also be called after this.
      this.emit('error', err);
    });
    // Channels are like sessions established over the connection.
    // Confirmation channels: http://www.rabbitmq.com/confirms.html
    this.channel = await this.connection.createConfirmChannel();
    this.channel.on('close', () => {
      if (!this.connection || !this.channel) return;
      // Any unresolved operations on the channel will be abandoned.
      this.emit('close');
      this.channel = null;
      this.connection = null;
    });
    this.channel.on('error', (err) => {
      // Server closed the channel for any reason (invalid operation).
      // Will not be triggered on connection error.
      this.emit('error', err);
    });
    // Set max number of messages sent over the channel that can be awaiting acknowledgement.
    this.channel.prefetch(this.config.prefetch);
  }

  /**
   * Cleanly disconnect.
   */
  async close() {
    // Try to requeue unacknowledged messages on this channel.
    try {
      await this.channel.recover();
    } catch (err) {
      // It might happen that this action fails because the channel is already
      // closed due to an other error, we still want to continue closing.
    }
    // Closing connection is not graceful on per operation basis, it will
    // immediately invalidate any unresolved operations!
    try {
      await this.channel.close();
    } catch (err) {
      // It might happen that this action fails because the channel is already
      // closed due to an other error, we still want to continue closing.
    }
    try {
      await this.connection.close();
    } catch (err) {
      // It might happen that this action fails because the connection is
      // already closed due to an other error, then there's nothing else to do.
    }
  }

  /**
   * Acknowledge the specified message.
   *
   * It's an error to supply a message that has already been acknowledged.
   */
  async ack(msg) {
    // We must not acknowledge messages if we turned that feature off.
    if (this.config.consumeOptions.noAck === true) return;
    await this.channel.ack(msg);
  }

  /**
   * Rejects the specified message and requeues it.
   *
   * It's an error to supply a message that has already been acknowledged.
   */
  async nack(msg) {
    // We must not reject messages if we turned acknowledgements off.
    if (this.config.consumeOptions.noAck === true) return;
    await this.channel.nack(msg);
  }

  /**
   * Encodes a message before sending.
   *
   * Turn any javascript value into a Buffer to be send as message.
   */
  static encode(message) {
    return Buffer.from(JSON.stringify(message));
  }

  /**
   * Decodes a message we received.
   *
   * Get the original javascript value from the received Buffer.
   */
  static decode(message) {
    return JSON.parse(message.toString());
  }

}

module.exports = Client;
 at SyntaxError: Unexpected token (28:8)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp.expect (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:597:28)
    at Parser.pp$3.parseMethod (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2071:10)
    at Parser.pp$1.parseClassMethod (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1137:25)
    at Parser.pp$1.parseClass (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1118:14)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:697:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
    at Parser.parse (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:516:17)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/wrappitmq/node_modules/wrappitmq/index.js. Coverage (Term): 49% Coverage (LOC): 80%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
