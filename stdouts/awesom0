
> iconv@2.1.11 install /root/Targets/awesom0/node_modules/iconv
> node-gyp rebuild

make: Entering directory '/root/Targets/awesom0/node_modules/iconv/build'
  CC(target) Release/obj.target/libiconv/deps/libiconv/lib/iconv.o
  AR(target) Release/obj.target/iconv.a
  COPY Release/iconv.a
  CXX(target) Release/obj.target/iconv/src/binding.o
iconv.target.mk:109: recipe for target 'Release/obj.target/iconv/src/binding.o' failed
make: Leaving directory '/root/Targets/awesom0/node_modules/iconv/build'

> node-icu-charset-detector@0.1.0 install /root/Targets/awesom0/node_modules/node-icu-charset-detector
> node-gyp rebuild

make: Entering directory '/root/Targets/awesom0/node_modules/node-icu-charset-detector/build'
  CXX(target) Release/obj.target/node-icu-charset-detector/node-icu-charset-detector.o
node-icu-charset-detector.target.mk:92: recipe for target 'Release/obj.target/node-icu-charset-detector/node-icu-charset-detector.o' failed
make: Leaving directory '/root/Targets/awesom0/node_modules/node-icu-charset-detector/build'
/root/Targets/awesom0
└─┬ awesom0@0.0.4 
  ├─┬ chai@1.10.0 
  │ ├── assertion-error@1.0.0 
  │ └─┬ deep-eql@0.1.3 
  │   └── type-detect@0.1.1 
  ├─┬ chalk@0.5.1 
  │ ├── ansi-styles@1.1.0 
  │ ├── escape-string-regexp@1.0.5 
  │ ├─┬ has-ansi@0.1.0 
  │ │ └── ansi-regex@0.2.1 
  │ ├── strip-ansi@0.3.0 
  │ └── supports-color@0.2.0 
  ├─┬ cool-ascii-faces@1.3.4 
  │ └─┬ stream-spigot@3.0.6 
  │   ├─┬ readable-stream@2.2.11 
  │   │ ├── core-util-is@1.0.2 
  │   │ ├── inherits@2.0.3 
  │   │ ├── isarray@1.0.0 
  │   │ ├── process-nextick-args@1.0.7 
  │   │ ├── safe-buffer@5.0.1 
  │   │ ├─┬ string_decoder@1.0.3 
  │   │ │ └── safe-buffer@5.1.1 
  │   │ └── util-deprecate@1.0.2 
  │   └── xtend@4.0.1 
  ├─┬ irc@0.3.12 
  │ ├── ansi-color@0.2.1 
  │ └── irc-colors@1.3.3 
  ├── lodash@2.4.2 
  ├── moment@2.2.1 
  ├── redis@0.9.2 
  ├─┬ request@2.27.0 
  │ ├── aws-sign@0.3.0 
  │ ├── cookie-jar@0.3.0 
  │ ├── forever-agent@0.5.2 
  │ ├─┬ form-data@0.1.4 
  │ │ ├── async@0.9.2 
  │ │ └─┬ combined-stream@0.0.7 
  │ │   └── delayed-stream@0.0.5 
  │ ├─┬ hawk@1.0.0 
  │ │ ├── boom@0.4.2 
  │ │ ├── cryptiles@0.2.2 
  │ │ ├── hoek@0.9.1 
  │ │ └── sntp@0.2.4 
  │ ├─┬ http-signature@0.10.1 
  │ │ ├── asn1@0.1.11 
  │ │ ├── assert-plus@0.1.5 
  │ │ └── ctype@0.5.3 
  │ ├── json-stringify-safe@5.0.1 
  │ ├── mime@1.2.11 
  │ ├── node-uuid@1.4.8 
  │ ├── oauth-sign@0.3.0 
  │ ├── qs@0.6.6 
  │ └── tunnel-agent@0.3.0 
  ├── sandbox@0.8.3 
  └── underscore@1.5.2 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/awesom0/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0788 took 3.6174s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected character '#' (1:78) on program #!/usr/bin/env node

var irc = require('irc'),
  chalk = require('chalk'),
  db = require('./db'),
  _ = require('lodash'),
  Awesom0;


module.exports = Awesom0 = {

  settings : {},
  client : {},

  // setup namespaces for different event types
  triggers : {
    oncommand : [],
    onhear : [],
    onjoin : []
  },

  init: function(settings) {
    // import settings
    try {
      this.settings = settings || require('./settings');
    }
    catch (error) {
      throw 'Unable to load ./settings.js.';
    }

    // setup db
    this.db = db(this);
    // determine whether or not we should be in debug mode
    this.debug = !!this.settings.debug;
    this.debugREPL = !!this.settings.debugREPL; // this is set in `debug.js`
    this.autostart = typeof this.settings.autostart !== 'undefined' ? this.settings.autostart : true;

    // loop through all scripts enabled in settings and import them
    _.each(this.settings.commands, function(command){
      if (this.debug) {
        process.stdout.write(chalk.blue('Loading script:') + ' ' + command + ' ' + chalk.blue('...'));
      }

      try {
        require('./scripts/' + command)(this);
        if (this.debug){ process.stdout.write(chalk.blue(' done') + '\n'); }
      }
      catch (err) {
        if (this.debug) {
          process.stdout.write(chalk.red(' error') + '\n');
          console.warn(err);
        }
      }
    }, this);

    if (this.autostart){
      this.start();
    }

    return this;
  },

  start : function(){
    var debug = this.debug;
    // create a new client
    if (this.debugREPL){
      // if we are debugging a script via repl, define our own say function and
      // a function that makes testing commands easier
      var lastMsg = '';
      this.client = {
        say: function(channel, msg) {
          lastMsg = msg;
          if (debug) {
            console.log(chalk.green('Response (via ' + channel + '):'), msg);
          }
        },
        opt : this.client.opt
      };
      this.testMsg = function(msg) {
        this.onmessage('TestUser', '#test', msg);
      };
      this.lastMsg = function(){
        return lastMsg;
      };
    } else {
      // connect to the irc server
      this.client = new irc.Client(this.settings.server, this.settings.botname, {
        channels: this.settings.channels,
        port: this.settings.port || 6667,
        showErrors: this.debug,
        userName: this.settings.userName || 'awesom0',
        realName: this.settings.realName || 'AWESOM-0'
      });

      // bind all events
      this.client.addListener('connect', _.bind(this.connecting, this));
      this.client.addListener('registered', _.bind(this.onconnect, this));
      this.client.addListener('message', _.bind(this.onmessage, this));
      this.client.addListener('join', _.bind(this.onjoin, this));
      this.client.addListener('error', _.bind(this.onerror, this));
    }

    return this;
  },

  // scripts call this method to register their commands, callbacks, and usage
  respond: function(match, usage, callback) {
    // if usage is a function, then it's probably supposed to be the callback
    // and there isn't a usage defined
    if (typeof usage === 'function') {
      callback = usage;
      usage = null;
    }
    this.triggers.oncommand.push({ match: match, command: callback, usage: usage });
  },

  hear: function(match, usage, callback) {
    if (_.isFunction(usage)) {
      callback = usage;
      usage = null;
    }
    this.triggers.onhear.push({ match: match, command: callback, usage: usage });
  },

  userJoin: function(callback) {
    this.triggers.onjoin.push(callback);
  },

  connecting: function() {
    var opt = this.client.opt;
    if( this.debug ){
      process.stdout.write('\n');
      process.stdout.write(chalk.blue('Connecting to') + ' ' + opt.server + chalk.blue(' port ') + opt.port +
        chalk.blue(' on channels ') + opt.channels + chalk.blue(' as ') + opt.nick + chalk.blue(' ... '));
    }
  },

  onconnect: function() {
    if( this.debug ){
      process.stdout.write(chalk.blue('connected.\n'));
    }
  },

  onjoin: function(channel, nick, message) {
    _.each(this.triggers.onjoin, function(trigger){
      trigger({channel: channel, nick: nick, message:message});
    });
  },

  onmessage: function(from, channel, message) {
    if (this.debug){
      console.log(chalk.yellow('Message (' + from + ' via ' + channel + '):'), message);
    }

    // check if pm. if so, set channel to nick sending the pm
    if (channel === this.settings.botname) {
      channel = from;
      this.checkCommands(from, channel, message);
    }

    // check if message is directed at our bot
    if (message.split(' ')[0].indexOf(this.settings.botname) > -1) {
      // remove the name of the bot from the message
      var tokens = message.split(' ');
      tokens.splice(0, 1);
      message = tokens.join(' ');
      this.checkCommands(from, channel, message);
    }

    this.checkListens(from, channel, message);
  },

  checkCommands: function(from, channel, message) {
    // commands
    for (var i = 0, match, j = this.triggers.oncommand.length; i < j; i++) {
      match = message.match(this.triggers.oncommand[i].match);
      if (match && match.length) {
        var msg = {
          match: match,
          from: from,
          message: message,
          channel: channel
        };
        this.triggers.oncommand[i].command(msg);
      }
    }
  },

  checkListens: function(from, channel, message) {
    // listen
    for (var i = 0, match, j = this.triggers.onhear.length; i < j; i++) {
      match = message.match(this.triggers.onhear[i].match);
      if (match && match.length) {
        var msg = {
          match: match,
          from: from,
          message: message,
          channel: channel
        };
        this.triggers.onhear[i].command(msg);
      }
    }
  },

  onerror: function(error) {
    console.log(chalk.red('Error: '), error);
  },

  // help is always returned as a private message to the user who issued the command
  printHelp: function(from) {
    var response = (typeof this.settings.help === 'undefined') ? '' : this.settings.help;
    response += 'Here is a list of my available commands:\n';
    // loop through all commands and print their help, if it's been defined
    _.each(this.triggers.oncommand, function(command){
      if( !_.isEmpty(command.usage) ){
        response += command.usage + '\n';
      }
    });
    response += 'Note: Generally if a command has a bang (!) in front of it, the bot is listening for ';
    response += 'for that string. The command doesn\'t need to have the botname before it.';

    this.client.say(from, response);
  }
};

// if script is called directly, initialize the bot
if(require.main === module){
    Awesom0.init();
}
 at SyntaxError: Unexpected character '#' (1:78)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$7.getTokenFromCode (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2756:10)
    at Parser.pp$7.readToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2477:17)
    at Parser.readToken (/root/ExpoSE/lib/Tropigate/bin/Tokens.js:124:26)
    at Parser.pp$7.nextToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2468:15)
    at Parser.pp$7.next (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2413:10)
    at Parser.pp.eat (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:536:12)
    at Parser.pp.semicolon (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:581:15)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:918:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
