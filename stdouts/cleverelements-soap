
> node-expat@2.3.16 install /root/Targets/cleverelements-soap/node_modules/node-expat
> node-gyp rebuild

make: Entering directory '/root/Targets/cleverelements-soap/node_modules/node-expat/build'
  CC(target) Release/obj.target/expat/deps/libexpat/lib/xmlparse.o
  CC(target) Release/obj.target/expat/deps/libexpat/lib/xmltok.o
  CC(target) Release/obj.target/expat/deps/libexpat/lib/xmlrole.o
  AR(target) Release/obj.target/deps/libexpat/libexpat.a
  COPY Release/libexpat.a
  CXX(target) Release/obj.target/node_expat/node-expat.o
  SOLINK_MODULE(target) Release/obj.target/node_expat.node
  COPY Release/node_expat.node
make: Leaving directory '/root/Targets/cleverelements-soap/node_modules/node-expat/build'
/root/Targets/cleverelements-soap
└─┬ cleverelements-soap@0.1.0 
  └─┬ soap-js@0.2.11 
    ├─┬ node-expat@2.3.16 
    │ ├── bindings@1.3.0 
    │ └── nan@2.7.0 
    └─┬ request@2.83.0 
      ├── aws-sign2@0.7.0 
      ├── aws4@1.6.0 
      ├── caseless@0.12.0 
      ├─┬ combined-stream@1.0.5 
      │ └── delayed-stream@1.0.0 
      ├── extend@3.0.1 
      ├── forever-agent@0.6.1 
      ├─┬ form-data@2.3.1 
      │ └── asynckit@0.4.0 
      ├─┬ har-validator@5.0.3 
      │ ├─┬ ajv@5.2.3 
      │ │ ├── co@4.6.0 
      │ │ ├── fast-deep-equal@1.0.0 
      │ │ ├── json-schema-traverse@0.3.1 
      │ │ └─┬ json-stable-stringify@1.0.1 
      │ │   └── jsonify@0.0.0 
      │ └── har-schema@2.0.0 
      ├─┬ hawk@6.0.2 
      │ ├── boom@4.3.1 
      │ ├─┬ cryptiles@3.1.2 
      │ │ └── boom@5.2.0 
      │ ├── hoek@4.2.0 
      │ └── sntp@2.0.2 
      ├─┬ http-signature@1.2.0 
      │ ├── assert-plus@1.0.0 
      │ ├─┬ jsprim@1.4.1 
      │ │ ├── extsprintf@1.3.0 
      │ │ ├── json-schema@0.2.3 
      │ │ └─┬ verror@1.10.0 
      │ │   └── core-util-is@1.0.2 
      │ └─┬ sshpk@1.13.1 
      │   ├── asn1@0.2.3 
      │   ├── bcrypt-pbkdf@1.0.1 
      │   ├── dashdash@1.14.1 
      │   ├── ecc-jsbn@0.1.1 
      │   ├── getpass@0.1.7 
      │   ├── jsbn@0.1.1 
      │   └── tweetnacl@0.14.5 
      ├── is-typedarray@1.0.0 
      ├── isstream@0.1.2 
      ├── json-stringify-safe@5.0.1 
      ├─┬ mime-types@2.1.17 
      │ └── mime-db@1.30.0 
      ├── oauth-sign@0.8.2 
      ├── performance-now@2.1.0 
      ├── qs@6.5.1 
      ├── safe-buffer@5.1.1 
      ├── stringstream@0.0.5 
      ├─┬ tough-cookie@2.3.3 
      │ └── punycode@1.4.1 
      ├── tunnel-agent@0.6.0 
      └── uuid@3.1.0 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/cleverelements-soap/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 22% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0431 took 5.0999s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (11:4) on program /*
 * Copyright (c) 2011 Vinay Pulim <vinay@milewise.com>
 * MIT Licensed
 */
 
function findKey(obj, val) {
    for (var n in obj) if (obj[n] === val) return n;
}

var http = require('./http'),
    assert = require('assert'),
    url = require('url');

var Client = function(wsdl, endpoint) {
    this.wsdl = wsdl;
    this._initializeServices(endpoint);
}

Client.prototype.addSoapHeader = function(soapHeader, name, namespace, xmlns) {
	if(!this.soapHeaders){
		this.soapHeaders = [];
	}
	if(typeof soapHeader == 'object'){
		soapHeader = this.wsdl.objectToXML(soapHeader, name, namespace, xmlns);
	}
	this.soapHeaders.push(soapHeader);
}

Client.prototype.setEndpoint = function(endpoint) {
    this.endpoint = endpoint;
    this._initializeServices(endpoint);
}

Client.prototype.describe = function() {
    var types = this.wsdl.definitions.types;
    return this.wsdl.describeServices();
}

Client.prototype.setSecurity = function(security) {
    this.security = security;
}

Client.prototype.setSOAPAction = function(SOAPAction) {
    this.SOAPAction = SOAPAction;
}

Client.prototype._initializeServices = function(endpoint) {
    var definitions = this.wsdl.definitions,
        services = definitions.services;
    for (var name in services) {
        this[name] = this._defineService(services[name], endpoint);
    }
}

Client.prototype._defineService = function(service, endpoint) {
    var ports = service.ports,
        def = {};
    for (var name in ports) {
        def[name] = this._definePort(ports[name], endpoint ? endpoint : ports[name].location);
    }
    return def;
}

Client.prototype._definePort = function(port, endpoint) {
    var location = endpoint,
        binding = port.binding,
        methods = binding.methods,
        def = {};
    for (var name in methods) {
        def[name] = this._defineMethod(methods[name], location);
        if (!this[name]) this[name] = def[name];
    }
    return def;
}

Client.prototype._defineMethod = function(method, location) {
    var self = this;
    return function(args, callback) {
        if (typeof args === 'function') {
            callback = args;
            args = {};
        }
        self._invoke(method, args, location, function(error, result, raw) {
            callback(error, result, raw);
        })
    }
}

Client.prototype._invoke = function(method, arguments, location, callback) {
    var self = this,
        name = method.$name,
        input = method.input,
        output = method.output,
        style = method.style,
        defs = this.wsdl.definitions,
        ns = defs.$targetNamespace,
        encoding = '',
        message = '',
        xml = null,
        soapAction = this.SOAPAction ? this.SOAPAction(ns, name) : (method.soapAction || (((ns.lastIndexOf("/") != ns.length - 1) ? ns + "/" : ns) + name)),
        headers = {
            SOAPAction: '"' + soapAction + '"',
            'Content-Type': "text/xml; charset=utf-8"
        },
        options = {},
        alias = findKey(defs.xmlns, ns);
    
    // Allow the security object to add headers
    if (self.security && self.security.addHeaders)
        self.security.addHeaders(headers);
    if (self.security && self.security.addOptions)
        self.security.addOptions(options);
        
    if (input.parts) {
        assert.ok(!style || style == 'rpc', 'invalid message definition for document style binding');
        message = self.wsdl.objectToRpcXML(name, arguments, alias, ns);
        (method.inputSoap === 'encoded') && (encoding = 'soap:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" ');
    }
    else if (typeof(arguments) === 'string') {
      message = arguments;
    }
    else {
        assert.ok(!style || style == 'document', 'invalid message definition for rpc style binding');
        message = self.wsdl.objectToDocumentXML(input.$name, arguments, input.targetNSAlias, input.targetNamespace);
    }
    xml = "<soap:Envelope " + 
            "xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\" " +
            encoding +
            this.wsdl.xmlnsInEnvelope + '>' +
            "<soap:Header>" +
                (self.soapHeaders ? self.soapHeaders.join("\n") : "") +
                (self.security ? self.security.toXML() : "") +
            "</soap:Header>" +
            "<soap:Body>" +
                message +
            "</soap:Body>" +
        "</soap:Envelope>";
    
	self.lastRequest = xml;
	
    http.request(location, xml, function(err, response, body) {
        if (err) {
            callback(err);
        }
        else {
            try {
                var obj = self.wsdl.xmlToObject(body);
            }
            catch (error) {
                return callback(error, response, body);
            }
            var result = obj.Body[output.$name];
            // RPC/literal response body may contain element named after the method + 'Response'
            // This doesn't necessarily equal the ouput message name. See WSDL 1.1 Section 2.4.5
            if(!result) {
               result = obj.Body[name + 'Response'];
            }
            callback(null, result, body);
        }
    }, headers, options);
}

exports.Client = Client;
 at SyntaxError: Unexpected token (11:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/cleverelements-soap/node_modules/cleverelements-soap/lib/cleverelements.js. Coverage (Term): 3% Coverage (LOC): 4%
*- File /root/Targets/cleverelements-soap/node_modules/soap-js/index.js. Coverage (Term): 80% Coverage (LOC): 100%
*- File /root/Targets/cleverelements-soap/node_modules/soap-js/lib/soap.js. Coverage (Term): 5% Coverage (LOC): 11%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
