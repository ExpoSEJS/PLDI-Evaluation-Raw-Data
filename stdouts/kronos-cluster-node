
> spawn-sync@1.0.15 postinstall /root/Targets/kronos-cluster-node/node_modules/spawn-sync
> node postinstall


> caporal@0.7.0 postinstall /root/Targets/kronos-cluster-node/node_modules/caporal
> (test -f ./node_modules/husky/bin/install.js && node ./node_modules/husky/bin/install.js) || exit 0

/root/Targets/kronos-cluster-node
└─┬ kronos-cluster-node@5.0.12 
  ├─┬ caporal@0.7.0 
  │ ├── bluebird@3.5.0 
  │ ├─┬ chalk@1.1.3 
  │ │ ├── ansi-styles@2.2.1 
  │ │ ├── escape-string-regexp@1.0.5 
  │ │ ├─┬ has-ansi@2.0.0 
  │ │ │ └── ansi-regex@2.1.1 
  │ │ ├── strip-ansi@3.0.1 
  │ │ └── supports-color@2.0.0 
  │ ├─┬ cli-table2@0.2.0 
  │ │ ├── colors@1.1.2 
  │ │ ├── lodash@3.10.1 
  │ │ └─┬ string-width@1.0.2 
  │ │   ├── code-point-at@1.1.0 
  │ │   └─┬ is-fullwidth-code-point@1.0.0 
  │ │     └── number-is-nan@1.0.1 
  │ ├── fast-levenshtein@2.0.6 
  │ ├── lodash.camelcase@4.3.0 
  │ ├── micromist@1.0.2 
  │ ├── prettyjson@1.2.1 
  │ ├─┬ tabtab@2.2.2 
  │ │ ├─┬ debug@2.6.8 
  │ │ │ └── ms@2.0.0 
  │ │ ├─┬ inquirer@1.2.3 
  │ │ │ ├── ansi-escapes@1.4.0 
  │ │ │ ├─┬ cli-cursor@1.0.2 
  │ │ │ │ └─┬ restore-cursor@1.0.1 
  │ │ │ │   ├── exit-hook@1.1.1 
  │ │ │ │   └── onetime@1.1.0 
  │ │ │ ├── cli-width@2.2.0 
  │ │ │ ├─┬ external-editor@1.1.1 
  │ │ │ │ ├─┬ spawn-sync@1.0.15 
  │ │ │ │ │ └── os-shim@0.1.3 
  │ │ │ │ └─┬ tmp@0.0.29 
  │ │ │ │   └── os-tmpdir@1.0.2 
  │ │ │ ├── figures@1.7.0 
  │ │ │ ├── lodash@4.17.4 
  │ │ │ ├── mute-stream@0.0.6 
  │ │ │ ├─┬ run-async@2.3.0 
  │ │ │ │ └── is-promise@2.1.0 
  │ │ │ ├── rx@4.1.0 
  │ │ │ └── through@2.3.8 
  │ │ ├── lodash.difference@4.5.0 
  │ │ ├── lodash.uniq@4.5.0 
  │ │ ├─┬ mkdirp@0.5.1 
  │ │ │ └── minimist@0.0.8 
  │ │ └─┬ npmlog@2.0.4 
  │ │   ├── ansi@0.3.1 
  │ │   ├─┬ are-we-there-yet@1.1.4 
  │ │   │ └── delegates@1.0.0 
  │ │   └─┬ gauge@1.2.7 
  │ │     ├── has-unicode@2.0.1 
  │ │     ├── lodash.pad@4.5.1 
  │ │     ├── lodash.padend@4.6.1 
  │ │     └── lodash.padstart@4.6.1 
  │ └─┬ winston@2.3.1 
  │   ├── async@1.0.0 
  │   ├── colors@1.0.3 
  │   ├── cycle@1.0.3 
  │   ├── eyes@0.1.8 
  │   ├── isstream@0.1.2 
  │   └── stack-trace@0.0.10 
  ├─┬ config-expander@9.0.0 
  │ ├── expression-expander@6.0.0 
  │ └── pratt-parser@7.0.7 
  ├─┬ coveralls@2.13.1 
  │ ├─┬ js-yaml@3.6.1 
  │ │ ├─┬ argparse@1.0.9 
  │ │ │ └── sprintf-js@1.0.3 
  │ │ └── esprima@2.7.3 
  │ ├── lcov-parse@0.0.10 
  │ ├── log-driver@1.2.5 
  │ ├── minimist@1.2.0 
  │ └─┬ request@2.79.0 
  │   ├── aws-sign2@0.6.0 
  │   ├── aws4@1.6.0 
  │   ├── caseless@0.11.0 
  │   ├─┬ combined-stream@1.0.5 
  │   │ └── delayed-stream@1.0.0 
  │   ├── extend@3.0.1 
  │   ├── forever-agent@0.6.1 
  │   ├── form-data@2.1.4 
  │   ├─┬ har-validator@2.0.6 
  │   │ └─┬ is-my-json-valid@2.16.1 
  │   │   ├── generate-function@2.0.0 
  │   │   ├─┬ generate-object-property@1.2.0 
  │   │   │ └── is-property@1.0.2 
  │   │   └── jsonpointer@4.0.1 
  │   ├─┬ hawk@3.1.3 
  │   │ ├── boom@2.10.1 
  │   │ ├── cryptiles@2.0.5 
  │   │ ├── hoek@2.16.3 
  │   │ └── sntp@1.0.9 
  │   ├─┬ http-signature@1.1.1 
  │   │ ├── assert-plus@0.2.0 
  │   │ ├─┬ jsprim@1.4.1 
  │   │ │ ├── assert-plus@1.0.0 
  │   │ │ ├── extsprintf@1.3.0 
  │   │ │ ├── json-schema@0.2.3 
  │   │ │ └─┬ verror@1.10.0 
  │   │ │   └── assert-plus@1.0.0 
  │   │ └─┬ sshpk@1.13.1 
  │   │   ├── assert-plus@1.0.0 
  │   │   ├── bcrypt-pbkdf@1.0.1 
  │   │   ├─┬ dashdash@1.14.1 
  │   │   │ └── assert-plus@1.0.0 
  │   │   ├── ecc-jsbn@0.1.1 
  │   │   ├─┬ getpass@0.1.7 
  │   │   │ └── assert-plus@1.0.0 
  │   │   ├── jsbn@0.1.1 
  │   │   └── tweetnacl@0.14.5 
  │   ├── is-typedarray@1.0.0 
  │   ├── json-stringify-safe@5.0.1 
  │   ├─┬ mime-types@2.1.17 
  │   │ └── mime-db@1.30.0 
  │   ├── oauth-sign@0.8.2 
  │   ├── qs@6.3.2 
  │   ├── stringstream@0.0.5 
  │   ├─┬ tough-cookie@2.3.2 
  │   │ └── punycode@1.4.1 
  │   ├── tunnel-agent@0.4.3 
  │   └── uuid@3.1.0 
  ├─┬ globby@6.1.0 
  │ ├─┬ array-union@1.0.2 
  │ │ └── array-uniq@1.0.3 
  │ ├─┬ glob@7.1.2 
  │ │ ├── fs.realpath@1.0.0 
  │ │ ├─┬ inflight@1.0.6 
  │ │ │ └── wrappy@1.0.2 
  │ │ ├── inherits@2.0.3 
  │ │ ├─┬ minimatch@3.0.4 
  │ │ │ └─┬ brace-expansion@1.1.8 
  │ │ │   ├── balanced-match@1.0.0 
  │ │ │   └── concat-map@0.0.1 
  │ │ ├── once@1.4.0 
  │ │ └── path-is-absolute@1.0.1 
  │ ├── object-assign@4.1.1 
  │ ├── pify@2.3.0 
  │ └─┬ pinkie-promise@2.0.1 
  │   └── pinkie@2.0.4 
  ├─┬ kronos-adapter-inbound-file@2.0.15 
  │ ├─┬ chokidar@1.7.0 
  │ │ ├─┬ anymatch@1.3.2 
  │ │ │ ├─┬ micromatch@2.3.11 
  │ │ │ │ ├─┬ arr-diff@2.0.0 
  │ │ │ │ │ └── arr-flatten@1.1.0 
  │ │ │ │ ├── array-unique@0.2.1 
  │ │ │ │ ├─┬ braces@1.8.5 
  │ │ │ │ │ ├─┬ expand-range@1.8.2 
  │ │ │ │ │ │ └─┬ fill-range@2.2.3 
  │ │ │ │ │ │   ├── is-number@2.1.0 
  │ │ │ │ │ │   ├── isobject@2.1.0 
  │ │ │ │ │ │   ├─┬ randomatic@1.1.7 
  │ │ │ │ │ │   │ ├─┬ is-number@3.0.0 
  │ │ │ │ │ │   │ │ └── kind-of@3.2.2 
  │ │ │ │ │ │   │ └── kind-of@4.0.0 
  │ │ │ │ │ │   └── repeat-string@1.6.1 
  │ │ │ │ │ ├── preserve@0.2.0 
  │ │ │ │ │ └── repeat-element@1.1.2 
  │ │ │ │ ├─┬ expand-brackets@0.1.5 
  │ │ │ │ │ └── is-posix-bracket@0.1.1 
  │ │ │ │ ├── extglob@0.3.2 
  │ │ │ │ ├── filename-regex@2.0.1 
  │ │ │ │ ├── object.omit@2.0.1 
  │ │ │ │ ├─┬ parse-glob@3.0.4 
  │ │ │ │ │ ├── glob-base@0.3.0 
  │ │ │ │ │ └── is-dotfile@1.0.3 
  │ │ │ │ └─┬ regex-cache@0.4.4 
  │ │ │ │   └─┬ is-equal-shallow@0.1.3 
  │ │ │ │     └── is-primitive@2.0.0 
  │ │ │ └─┬ normalize-path@2.1.1 
  │ │ │   └── remove-trailing-separator@1.1.0 
  │ │ ├── async-each@1.0.1 
  │ │ ├── glob-parent@2.0.0 
  │ │ ├─┬ is-binary-path@1.0.1 
  │ │ │ └── binary-extensions@1.10.0 
  │ │ ├─┬ is-glob@2.0.1 
  │ │ │ └── is-extglob@1.0.0 
  │ │ └─┬ readdirp@2.1.0 
  │ │   ├── graceful-fs@4.1.11 
  │ │   └── set-immediate-shim@1.0.1 
  │ ├── kronos-endpoint@2.14.11 
  │ └─┬ kronos-step@5.3.8 
  │   ├── loglevel-mixin@1.6.22 
  │   ├─┬ merge-deep@3.0.0 
  │   │ ├── arr-union@3.1.0 
  │   │ ├─┬ clone-deep@0.2.4 
  │   │ │ ├── for-own@0.1.5 
  │   │ │ └─┬ shallow-clone@0.1.2 
  │   │ │   ├── kind-of@2.0.1 
  │   │ │   └── lazy-cache@0.2.7 
  │   │ ├── kind-of@3.2.2 
  │   │ └── lazy-cache@1.0.4 
  │   └── statetransition-mixin@3.1.21 
  ├─┬ kronos-adapter-outbound-file@2.0.14 
  │ └── iconv-lite@0.4.19 
  ├─┬ kronos-adapter-outbound-http@1.0.13 
  │ ├─┬ form-data@2.3.1 
  │ │ └── asynckit@0.4.0 
  │ └─┬ node-fetch@1.7.3 
  │   ├── encoding@0.1.12 
  │   └── is-stream@1.1.0 
  ├── kronos-flow@2.5.34 
  ├── kronos-flow-control-step@3.0.11 
  ├─┬ kronos-http-routing-step@4.3.24 
  │ └─┬ kronos-service-koa@3.3.12 
  │   ├─┬ koa-jwt@3.2.2 
  │   │ ├─┬ jsonwebtoken@7.4.1 
  │   │ │ ├─┬ joi@6.10.1 
  │   │ │ │ ├── isemail@1.2.0 
  │   │ │ │ └── topo@1.1.0 
  │   │ │ ├─┬ jws@3.1.4 
  │   │ │ │ ├── base64url@2.0.0 
  │   │ │ │ └─┬ jwa@1.1.5 
  │   │ │ │   ├── buffer-equal-constant-time@1.0.1 
  │   │ │ │   └── ecdsa-sig-formatter@1.0.9 
  │   │ │ └── lodash.once@4.1.1 
  │   │ └── koa-unless@1.0.0 
  │   ├─┬ koa-static@4.0.1 
  │   │ └─┬ koa-send@4.1.0 
  │   │   ├─┬ http-errors@1.6.2 
  │   │   │ └── setprototypeof@1.0.3 
  │   │   ├─┬ mz@2.7.0 
  │   │   │ ├── any-promise@1.3.0 
  │   │   │ └─┬ thenify-all@1.6.0 
  │   │   │   └── thenify@3.3.0 
  │   │   └─┬ resolve-path@1.3.3 
  │   │     └─┬ http-errors@1.5.1 
  │   │       └── setprototypeof@1.0.2 
  │   ├─┬ kronos-koa@1.2.2 
  │   │ ├─┬ koa@2.3.0 
  │   │ │ ├─┬ accepts@1.3.4 
  │   │ │ │ └── negotiator@0.6.1 
  │   │ │ ├── content-disposition@0.5.2 
  │   │ │ ├── content-type@1.0.4 
  │   │ │ ├─┬ cookies@0.7.1 
  │   │ │ │ └── keygrip@1.0.2 
  │   │ │ ├── depd@1.1.1 
  │   │ │ ├── destroy@1.0.4 
  │   │ │ ├── error-inject@1.0.0 
  │   │ │ ├── escape-html@1.0.3 
  │   │ │ ├── fresh@0.5.2 
  │   │ │ ├─┬ http-assert@1.3.0 
  │   │ │ │ └── deep-equal@1.0.1 
  │   │ │ ├── is-generator-function@1.0.6 
  │   │ │ ├─┬ koa-convert@1.2.0 
  │   │ │ │ ├── co@4.6.0 
  │   │ │ │ └── koa-compose@3.2.1 
  │   │ │ ├── only@0.0.2 
  │   │ │ ├── parseurl@1.3.2 
  │   │ │ ├─┬ type-is@1.6.15 
  │   │ │ │ └── media-typer@0.3.0 
  │   │ │ └── vary@1.1.1 
  │   │ ├── koa-compose@4.0.0 
  │   │ ├── koa-is-json@1.0.0 
  │   │ ├─┬ on-finished@2.3.0 
  │   │ │ └── ee-first@1.1.1 
  │   │ └── statuses@1.3.1 
  │   ├── path-to-regexp@2.0.0 
  │   └─┬ ws@3.2.0 
  │     ├── async-limiter@1.0.0 
  │     ├── safe-buffer@5.1.1 
  │     └── ultron@1.1.0 
  ├─┬ kronos-interceptor-decode-json@1.0.12 
  │ ├── kronos-interceptor@2.4.16 
  │ └─┬ parse-concat-stream@0.2.0 
  │   ├─┬ concat-stream@1.6.0 
  │   │ └── typedarray@0.0.6 
  │   └─┬ through2@0.6.5 
  │     └─┬ readable-stream@1.0.34 
  │       ├── isarray@0.0.1 
  │       └── string_decoder@0.10.31 
  ├─┬ kronos-interceptor-http-request@3.2.9 
  │ ├─┬ busboy@0.2.14 
  │ │ ├─┬ dicer@0.2.5 
  │ │ │ ├─┬ readable-stream@1.1.14 
  │ │ │ │ ├── isarray@0.0.1 
  │ │ │ │ └── string_decoder@0.10.31 
  │ │ │ └── streamsearch@0.1.2 
  │ │ └─┬ readable-stream@1.1.14 
  │ │   ├── core-util-is@1.0.2 
  │ │   ├── isarray@0.0.1 
  │ │   └── string_decoder@0.10.31 
  │ └── model-attributes@3.0.10 
  ├─┬ kronos-interceptor-line-header@2.1.8 
  │ └─┬ z-schema@3.18.4 
  │   ├── commander@2.11.0 
  │   ├── lodash.get@4.4.2 
  │   ├── lodash.isequal@4.5.0 
  │   └── validator@8.2.0 
  ├── kronos-interceptor-line-parser@2.0.10 
  ├── kronos-interceptor-line-tokenizer-csv@2.1.7 
  ├── kronos-interceptor-line-tokens2obj@2.1.7 
  ├─┬ kronos-interceptor-message-handler@2.1.5 
  │ └─┬ kronos-message@2.1.3 
  │   ├─┬ clone-deep@1.0.0 
  │   │ ├─┬ for-own@1.0.0 
  │   │ │ └── for-in@1.0.2 
  │   │ ├─┬ is-plain-object@2.0.4 
  │   │ │ └── isobject@3.0.1 
  │   │ ├── kind-of@5.0.2 
  │   │ └─┬ shallow-clone@1.0.0 
  │   │   ├── is-extendable@0.1.1 
  │   │   └─┬ mixin-object@2.0.1 
  │   │     └── for-in@0.1.8 
  │   ├── merge-light@0.0.2 
  │   └── uuid-js@0.7.5 
  ├─┬ kronos-interceptor-object-data-processor-chunk@2.1.7 
  │ └─┬ md5@2.2.1 
  │   ├── charenc@0.0.2 
  │   ├── crypt@0.0.2 
  │   └── is-buffer@1.1.5 
  ├─┬ kronos-interceptor-object-data-processor-row@1.2.9 
  │ ├── moment@2.18.1 
  │ └─┬ z-schema@3.17.0 
  │   └── validator@5.7.0 
  ├── kronos-interceptor-stream-obj2string@2.0.14 
  ├─┬ kronos-service-admin@2.26.12 
  │ ├── blessed@0.1.81 
  │ ├─┬ kronos-service@4.5.6 
  │ │ └── fast-safe-stringify@1.2.0 
  │ └─┬ ssh2@0.5.5 
  │   └─┬ ssh2-streams@0.1.19 
  │     ├── asn1@0.2.3 
  │     └── semver@5.4.1 
  ├─┬ kronos-service-consul@2.19.11 
  │ ├─┬ consul@0.29.0 
  │ │ └── papi@0.27.0 
  │ ├─┬ koa-route@3.2.0 
  │ │ ├── methods@1.1.2 
  │ │ └─┬ path-to-regexp@1.7.0 
  │ │   └── isarray@0.0.1 
  │ └── promise-repeat@0.4.0 
  ├── kronos-service-health-check@2.10.11 
  ├─┬ kronos-service-manager@3.5.10 
  │ └── registry-mixin@2.1.14 
  ├─┬ kronos-service-uti@1.1.9 
  │ └── uti@2.1.0 
  ├── kronos-step-aggregate@1.4.6 
  ├─┬ kronos-step-archive-tar@2.0.13 
  │ └─┬ tar-stream@1.5.4 
  │   ├── bl@1.2.1 
  │   ├── end-of-stream@1.4.0 
  │   ├─┬ readable-stream@2.3.3 
  │   │ ├── isarray@1.0.0 
  │   │ ├── process-nextick-args@1.0.7 
  │   │ ├── string_decoder@1.0.3 
  │   │ └── util-deprecate@1.0.2 
  │   └── xtend@4.0.1 
  ├── kronos-step-file@1.0.19 
  ├─┬ kronos-step-gzip@2.0.13 
  │ └── kronos-step@5.3.7 
  ├── kronos-step-passthrough@2.0.15 
  ├── kronos-step-stdio@3.0.18 
  ├── kronos-step-system@2.0.10 
  ├── network-address@1.1.2 
  ├── rebirth@1.0.2 
  └── systemd-socket@0.0.0 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/kronos-cluster-node/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0549 took 3.2693s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected character '#' (1:78) on program #!/usr/bin/env node
'use strict';

var kronosServiceManager = require('kronos-service-manager');

const fs = require('fs');
const path$1 = require('path');
const globby = require('globby');

async function kronosModules() {
  const files = await globby(
    path$1.join(__dirname, '..', 'node_modules/*/package.json'),
    {}
  );

  const modules = [];
  const result = await Promise.all(
    files.map(
      file =>
        new Promise((fullfill, reject) => {
          fs.readFile(file, (err, data) => {
            if (err) {
              reject(`loading ${file}: ${err}`);
              return;
            }
            try {
              const p = JSON.parse(data);

              if (p.keywords) {
                if (
                  p.keywords.find(
                    k =>
                      k === 'kronos-step' ||
                      k === 'kronos-service' ||
                      k === 'kronos-interceptor'
                  )
                ) {
                  try {
                    modules.push(require(p.name));
                    fullfill();
                    return;
                  } catch (e) {
                    reject(`${file}: ${p.name} ${e}`);
                  }
                }
              }
            } catch (e) {
              reject(e);
            }

            fullfill();
          });
        })
    )
  );

  return modules;
}

function assign(dest, value, attributePath) {
  const m = attributePath.match(/^(\w+)\.(.*)/);

  if (m) {
    const key = m[1];
    if (dest[key] === undefined) {
      dest[key] = {};
    }
    assign(dest[key], value, m[1]);
  } else {
    dest[attributePath] = value;
  }
}

/**
 * @module expression-expander
 */

function _quote(str) {
  return str;
}

/**
 * Creates a new expansion context
 * @param [options] {object}  object with the following keys
 * @param [options.valueQuoter] {function} - to quote expanded values
 *    by default no special quoting is done and the evaluated result will be direcly
 *    inserted into the output string
 * @param [options.evaluate] {function} - evaluate(expression,context,path) function to evaluate expressions
 *    the default evaluation function does a lookup into the properties
 * @param [options.keepUndefinedValues] {bool} - true: is expression resolves to undefind the original string will be used (with surrounding ${})
 * @param [options.maxNestingLevel] {number} - max number of recursive calls to expand defaults to 20
 *
 * @return {ExpressionExpander} newly created expansion context
 */
function createContext(options = {}) {
  const leftMarker = options.leftMarker || '${';
  const rightMarker = options.rightMarker || '}';
  const markerRegexp = new RegExp(options.markerRegexp || /\${([^}]+)}/, 'g');
  const keepUndefinedValues =
    options.keepUndefinedValues === undefined
      ? false
      : options.keepUndefinedValues;

  const valueQuoter = options.valueQuoter || _quote;
  const maxNestingLevel = options.maxNestingLevel || 20;

  let properties = {};

  function _evaluate(expression) {
    return properties[expression];
  }

  const evaluate = options.evaluate || _evaluate;

  const context = Object.create(
    {
      /**
     * Expands object
     * @param object {any} to expand
     * @param [path] {object[]} describing the location in the to expanding data source
     * @return {any} expanded object
     */
      expand(
        object,
        path = [
          {
            value: object
          }
        ]
      ) {
        const promises = [];
        const value = _expand(object, path, promises);
        if (promises.length !== 0) {
          return Promise.all(promises).then(() => value);
        }
        return value;
      }
    },
    {
      /**
     * Properties used for the default expander implementation
     */
      properties: {
        get() {
          return properties;
        },
        set(newProperties) {
          properties = newProperties;
        }
      }
    }
  );

  function _expand(object, path, promises) {
    if (path.length >= maxNestingLevel) {
      throw new Error(
        `Max nesting level ${maxNestingLevel} reached: ${object}`
      );
    }

    if (typeof object === 'string' || object instanceof String) {
      let wholeValue;

      const localPromises = [];
      const v = object.replace(markerRegexp, (match, key, offset, string) => {
        let value = evaluate(key, context, path);

        if (typeof value === 'string' || value instanceof String) {
          value = valueQuoter(_expand(value, path, promises));
        } else if (value === undefined) {
          value = keepUndefinedValues ? leftMarker + key + rightMarker : '';
        }
        if (
          string.length ===
          key.length + leftMarker.length + rightMarker.length
        ) {
          wholeValue = value;
          return '';
        }

        if (value instanceof Promise) {
          localPromises.push(value);
          return '${' + (localPromises.length - 1) + '}';
        }
        return value;
      });

      if (wholeValue !== undefined) {
        return wholeValue;
      }

      if (localPromises.length !== 0) {
        return Promise.all(localPromises).then(all =>
          v.replace(/\$\{(\d+)\}/, (match, key) => all[parseInt(key, 10)])
        );
      }

      return v;
    }
    if (
      object === true ||
      object === false ||
      object === undefined ||
      object === null ||
      typeof object === 'number' ||
      object instanceof Number ||
      object instanceof Date
    ) {
      // TODO: find a better way to identify special cases
      return object;
    }

    if (object instanceof Map) {
      const r = new Map();
      for (const [key, value] of object.entries()) {
        path.push({
          key,
          value
        });

        r.set(_expand(key, path, promises), _expand(value, path, promises));

        path.pop();
      }

      return r;
    }

    if (object instanceof Set) {
      const r = new Set();
      for (const value of object.values()) {
        path.push({
          value
        });

        r.add(_expand(value, path, promises));

        path.pop();
      }

      return r;
    }

    if (Array.isArray(object)) {
      const array = new Array(object.length);

      for (let index = 0; index < object.length; index++) {
        const o = object[index];
        path.push({
          key: index,
          value: o
        });

        const r = _expand(o, path, promises);
        if (r instanceof Promise) {
          promises.push(r);
          r.then(f => {
            array[index] = f;
            return f;
          });
        }
        array[index] = r;
        path.pop();
      }

      return array;
    }

    let newObject = {};

    for (const key of Object.keys(object)) {
      const newKey = _expand(key, path, promises);
      if (typeof newKey === 'string' || newKey instanceof String) {
        path.push({
          key,
          value: object[key]
        });
        const value = _expand(object[key], path, promises);
        if (value instanceof Promise) {
          promises.push(value);
          value.then(v => {
            newObject[newKey] = v;
            return v;
          });
        }
        newObject[newKey] = value;
        path.pop();
      } else {
        newObject = newKey;
      }
    }

    return newObject;
  }

  return context;
}

/**
 * @module pratt-parser
 */

const RootToken = {
  //get precedence() { return 0; },
  precedence: 0,
  get type() {
    return 'unknown';
  },
  get value() {
    return undefined;
  },

  registerWithinTokenizer(tokenizer) {},

  /**
   * Parses from chunk of PrasePosition and delivers next token
   * Modifies ParsePosition so that it points behind the detected token.
   * @param {PrsePosition} pp
   * @return {Token}
   */
  parseString(pp) {
    return undefined;
  },
  toString() {
    return `${this.type}: ${this.value} [${this.precedence}]`;
  },
  led(grammar, left) {
    return left;
  },
  nud(grammar) {
    return this;
  },
  combine() {
    return 0;
  }
};

const IdentifierToken = Object.create(RootToken, {
  firstChar: {
    value: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_'
  },
  registerWithinTokenizer: {
    value(tokenizer) {
      for (const c of this.firstChar) {
        tokenizer.maxTokenLengthForFirstChar[c] = 1;
        tokenizer.registeredTokens[c] = this;
      }
    }
  },
  parseString: {
    value(pp) {
      let i = pp.offset + 1;
      for (;;) {
        const c = pp.chunk[i];
        if (
          (c >= 'a' && c <= 'z') ||
          (c >= 'A' && c <= 'Z') ||
          (c >= '0' && c <= '9') ||
          c === '_'
        ) {
          i += 1;
        } else {
          break;
        }
      }

      const properties = pp.properties;
      properties.value = {
        value: pp.chunk.substring(pp.offset, i)
      };
      pp.offset = i;
      return Object.create(this, properties);
    }
  },
  type: {
    value: 'identifier'
  }
});



const StringToken = Object.create(RootToken, {
  registerWithinTokenizer: {
    value(tokenizer) {
      for (const c of '"\'') {
        tokenizer.maxTokenLengthForFirstChar[c] = 1;
        tokenizer.registeredTokens[c] = this;
      }
    }
  },
  parseString: {
    value(pp) {
      const properties = pp.properties;
      const tc = pp.chunk[pp.offset];
      let str = '';
      let i = pp.offset + 1;
      let c;
      for (; i < pp.chunk.length; ) {
        c = pp.chunk[i];
        if (c === tc) {
          pp.offset = i + 1;
          return Object.create(
            this,
            Object.assign(
              {
                value: {
                  value: str
                }
              },
              properties
            )
          );
        } else if (c === '\\') {
          i += 1;
          c = pp.chunk[i];
          switch (c) {
            case 'b':
              c = '\b';
              break;
            case 'f':
              c = '\f';
              break;
            case 'n':
              c = '\n';
              break;
            case 'r':
              c = '\r';
              break;
            case 't':
              c = '\t';
              break;
            case 'u':
              c = parseInt(pp.chunk.substr(i + 1, 4), 16);
              if (!isFinite(c) || c < 0) {
                pp.tokenizer.error('Unterminated string', pp, str);
              }
              c = String.fromCharCode(c);
              i += 4;
              break;
          }
          str += c;
          i += 1;
        } else {
          str += c;
          i += 1;
        }
      }
      if (i === pp.chunk.length && c !== tc) {
        pp.tokenizer.error('Unterminated string', pp, str);
      }
    }
  },
  type: {
    value: 'string'
  }
});

const NumberToken = Object.create(RootToken, {
  registerWithinTokenizer: {
    value(tokenizer) {
      for (const c of '0123456789') {
        tokenizer.maxTokenLengthForFirstChar[c] = 1;
        tokenizer.registeredTokens[c] = this;
      }
    }
  },
  parseString: {
    value(pp) {
      const properties = pp.properties;
      let str = pp.chunk[pp.offset];
      pp.offset += 1;
      for (; pp.offset < pp.chunk.length; ) {
        const c = pp.chunk[pp.offset];
        if ((c < '0' || c > '9') && c !== '.' && c !== 'e' && c !== 'E') {
          break;
        }
        pp.offset += 1;
        str += c;
      }
      return Object.create(
        this,
        Object.assign(properties, {
          value: {
            value: +str
          }
        })
      );
    }
  },
  type: {
    value: 'number'
  }
});

const OperatorToken = Object.create(RootToken, {
  registerWithinTokenizer: {
    value(tokenizer) {
      const c = this.value;
      const firstChar = c[0];
      const maxLength = tokenizer.maxTokenLengthForFirstChar[firstChar] || 0;

      if (maxLength < c.length) {
        tokenizer.maxTokenLengthForFirstChar[firstChar] = c.length;
      }

      const p = tokenizer.registeredTokens[c];
      if (p) {
        // TODO dirty hack how to merge nud() and let() tokens
        //console.log(`Token already defined ${c} ${this.nud} <> ${p.nud}`);
        this.nud = p.nud;
        //tokenizer.registeredTokens[c] = Object.assign(this,p);
        tokenizer.registeredTokens[c] = this;
      } else {
        tokenizer.registeredTokens[c] = this;
      }
    }
  },
  parseString: {
    value(pp) {
      pp.offset += this.value.length;
      return Object.create(this, pp.properties);
    }
  },
  type: {
    value: 'operator'
  }
});

/**
 * skip white space
 */
const WhiteSpaceToken = Object.create(RootToken, {
  registerWithinTokenizer: {
    value(tokenizer) {
      for (const c of ' \f\t\b\r\n') {
        tokenizer.maxTokenLengthForFirstChar[c] = 1;
        tokenizer.registeredTokens[c] = this;
      }
    }
  },
  parseString: {
    value(pp) {
      while (pp.chunk[pp.offset] <= ' ') {
        if (pp.chunk[pp.offset] === '\n') {
          pp.lineNumber += 1;
          pp.firstCharInLine = pp.offset;
        }
        pp.offset += 1;
      }
      return undefined;
    }
  },
  type: {
    value: 'space'
  }
});

/**
 * skips until end of line
 */


/**
 * Token representing 'end of file'
 */
const EOFToken = Object.create(RootToken, {
  type: {
    value: 'EOF'
  }
});

/**
 * @module pratt-parser
 */

const rootPP = {
  chunk: undefined,
  context: {},
  firstCharInLine: 0,
  lineNumber: 1,
  offset: 0,
  get positionInLine() {
    return this.offset - this.firstCharInLine;
  },
  get properties() {
    return {
      lineNumber: {
        value: this.lineNumber
      },
      positionInLine: {
        value: this.positionInLine
      }
    };
  }
};

class Tokenizer {
  /**
	 * Creates a tokenizer for later parsing
	 * @param {object} grammar definition of the grammar with operators...
	 */
  constructor(grammar) {
    const maxTokenLengthForFirstChar = {};
    const registeredTokens = {};

    Object.defineProperty(this, 'maxTokenLengthForFirstChar', {
      value: maxTokenLengthForFirstChar
    });
    Object.defineProperty(this, 'registeredTokens', {
      value: registeredTokens
    });

    const operatorTypes = {
      prefix: {
        token: OperatorToken,

        properties: {
          nud: {
            value(grammar, left) {
              return this.combine(left, grammar.expression(this.precedence));
            },
            writable: true
          }
        }
      },
      infix: {
        token: OperatorToken,

        properties: {
          led: {
            value(grammar, left) {
              return this.combine(left, grammar.expression(this.precedence));
            },
            writable: true
          }
        }
      },
      infixr: {
        token: OperatorToken,

        properties: {
          led: {
            value(grammar, left) {
              return this.combine(
                left,
                grammar.expression(this.precedence - 1)
              );
            },
            writable: true
          }
        }
      }
    };

    for (const operatorTypeName in operatorTypes) {
      const ops = grammar[operatorTypeName];
      const operatorType = operatorTypes[operatorTypeName];

      for (const c in ops) {
        operatorType.properties.value = {
          value: c
        };

        Object.assign(
          Object.create(operatorType.token, operatorType.properties),
          ops[c]
        ).registerWithinTokenizer(this);
      }
    }

    if (grammar.tokens !== undefined) {
      grammar.tokens.forEach(token => token.registerWithinTokenizer(this));
    }
  }

  /**
	 * delivers tokens from the input
	 * @param {string} chunk the input to be processed
	 * @param {object} context additional info to be used by the actual token types
	 */
  *tokens(chunk, context) {
    const pp = Object.create(rootPP);
    pp.context = context;
    pp.chunk = chunk;
    pp.tokenizer = this;

    do {
      const c = pp.chunk[pp.offset];
      let tokenLength = this.maxTokenLengthForFirstChar[c];

      if (tokenLength > 0) {
        do {
          const t = this.registeredTokens[
            pp.chunk.substring(pp.offset, pp.offset + tokenLength)
          ];
          if (t !== undefined) {
            const rt = t.parseString(pp);

            if (rt !== undefined) {
              yield rt;
            }
            break;
          }
        } while (tokenLength-- > 1);
      } else {
        if (c === undefined) {
          return Object.create(EOFToken, pp.properties);
        }

        pp.offset += 1;

        this.error('Unknown char', pp, c);
      }
    } while (true);
  }

  /**
	 * @param {string} message
	 * @param {object} context token initiating the error
	 * @param {object} [value]
	 * @return {Object} error
	 */
  error(message, context, value) {
    message = `${context.lineNumber},${context.positionInLine}: ${message} "${value}"`;
    throw new Error(message);
  }
}

/**
 * @module pratt-parser
 */

class Parser {
  /**
	 * Creates a grammar for later parsing
	 * @param {object} grammar definition of the grammar with operators...
	 * @return {object} parser
	 */
  constructor(grammar, options = {}) {
    Object.defineProperty(this, 'tokenizer', {
      value: options.tokenizer || new Tokenizer(grammar)
    });
  }

  /**
	 * Forwards error to the tokenizer
	 * @param {string} message
	 * @param {object} context
	 * @return {Object} error
	 */
  error(...args) {
    return this.tokenizer.error(...args);
  }

  /**
	 * Parses the input and delivers the outermoost expression.
	 * @param {string} chunk input text
	 * @param {object} context object transparently passed to tokenizer
	 * @return {object} evaluated input
	 */
  parse(chunk, context) {
    this.context = context;

    const tokens = this.tokenizer.tokens(chunk, context);

    this.advance = id => {
      if (
        id !== undefined &&
        this.token.value !== undefined &&
        this.token.value !== id
      ) {
        this.error(`Got ${this.token.value} expected ${id}`, this.token);
      }

      const n = tokens.next();
      this.token = n.done ? EOFToken : n.value;
      return this.token;
    };

    this.token = this.advance();

    this.expression = precedence => {
      let t = this.token;
      this.advance();
      let left = t.nud(this);

      while (precedence < this.token.precedence) {
        t = this.token;
        this.advance();
        left = t.led(this, left);
      }

      return left;
    };

    return this.expression(this.token.precedence);
  }
}

function createValue(value) {
  return Object.create(null, {
    value: {
      value
    }
  });
}

class AST {
  get value() {
    return undefined;
  }
}

class ArraySlice extends AST {
  constructor(array, index) {
    super();
    Object.defineProperty(this, 'value', {
      get: () => array.value[index.value]
    });
  }
}

class ObjectAccess extends AST {
  constructor(object, attribute) {
    super();
    Object.defineProperty(this, 'value', {
      get: () => {
        if (object.value instanceof Promise) {
          return object.value.then(v => {
            const a = v[attribute.value];
            return a instanceof Function ? a() : a;
          });
        }
        const a = object.value[attribute.value];
        return a instanceof Function ? a() : a;
      }
    });
  }
}

class SpreadOP extends AST {
  constructor(a, b) {
    super();
    Object.defineProperty(this, 'value', {
      get: () => createValue([a.value, b.value])
    });
  }
}

class BinOP extends AST {
  constructor(a, b, exec) {
    super();
    Object.defineProperty(this, 'value', {
      get: () => {
        if (a.value instanceof Promise) {
          if (b.value instanceof Promise) {
            return Promise.all([a.value, b.value]).then(args =>
              exec(...args.map(v => createValue(v)))
            );
          }
          return a.value.then(a => exec(createValue(a), b));
        } else if (b.value instanceof Promise) {
          return b.value.then(b => exec(a, createValue(b)));
        }
        return exec(a, b);
      }
    });
  }
}

class TeneryOP extends AST {
  constructor(exp, a, b) {
    super();
    Object.defineProperty(this, 'value', {
      get: () => (exp.value ? a.value : b.value)
    });
  }
}

class FCall extends AST {
  constructor(f, context, args) {
    super();

    Object.defineProperty(this, 'value', {
      get: () =>
        Promise.all(args.map(a => a.value)).then(
          r => f.apply(context, r.map(v => createValue(v))).value
        )
    });
  }
}

const grammar = {
  tokens: [
    WhiteSpaceToken,
    NumberToken,
    StringToken,
    Object.create(IdentifierToken, {
      parseString: {
        value(pp) {
          let i = pp.offset + 1;
          for (;;) {
            const c = pp.chunk[i];
            if (
              (c >= 'a' && c <= 'z') ||
              (c >= 'A' && c <= 'Z') ||
              (c >= '0' && c <= '9') ||
              c === '_'
            ) {
              i += 1;
            } else {
              break;
            }
          }

          const value = pp.chunk.substring(pp.offset, i);
          const properties = pp.properties;

          pp.offset = i;

          const path = pp.context.path;

          if (path.length >= 2) {
            const ctx = path[path.length - 2];
            if (ctx.value[value] !== undefined) {
              properties.value = {
                value: ctx.value[value]
              };
              return Object.create(this, properties);
            }
          }

          if (path[0].value.constants) {
            const v = path[0].value.constants[value];
            if (v !== undefined) {
              properties.value = {
                value: v
              };
              return Object.create(this, properties);
            }
          }

          const c = pp.context.constants[value];
          if (c) {
            properties.value = {
              value: c
            };
          } else {
            properties.value = {
              value
            };
          }

          return Object.create(this, properties);
        }
      }
    })
  ],

  prefix: {
    '(': {
      precedence: 80,
      led(grammar, left) {
        if (left.type === 'identifier') {
          const args = [];

          if (grammar.token.value !== ')') {
            while (true) {
              args.push(grammar.expression(0));

              if (grammar.token.value !== ',') {
                break;
              }
              grammar.advance(',');
            }
          }

          grammar.advance(')');

          const f = grammar.context.functions[left.value];
          if (f) {
            if (f.arguments && f.arguments.length > args.length) {
              grammar.error('Missing argument', left, left.value);
            } else {
              if (f.arguments) {
                let i = 0;
                for (const a of f.arguments) {
                  if (!isOfType(a, args[i].value)) {
                    grammar.error(
                      `Wrong argument type ${a} != ${typeof args[i].value}`,
                      left,
                      left.value
                    );
                  }
                  i++;
                }
              }

              return new FCall(f, grammar.context, args);
            }
          } else {
            grammar.error('Unknown function', left, left.value);
          }
        } else {
          const e = grammar.expression(0);
          grammar.advance(')');
          return e;
        }
      }
    },
    '[': {
      nud(grammar) {
        const values = [];

        if (grammar.token.value !== ']') {
          while (true) {
            values.push(grammar.expression(0).value);

            if (grammar.token.value !== ',') {
              break;
            }
            grammar.advance(',');
          }
        }
        grammar.advance(']');
        return createValue(values);
      }
    }
  },
  infixr: {
    '..': {
      precedence: 30,
      combine: (left, right) =>
        new SpreadOP(left, right, (l, r) => l.value && r.value)
    },
    '&&': {
      precedence: 30,
      combine: (left, right) =>
        new BinOP(left, right, (l, r) => l.value && r.value)
    },
    '||': {
      precedence: 30,
      combine: (left, right) =>
        new BinOP(left, right, (l, r) => l.value || r.value)
    },
    '==': {
      precedence: 40,
      combine: (left, right) =>
        new BinOP(left, right, (l, r) => l.value === r.value)
    },
    '!=': {
      precedence: 40,
      combine: (left, right) =>
        new BinOP(left, right, (l, r) => l.value !== r.value)
    },
    '>=': {
      precedence: 40,
      combine: (left, right) =>
        new BinOP(left, right, (l, r) => l.value >= r.value)
    },
    '<=': {
      precedence: 40,
      combine: (left, right) =>
        new BinOP(left, right, (l, r) => l.value <= r.value)
    },
    '>': {
      precedence: 40,
      combine: (left, right) =>
        new BinOP(left, right, (l, r) => l.value > r.value)
    },
    '<': {
      precedence: 40,
      combine: (left, right) =>
        new BinOP(left, right, (l, r) => l.value < r.value)
    }
  },
  infix: {
    '.': {
      precedence: 80,
      combine: (left, right) => new ObjectAccess(left, right)
    },
    '[': {
      precedence: 80,
      led(grammar, left) {
        const right = grammar.expression(0);
        grammar.advance(']');
        return new ArraySlice(left, right);
      }
    },

    '?': {
      precedence: 20,
      led(grammar, left) {
        const e1 = grammar.expression(0);
        grammar.advance(':');
        const e2 = grammar.expression(0);
        return new TeneryOP(left, e1, e2);
      }
    },
    ':': {},
    ']': {},
    ',': {},
    ')': {},
    '+': {
      precedence: 50,
      combine: (left, right) =>
        new BinOP(left, right, (l, r) => l.value + r.value)
    },
    '-': {
      precedence: 50,
      combine: (left, right) =>
        new BinOP(left, right, (l, r) => l.value - r.value)
    },
    '*': {
      precedence: 60,
      combine: (left, right) =>
        new BinOP(left, right, (l, r) => l.value * r.value)
    },
    '/': {
      precedence: 60,
      combine: (left, right) =>
        new BinOP(left, right, (l, r) => l.value / r.value)
    }
  }
};

class ConfigParser extends Parser {
  constructor() {
    super(grammar);
  }
}

function isOfType(typeDescription, value) {
  const tv = typeof value;

  for (const t of typeDescription.split(/\|/)) {
    if (t === tv) {
      return true;
    }
    if (t === 'integer' && tv === 'number') {
      return true;
    }
  }

  // TODO how to handle promises ?
  if (value instanceof Promise) {
    return true;
  }

  return false;
}

/**
 * @module config-expander
 */

const path$2 = require('path');
const fs$1 = require('fs');
const crypto = require('crypto');
const { promisify } = require('util');

const readFile = promisify(fs$1.readFile);

const functions = {
  document: {
    arguments: ['string'],
    returns: 'buffer',
    apply: (context, args) =>
      createValue(
        readFile(path$2.resolve(context.constants.basedir, args[0].value))
      )
  },
  resolve: {
    arguments: ['string'],
    returns: 'string',
    apply: (context, args) =>
      createValue(path$2.resolve(context.constants.basedir, args[0].value))
  },

  /**
   * include definition form a file
   * @param file {string} file name to be included
   * @return {string} content of the file
   */
  include: {
    arguments: ['string'],
    returns: 'object',
    apply: (context, args) => {
      const file = path$2.resolve(context.constants.basedir, args[0].value);

      return createValue(
        readFile(file).then(data =>
          expand(
            JSON.parse(data),
            Object.assign({}, context, {
              constants: Object.assign({}, context.constants, {
                basedir: path$2.dirname(file)
              })
            })
          )
        )
      );
    }
  },
  number: {
    arguments: ['string|number'],
    returns: 'number',
    apply: (context, args) => {
      const v = args[0].value;
      return createValue(
        parseFloat(v) === v ? v : parseFloat(v.replace(/[a-z]+/, ''))
      );
    }
  },
  string: {
    arguments: ['string|buffer'],
    returns: 'string',
    apply: (context, args) => {
      const v = args[0].value;
      return createValue(v instanceof Buffer ? v.toString() : v);
    }
  },
  length: {
    arguments: ['string|object'],
    returns: 'integer',
    apply: (context, args) => createValue(args[0].value.length)
  },

  substring: {
    arguments: ['string', 'integer', 'integer'],
    returns: 'string',
    apply: (context, args) =>
      createValue(args[0].value.substring(args[1].value, args[2].value))
  },
  replace: {
    arguments: ['string', 'string', 'string'],
    returns: 'string',
    apply: (context, args) =>
      createValue(args[0].value.replace(args[1].value, args[2].value))
  },

  /**
	 * convert string into upper case
	 * @param source {string} input value
	 * @return {string} uppercase result
	 */
  toUpperCase: {
    arguments: ['string'],
    returns: 'string',
    apply: (context, args) => createValue(args[0].value.toUpperCase())
  },

  /**
	 * convert string into lower case
	 * @param source {string} input value
	 * @return {string} lowercase result
	 */
  toLowerCase: {
    arguments: ['string'],
    returns: 'string',
    apply: (context, args) => createValue(args[0].value.toLowerCase())
  },

  split: {
    arguments: ['string', 'string'],
    returns: 'string[]',
    /**
		 * split source string on pattern boundaries
		 * @param source {string}
		 * @param pattern {string}
		 * @return {string[]} separated source
		 */
    apply: (context, args) => createValue(args[0].value.split(args[1].value))
  },

  first: {
    arguments: ['object|number'],
    returns: 'object?',
    apply: (context, args) => {
      args = args.filter(e => e !== undefined && e.value !== undefined);

      /*
						const promises = args.filter(e => e.value instanceof Promise);

						if(promises.length > 0) {
							console.log(`has promises`);
							return Promise.all(promises)
								.then(all => all[0])
								.catch(error => undefined);
						}
			*/

      return args.length === 0 ? createValue(undefined) : args[0];
    }
  },

  encrypt: {
    arguments: ['string', 'string'],
    returns: 'string',
    /**
		 * Encrypt a plaintext value
		 * @param key {string}
		 * @param plaintext {string} input value
		 * @return {string} encrypted value
		 */
    apply: (context, args) => {
      const [key, plaintext] = args.map(a => a.value);
      const encipher = crypto.createCipher('aes-256-cbc', key);
      let encryptdata = encipher.update(plaintext, 'utf8', 'binary');
      encryptdata += encipher.final('binary');
      return createValue(Buffer.from(encryptdata, 'binary').toString('base64'));
    }
  },

  decrypt: {
    arguments: ['string', 'string'],
    returns: 'string',
    /**
		 * Decrypt a former encrypted string
		 * @param key {string}
		 * @param encrypted {string}
		 * @return {string} plaintext
		 */
    apply: (context, args) => {
      let [key, encryptdata] = args.map(a => a.value);
      encryptdata = Buffer.from(encryptdata, 'base64').toString('binary');
      const decipher = crypto.createDecipher('aes-256-cbc', key);
      let decoded = decipher.update(encryptdata, 'binary', 'utf8');
      decoded += decipher.final('utf8');
      return createValue(decoded);
    }
  }
};

/**
 * @module config-expander
 */

const os$1 = require('os');

/**
 * Expands expressions in a configuration object
 * Predefined constants:
 * - os
 * - basedir
 * @param config {object} config source
 * @param [options] {object} - the options
 * @param [options.constants] {object} - additional constants
 * @param [options.functions] {object} - additional functions
 * @returns {Promise}
 * @fulfil {object} - expanded configuration
 */
async function expand(config, options = {}) {
  const context = {
    constants: Object.assign(
      {
        basedir: process.cwd(),
        os: os$1
      },
      options.constants
    ),
    functions: Object.assign({}, functions, options.functions)
  };

  const parser = new ConfigParser();

  const ee = createContext({
    evaluate: (expression, _unusedContext, path) => {
      context.path = path;
      const ast = parser.parse(expression, context);
      return ast.value;
    }
  });

  return ee.expand(config);
}

const os = require('os');
const path = require('path');
const program = require('caporal');
const systemdSocket = require('systemd-socket');
const rebirth = require('rebirth');
const address = require('network-address');

let logLevel;

const flowFileNames = [];
const configStatements = [];

program
  .version(require(path.join(__dirname, '..', 'package.json')).version)
  .description('run cluster node')
  .option('-f, --flow <file>', 'flow to be registered', name =>
    flowFileNames.push(name)
  )
  .option('-s, --start', 'start flow after registering')
  .option('-c, --config <file>', 'use config from file')
  .option('-d --define <key=value>', 'define (service) value', value =>
    configStatements.push(value)
  )
  .option('--debug', 'enable debugging')
  .option('--trace', 'enable tracing')
  .action(async (args, options, logger) => {
    if (options.debug) {
      logLevel = 'debug';
    } else if (options.trace) {
      logLevel = 'trace';
    }

    const constants = {
      basedir: path.dirname(options.config || process.cwd()),
      installdir: path.resolve(__dirname, '..'),
      networkAddress: address()
    };

    configStatements.forEach(value => {
      const m = value.match(/^([a-zA-Z_][a-zA-Z_0-9]*)=(.*)/);
      if (m) {
        constants[m[1]] = m[2];
      }
    });

    const [modules, config] = await Promise.all([
      kronosModules(),
      expand(
        options.config
          ? "${include('" + path.basename(options.config) + "')}"
          : {
              services: {
                registry: {
                  // consul
                  checkInterval: 60
                },
                'koa-admin': {
                  docRoot: "${installdir + '/docroot'}"
                }
              }
            },
        {
          constants
        }
      )
    ]);

    configStatements.forEach(value => {
      const m = value.match(/^([^\.]+).([^=]+)=(.*)/);
      if (m) {
        const serviceName = m[1];
        const attributeName = m[2];
        const value = m[3];

        let service = config.services[serviceName];
        if (!service) {
          service = config.services[serviceName] = {};
        }

        assign(service, value, attributeName);
      }
    });

    if (logLevel !== undefined) {
      Object.keys(config.services).forEach(
        sn => (config.services[sn].logLevel = logLevel)
      );
    }

    const sds = systemdSocket();
    if (sds) {
      const as = config.services['koa-admin'];
      if (as !== undefined) {
        as.port = sds;
      }
    }

    const services = [
      config.services.kronos || {
        port: 10000
      }
    ];
    services[0].name = 'kronos';

    Object.keys(config.services).forEach(sn => {
      if (sn !== 'kronos') {
        const service = config.services[sn];
        service.name = sn;
        services.push(service);
      }
    });

    const m = await kronosServiceManager.manager(services, modules);

    if (logLevel !== undefined) {
      Object.keys(m.services).forEach(
        sn => (m.services[sn].logLevel = logLevel)
      );
    }

    process.on('uncaughtException', err => m.error(err));
    process.on('unhandledRejection', reason => m.error(reason));
    process.on('SIGINT', () => {
      try {
        m.stop().then(() => process.exit());
      } catch (e) {
        console.error(e);
        process.exit();
      }
    });

    process.title = m.id;

    flowFileNames.forEach(name => {
      kronosServiceManager.manager
        .loadFlowFromFile(name)
        .then(flow => {
          m.info(`Flow declared: ${flow}`);
          if (program.start) {
            m.info(`Starting ... ${flow}`);
            flow
              .start()
              .then(() => m.info(`Flow started: ${flow}`))
              .catch(error => m.error(`Flow started failed: ${error}`));
          }
        })
        .catch(error => m.error(`Flow initialization failed: ${error}`));
    });
  });

program.parse(process.argv);

process.on('SIGHUP', () => rebirth());
 at SyntaxError: Unexpected character '#' (1:78)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$7.getTokenFromCode (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2756:10)
    at Parser.pp$7.readToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2477:17)
    at Parser.readToken (/root/ExpoSE/lib/Tropigate/bin/Tokens.js:124:26)
    at Parser.pp$7.nextToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2468:15)
    at Parser.pp$7.next (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2413:10)
    at Parser.pp.eat (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:536:12)
    at Parser.pp.semicolon (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:581:15)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:918:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
