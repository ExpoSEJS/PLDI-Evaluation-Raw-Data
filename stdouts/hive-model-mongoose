/root/Targets/hive-model-mongoose
└─┬ hive-model-mongoose@0.0.3 
  ├── async@0.1.22 
  ├── gate@0.3.0 
  ├─┬ hive-component@0.0.1 
  │ └─┬ hive-configuration@0.0.1 
  │   └── underscore@1.3.3 
  ├─┬ tap@0.3.3 
  │ ├── buffer-equal@0.0.2 
  │ ├── deep-equal@0.0.0 
  │ ├─┬ difflet@0.2.6 
  │ │ ├── charm@0.1.2 
  │ │ ├── deep-is@0.1.3 
  │ │ └── traverse@0.6.6 
  │ ├── inherits@1.0.0 
  │ ├── mkdirp@0.3.5 
  │ ├─┬ nopt@2.2.1 
  │ │ └── abbrev@1.1.0 
  │ ├─┬ runforcover@0.0.2 
  │ │ └─┬ bunker@0.1.2 
  │ │   └─┬ burrito@0.2.12 
  │ │     ├── traverse@0.5.2 
  │ │     └── uglify-js@1.1.1 
  │ ├── slide@1.1.6 
  │ ├─┬ tap-consumer@0.0.1 
  │ │ ├── inherits@2.0.3 
  │ │ ├─┬ tap-results@0.0.2 
  │ │ │ └── inherits@1.0.2 
  │ │ └── yamlish@0.0.7 
  │ └── yamlish@0.0.5 
  └── underscore@1.4.4 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/hive-model-mongoose/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 31% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","call","join","RegExp","sort"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.081 took 14.483s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (6:4) on program 'use strict';

exports.create = create;

var util = require('util');
var assert = require('assert');
var noop = function noop() {};

function create(options) {
  return new Gate(options);
}

function Gate(options) {
  options = options || {};
  var count = typeof options.count === 'number' ? options.count : -1;
  var failFast = options.failFast !== false;
  this._async = new Async(count, failFast);
}

Object.defineProperty(Gate.prototype, "count", {
  get: function count() { return this._async.count; },
  enumerable: true
});

Gate.prototype.latch = function latch(name, mapping) {
  if (typeof name !== "string") {
      mapping = name;
      name = null;
  }
  return this._async.makeCallback(latch, name, mapping);
};

Gate.prototype.val = function val(value) {
  return new Val(value);
};

Gate.prototype.await = function await(callback) {
  this._async.await(callback);
  this._async.await = noop;  
};

function Val(value) {
  this.value = value;
}

function Async(count, failFast) {
  this.count = count;
  this.failFast = failFast;
  this.index = 0;
  this.pending = 0;
  this.canceled = false;
  this.next = null;
  this.error = null;
  this.results = {};
}

Async.prototype.await = function await(callback) {
  if (this.error) {
    next(this.error, null);
  } else if (this.pending === 0 && this.count <= 0) {
    next(null, this.results);
  } else {
    this.next = next;
  }

  function next(error, results) {
    callback(error, results, new Gate());
  }
};

Async.prototype.makeCallback = function makeCallback(caller, name, mapping) {
  var type = typeof mapping;
  assert(type !== 'undefined' || type !== 'number' || type !== 'object', 
    'An argument `mapping` must be a number or an object, if specified.');
  if (this.count === 0) return noop;
  if (this.count > 0) this.count--;
  this.pending++;
  var index = this.index++;
  var location = getLocation(caller);
  var self = this;

  return function callback(error) {
    var next = self.next;
    self.pending--;
    if (!self.canceled) {
      
      if (error instanceof Error) {
        if (!('gate_location' in error)) {
          // expand the error object
          error.gate_location = location;
        }
        if (self.failFast) {
          self.canceled = true;
          if (next) {
            self.next = noop;
            next(error, null);
          } else {
            self.error = error;
          }
          return;
        }
      }

      var result = mapArguments(mapping, arguments);
      if (name === null) {
        self.results[index] = result;
      } else {
        self.results[name] = result;
      }
      if (self.pending === 0 && self.count <= 0 && next) {
        self.next = noop;
        next(null, self.results);
      }
    }
  };
  
  function mapArguments(mapping, args) {
    if (typeof mapping === 'number') return args[mapping];
    if (!mapping) return Array.prototype.slice.call(args);
    return Object.keys(mapping).reduce(function (result, key) {
      var value = mapping[key];
      if (typeof value === 'number') {
        result[key] = args[value];
      } else if (value instanceof Val) {
        result[key] = value.value;
      } else {
        result[key] = value;
      }
      return result;
    }, {});
  }

  function getLocation(target) {
    var originalPrepareStackTrace = Error.prepareStackTrace;
    var originalStackTraceLimit = Error.stackTraceLimit;
    Error.prepareStackTrace = prepareStackTrace;
    Error.stackTraceLimit = 1;
    var err = {};
    Error.captureStackTrace(err, target);
    var stack = err.stack;
    Error.prepareStackTrace = originalPrepareStackTrace;
    Error.stackTraceLimit = originalStackTraceLimit;
    return util.format('%s:%d:%d', stack.getFileName(), stack.getLineNumber(), stack.getColumnNumber());
  }

  function prepareStackTrace() {
    return arguments[1][0];
  }
}; at SyntaxError: Unexpected token (6:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/hive-model-mongoose/node_modules/hive-model-mongoose/index.js. Coverage (Term): 80% Coverage (LOC): 100%
*- File /root/Targets/hive-model-mongoose/node_modules/hive-model-mongoose/lib/index.js. Coverage (Term): 7% Coverage (LOC): 8%
*- File /root/Targets/hive-model-mongoose/node_modules/underscore/underscore.js. Coverage (Term): 18% Coverage (LOC): 32%
*- File /root/Targets/hive-model-mongoose/node_modules/hive-component/index.js. Coverage (Term): 37% Coverage (LOC): 57%
*- File /root/Targets/hive-model-mongoose/node_modules/hive-component/lib/Component.js. Coverage (Term): 36% Coverage (LOC): 38%
*- File /root/Targets/hive-model-mongoose/node_modules/hive-component/lib/extend.js. Coverage (Term): 25% Coverage (LOC): 30%
*- File /root/Targets/hive-model-mongoose/node_modules/hive-component/lib/params.js. Coverage (Term): 21% Coverage (LOC): 23%
*- File /root/Targets/hive-model-mongoose/node_modules/hive-component/lib/init.js. Coverage (Term): 32% Coverage (LOC): 30%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
