/root/Targets/firebase-mock-v3
└─┬ firebase-mock-v3@0.1.3 
  ├─┬ browserify@6.3.4 
  │ ├── assert@1.1.2 
  │ ├─┬ browser-pack@3.2.0 
  │ │ ├─┬ combine-source-map@0.3.0 
  │ │ │ ├── convert-source-map@0.3.5 
  │ │ │ ├─┬ inline-source-map@0.3.1 
  │ │ │ │ └── source-map@0.3.0 
  │ │ │ └─┬ source-map@0.1.43 
  │ │ │   └── amdefine@1.0.1 
  │ │ └─┬ through2@0.5.1 
  │ │   └── readable-stream@1.0.34 
  │ ├─┬ browser-resolve@1.11.2 
  │ │ └── resolve@1.1.7 
  │ ├─┬ browserify-zlib@0.1.4 
  │ │ └── pako@0.2.9 
  │ ├─┬ buffer@2.8.2 
  │ │ ├── base64-js@0.0.7 
  │ │ ├── ieee754@1.1.8 
  │ │ └── is-array@1.0.1 
  │ ├── builtins@0.0.7 
  │ ├── commondir@0.0.1 
  │ ├─┬ concat-stream@1.4.10 
  │ │ └── typedarray@0.0.6 
  │ ├─┬ console-browserify@1.1.0 
  │ │ └── date-now@0.1.4 
  │ ├── constants-browserify@0.0.1 
  │ ├─┬ crypto-browserify@3.11.1 
  │ │ ├─┬ browserify-cipher@1.0.0 
  │ │ │ ├─┬ browserify-aes@1.0.8 
  │ │ │ │ └── buffer-xor@1.0.3 
  │ │ │ ├─┬ browserify-des@1.0.0 
  │ │ │ │ └── des.js@1.0.0 
  │ │ │ └─┬ evp_bytestokey@1.0.3 
  │ │ │   └─┬ md5.js@1.3.4 
  │ │ │     └── hash-base@3.0.4 
  │ │ ├─┬ browserify-sign@4.0.4 
  │ │ │ ├── bn.js@4.11.8 
  │ │ │ ├── browserify-rsa@4.0.1 
  │ │ │ ├─┬ elliptic@6.4.0 
  │ │ │ │ ├── brorand@1.1.0 
  │ │ │ │ ├── hash.js@1.1.3 
  │ │ │ │ ├── hmac-drbg@1.0.1 
  │ │ │ │ ├── minimalistic-assert@1.0.0 
  │ │ │ │ └── minimalistic-crypto-utils@1.0.1 
  │ │ │ └─┬ parse-asn1@5.1.0 
  │ │ │   └── asn1.js@4.9.1 
  │ │ ├── create-ecdh@4.0.0 
  │ │ ├─┬ create-hash@1.1.3 
  │ │ │ ├── cipher-base@1.0.4 
  │ │ │ └─┬ ripemd160@2.0.1 
  │ │ │   └── hash-base@2.0.2 
  │ │ ├─┬ create-hmac@1.1.6 
  │ │ │ └── safe-buffer@5.1.1 
  │ │ ├─┬ diffie-hellman@5.0.2 
  │ │ │ └── miller-rabin@4.0.1 
  │ │ ├── pbkdf2@3.0.14 
  │ │ ├── public-encrypt@4.0.0 
  │ │ └── randombytes@2.0.5 
  │ ├── deep-equal@0.2.2 
  │ ├── defined@0.0.0 
  │ ├─┬ deps-sort@1.3.9 
  │ │ └─┬ JSONStream@1.3.1 
  │ │   └── jsonparse@1.3.1 
  │ ├── domain-browser@1.1.7 
  │ ├── duplexer2@0.0.2 
  │ ├── events@1.0.2 
  │ ├─┬ glob@4.5.3 
  │ │ ├─┬ inflight@1.0.6 
  │ │ │ └── wrappy@1.0.2 
  │ │ ├─┬ minimatch@2.0.10 
  │ │ │ └─┬ brace-expansion@1.1.8 
  │ │ │   ├── balanced-match@1.0.0 
  │ │ │   └── concat-map@0.0.1 
  │ │ └── once@1.4.0 
  │ ├─┬ http-browserify@1.7.0 
  │ │ └── Base64@0.2.1 
  │ ├── https-browserify@0.0.1 
  │ ├── inherits@2.0.3 
  │ ├─┬ insert-module-globals@6.6.3 
  │ │ ├─┬ combine-source-map@0.6.1 
  │ │ │ ├── convert-source-map@1.1.3 
  │ │ │ ├── inline-source-map@0.5.0 
  │ │ │ ├── lodash.memoize@3.0.4 
  │ │ │ └── source-map@0.4.4 
  │ │ ├─┬ JSONStream@1.3.1 
  │ │ │ └── jsonparse@1.3.1 
  │ │ ├─┬ lexical-scope@1.2.0 
  │ │ │ └── astw@2.2.0 
  │ │ ├── process@0.11.10 
  │ │ └── xtend@4.0.1 
  │ ├── isarray@0.0.1 
  │ ├─┬ JSONStream@0.8.4 
  │ │ └── jsonparse@0.0.5 
  │ ├─┬ labeled-stream-splicer@1.0.2 
  │ │ └─┬ stream-splicer@1.3.2 
  │ │   └── readable-wrap@1.0.0 
  │ ├─┬ module-deps@3.9.1 
  │ │ ├── defined@1.0.0 
  │ │ ├─┬ detective@4.5.0 
  │ │ │ └── defined@1.0.0 
  │ │ ├─┬ JSONStream@1.3.1 
  │ │ │ └── jsonparse@1.3.1 
  │ │ ├─┬ parents@1.0.1 
  │ │ │ └── path-platform@0.11.15 
  │ │ ├─┬ resolve@1.4.0 
  │ │ │ └── path-parse@1.0.5 
  │ │ ├─┬ stream-combiner2@1.0.2 
  │ │ │ └─┬ through2@0.5.1 
  │ │ │   └── readable-stream@1.0.34 
  │ │ └── xtend@4.0.1 
  │ ├── os-browserify@0.1.2 
  │ ├─┬ parents@0.0.3 
  │ │ └── path-platform@0.0.1 
  │ ├── path-browserify@0.0.0 
  │ ├── process@0.8.0 
  │ ├── punycode@1.2.4 
  │ ├── querystring-es3@0.2.1 
  │ ├─┬ readable-stream@1.1.14 
  │ │ └── core-util-is@1.0.2 
  │ ├── resolve@0.7.4 
  │ ├── shallow-copy@0.0.1 
  │ ├─┬ shasum@1.0.2 
  │ │ ├─┬ json-stable-stringify@0.0.1 
  │ │ │ └── jsonify@0.0.0 
  │ │ └── sha.js@2.4.9 
  │ ├── shell-quote@0.0.1 
  │ ├── stream-browserify@1.0.0 
  │ ├── string_decoder@0.10.31 
  │ ├─┬ subarg@1.0.0 
  │ │ └── minimist@1.2.0 
  │ ├─┬ syntax-error@1.3.0 
  │ │ └── acorn@4.0.13 
  │ ├─┬ through2@1.1.1 
  │ │ └── xtend@4.0.1 
  │ ├─┬ timers-browserify@1.4.2 
  │ │ └── process@0.11.10 
  │ ├── tty-browserify@0.0.0 
  │ ├─┬ umd@2.1.0 
  │ │ ├─┬ rfile@1.0.0 
  │ │ │ ├── callsite@1.0.0 
  │ │ │ └── resolve@0.3.1 
  │ │ ├─┬ ruglify@1.0.0 
  │ │ │ └─┬ uglify-js@2.2.5 
  │ │ │   └─┬ optimist@0.3.7 
  │ │ │     └── wordwrap@0.0.3 
  │ │ └─┬ uglify-js@2.4.24 
  │ │   ├── async@0.2.10 
  │ │   ├── source-map@0.1.34 
  │ │   ├── uglify-to-browserify@1.0.2 
  │ │   └─┬ yargs@3.5.4 
  │ │     ├── camelcase@1.2.1 
  │ │     ├── decamelize@1.2.0 
  │ │     ├── window-size@0.1.0 
  │ │     └── wordwrap@0.0.2 
  │ ├─┬ url@0.10.3 
  │ │ ├── punycode@1.3.2 
  │ │ └── querystring@0.2.0 
  │ ├─┬ util@0.10.3 
  │ │ └── inherits@2.0.1 
  │ ├─┬ vm-browserify@0.0.4 
  │ │ └── indexof@0.0.1 
  │ └── xtend@3.0.0 
  ├─┬ browserify-shim@3.8.14 
  │ ├─┬ exposify@0.5.0 
  │ │ ├─┬ globo@1.1.0 
  │ │ │ ├─┬ accessory@1.1.0 
  │ │ │ │ ├── ap@0.2.0 
  │ │ │ │ ├── balanced-match@0.2.1 
  │ │ │ │ └── dot-parts@1.0.1 
  │ │ │ ├── is-defined@1.0.0 
  │ │ │ └── ternary@1.0.0 
  │ │ ├── map-obj@1.0.1 
  │ │ ├─┬ replace-requires@1.0.4 
  │ │ │ ├─┬ has-require@1.2.2 
  │ │ │ │ └── escape-string-regexp@1.0.5 
  │ │ │ ├── patch-text@1.0.2 
  │ │ │ └── xtend@4.0.1 
  │ │ ├─┬ through2@0.4.2 
  │ │ │ ├── readable-stream@1.0.34 
  │ │ │ └─┬ xtend@2.1.2 
  │ │ │   └── object-keys@0.4.0 
  │ │ └── transformify@0.1.2 
  │ ├─┬ mothership@0.2.0 
  │ │ └── find-parent-dir@0.3.0 
  │ ├─┬ rename-function-calls@0.1.1 
  │ │ └─┬ detective@3.1.0 
  │ │   ├─┬ escodegen@1.1.0 
  │ │   │ ├── esprima@1.0.4 
  │ │   │ ├── estraverse@1.5.1 
  │ │   │ └── esutils@1.0.0 
  │ │   └── esprima-fb@3001.1.0-dev-harmony-fb 
  │ ├── resolve@0.6.3 
  │ └── through@2.3.8 
  ├── firebase-auto-ids@1.1.0 
  ├── lodash@2.4.2 
  ├─┬ md5@2.2.1 
  │ ├── charenc@0.0.2 
  │ ├── crypt@0.0.2 
  │ └── is-buffer@1.1.5 
  └── rsvp@3.6.2 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/firebase-mock-v3/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 34% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0455 took 2.6285s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (4:4) on program 'use strict';

var _        = require('lodash');
var assert   = require('assert');
var autoId   = require('firebase-auto-ids');
var Query    = require('./query');
var Snapshot = require('./snapshot');
var Queue    = require('./queue').Queue;
var utils    = require('./utils');
var Auth     = require('./auth');
var validate = require('./validators');

function MockFirebase (path, data, parent, name) {
  this.ref = this;
  this.path = path || 'Mock://';
  this.errs = {};
  this.priority = null;
  this.myName = parent ? name : extractName(path);
  this.key = this.myName;
  this.flushDelay = parent ? parent.flushDelay : false;
  this.queue = parent ? parent.queue : new Queue();
  this._events = {
    value: [],
    child_added: [],
    child_removed: [],
    child_changed: [],
    child_moved: []
  };
  this.parentRef = parent || null;
  this.children = {};
  if (parent) parent.children[this.key] = this;
  this.sortedDataKeys = [];
  this.data = null;
  this._dataChanged(_.cloneDeep(data) || null);
  this._lastAutoId = null;
  _.extend(this, Auth.prototype, new Auth());
}

MockFirebase.ServerValue = {
  TIMESTAMP: {
    '.sv': 'timestamp'
  }
};

var getServerTime, defaultClock;
getServerTime = defaultClock = function () {
  return new Date().getTime();
};

MockFirebase.setClock = function (fn) {
  getServerTime = fn;
};

MockFirebase.restoreClock = function () {
  getServerTime = defaultClock;
};

MockFirebase.prototype.flush = function (delay) {
  this.queue.flush(delay);
  return this;
};

MockFirebase.prototype.autoFlush = function (delay) {
  if( _.isUndefined(delay)) {
    delay = true;
  }
  if (this.flushDelay !== delay) {
    this.flushDelay = delay;
    _.each(this.children, function (child) {
      child.autoFlush(delay);
    });
    if (this.parentRef) {
      this.parentRef.autoFlush(delay);
    }
  }
  return this;
};

MockFirebase.prototype.getFlushQueue = function() {
  return this.queue.getEvents();
};

MockFirebase.prototype.failNext = function (methodName, err) {
  assert(err instanceof Error, 'err must be an "Error" object');
  this.errs[methodName] = err;
};

MockFirebase.prototype.forceCancel = function (error, event, callback, context) {
  var events = this._events;
  (event ? [event] : _.keys(events))
    .forEach(function (eventName) {
      events[eventName]
        .filter(function (parts) {
          return !event || !callback || (callback === parts[0] && context === parts[1]);
        })
        .forEach(function (parts) {
          parts[2].call(parts[1], error);
          this.off(event, callback, context);
        }, this);
    }, this);
};

MockFirebase.prototype.getData = function () {
  return _.cloneDeep(this.data);
};

MockFirebase.prototype.getKeys = function () {
  return this.sortedDataKeys.slice();
};

MockFirebase.prototype.fakeEvent = function (event, key, data, prevChild, priority) {
  validate.event(event);
  if (arguments.length < 5) priority = null;
  if (arguments.length < 4) prevChild = null;
  if (arguments.length < 3) data = null;
  var ref = event === 'value' ? this : this.child(key);
  var snapshot = new Snapshot(ref, data, priority);
  this._defer('fakeEvent', _.toArray(arguments), function () {
    this._events[event]
      .map(function (parts) {
        return {
          fn: parts[0],
          args: [snapshot],
          context: parts[1]
        };
      })
      .forEach(function (data) {
        if ('child_added' === event || 'child_moved' === event) {
          data.args.push(prevChild);
        }
        data.fn.apply(data.context, data.args);
      });
  });
  return this;
};

MockFirebase.prototype.toString = function () {
  return this.path;
};

MockFirebase.prototype.child = function (childPath) {
  assert(childPath, 'A child path is required');
  var parts = _.compact(childPath.split('/'));
  var childKey = parts.shift();
  var child = this.children[childKey];
  if (!child) {
    child = new MockFirebase(utils.mergePaths(this.path, childKey), this._childData(childKey), this, childKey);
    this.children[child.key] = child;
  }
  if (parts.length) {
    child = child.child(parts.join('/'));
  }
  return child;
};

MockFirebase.prototype.set = function (data, callback) {
  var err = this._nextErr('set');
  data = _.cloneDeep(data);
  this._defer('set', _.toArray(arguments), function() {
    if (err === null) {
      this._dataChanged(data);
    }
    if (callback) callback(err);
  });
};

MockFirebase.prototype.update = function (changes, callback) {
  assert.equal(typeof changes, 'object', 'First argument must be an object when calling "update"');
  var err = this._nextErr('update');
  this._defer('update', _.toArray(arguments), function () {
    if (!err) {
      var base = this.getData();
      var data = _.assign(_.isObject(base) ? base : {}, changes);
      this._dataChanged(data);
    }
    if (callback) callback(err);
  });
};

MockFirebase.prototype.setPriority = function (newPriority, callback) {
  var err = this._nextErr('setPriority');
  this._defer('setPriority', _.toArray(arguments), function () {
    this._priChanged(newPriority);
    if (callback) callback(err);
  });
};

MockFirebase.prototype.setWithPriority = function (data, pri, callback) {
  this.setPriority(pri);
  this.set(data, callback);
};

/* istanbul ignore next */
MockFirebase.prototype.name = function () {
  console.warn('ref.name() is deprecated. Use ref.key');
  return this.key;
};

MockFirebase.prototype.parent = function () {
  return this.parentRef;
};

MockFirebase.prototype.root = function () {
  var next = this;
  while (next.parentRef) {
    next = next.parentRef;
  }
  return next;
};

MockFirebase.prototype.push = function (data, callback) {
  var child = this.child(this._newAutoId());
  var err = this._nextErr('push');
  if (err) child.failNext('set', err);
  if (arguments.length && data !== null) {
    // currently, callback only invoked if child exists
    child.set(data, callback);
  }
  return child;
};

MockFirebase.prototype.once = function (event, callback, cancel, context) {
  validate.event(event);
  if (arguments.length === 3 && !_.isFunction(cancel)) {
    context = cancel;
    cancel = _.noop;
  }
  cancel = cancel || _.noop;
  var err = this._nextErr('once');
  if (err) {
    this._defer('once', _.toArray(arguments), function () {
      cancel.call(context, err);
    });
  }
  else {
    var fn = _.bind(function (snapshot) {
      this.off(event, fn, context);
      callback.call(context, snapshot);
    }, this);
    this._on('once', event, fn, cancel, context);
  }
};

MockFirebase.prototype.remove = function (callback) {
  var err = this._nextErr('remove');
  this._defer('remove', _.toArray(arguments), function () {
    if (err === null) {
      this._dataChanged(null);
    }
    if (callback) callback(err);
  });
  return this;
};

MockFirebase.prototype.on = function (event, callback, cancel, context) {
  validate.event(event);
  if (arguments.length === 3 && typeof cancel !== 'function') {
    context = cancel;
    cancel = _.noop;
  }
  cancel = cancel || _.noop;

  var err = this._nextErr('on');
  if (err) {
    this._defer('on', _.toArray(arguments), function() {
      cancel.call(context, err);
    });
  }
  else {
    this._on('on', event, callback, cancel, context);
  }
  return callback;
};

MockFirebase.prototype.off = function (event, callback, context) {
  if (!event) {
    for (var key in this._events) {
      /* istanbul ignore else */
      if (this._events.hasOwnProperty(key)) {
        this.off(key);
      }
    }
  }
  else {
    validate.event(event);
    if (callback) {
      var events = this._events[event];
      var newEvents = this._events[event] = [];
      _.each(events, function (parts) {
        if (parts[0] !== callback || parts[1] !== context) {
          newEvents.push(parts);
        }
      });
    }
    else {
      this._events[event] = [];
    }
  }
};

MockFirebase.prototype.transaction = function (valueFn, finishedFn, applyLocally) {
  this._defer('transaction', _.toArray(arguments), function () {
    var err = this._nextErr('transaction');
    var res = valueFn(this.getData());
    var newData = _.isUndefined(res) || err? this.getData() : res;
    this._dataChanged(newData);
    if (typeof finishedFn === 'function') {
      finishedFn(err, err === null && !_.isUndefined(res), new Snapshot(this, newData, this.priority));
    }
  });
  return [valueFn, finishedFn, applyLocally];
};

MockFirebase.prototype./**
 * Just a stub at this point.
 * @param {int} limit
 */
limit = function (limit) {
  return new Query(this).limit(limit);
};

MockFirebase.prototype.startAt = function (priority, key) {
  return new Query(this).startAt(priority, key);
};

MockFirebase.prototype.endAt = function (priority, key) {
  return new Query(this).endAt(priority, key);
};

MockFirebase.prototype._childChanged = function (ref) {
  var events = [];
  var childKey = ref.key;
  var data = ref.getData();
  if( data === null ) {
    this._removeChild(childKey, events);
  }
  else {
    this._updateOrAdd(childKey, data, events);
  }
  this._triggerAll(events);
};

MockFirebase.prototype._dataChanged = function (unparsedData) {
  var pri = utils.getMeta(unparsedData, 'priority', this.priority);
  var data = utils.cleanData(unparsedData);

  if (utils.isServerTimestamp(data)) {
    data = getServerTime();
  }

  if( pri !== this.priority ) {
    this._priChanged(pri);
  }
  if( !_.isEqual(data, this.data) ) {
    var oldKeys = _.keys(this.data).sort();
    var newKeys = _.keys(data).sort();
    var keysToRemove = _.difference(oldKeys, newKeys);
    var keysToChange = _.difference(newKeys, keysToRemove);
    var events = [];

    keysToRemove.forEach(function(key) {
      this._removeChild(key, events);
    }, this);

    if(!_.isObject(data)) {
      events.push(false);
      this.data = data;
    }
    else {
      keysToChange.forEach(function(key) {
        var childData = unparsedData[key];
          if (utils.isServerTimestamp(childData)) {
            childData = getServerTime();
          }
        this._updateOrAdd(key, childData, events);
      }, this);
    }

    // update order of my child keys
    this._resort();

    // trigger parent notifications after all children have
    // been processed
    this._triggerAll(events);
  }
};

MockFirebase.prototype._priChanged = function (newPriority) {
  if (utils.isServerTimestamp(newPriority)) {
    newPriority = getServerTime();
  }
  this.priority = newPriority;
  if( this.parentRef ) {
    this.parentRef._resort(this.key);
  }
};

MockFirebase.prototype._getPri = function (key) {
  return _.has(this.children, key)? this.children[key].priority : null;
};

MockFirebase.prototype._resort = function (childKeyMoved) {
  this.sortedDataKeys.sort(_.bind(this.childComparator, this));
  // resort the data object to match our keys so value events return ordered content
  var oldData = _.assign({}, this.data);
  _.each(oldData, function(v,k) { delete this.data[k]; }, this);
  _.each(this.sortedDataKeys, function(k) {
    this.data[k] = oldData[k];
  }, this);
  if( !_.isUndefined(childKeyMoved) && _.has(this.data, childKeyMoved) ) {
    this._trigger('child_moved', this.data[childKeyMoved], this._getPri(childKeyMoved), childKeyMoved);
  }
};

MockFirebase.prototype._addKey = function (newKey) {
  if(_.indexOf(this.sortedDataKeys, newKey) === -1) {
    this.sortedDataKeys.push(newKey);
    this._resort();
  }
};

MockFirebase.prototype._dropKey = function (key) {
  var i = _.indexOf(this.sortedDataKeys, key);
  if( i > -1 ) {
    this.sortedDataKeys.splice(i, 1);
  }
};

MockFirebase.prototype._defer = function (sourceMethod, sourceArgs, callback) {
  this.queue.push({
    fn: callback,
    context: this,
    sourceData: {
      ref: this,
      method: sourceMethod,
      args: sourceArgs
    }
  });
  if (this.flushDelay !== false) {
    this.flush(this.flushDelay);
  }
};

MockFirebase.prototype._trigger = function (event, data, pri, key) {
  var ref = event==='value'? this : this.child(key);
  var snap = new Snapshot(ref, data, pri);
  _.each(this._events[event], function(parts) {
    var fn = parts[0], context = parts[1];
    if(_.contains(['child_added', 'child_moved'], event)) {
      fn.call(context, snap, this._getPrevChild(key));
    }
    else {
      fn.call(context, snap);
    }
  }, this);
};

MockFirebase.prototype._triggerAll = function (events) {
  if (!events.length) return;
  events.forEach(function(event) {
    if (event !== false) this._trigger.apply(this, event);
  }, this);
  this._trigger('value', this.data, this.priority);
  if (this.parentRef) {
    this.parentRef._childChanged(this);
  }
};

MockFirebase.prototype._updateOrAdd = function (key, data, events) {
  var exists = _.isObject(this.data) && this.data.hasOwnProperty(key);
  if( !exists ) {
    return this._addChild(key, data, events);
  }
  else {
    return this._updateChild(key, data, events);
  }
};

MockFirebase.prototype._addChild = function (key, data, events) {
  if (!_.isObject(this.data)) {
    this.data = {};
  }
  this._addKey(key);
  this.data[key] = utils.cleanData(data);
  var child = this.child(key);
  child._dataChanged(data);
  if (events) events.push(['child_added', child.getData(), child.priority, key]);
};

MockFirebase.prototype._removeChild = function (key, events) {
  if(this._hasChild(key)) {
    this._dropKey(key);
    var data = this.data[key];
    delete this.data[key];
    if(_.isEmpty(this.data)) {
      this.data = null;
    }
    if(_.has(this.children, key)) {
      this.children[key]._dataChanged(null);
    }
    if (events) events.push(['child_removed', data, null, key]);
  }
};

MockFirebase.prototype._updateChild = function (key, data, events) {
  var cdata = utils.cleanData(data);
  if(_.isObject(this.data) && _.has(this.data,key) && !_.isEqual(this.data[key], cdata)) {
    this.data[key] = cdata;
    var c = this.child(key);
    c._dataChanged(data);
    if (events) events.push(['child_changed', c.getData(), c.priority, key]);
  }
};

MockFirebase.prototype._newAutoId = function () {
  return (this._lastAutoId = autoId(new Date().getTime()));
};

MockFirebase.prototype._nextErr = function (type) {
  var err = this.errs[type];
  delete this.errs[type];
  return err||null;
};

MockFirebase.prototype._hasChild = function (key) {
  return _.isObject(this.data) && _.has(this.data, key);
};

MockFirebase.prototype._childData = function (key) {
  return this._hasChild(key)? this.data[key] : null;
};

MockFirebase.prototype._getPrevChild = function (key) {
//      this._resort();
  var keys = this.sortedDataKeys;
  var i = _.indexOf(keys, key);
  if( i === -1 ) {
    keys = keys.slice();
    keys.push(key);
    keys.sort(_.bind(this.childComparator, this));
    i = _.indexOf(keys, key);
  }
  return i === 0? null : keys[i-1];
};

MockFirebase.prototype._on = function (deferName, event, callback, cancel, context) {
  var handlers = [callback, context, cancel];
  this._events[event].push(handlers);
  // value and child_added both trigger initial events when called so
  // defer those here
  if ('value' === event || 'child_added' === event) {
    this._defer(deferName, _.toArray(arguments).slice(1), function () {
      // make sure off() wasn't called before we triggered this
      if (this._events[event].indexOf(handlers) > -1) {
        switch (event) {
          case 'value':
            callback.call(context, new Snapshot(this, this.getData(), this.priority));
            break;
          case 'child_added':
            var previousChild = null;
            this.sortedDataKeys
              .forEach(function (key) {
                var child = this.child(key);
                callback.call(context, new Snapshot(child, child.getData(), child.priority), previousChild);
                previousChild = key;
              }, this);
            break;
        }
      }
    });
  }
};

MockFirebase.prototype.childComparator = function (a, b) {
  var aPri = this._getPri(a);
  var bPri = this._getPri(b);
  var x = utils.priorityComparator(aPri, bPri);
  if( x === 0 ) {
    if( a !== b ) {
      x = a < b? -1 : 1;
    }
  }
  return x;
};

function extractName(path) {
  return ((path || '').match(/\/([^.$\[\]#\/]+)$/)||[null, null])[1];
}

module.exports = MockFirebase;
 at SyntaxError: Unexpected token (4:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/firebase-mock-v3/node_modules/firebase-mock-v3/src/index.js. Coverage (Term): 64% Coverage (LOC): 100%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
