/root/Targets/media-collective
└─┬ media-collective@1.1.0 
  ├─┬ bistre@1.0.1 
  │ ├─┬ chalk@0.5.1 
  │ │ ├── ansi-styles@1.1.0 
  │ │ ├── escape-string-regexp@1.0.5 
  │ │ ├─┬ has-ansi@0.1.0 
  │ │ │ └── ansi-regex@0.2.1 
  │ │ ├── strip-ansi@0.3.0 
  │ │ └── supports-color@0.2.0 
  │ ├─┬ split@0.3.3 
  │ │ └── through@2.3.8 
  │ ├─┬ stream-combiner@0.2.2 
  │ │ └── duplexer@0.1.1 
  │ └─┬ through2@0.5.1 
  │   ├─┬ readable-stream@1.0.34 
  │   │ ├── inherits@2.0.3 
  │   │ ├── isarray@0.0.1 
  │   │ └── string_decoder@0.10.31 
  │   └── xtend@3.0.0 
  ├─┬ bole@1.0.0 
  │ ├── core-util-is@1.0.2 
  │ ├── individual@2.0.0 
  │ └── json-stringify-safe@5.0.1 
  ├── console-stream@0.1.1 
  ├─┬ debug@2.6.9 
  │ └── ms@2.0.0 
  ├─┬ form-data@0.2.0 
  │ ├── async@0.9.2 
  │ ├─┬ combined-stream@0.0.7 
  │ │ └── delayed-stream@0.0.5 
  │ └─┬ mime-types@2.0.14 
  │   └── mime-db@1.12.0 
  └─┬ promise@6.1.0 
    └── asap@1.0.0 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/media-collective/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.027 took 3.4294s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (7:4) on program 'use strict';

var http = require('http'),
    https = require('https'),
    qs = require('querystring'),
    url = require('url'),
    assert = require('assert');

var promise = require('promise'),
    console_stream = require('console-stream'),
    bole = require('bole'),
    pretty = require('bistre')(),
    FormData;

try {
    FormData = window.FormData;
} catch (e) {
    FormData = require('form-data');
}

var STATUS_CODES = http.STATUS_CODES,
    PROTOCOLS = { 'http': http, 'https': https },
    PORTS = { http: 80, https: 443 };

var logLevel = 'info';
if (process.env.NODE_ENV &&
    ('dev|debug').indexOf(process.env.NODE_ENV.toLowerCase() !== -1)) {
    logLevel = 'debug';
}
var log = bole('collective');
bole.output({ level: logLevel, stream: pretty });
pretty.pipe(console_stream());


/**
 * request
 *
 * Make a simple request to the Collective REST API.
 *
 * @param method    String      An HTTP method corresponding to the request
 *                              (can be GET, POST, PUT, PATCH, HEAD, or DELETE).
 * @param path      String      The path.
 * @param query     Object      Any query data. Will be sent as query string
 *                              for GET/DELETE/HEAD, or body for others.
 * @param options   Object      Any other request options. See node's HTTP
 *                              module.
 * @param callback  Function    An optional callback. If not provided, a
 *                              promise is returned instead.
 *
 * @return Promise
 */
var request = function request(method, path, query, options, callback){

    return new promise(function(resolve, reject) {
        options = JSON.parse(JSON.stringify(options || {}));

        var protocol = options.protocol || 'https',
            host = options.host || 'localhost',
            port = options.port || 8080;

        assert(['https', 'http'].indexOf(protocol) !== -1, 'Only http and ' +
               'https are supported.');

        method = method.toUpperCase();
        assert(['GET', 'POST', 'PUT', 'DELETE', 'HEAD', 'PATCH']
               .indexOf(method) !== -1,
               'Only methods supported are GET, POST, PUT, DELETE, HEAD, ' +
               'and PATCH');

        assert(query === null || typeof query === 'object',
               'Query must be an object or null');

        // interpolate query with key/val pairs

        if (query && !(query instanceof FormData)) {
            try {
                query = JSON.parse(JSON.stringify(query));
            } catch (ex) {}
            path = path.replace(/\:([^\/\.]+)/g, function(_,p ){
                if (query[p]){
                    var ret = query[p];
                    delete query[p];
                    return ret;
                }
            });
        }

        var headers = {
            'user-agent': 'node-collective',
            'content-length': 0,
            'accept': 'application/json'
        };

        var hasBody = query !== null &&
            ('GET|DELETE|HEAD'.indexOf(method) === -1) ? true : false;

        var body;
        if (hasBody){
            log.debug('Detected request body data');
            if (query instanceof FormData) {
                body = query;
                headers['content-length'] = query.knownLength || 0;
                //headers['content-type'] = 'application/json; charset=utf-8';
            } else {
                body = JSON.stringify(query) + '\n';
                headers['content-length'] = Buffer.byteLength(body, 'utf-8');
                headers['content-type'] = 'application/json; charset=utf-8';
            }
        } else if (query !== null){
            log.debug('Detected URL query data');
            headers['content-type'] = 'text/plain; charset=utf-8';
            body = qs.stringify(query);
            if (body.length){
                path+='?'+body;
            }
        }

        if (options.auth) {
            log.debug('Detected auth');
            switch (options.auth.type) {
                case 'oauth':
                    log.debug('Detected oauth');
                    path += (path.indexOf('?') === -1 ? '?' : '&') +
                        'access_token=' +
                        encodeURIComponent(options.auth.token);
                    break;
                case 'basic':
                    log.debug('Detected basic auth');
                    headers.authorization = 'Basic ' + new Buffer(
                        options.auth.username +
                        ':' +
                        options.auth.password, 'ascii').toString('base64');
                    break;
                case 'bearer':
                    log.debug('Detected bearer token');
                    headers.Authorization = 'Bearer ' + options.auth.bearer;
                    break;
                default:
                    /* jshint -W027 */
                    throw new Error('Auth type of `' +
                                    options.auth.type + '` is not recognised.');
                    break;
            }
        }

        if (options.headers) {
            Object.keys(options.headers).forEach(function (key) {
                headers[key] = options.headers[key];
            });
        }

        var full_path = '/api/rest' + path;

        log.debug('Protocol: ' + protocol);
        log.debug('Host: ' + host);
        log.debug('Port: ' + port);
        log.debug('Headers:', headers);
        log.debug('Method: ' + method);
        log.debug('Path: ' + full_path);

        var req = PROTOCOLS[protocol].request({
            host: host,
            port: port,
            method: method,
            path: full_path,
            headers: headers,
            withCredentials: false
        });

        req.on('response', function(res){

            res.on('error', function(e) {
                log.error('Response error', e);
                reject(e);
            });

            log.debug('Response status: ' + res.statusCode);
            if ([301,302,307].indexOf(res.statusCode) !== -1) {
                log.debug('Recevied ' + res.statusCode + ' redirect');
                var location = url.parse(res.headers.location);
                options.protocol = location.protocol.substring(0,
                                            location.protocol.length - 1);
                options.host = location.host;
                var redirect_request = request(method, location.pathname, query,
                                  options);
                return resolve(redirect_request);
            }
            if (res.statusCode === 0 || res.statusCode >= 400) {
                var buf = [],
                    buffer;
                res.on('data', function(d) {
                    if (!Buffer.isBuffer(d)) {
                        d = new Buffer(d);
                    }
                    buf.push(d);
                });
                res.on('end', function(){
                    buffer = new Buffer.concat(buf);

                    var err = new Error();
                    try {
                        res.body = buffer.toString('utf-8');
                    } catch (exception) {
                    } finally {
                        var err_message = STATUS_CODES[res.statusCode] ||
                                          'UnknownHttpError';
                        err.name = err_message.replace(/ /g, '');
                        err.method = method;
                        err.path = path;
                        err.statusCode = (err.code = res.statusCode);
                        err.res = res;
                        log.debug(err);
                        reject(err);
                    }
                });
            }
            else {
                resolve(res);
            }
        });

        req.on('error', function(e){
            log.error('Request error', e);
            reject(e);
        });

        req.on('close', function(){
            log.debug('Request close');
        });

        if (hasBody){
            if (body.pipe && typeof body.pipe === 'function') {
                log.debug('Pipe-able body');
                body.pipe(req);
            }
            else if (body instanceof FormData) {
                log.debug('Request FormData body');
                req.end(body);
            } else {
                log.debug('Request send body');
                req.end(body);
            }
            log.debug('Request end');
        } else {
            req.end();
            log.debug('Request end');
        }

   }).nodeify(callback);

};

/**
 * buffer
 *
 * Same parameters as `request`. The response body will be a Buffer
 * containing the entire response.
 *
 * @return Promise  A Promise where the request body is a buffer
 */
var buffer = function buffer(method, path, query, options, callback){

    return request(method, path, query, options).then(function (res) {
        return new promise(function(resolve, reject){
            var buf = [],
                buffer;
            res.on('data', function(d) {
                log.debug('Data received', d);
                if (!Buffer.isBuffer(d)) {
                    d = new Buffer(d);
                }
                buf.push(d);
            });
            res.on('end', function(){
                log.debug('Buffer allocated');
                buffer = new Buffer.concat(buf);
                res.body = buffer;
                resolve(res);
            });
            res.on('error', function(e){
                log.error('Buffer allocation error', e);
                reject(e);
            });
        });
    }).nodeify(callback);
};

/**
 * json
 *
 * Same parameters as `request`. The response body will be a JSON object
 * containing the entire parsed response.
 *
 * @return Promise  A Promise where the request body is JSON.
 */
var json = function json(method, path, query, options, callback) {

    return buffer(method, path, query, options).then(function(res){
        if (res.body) {
            try {
                res.body = JSON.parse(res.body.toString('utf-8'));
            } catch (e) {
                res.body = res.body.toString('utf-8');
            }
        }
        return res;
    }).nodeify(callback);
};

exports = ( module.exports = request );
exports.json = json;
exports.buffer = buffer;
 at SyntaxError: Unexpected token (7:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
