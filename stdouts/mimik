/root/Targets/mimik
└─┬ mimik@0.13.0 
  ├── adm-zip@0.4.7 
  ├── async@1.5.2 
  ├─┬ chai@3.5.0 
  │ ├── assertion-error@1.0.2 
  │ ├─┬ deep-eql@0.1.3 
  │ │ └── type-detect@0.1.1 
  │ └── type-detect@1.0.0 
  ├─┬ chokidar@1.7.0 
  │ ├─┬ anymatch@1.3.2 
  │ │ ├─┬ micromatch@2.3.11 
  │ │ │ ├─┬ arr-diff@2.0.0 
  │ │ │ │ └── arr-flatten@1.1.0 
  │ │ │ ├── array-unique@0.2.1 
  │ │ │ ├─┬ braces@1.8.5 
  │ │ │ │ ├─┬ expand-range@1.8.2 
  │ │ │ │ │ └─┬ fill-range@2.2.3 
  │ │ │ │ │   ├── is-number@2.1.0 
  │ │ │ │ │   ├── isobject@2.1.0 
  │ │ │ │ │   ├─┬ randomatic@1.1.7 
  │ │ │ │ │   │ ├─┬ is-number@3.0.0 
  │ │ │ │ │   │ │ └── kind-of@3.2.2 
  │ │ │ │ │   │ └── kind-of@4.0.0 
  │ │ │ │ │   └── repeat-string@1.6.1 
  │ │ │ │ ├── preserve@0.2.0 
  │ │ │ │ └── repeat-element@1.1.2 
  │ │ │ ├─┬ expand-brackets@0.1.5 
  │ │ │ │ └── is-posix-bracket@0.1.1 
  │ │ │ ├── extglob@0.3.2 
  │ │ │ ├── filename-regex@2.0.1 
  │ │ │ ├─┬ kind-of@3.2.2 
  │ │ │ │ └── is-buffer@1.1.5 
  │ │ │ ├─┬ object.omit@2.0.1 
  │ │ │ │ ├─┬ for-own@0.1.5 
  │ │ │ │ │ └── for-in@1.0.2 
  │ │ │ │ └── is-extendable@0.1.1 
  │ │ │ ├─┬ parse-glob@3.0.4 
  │ │ │ │ ├── glob-base@0.3.0 
  │ │ │ │ └── is-dotfile@1.0.3 
  │ │ │ └─┬ regex-cache@0.4.4 
  │ │ │   └─┬ is-equal-shallow@0.1.3 
  │ │ │     └── is-primitive@2.0.0 
  │ │ └─┬ normalize-path@2.1.1 
  │ │   └── remove-trailing-separator@1.1.0 
  │ ├── async-each@1.0.1 
  │ ├── glob-parent@2.0.0 
  │ ├── inherits@2.0.3 
  │ ├─┬ is-binary-path@1.0.1 
  │ │ └── binary-extensions@1.10.0 
  │ ├─┬ is-glob@2.0.1 
  │ │ └── is-extglob@1.0.0 
  │ ├── path-is-absolute@1.0.1 
  │ └─┬ readdirp@2.1.0 
  │   ├── graceful-fs@4.1.11 
  │   ├─┬ readable-stream@2.3.3 
  │   │ ├── core-util-is@1.0.2 
  │   │ ├── isarray@1.0.0 
  │   │ ├── process-nextick-args@1.0.7 
  │   │ ├── string_decoder@1.0.3 
  │   │ └── util-deprecate@1.0.2 
  │   └── set-immediate-shim@1.0.1 
  ├─┬ cli-table@0.3.1 
  │ └── colors@1.0.3 
  ├── coffee-script@1.12.7 
  ├── commander@2.11.0 
  ├── didyoumean@1.2.1 
  ├── diff@2.2.3 
  ├── dot@1.0.3 
  ├─┬ fs-tools@0.2.11 
  │ ├── async@0.2.10 
  │ └── lodash@2.4.2 
  ├─┬ glob@5.0.15 
  │ ├─┬ inflight@1.0.6 
  │ │ └── wrappy@1.0.2 
  │ ├─┬ minimatch@3.0.4 
  │ │ └─┬ brace-expansion@1.1.8 
  │ │   ├── balanced-match@1.0.0 
  │ │   └── concat-map@0.0.1 
  │ └── once@1.4.0 
  ├─┬ mocha@2.5.3 
  │ ├── commander@2.3.0 
  │ ├─┬ debug@2.2.0 
  │ │ └── ms@0.7.1 
  │ ├── diff@1.4.0 
  │ ├── escape-string-regexp@1.0.2 
  │ ├─┬ glob@3.2.11 
  │ │ └─┬ minimatch@0.3.0 
  │ │   ├── lru-cache@2.7.3 
  │ │   └── sigmund@1.0.1 
  │ ├── growl@1.9.2 
  │ ├─┬ jade@0.26.3 
  │ │ ├── commander@0.6.1 
  │ │ └── mkdirp@0.3.0 
  │ ├─┬ mkdirp@0.5.1 
  │ │ └── minimist@0.0.8 
  │ ├── supports-color@1.2.0 
  │ └── to-iso-string@0.0.2 
  ├── moment@2.18.1 
  ├─┬ request@2.82.0 
  │ ├── aws-sign2@0.7.0 
  │ ├── aws4@1.6.0 
  │ ├── caseless@0.12.0 
  │ ├─┬ combined-stream@1.0.5 
  │ │ └── delayed-stream@1.0.0 
  │ ├── extend@3.0.1 
  │ ├── forever-agent@0.6.1 
  │ ├─┬ form-data@2.3.1 
  │ │ └── asynckit@0.4.0 
  │ ├─┬ har-validator@5.0.3 
  │ │ ├─┬ ajv@5.2.2 
  │ │ │ ├── fast-deep-equal@1.0.0 
  │ │ │ ├── json-schema-traverse@0.3.1 
  │ │ │ └─┬ json-stable-stringify@1.0.1 
  │ │ │   └── jsonify@0.0.0 
  │ │ └── har-schema@2.0.0 
  │ ├─┬ hawk@6.0.2 
  │ │ ├── boom@4.3.1 
  │ │ ├─┬ cryptiles@3.1.2 
  │ │ │ └── boom@5.2.0 
  │ │ ├── hoek@4.2.0 
  │ │ └── sntp@2.0.2 
  │ ├─┬ http-signature@1.2.0 
  │ │ ├── assert-plus@1.0.0 
  │ │ ├─┬ jsprim@1.4.1 
  │ │ │ ├── extsprintf@1.3.0 
  │ │ │ ├── json-schema@0.2.3 
  │ │ │ └── verror@1.10.0 
  │ │ └─┬ sshpk@1.13.1 
  │ │   ├── asn1@0.2.3 
  │ │   ├── bcrypt-pbkdf@1.0.1 
  │ │   ├── dashdash@1.14.1 
  │ │   ├── ecc-jsbn@0.1.1 
  │ │   ├── getpass@0.1.7 
  │ │   ├── jsbn@0.1.1 
  │ │   └── tweetnacl@0.14.5 
  │ ├── is-typedarray@1.0.0 
  │ ├── isstream@0.1.2 
  │ ├── json-stringify-safe@5.0.1 
  │ ├─┬ mime-types@2.1.17 
  │ │ └── mime-db@1.30.0 
  │ ├── oauth-sign@0.8.2 
  │ ├── performance-now@2.1.0 
  │ ├── qs@6.5.1 
  │ ├── safe-buffer@5.1.1 
  │ ├── stringstream@0.0.5 
  │ ├─┬ tough-cookie@2.3.2 
  │ │ └── punycode@1.4.1 
  │ ├── tunnel-agent@0.6.0 
  │ └── uuid@3.1.0 
  ├─┬ wd@0.3.12 
  │ ├─┬ archiver@0.14.4 
  │ │ ├── async@0.9.2 
  │ │ ├── buffer-crc32@0.2.13 
  │ │ ├─┬ glob@4.3.5 
  │ │ │ └── minimatch@2.0.10 
  │ │ ├─┬ lazystream@0.1.0 
  │ │ │ └─┬ readable-stream@1.0.34 
  │ │ │   ├── isarray@0.0.1 
  │ │ │   └── string_decoder@0.10.31 
  │ │ ├── lodash@3.2.0 
  │ │ ├─┬ readable-stream@1.0.34 
  │ │ │ ├── isarray@0.0.1 
  │ │ │ └── string_decoder@0.10.31 
  │ │ ├─┬ tar-stream@1.1.5 
  │ │ │ ├── end-of-stream@1.4.0 
  │ │ │ ├─┬ readable-stream@1.0.34 
  │ │ │ │ ├── isarray@0.0.1 
  │ │ │ │ └── string_decoder@0.10.31 
  │ │ │ └── xtend@4.0.1 
  │ │ └─┬ zip-stream@0.5.2 
  │ │   ├─┬ compress-commons@0.2.9 
  │ │   │ ├─┬ crc32-stream@0.3.4 
  │ │   │ │ └─┬ readable-stream@1.0.34 
  │ │   │ │   ├── isarray@0.0.1 
  │ │   │ │   └── string_decoder@0.10.31 
  │ │   │ ├── node-int64@0.3.3 
  │ │   │ └─┬ readable-stream@1.0.34 
  │ │   │   ├── isarray@0.0.1 
  │ │   │   └── string_decoder@0.10.31 
  │ │   ├── lodash@3.2.0 
  │ │   └─┬ readable-stream@1.0.34 
  │ │     ├── isarray@0.0.1 
  │ │     └── string_decoder@0.10.31 
  │ ├── async@1.0.0 
  │ ├── lodash@3.9.3 
  │ ├── q@1.4.1 
  │ ├─┬ request@2.55.0 
  │ │ ├── aws-sign2@0.5.0 
  │ │ ├─┬ bl@0.9.5 
  │ │ │ └─┬ readable-stream@1.0.34 
  │ │ │   ├── isarray@0.0.1 
  │ │ │   └── string_decoder@0.10.31 
  │ │ ├── caseless@0.9.0 
  │ │ ├─┬ combined-stream@0.0.7 
  │ │ │ └── delayed-stream@0.0.5 
  │ │ ├─┬ form-data@0.2.0 
  │ │ │ └── async@0.9.2 
  │ │ ├─┬ har-validator@1.8.0 
  │ │ │ ├── bluebird@2.11.0 
  │ │ │ └─┬ is-my-json-valid@2.16.1 
  │ │ │   ├── generate-function@2.0.0 
  │ │ │   ├─┬ generate-object-property@1.2.0 
  │ │ │   │ └── is-property@1.0.2 
  │ │ │   └── jsonpointer@4.0.1 
  │ │ ├─┬ hawk@2.3.1 
  │ │ │ ├── boom@2.10.1 
  │ │ │ ├── cryptiles@2.0.5 
  │ │ │ ├── hoek@2.16.3 
  │ │ │ └── sntp@1.0.9 
  │ │ ├─┬ http-signature@0.10.1 
  │ │ │ ├── asn1@0.1.11 
  │ │ │ ├── assert-plus@0.1.5 
  │ │ │ └── ctype@0.5.3 
  │ │ ├─┬ mime-types@2.0.14 
  │ │ │ └── mime-db@1.12.0 
  │ │ ├── node-uuid@1.4.8 
  │ │ ├── oauth-sign@0.6.0 
  │ │ ├── qs@2.4.2 
  │ │ └── tunnel-agent@0.4.3 
  │ ├── underscore.string@3.0.3 
  │ └── vargs@0.1.0 
  ├─┬ webdriverio@3.4.0 
  │ ├── array.from@0.2.0 
  │ ├── co@4.6.0 
  │ ├─┬ css-parse@2.0.0 
  │ │ └─┬ css@2.2.1 
  │ │   ├─┬ source-map@0.1.43 
  │ │   │ └── amdefine@1.0.1 
  │ │   ├─┬ source-map-resolve@0.3.1 
  │ │   │ ├── atob@1.1.3 
  │ │   │ ├── resolve-url@0.2.1 
  │ │   │ └── source-map-url@0.3.0 
  │ │   └── urix@0.1.0 
  │ ├── css-value@0.0.1 
  │ ├── deepmerge@0.2.10 
  │ ├── ejs@2.5.7 
  │ ├─┬ inquirer@0.8.5 
  │ │ ├── ansi-regex@1.1.1 
  │ │ ├─┬ chalk@1.1.3 
  │ │ │ ├── ansi-styles@2.2.1 
  │ │ │ ├─┬ has-ansi@2.0.0 
  │ │ │ │ └── ansi-regex@2.1.1 
  │ │ │ ├── strip-ansi@3.0.1 
  │ │ │ └── supports-color@2.0.0 
  │ │ ├── cli-width@1.1.1 
  │ │ ├─┬ figures@1.7.0 
  │ │ │ ├── escape-string-regexp@1.0.5 
  │ │ │ └── object-assign@4.1.1 
  │ │ ├── lodash@3.10.1 
  │ │ ├─┬ readline2@0.1.1 
  │ │ │ ├── mute-stream@0.0.4 
  │ │ │ └─┬ strip-ansi@2.0.1 
  │ │ │   └── ansi-regex@1.1.1 
  │ │ ├── rx@2.5.3 
  │ │ └── through@2.3.8 
  │ ├── is-generator@1.0.3 
  │ ├─┬ optimist@0.6.1 
  │ │ └── wordwrap@0.0.3 
  │ ├── q@1.3.0 
  │ ├─┬ request@2.49.0 
  │ │ ├── aws-sign2@0.5.0 
  │ │ ├── caseless@0.8.0 
  │ │ ├─┬ combined-stream@0.0.7 
  │ │ │ └── delayed-stream@0.0.5 
  │ │ ├── forever-agent@0.5.2 
  │ │ ├─┬ form-data@0.1.4 
  │ │ │ ├── async@0.9.2 
  │ │ │ └── mime@1.2.11 
  │ │ ├─┬ hawk@1.1.1 
  │ │ │ ├── boom@0.4.2 
  │ │ │ ├── cryptiles@0.2.2 
  │ │ │ ├── hoek@0.9.1 
  │ │ │ └── sntp@0.2.4 
  │ │ ├─┬ http-signature@0.10.1 
  │ │ │ ├── asn1@0.1.11 
  │ │ │ └── assert-plus@0.1.5 
  │ │ ├── mime-types@1.0.2 
  │ │ ├── node-uuid@1.4.8 
  │ │ ├── oauth-sign@0.5.0 
  │ │ ├── qs@2.3.3 
  │ │ └── tunnel-agent@0.4.3 
  │ ├── rgb2hex@0.1.0 
  │ ├── supports-color@1.3.1 
  │ ├─┬ url@0.10.3 
  │ │ ├── punycode@1.3.2 
  │ │ └── querystring@0.2.0 
  │ └── wgxpath@1.0.0 
  ├─┬ winston@1.1.2 
  │ ├── async@1.0.0 
  │ ├── cycle@1.0.3 
  │ ├── eyes@0.1.8 
  │ ├── pkginfo@0.3.1 
  │ └── stack-trace@0.0.10 
  └── yadda@0.10.14 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/mimik/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0386 took 3.1354s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected character '#' (1:78) on program #!/usr/bin/env node
/*global require,console,process */

/*
 * MODULE DEPENDENCIES
 */

var fs = require('fs'),
    glob = require('glob'),
    path = require('path'),
    winston = require('winston'),
    exists = fs.existsSync || path.existsSync,
    pkg = require('../package.json'),
    program = require('commander'),
    utils = require('../lib/utils'),
    tint = require('../lib/tint'),
    Yadda = require('yadda'),
    chokidar = require('chokidar'),
    Runner = require('../runner/Runner');

var stdin = process.stdin,
    stdout = process.stdout,
    prompt = '\u203A',
    runner;

program
    .version(pkg.version)
    .description(pkg.description);

var cmd = require('../lib/help')(program);

/*
 * GLOBALS
 */

var reruns = [],
    logger,
    runner;

/**
 * scan for files at the given `path`.
 */
function scanFiles(target) {
    var files = [];
    if (exists(target)) {
        files = glob.sync(target + '/**/*.{feature,coffee,js}');
    } else {
        logger.warn('[command] cannot resolve path (or pattern) "' + target + '"');
    }
    return files;
    
}

/*
 * filter through a list of files using optional match patterns
 */
function filterFiles(files, params) {

    var re = new RegExp(params.match || '');
    var inv = !!params.matchInvert,
        featureFiles = [],
        stepFiles = [],
        sourceFiles = [],
        ignore = ['reports', 'coverage', 'node_modules', 'bower_components', '.svn', '.git'];

    var English = Yadda.localisation.English,
        parser = new Yadda.parsers.FeatureFileParser(English);

    // exclude dynamically temporary folders that mimik is known to generate
    function isIgnored(path) {
        var ignored = false;
        for(var i = 0, len = ignore.length; i < len; i++) {
            if(~path.indexOf(ignore[i])) {
                ignored = true;
                break;
            }
        }
        return ignored;
    }
    function hasTags(feature, tags) {
        var status = false,
            annotations = feature.annotations;
        (tags||[]).every(function(tag) {
            if(annotations[tag]) {
                status = true;
                return false;
            }
            return true;
        });
        return status;
    }
    
    function filterByTags(file, params) {
        if((!params.tags || params.tags.length === 0) && (!params.excludeTags || params.excludeTags.length === 0)) {
            return true;
        }
        var feature = parser.parse(file);
        if((!params.tags || hasTags(feature, params.tags)) && (!params.excludeTags || !hasTags(feature, params.excludeTags))) {
            return true;
        }
        return false;
    }

    function filterByPattern(file, re, inv) {
        var match = re.test(file);
        return match && !inv || !match && inv;        
    }
    
    function isFeature(file) {
        var ext = path.extname(file).substr(1);
        return ~['feature', 'spec', 'specification'].indexOf(ext);
    }

    function isRerun(file) {
        return !reruns.length || reruns.indexOf(path.join(process.cwd(), file)) > -1;
    }

    // load reruns if any
    if(params.rerun) {
        var rerunFile = path.join(process.cwd(), 'failed.dat');

        if(exists(rerunFile)) {
            reruns = fs.readFileSync(rerunFile).toString().trim();
            reruns = reruns ? reruns.split('\n') : [];
        } else {
            logger.debug('[command] rerun file %s not found', rerunFile);
        }
    }
    
    files.forEach(function(file) {
        if(!isIgnored(file)) {
            // filter by match pattern, tag annotations and reruns
            if(isFeature(file) && filterByPattern(file, re, inv) && filterByTags(file, params) && isRerun(file)) {
                featureFiles.push(file);
            } else if(/(-step|Step)s?\./.test(path.basename(file))){
                stepFiles.push(file);
            } else {
                sourceFiles.push(file);
            }
        }
    });
    
    return {
        featureFiles: featureFiles,
        stepFiles: stepFiles,
        sourceFiles: sourceFiles
    };

}

/*
 * scan and filter through passed file paths to retrieve tests.
 */
function getTestFiles(args, options) {

    // default files to ./**/*.{feature,js,coffee}
    var files = [];
    args = args.length > 0 ? args : ['.'];
    args.forEach(function(arg){
       files = files.concat(scanFiles(arg));
    });
    // process exclusions and filtering
    return filterFiles(files, options);

}

function getLogger(config) {
    var isatty = require('tty').isatty(process.stdout.fd),
        levels = {
            debug: 1,
            info: 2,
            warn: 3,
            error: 4
        },
        colors = {
            info: 'cyan',
            debug: 'grey',
            warn: 'yellow',
            error: 'red'
        };
    var options = {
        console: utils.apply({
            //handleExceptions: true,
            json: false,
            level: 'error',
            colorize:  isatty, /* patch: do not colorize file and pipe output */
            exitOnError: false
        }, options)
    };

    if (config.log) {
        options.file = {
            filename: config.log,
            level: 'debug',
            json: false
        };
    }

    // share logger config
    winston.addColors(colors);
    winston.loggers.add('mimik', options);

    var logger = winston.loggers.get('mimik');
    logger.setLevels(levels);

    if (config.debug) {
        logger.transports.console.level = 'debug';
        logger.debug('[mimik] debug logging is ON');
    }
    return logger;
}

/**
 * Load an external configuration file. Supported formats are:
 * - JSON configuration file can be overwritten by command line options). Example: config.json, setup.conf
 * - JS configuration file enables more capabilities such as hooking up to the mimik's execution lifecycle and enabling plugin extendability. Example: config.js
 * - COFFEE configuration file is a coffeescript variation of the js config file. Example config.coffee
 *
 *  @param config
 */
function loadConfig(file, runner, cb) {

    if(!file) {
        // no external config
        return cb(null, null);
    }
    
    file = path.join(process.cwd(), file);
    if(path.basename(file).match(/.(js|coffee)$/)) {
        // JS or coffeescript input file
        // invalidate cached version of the config file if it's already cached
        delete require.cache[file];
        var config = require(file);
        config(runner);
        return cb(null);
    }

    if(path.basename(file).match(/.(json|conf)$/)) {
        // json config file
        fs.readFile(file, function(err, config) {
            try {
                config = JSON.parse(config);
                runner.setConfig(config);
                return cb(null);
            } catch(e) {
                console.error('Error parsing config file:', file);
                console.error(e.message);
                // return cb(e);
                process.exit(1);
            }
        });
        return;
    }
    
    console.error('Unsupported config file:', file);
    // return cb(new Error('Unsupported config file:' + file));
    process.exit(1);

}
/**
 * merge external config file with inline config. Inline config overrides external config
 */
function mergeConfig(externalConfig) {

    var config = externalConfig || {};
    // Fetch test files and apply file pattern filtering
    var targets = program.args.slice(0, -1);
    targets = targets.length > 0 ? targets : ['.'];

    var files = getTestFiles(targets, utils.copyTo({}, program, 'match,matchInvert,tags,excludeTags,rerun'));
    logger.debug('[command] matching files', files);

    utils.apply(utils.copyTo(config, program, 'browsers,timeout,slow,debug,failfast,tunnel,port,testStrategy,reporters,reportPath,shareSession,match,matchInvert,tags,excludeTags,rerun,watchDelay'), {
        featureFiles: files.featureFiles,
        stepFiles: files.stepFiles,
        sourceFiles: files.sourceFiles
    });
    logger.debug('[command] configuration', config);
    return config;

}

function runTests(options) {

    // If runTests() is invoked over an already active session, then abort current execution first then start a new one.
    if(runner && runner.state === 'started') {
        runner.abort(function() {
            runTests(options);
        });
        return;
    }

    function onRunComplete (stats) {
        // record failed tests for use with the next command if --rerun is enabled
        var recordFile = path.join(process.cwd(), 'failed.dat'),
            output = [];
        if(stats.failures > 0) {
            utils.each(stats.results, function(result) {
                if(result.stats.failures > 0) {
                    output.push(path.join(process.cwd(), result.feature.file));
                }
            });
        }
        fs.writeFileSync(recordFile, output.join('\n'));
        
        // don't exit if we're in watch mode
        if(options && !options.watch) {
            /*
                Exit with the following status codes:
                0 if testing was completed and all tests passed.
                1 if testing was completed but some tests failed.
            */
            var exitCode = (stats.failures > 0) ? 1 : 0;
            process.exit(exitCode);
        }
    }
    // Execute the runner
    runner.run(onRunComplete);

}

function generateSteps(file) {

    var StepDefinitionGenerator = require('../lib/StepDefinitionGenerator'),
        generator = new StepDefinitionGenerator();
    // clear the console
    process.stdout.write('\u001B[2J');
    // Move the cursor to the top
    process.stdout.write('\u001B[f');
    printLogo();
    
    fs.exists(file, function(exists) {
        if(!exists) {
            logger.debug('[command] Could not locate the file "' + file + '"');
            return console.error('[command] Could not locate the file "' + file + '"');
        }
        generator.prompt(file, function(data) {
            // display output only. no saving of output to file
            if(!data.target) {
                return doGenerateSteps(generator, file, data);
            }
            // check if target file exists and get confirmation to overwrite.
            fs.exists(file, function(exists) {
                if(!exists) {
                    // target file doesn't exist. proceed to save.
                    return doGenerateSteps(generator, file, data);
                }
                utils.question('The target file "' + file + '" already exists. Do you want to replace it?', {
                    stdin: stdin,
                    stdout: stdout,
                    prompt: prompt
                }, function(answer) {
                    process.stdout.write('\u001B[1A  ' + prompt + ' \u001B[K');
                    if(~['y', 'yes'].indexOf(answer.toLowerCase())) {
                        console.log(tint.green('yes') + '\n');
                        // user wants to overwrite existing file. Let's proceed
                        return doGenerateSteps(generator, file, data);
                    }
                    console.log(tint.green('no') + '\n\nok, operation aborted.\n');
                    process.exit();
                });
            });
        });
    });

}

function doGenerateSteps(generator, file, data) {

    generator.generateFromFile(file, data.language, data.type, data.target, function(err, output) {
        if(err) {
            logger.debug('[command] Could not generate step definitions.', err.message);
            console.error('[command] Could not generate step definitions.', err.message);
        } else if(!data.target) {
            console.log(tint.gray('Output:\n'));
            console.log(output);
        }
        process.exit();
    });

}


function watch() {

    // clear the console
    process.stdout.write('\u001B[2J');
    // Move the cursor to the top
    process.stdout.write('\u001B[f');
    printLogo();
    console.log('Watching for changes, press', tint.gray('Ctrl+C'), 'to exit');

    var fn = function(target) {
        function fmt(n) {
            // Format integers to have a leading zero.
            return n < 10 ? '0' + n : n;
        }
        var date = new Date(),
            time = fmt(date.getHours()) + ":" + fmt(date.getMinutes()) + ":" + fmt(date.getSeconds());
        console.info(tint.gray('\nChange detected at ' + time + ' in'), path.basename(target));
        console.log();
        
        // instantiate a new runner instance
        runner = new Runner();

        // Process configuration    
        loadConfig(program.config, runner, function(err) {
            if(err) {
                return;
            }
            var config = mergeConfig(runner.getConfig());
            runner.setConfig(config);
            runTests({ watch: true });
        });

    };

    // add buffer delay to reduce massive triggering of test runs on file changes
    var cmd = program.args.slice(-1)[0];
    fn = buffer(fn, cmd.watchDelay);

    var targets = program.args.slice(0, -1);
    targets = targets.length > 0 ? targets : ['.'];

    var watcher = chokidar.watch(targets, { 
        ignored: /[\/\\]\./, 
        persistent: true,
        ignoreInitial: true
    });

    utils.each(['add', 'addDir', 'change', 'unlink'], function(event) {
        watcher.on(event, fn);
    });

}

function buffer(fn, ms, scope) {
    var id;
    return function() {
           clearTimeout(id);
           var args = arguments;
           id = setTimeout(function() {
               fn.apply(scope||this, args);
               id = null;
             }, ms);
    };
}

function processCommand(cmd) {

    if(cmd.action === 'run') {

        logger.info('[command] execute "run" mode');
        printLogo();

        // instantiate a new runner instance
        runner = new Runner();

        // Process configuration    
        loadConfig(program.config, runner, function(err) {
            if(err) {
                return;
            }
            var config = mergeConfig(runner.getConfig());
            runner.setConfig(config);
            runTests();
        });

    } else if(cmd.action === 'watch') {
        logger.info('[command] execute "watch" mode');

        watch();

    } else if(cmd.action === 'web') {

        logger.info('[command] execute "web" mode');
        printLogo();

    } else if(cmd.action === 'generate') {

        logger.info('[command] execute "generate" mode');

        if(!cmd.file) {
            printLogo();
            console.error('  The "generate" command requires a file <path>.');
            console.error('  --------------------------------');
            cmd.cmd.help();
            return;
        }
        generateSteps(cmd.file);

    } else {

        printLogo();
        console.error('  No command specified.');
        console.error('  ---------------------');
        program.help();

    }
}
function printLogo() {
    console.log(["",
    "  ███    ███ ██ ███    ███ ██ ██   ██  ",
    "  ████  ████ ██ ████  ████ ██ ██  ██   ",
    "  ██ ████ ██ ██ ██ ████ ██ ██ █████    ",
    "  ██  ██  ██ ██ ██  ██  ██ ██ ██  ██   ",
    "  ██      ██ ██ ██      ██ ██ ██   ██  ",
    ""].join('\n'));
}

/*
 * INITIALIZATION
 */

// parse args
program.parse(process.argv);
// Init logger
logger = getLogger(utils.copyTo({}, program, 'debug,log'));

// perform graceful shutdown on Ctrl+C
process.on('SIGINT', function () {
    if(runner) {
        runner.abort(function() {
            process.exit(runner.stats.failures > 0 ? 1 : 0);
        });
    } else {
        process.exit(0);
    }
});

processCommand(cmd);
 at SyntaxError: Unexpected character '#' (1:78)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$7.getTokenFromCode (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2756:10)
    at Parser.pp$7.readToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2477:17)
    at Parser.readToken (/root/ExpoSE/lib/Tropigate/bin/Tokens.js:124:26)
    at Parser.pp$7.nextToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2468:15)
    at Parser.pp$7.next (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2413:10)
    at Parser.pp.eat (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:536:12)
    at Parser.pp.semicolon (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:581:15)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:918:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
