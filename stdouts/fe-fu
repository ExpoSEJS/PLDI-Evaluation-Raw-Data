/root/Targets/fe-fu
└─┬ fe-fu@0.1.9 
  ├─┬ clean-css@4.1.9 
  │ └── source-map@0.5.7 
  ├── growl@1.10.3 
  ├─┬ less@2.7.2 
  │ ├─┬ errno@0.1.4 
  │ │ └── prr@0.0.0 
  │ ├── graceful-fs@4.1.11 
  │ ├── image-size@0.5.5 
  │ ├── mime@1.4.1 
  │ ├── mkdirp@0.5.1 
  │ ├─┬ promise@7.3.1 
  │ │ └── asap@2.0.6 
  │ └─┬ request@2.83.0 
  │   ├── aws-sign2@0.7.0 
  │   ├── aws4@1.6.0 
  │   ├── caseless@0.12.0 
  │   ├─┬ combined-stream@1.0.5 
  │   │ └── delayed-stream@1.0.0 
  │   ├── extend@3.0.1 
  │   ├── forever-agent@0.6.1 
  │   ├─┬ form-data@2.3.1 
  │   │ └── asynckit@0.4.0 
  │   ├─┬ har-validator@5.0.3 
  │   │ ├─┬ ajv@5.2.3 
  │   │ │ ├── co@4.6.0 
  │   │ │ ├── fast-deep-equal@1.0.0 
  │   │ │ ├── json-schema-traverse@0.3.1 
  │   │ │ └─┬ json-stable-stringify@1.0.1 
  │   │ │   └── jsonify@0.0.0 
  │   │ └── har-schema@2.0.0 
  │   ├─┬ hawk@6.0.2 
  │   │ ├── boom@4.3.1 
  │   │ ├─┬ cryptiles@3.1.2 
  │   │ │ └── boom@5.2.0 
  │   │ ├── hoek@4.2.0 
  │   │ └── sntp@2.0.2 
  │   ├─┬ http-signature@1.2.0 
  │   │ ├── assert-plus@1.0.0 
  │   │ ├─┬ jsprim@1.4.1 
  │   │ │ ├── extsprintf@1.3.0 
  │   │ │ ├── json-schema@0.2.3 
  │   │ │ └─┬ verror@1.10.0 
  │   │ │   └── core-util-is@1.0.2 
  │   │ └─┬ sshpk@1.13.1 
  │   │   ├── asn1@0.2.3 
  │   │   ├── bcrypt-pbkdf@1.0.1 
  │   │   ├── dashdash@1.14.1 
  │   │   ├── ecc-jsbn@0.1.1 
  │   │   ├── getpass@0.1.7 
  │   │   ├── jsbn@0.1.1 
  │   │   └── tweetnacl@0.14.5 
  │   ├── is-typedarray@1.0.0 
  │   ├── isstream@0.1.2 
  │   ├── json-stringify-safe@5.0.1 
  │   ├─┬ mime-types@2.1.17 
  │   │ └── mime-db@1.30.0 
  │   ├── oauth-sign@0.8.2 
  │   ├── performance-now@2.1.0 
  │   ├── qs@6.5.1 
  │   ├── safe-buffer@5.1.1 
  │   ├── stringstream@0.0.5 
  │   ├─┬ tough-cookie@2.3.3 
  │   │ └── punycode@1.4.1 
  │   ├── tunnel-agent@0.6.0 
  │   └── uuid@3.1.0 
  ├── libnotify@1.0.4 
  ├─┬ optimist@0.6.1 
  │ ├── minimist@0.0.8 
  │ └── wordwrap@0.0.3 
  └─┬ uglify-js@3.1.3 
    └── commander@2.11.0 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/fe-fu/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.1205 took 3.759s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Octal literal in strict mode (210:12) on program //Less part taken from : Joseph McCullough http://www.vertstudios.com/blog/less-app-windows-sorta/

var defaults = {
	"lessDir" : ".",
	"jsDir": ".",
	"watch" : true,
	"recursive" : false,
	"notify" : true,
	"errorsOnly" : true,
	"jsLint" : true
};

var version = "0.1.9";

var icons = {
		success : 'thumbsup',
		error : 'cross',
		watching : 'marker',
		info : 'speach_bubble',
		getIcon : function(icon){
			return __dirname + "/../images/" + icon + ".png";
		}
}

var	path = require('path'),
    fs = require('fs'),
    sys = require('sys'),
	os = require('os');

var isMac = os.type()=="Darwin";

//http://bit.ly/dKlPqQ (stack overflow) for package.json use
require.paths.unshift('./node_modules')

var noop =  function(){ };

/* Dependencies */
var notifier =  {  notify : noop };
var less = require('less');
var jsp = require("uglify-js").parser;
var pro = require("uglify-js").uglify;
var cleanCSS = require('clean-css');
var jsLint = noop;

function getValue(val){
	switch (val) {
		case "true" : return true;
		case "false" : return false;
			default : return val;
	}
}

function toJS(path){
	var bareFilename = getFileName(path);
	fs.readFile(path, 'utf-8', function (e, str) {
		if (e) { 
			return Notify(e, true); 
		}
		try {
			if (defaults.jsLint && jsLintContent(str, bareFilename))
				return;
			var ast = jsp.parse(str); // parse code and get the iitlnitial AST
			ast = pro.ast_mangle(ast); // get a new AST with mangled names
			ast = pro.ast_squeeze(ast); // get an AST with compression optimizations
			var final_code = pro.gen_code(ast); // compressed code here
			var newFile = path.slice(0,-2) + "min.js";
			fs.writeFile(newFile, final_code, function(err)
			{
				if (err){
					Notify("Error in writing file : " + bareFilename + "\n" + err, true);
				} else {
					Notify(getFileName(newFile) + " successfully updated.", false, icons.success);
				}
			}); 
        }
		catch (er)
		{
			var message ="Error compiling javascript file: " + bareFilename + "\n" + er.message + " (line: " + er.line + ", col: " + er.col + ", pos: " + er.pos + ")" 
			return Notify(message, true);
		}
   });
}

function jsLintContent(str, fileName){
	var isOk = jsLint.check(str);
	if (isOk){
		return false;
	}

	var message = new Array();
	var errors = jsLint.check.errors;
	var isCritical = jsLint.check.errors[jsLint.check.errors.length -1] == null;
	if (isCritical){
		errors.pop();
		if (errors[errors.length -1].reason.match(/Stopping\.\s\s\(\d{0,2}\%\sscanned\)\./g)){
			errors.pop();
		}
	}
    message.push('\nJSLint found ' + errors.length + ' error' + (errors.length > 1 ? 's' : ''));
	message.push(' in ' + fileName + (isCritical ? ' (Critical)\n' :  '\n'));
	for (var err in errors){
		var curr = errors[err];
		message.push('Error ' + (parseInt(err) + 1) + ' (Line: ' + curr.line + ', Char: ' + curr.character + '):\n');
		message.push('Reason : ' + curr.reason + '\n');
		if (curr.evidence) {
			message.push('Evidence : ' + curr.evidence + '\n');
		}
		if (curr.raw){
			var raw = curr.raw;
			var details = [{'letter' : 'a', 'val' :curr.a}, 
							{ 'letter' : 'b', 'val' : curr.b},
							{ 'letter' : 'c', 'val' : curr.c},
							{ 'letter' : 'd', 'val' : curr.d}
							];
			for (var det in details){
				if (details[det].val){
					raw = raw.replace("{" + details[det].letter + "}", details[det].val);
				}
			}
			if (raw != curr.reason){
				message.push('Raw: ' + raw);
			}
		}
		message.push('\n');
	}
	Notify(message.join(''), true);
	message = null;
	return isCritical;
}

function toCSS(path) {
    var tree, css;
	var bareFilename = getFileName(path);
    fs.readFile(path, 'utf-8', function (e, str) {
        if (e) { return Notify(e, true) }
        new(less.Parser)({
            paths: [require('path').dirname(path)],
            optimization: 0
        }).parse(str, function (err, tree) {
            if (err) {
				var message = "Error parsing less file: " + bareFilename + "\n"
					+ err.message + " line : " + err.line + " column : "
					+ err.column + " index : " +err.index
					+ "\n" + err.extract;
                Notify(message, true);
            } else {
                try {
                    css = tree.toCSS({compress: true});
                    writeCSS(path, css);
                } catch (errParsing) {
					var message = "Error converting less file: " + bareFilename + " to css\n"
						+ errParsing.message + " line : " + errParsing.line + " column : "
						+ errParsing.column + " index : " +errParsing.index
						+ "\n" + errParsing.extract;
					return Notify(message, true);
				}     
                writeCSS(path, css);
			}
        });
    });
}

function writeCSS(file,less){
	try { 
	var minless = cleanCSS.process(less);
	}
	catch (er) 
	{
		return Notify("Error compressing css from file " + getFileName(file) + " : " + er, true);
	}
	var newFile = file.slice(0, -4) + "css";
	var newMinFile = file.slice(0, -4) + "min.css"; 
	fs.writeFile(newFile, less, function(err)
	{
			if (err){
				Notify("error in writing css file: " + getFileName(file) + "\n" + err, true);
			} else {
				Notify(getFileName(newFile) + " successfully updated.", false, icons.success);
			}
	}); 
	fs.writeFile(newMinFile, minless, function(err)
	{
			if (err){
				Notify("error in writing minified css file: " + getFileName(newMinFile) + "\n" + err, true);
			} else {
				Notify(getFileName(newMinFile) + " successfully updated.", false, icons.success);
			}
	}); 
}

function Notify(str, isError, icon, forceEvenIfNotError){
	if (!forceEvenIfNotError && defaults.errorsOnly && !isError)
		return;
	var theTitle = 'Frontend Fu : ' + (isError ? 'Error' : 'Info');
	var theImage = icons.getIcon(icon || (isError ? icons.error : icons.info));
	var theMessage = new Date().toLocaleTimeString() + " : " + str;
	sys.puts(isError ? stylize(str,'red') : theMessage);
	notifier.notify(theMessage, {title : theTitle, image : theImage});
}

function stylize(str, style) {
    var styles = {
        'bold'      : [1,  22],
        'inverse'   : [7,  27],
        'underline' : [4,  24],
        'yellow'    : [33, 39],
        'green'     : [32, 39],
        'red'       : [31, 39]
    };
    return '\033[' + styles[style][0] + 'm' + str +
           '\033[' + styles[style][1] + 'm';
}

function valueWithout(str, what){
	return str.slice(what.length + 1); 
}

function showVersion(){
	sys.puts("Frontend Fu version " + version);
	sys.puts("");
}

function showHelp(){
	showVersion();
	sys.puts("Usage: fe-fu --parameter value");
	sys.puts("");
	sys.puts("Parameters :");
	sys.puts("");
	sys.puts("	jsDir : path to javascript files");
	sys.puts("				- defaults to current directory");
	sys.puts("	lessDir : path to .less files");
	sys.puts("				- defaults to current directory");
	sys.puts("	notify : use growl / notify notifications");
	sys.puts("				- defaults to true");
	sys.puts("				set to false if growl/notify is not installed");
	sys.puts("	recursive : do a recursive file search");
	sys.puts("				- defaults to false");
	sys.puts("	watch : watch .js/.less files for changes");
	sys.puts("				- defaults to true");
	sys.puts("	errorsOnly : Notify only on errors");
	sys.puts("				- defaults to true");
	sys.puts("	");
}

//https://gist.github.com/825583
function readDirRecursive(start, callback) {
    // Use lstat to resolve symlink if we are passed a symlink
    fs.lstat(start, function(err, stat) {
        if(err) {
            return callback(err);
        }
        var found = {dirs: [], files: []},
            total = 0,
            processed = 0;
        function isDir(abspath) {
            fs.stat(abspath, function(err, stat) {
                if(stat.isDirectory()) {
                    found.dirs.push(abspath);
                    // If we found a directory, recurse!
                    readDirRecursive(abspath, function(err, data) {
                        found.dirs = found.dirs.concat(data.dirs);
                        found.files = found.files.concat(data.files);
                        if(++processed == total) {
                            callback(null, found);
                        }
                    });
                } else {
                    found.files.push(abspath);
                    if(++processed == total) {
                        callback(null, found);
                    }
                }
            });
        }
        // Read through all the files in this directory
        if(stat.isDirectory()) {
            fs.readdir(start, function (err, files) {
                total = files.length;
                for(var x=0, l=files.length; x<l; x++) {
                    isDir(path.join(start, files[x]));
                }
            });
        } else {
            return callback(new Error("path: " + start + " is not a directory"));
        }
    });
}

function readDir(dir, fileCondition, doFcn, recursive, watch, callback){
	var getFiles = recursive ? readDirRecursive : fs.readdir;
	getFiles(dir, function(err, files){
		if (err){
			Notify(err, true);
			return callback(0);
		}
		var filesCount = 0;
		if (files.files) {
			files = files.files;
		}
		files.forEach(function(file){
			var filePath = recursive ? file : (ensureEndingWithSlash(dir) + file); 
			if (!fileCondition(filePath))
				return;
			if (watch) {
				watchFile(filePath, doFcn);
			}
			doFcn(filePath);
			++filesCount;
		});
		callback(filesCount);
	});
}

function readDirRegular(dir, callback){
	fs.readdir(dir, callback);
}

function watchFile(file, doFcn){
	fs.watchFile(file, { persistent: true, interval: 200}, function(curr,prev)
	{
		doFcn(file);
	});
}

function ensureEndingWithSlash(str){
	return endsWith(str, "/") ? str : (str + "/");
}

function endsWith(str, what){
	return (str || "").indexOf(what, str.length - what.length) !== -1;
}

function getFileName(path){
	return path.substring(path.lastIndexOf("/") + 1);
}

function startFeFuIng(options){
	initFeFu(options);
	readDir(defaults.lessDir, function (file) { return endsWith(file, ".less"); }, toCSS, defaults.recursive, defaults.watch, function(totalLess){
	     if (totalLess == 0){
			Notify("Not watching any .less files..", true);
		}
		else {
			Notify("Watching " + totalLess + " .less files..", false, null, true);
		}
	 
		readDir(defaults.jsDir, function (file) { return endsWith(file, ".js") && !endsWith(file, ".min.js"); }, toJS, defaults.recursive, defaults.watch, function(totalJS){
			if (totalJS == 0){
				Notify("Not watching any .js files..", true);
			}
			else {
				Notify("Watching " + totalJS + " .js files..",false, null, true);
			}
			if (totalJS + totalLess == 0){
				Notify("Frontend Fu - no .less or .js files found...",true);
			}
			else {
				Notify("Frontend Fu - compiling & listening...", false, icons.watching, true);
			} 
		});
	});
}

function initFeFu(options){
	for (var key in options){
		var opt = options[key];
		defaults[key] = getValue(opt);
	}

	if (defaults.notify){
		notifier = isMac ? require('growl') : require('libnotify');
	}

	if (defaults.jsLint){
		jsLint = require('./jslint');
	}
}

/* -----[ Exports ]----- */

exports.startFeFu = startFeFuIng;
exports.defaults = defaults;
exports.showHelp = showHelp;
exports.showVersion = showVersion;
 at SyntaxError: Octal literal in strict mode (210:12)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$7.readEscapedChar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:3023:16)
    at Parser.pp$7.readString (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2935:23)
    at Parser.pp$7.getTokenFromCode (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2724:19)
    at Parser.pp$7.readToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2477:17)
    at Parser.readToken (/root/ExpoSE/lib/Tropigate/bin/Tokens.js:124:26)
    at Parser.pp$7.nextToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2468:15)
    at Parser.pp$7.next (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2413:10)
    at Parser.pp$1.parseReturnStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:832:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:699:34)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
