/root/Targets/mcap-generator
└─┬ mcap-generator@1.1.6 
  ├─┬ gulp@3.5.6 
  │ ├── archy@0.0.2 
  │ ├─┬ chalk@0.4.0 
  │ │ ├── ansi-styles@1.0.0 
  │ │ ├── has-color@0.1.7 
  │ │ └── strip-ansi@0.1.1 
  │ ├── deprecated@0.0.1 
  │ ├─┬ gulp-util@2.2.20 
  │ │ ├─┬ chalk@0.5.1 
  │ │ │ ├── ansi-styles@1.1.0 
  │ │ │ ├── escape-string-regexp@1.0.5 
  │ │ │ ├── has-ansi@0.1.0 
  │ │ │ ├─┬ strip-ansi@0.3.0 
  │ │ │ │ └── ansi-regex@0.2.1 
  │ │ │ └── supports-color@0.2.0 
  │ │ ├─┬ dateformat@1.0.12 
  │ │ │ ├── get-stdin@4.0.1 
  │ │ │ └─┬ meow@3.7.0 
  │ │ │   ├─┬ camelcase-keys@2.1.0 
  │ │ │   │ └── camelcase@2.1.1 
  │ │ │   ├── decamelize@1.2.0 
  │ │ │   ├─┬ loud-rejection@1.6.0 
  │ │ │   │ ├─┬ currently-unhandled@0.4.1 
  │ │ │   │ │ └── array-find-index@1.0.2 
  │ │ │   │ └── signal-exit@3.0.2 
  │ │ │   ├── map-obj@1.0.1 
  │ │ │   ├── minimist@1.2.0 
  │ │ │   ├─┬ normalize-package-data@2.4.0 
  │ │ │   │ ├── hosted-git-info@2.5.0 
  │ │ │   │ ├─┬ is-builtin-module@1.0.0 
  │ │ │   │ │ └── builtin-modules@1.1.1 
  │ │ │   │ └─┬ validate-npm-package-license@3.0.1 
  │ │ │   │   ├─┬ spdx-correct@1.0.2 
  │ │ │   │   │ └── spdx-license-ids@1.2.2 
  │ │ │   │   └── spdx-expression-parse@1.0.4 
  │ │ │   ├── object-assign@4.1.1 
  │ │ │   ├─┬ read-pkg-up@1.0.1 
  │ │ │   │ ├─┬ find-up@1.1.2 
  │ │ │   │ │ ├── path-exists@2.1.0 
  │ │ │   │ │ └─┬ pinkie-promise@2.0.1 
  │ │ │   │ │   └── pinkie@2.0.4 
  │ │ │   │ └─┬ read-pkg@1.1.0 
  │ │ │   │   ├─┬ load-json-file@1.1.0 
  │ │ │   │   │ ├── graceful-fs@4.1.11 
  │ │ │   │   │ ├─┬ parse-json@2.2.0 
  │ │ │   │   │ │ └─┬ error-ex@1.3.1 
  │ │ │   │   │ │   └── is-arrayish@0.2.1 
  │ │ │   │   │ ├── pify@2.3.0 
  │ │ │   │   │ └─┬ strip-bom@2.0.0 
  │ │ │   │   │   └── is-utf8@0.2.1 
  │ │ │   │   └── path-type@1.1.0 
  │ │ │   ├─┬ redent@1.0.0 
  │ │ │   │ ├─┬ indent-string@2.1.0 
  │ │ │   │ │ └─┬ repeating@2.0.1 
  │ │ │   │ │   └─┬ is-finite@1.0.2 
  │ │ │   │ │     └── number-is-nan@1.0.1 
  │ │ │   │ └── strip-indent@1.0.1 
  │ │ │   └── trim-newlines@1.0.0 
  │ │ ├── lodash._reinterpolate@2.4.1 
  │ │ ├─┬ lodash.template@2.4.1 
  │ │ │ ├── lodash._escapestringchar@2.4.1 
  │ │ │ ├─┬ lodash.defaults@2.4.1 
  │ │ │ │ └── lodash._objecttypes@2.4.1 
  │ │ │ ├─┬ lodash.escape@2.4.1 
  │ │ │ │ ├─┬ lodash._escapehtmlchar@2.4.1 
  │ │ │ │ │ └── lodash._htmlescapes@2.4.1 
  │ │ │ │ └── lodash._reunescapedhtml@2.4.1 
  │ │ │ ├─┬ lodash.keys@2.4.1 
  │ │ │ │ ├── lodash._isnative@2.4.1 
  │ │ │ │ ├── lodash._shimkeys@2.4.1 
  │ │ │ │ └── lodash.isobject@2.4.1 
  │ │ │ ├── lodash.templatesettings@2.4.1 
  │ │ │ └── lodash.values@2.4.1 
  │ │ ├── minimist@0.2.0 
  │ │ ├─┬ multipipe@0.1.2 
  │ │ │ └─┬ duplexer2@0.0.2 
  │ │ │   └── readable-stream@1.1.14 
  │ │ ├─┬ through2@0.5.1 
  │ │ │ ├─┬ readable-stream@1.0.34 
  │ │ │ │ ├── isarray@0.0.1 
  │ │ │ │ └── string_decoder@0.10.31 
  │ │ │ └── xtend@3.0.0 
  │ │ └─┬ vinyl@0.2.3 
  │ │   └── clone-stats@0.0.1 
  │ ├─┬ liftoff@0.9.8 
  │ │ ├── extend@1.2.1 
  │ │ ├─┬ findup-sync@0.1.3 
  │ │ │ └─┬ glob@3.2.11 
  │ │ │   └─┬ minimatch@0.3.0 
  │ │ │     ├── lru-cache@2.7.3 
  │ │ │     └── sigmund@1.0.1 
  │ │ ├── minimist@0.0.10 
  │ │ └── resolve@0.6.3 
  │ ├─┬ orchestrator@0.3.8 
  │ │ ├─┬ end-of-stream@0.1.5 
  │ │ │ └─┬ once@1.3.3 
  │ │ │   └── wrappy@1.0.2 
  │ │ ├── sequencify@0.0.7 
  │ │ └── stream-consume@0.1.0 
  │ ├── pretty-hrtime@0.2.2 
  │ ├── semver@2.3.2 
  │ └─┬ vinyl-fs@0.1.4 
  │   ├─┬ glob-stream@3.1.18 
  │   │ ├─┬ glob@4.5.3 
  │   │ │ └── inflight@1.0.6 
  │   │ ├─┬ glob2base@0.0.12 
  │   │ │ └── find-index@0.1.1 
  │   │ ├─┬ minimatch@2.0.10 
  │   │ │ └─┬ brace-expansion@1.1.8 
  │   │ │   ├── balanced-match@1.0.0 
  │   │ │   └── concat-map@0.0.1 
  │   │ ├── ordered-read-streams@0.1.0 
  │   │ ├─┬ through2@0.6.5 
  │   │ │ ├── readable-stream@1.0.34 
  │   │ │ └── xtend@4.0.1 
  │   │ └── unique-stream@1.0.0 
  │   ├─┬ glob-watcher@0.0.6 
  │   │ └─┬ gaze@0.5.2 
  │   │   └─┬ globule@0.1.0 
  │   │     ├─┬ glob@3.1.21 
  │   │     │ ├── graceful-fs@1.2.3 
  │   │     │ └── inherits@1.0.2 
  │   │     ├── lodash@1.0.2 
  │   │     └── minimatch@0.2.14 
  │   ├── graceful-fs@2.0.3 
  │   └── map-stream@0.1.0 
  ├─┬ gulp-appendit@0.0.1 
  │ ├── appendit@0.1.2 
  │ ├─┬ event-stream@3.1.7 
  │ │ ├── duplexer@0.1.1 
  │ │ ├── from@0.1.7 
  │ │ ├── pause-stream@0.0.11 
  │ │ ├── split@0.2.10 
  │ │ └── stream-combiner@0.0.4 
  │ └── through@2.3.8 
  ├─┬ gulp-ejs@0.1.5 
  │ └── ejs@0.8.8 
  ├─┬ gulp-template@1.1.1 
  │ ├─┬ gulp-util@3.0.8 
  │ │ ├── array-differ@1.0.0 
  │ │ ├── array-uniq@1.0.3 
  │ │ ├── beeper@1.1.1 
  │ │ ├─┬ chalk@1.1.3 
  │ │ │ ├── ansi-styles@2.2.1 
  │ │ │ ├─┬ has-ansi@2.0.0 
  │ │ │ │ └── ansi-regex@2.1.1 
  │ │ │ ├── strip-ansi@3.0.1 
  │ │ │ └── supports-color@2.0.0 
  │ │ ├── dateformat@2.2.0 
  │ │ ├─┬ fancy-log@1.3.0 
  │ │ │ ├─┬ chalk@1.1.3 
  │ │ │ │ ├── ansi-styles@2.2.1 
  │ │ │ │ ├─┬ has-ansi@2.0.0 
  │ │ │ │ │ └── ansi-regex@2.1.1 
  │ │ │ │ ├── strip-ansi@3.0.1 
  │ │ │ │ └── supports-color@2.0.0 
  │ │ │ └── time-stamp@1.1.0 
  │ │ ├─┬ gulplog@1.0.0 
  │ │ │ └── glogg@1.0.0 
  │ │ ├─┬ has-gulplog@0.1.0 
  │ │ │ └── sparkles@1.0.0 
  │ │ ├── lodash._reescape@3.0.0 
  │ │ ├── lodash._reevaluate@3.0.0 
  │ │ ├── lodash._reinterpolate@3.0.0 
  │ │ ├─┬ lodash.template@3.6.2 
  │ │ │ ├── lodash._basecopy@3.0.1 
  │ │ │ ├── lodash._basetostring@3.0.1 
  │ │ │ ├── lodash._basevalues@3.0.0 
  │ │ │ ├── lodash._isiterateecall@3.0.9 
  │ │ │ ├─┬ lodash.escape@3.2.0 
  │ │ │ │ └── lodash._root@3.0.1 
  │ │ │ ├─┬ lodash.keys@3.1.2 
  │ │ │ │ ├── lodash._getnative@3.9.1 
  │ │ │ │ ├── lodash.isarguments@3.1.0 
  │ │ │ │ └── lodash.isarray@3.0.4 
  │ │ │ ├── lodash.restparam@3.6.1 
  │ │ │ └── lodash.templatesettings@3.1.1 
  │ │ ├── minimist@1.2.0 
  │ │ ├── object-assign@3.0.0 
  │ │ ├── replace-ext@0.0.1 
  │ │ ├─┬ through2@2.0.3 
  │ │ │ └─┬ readable-stream@2.3.3 
  │ │ │   ├── isarray@1.0.0 
  │ │ │   ├── process-nextick-args@1.0.7 
  │ │ │   ├── safe-buffer@5.1.1 
  │ │ │   ├── string_decoder@1.0.3 
  │ │ │   └── util-deprecate@1.0.2 
  │ │ └─┬ vinyl@0.5.3 
  │ │   └── clone@1.0.2 
  │ └─┬ through2@0.6.5 
  │   ├─┬ readable-stream@1.0.34 
  │   │ ├── core-util-is@1.0.2 
  │   │ ├── inherits@2.0.3 
  │   │ ├── isarray@0.0.1 
  │   │ └── string_decoder@0.10.31 
  │   └── xtend@4.0.1 
  ├── lodash@2.4.2 
  ├── mkdirp@0.3.5 
  ├── ncp@0.5.1 
  ├── node-uuid@1.4.8 
  └── rimraf@2.2.8 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/mcap-generator/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0762 took 4.7621s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (18:4) on program /*
 * mcap-generator
 * https://github.com//mcap-generator
 *
 * Copyright (c) 2014
 * Licensed under the MIT license.
 */

'use strict';

var path = require('path');
var util = require('util');
var ncp = require('ncp').ncp;
var gulp = require('gulp');
var gulpEjs = require('gulp-ejs');
var uuid = require('node-uuid');
var _ = require('lodash');
var assert = require('assert');
var fs = require('fs');
var template = require('gulp-template');
var rimraf = require('rimraf');
var TODO_NAME = 'Todo';
var moduleServerBikini = require('./module-server-bikini');

var TEMPLATES = {
    'HELLO_WORLD': 'helloworld',
    'helloworld': 'helloworld',
    'BIKINI': 'bikini',
    'bikini': 'bikini',
    'DEFAULT': 'default',
    'default': 'default'
};

var Generator = module.exports = function Generator(options) {
    this.options = options || {};
};

////////////////////////////////////////////////////
// Private

var copyApp = function (source, destination, cb) {
    ncp(source, destination, function (err) {
        if (err) {
            return cb(err);
        }
        cb(null);
    });
};

var createAppConfig = function (options, cb) {

    var source = path.join(__dirname + '/../templates/app.rln');
    options.year = options.year || new Date().getFullYear();

    var stream = gulp.src(source).pipe(gulpEjs(options, {ext: '.rln'})).pipe(gulp.dest('./'));

    stream.on('error', cb);
    stream.on('end', function () {
        cb();
    });
};

var createMcapConfig = function (options, cb) {

    var source = path.join(__dirname + '/../templates/mcap.json');
    options.uuid = options.uuid || uuid.v4();
    _.defaults(options, {
        name: '',
        apnsPassphrase: '',
        apnsCertificateFile: '',
        gcmApiKey: '',
        baseAlias: '',
        description: ''
    });

    if (!options.baseAlias) {
        options.baseAlias = '/' + encodeURIComponent(options.name);
    }

    var stream = gulp.src(source).pipe(gulpEjs(options, {ext: '.json'})).pipe(gulp.dest('./'));

    stream.on('error', cb);
    stream.on('end', function () {
        cb();
    });
};

var validateTemplateOptions = function (options, cb) {
    if (!options.template) {
        cb(new Error('error.generator.template.undefined'));
        return false;
    }
    cb(null);
};

var validateOptions = function (options, cb) {

    validateTemplateOptions(options, function (err) {
        if (options.templateValues && options.templateValues.package) {
            var pattern = /^[a-z][a-z0-9_]*(\.[a-z0-9_]+)+[0-9a-z_]$/i;
            if (!pattern.test(options.templateValues.package)) {
                cb(new Error('error.generator.package.invalid'));
                return;
            }
        }
        cb(err);
    });
};

////////////////////////////////////////////////////
// Public

/**
 * Creates a app.rln file on the given options.dest directory. Put the app.rln options/ template values into options.templateValues
 * @param {object} options
 * @param {function} cb
 */
Generator.prototype.createDefaultAppRln = function (options, cb) {
    assert(cb, 'Missing argument cb');
    assert.equal(typeof cb, 'function', 'callback must be a function');
    var _cwd = process.cwd();
    var callback = function () {
        process.chdir(_cwd);
        cb();
    };
    process.chdir(options.dest);
    createAppConfig(options.templateValues, callback);
};

/**
 * Generates a new application based on the given options.
 *
 * @param {object} options
 * {
 *     name: 'MyApp',
 *     package: 'com.company.myapp',
 *     template: 'default'
 * }
 * @param {function} cb
 */
Generator.prototype.createApp = function (options, cb) {
    assert(cb, 'Missing argument cb');
    assert.equal(typeof cb, 'function', 'callback must be a function');
    var that = this;
    options = options || {};
    validateOptions(options, function (err) {
        if (err) {
            cb(err);
            return;
        }

        var source = this.getAppTemplateDir() + that.getDefaultClientTemplate(options.template);
        copyApp(source, process.cwd(), function (err) {
            if (err) {
                return cb(err);
            }
            if (options.templateValues && options.templateValues.package) {
                createAppConfig(options.templateValues, cb);
            } else {
                cb(null);
            }

        });
    }.bind(this));
};

/**
 * Creates a mcap.json file on the given options.dest directory. Put the mcap.json options/ template values into options.templateValues
 * @param {object} options
 * @param {function} cb
 */
Generator.prototype.createMcapJson = function (options, cb) {
    assert(cb, 'Missing argument cb');
    assert.equal(typeof cb, 'function', 'callback must be a function');
    // cache the root of the start to switch back later
    var _cwd = process.cwd();
    var callback = function () {
        // change the process working dir back to the one it was started
        process.chdir(_cwd);
        cb();
    };
    process.chdir(options.dest);
    createMcapConfig(options.templateValues, callback);
};

/**
 * Wrappes the createApp with a client folder
 *
 * @param {object} options
 * {
 *     name: 'MyApp',
 *     package: 'com.company.myapp',
 *     template: 'default',
 *     dest: './'
 * }
 * @param {function} cb
 */
Generator.prototype.createClientApp = function (options, cb) {
    assert(cb, 'Missing argument cb');
    assert.equal(typeof cb, 'function', 'callback must be a function');
    var that = this;
    // get the dest or set ./ to default
    var dest = options.dest || './';
    // delete the dest from options to be createApp conform
    delete options.dest;
    // set helloworld as default template of an client application
    options.template = that.getDefaultClientTemplate(options.template, TEMPLATES.HELLO_WORLD);
    // cache the root of the start to switch back later
    var _cwd = process.cwd();
    // overwrite the callback
    var callback = function () {
        // change the process working dir back to the one it was started
        process.chdir(_cwd);
        // call the actual callback
        cb.apply(that, arguments);
    };
    // change the directory to run the copy in
    process.chdir(path.normalize(dest));
    fs.mkdir('client', function (err) {
        if (err) {
            cb(err);
            return;
        }
        process.chdir(path.normalize(dest + '/client'));
        that.createApp(options, callback);
    });
};

/**
 * Creates a server application
 *
 * @param {object} options
 * {
 *     name: 'MyApp',
 *     template: 'default',
 *     dest: './'
 * }
 * @param {function} cb
 */
Generator.prototype.createServerApp = function (options, cb) {
    assert(cb, 'Missing argument cb');
    assert.equal(typeof cb, 'function', 'callback must be a function');
    var that = this;
    options = options || {};
    validateTemplateOptions(options, function (err) {
        if (err) {
            cb(err);
            return;
        }
        var source = this.getServerTemplateDir() + that.getDefaultServerTemplate(options.template);
        var stream = gulp.src(source + '/**/*')
            .pipe(template(options.templateValues))
            .pipe(gulp.dest('.'));

        stream.on('error', cb);
        stream.on('end', function () {
            cb();
        });
    }.bind(this));
};

/**
 * Copies the .mcapignore file from templates/.mcapignore to '.' which should be equal to cwd
 * @param {function} cb
 */
Generator.prototype.createIgnoreFiles = function (cb) {
    var files = [
        path.resolve(this.getRootTemplateDir() + '/.mcapignore'),
        path.resolve(this.getRootTemplateDir() + '/.gitignore')
    ];
    gulp.src(files)
    .pipe(gulp.dest('.'))
    .on('error', cb)
    .on('end', cb);
};

/**
 * Create a mCAP Application based of a client application inside a client folder and a mcap.json in the root
 * @param {object} options
 * {
 *     templateValues: {
 *      name: 'MyApp',
 *      package: 'com.company.myapp',
 *     }
 *
 *     template: 'default',
 *     dest: './'
 * }
 * @param {function} cb
 */
Generator.prototype.createMcapApplication = function (options, cb) {
    assert(cb, 'Missing argument cb');
    assert.equal(typeof cb, 'function', 'callback must be a function');
    var that = this;

    that.createIgnoreFiles(function(){
        that.createMcapJson(options, function (err, data) {
            if (err) {
                cb(err, data);
                return;
            }
            fs.mkdir('server', function (err) {
                if (err) {
                    cb(err);
                    return;
                }
                var _cwd = process.cwd();
                process.chdir(path.normalize(_cwd + '/server'));

                options.clientTemplate = options.template;
                that.createServerApp(options, function (err) {
                    if (err) {
                        cb(err);
                        return;
                    }
                    options.template = options.clientTemplate;
                    process.chdir(path.normalize(_cwd));
                    that.createClientApp(options, function (err, data) {
                        cb(err, data);
                    });
                });
            });
        });
    });
};

/**
 * Create a mCAP Application based of a client application inside a client folder and a mcap.json in the root. Root is defined by folderName. The template defines what kind of application should be generated.
 * @param {object} options
 * {
 *     templateValues: {
 *      name: 'MyApp',
 *      package: 'com.company.myapp',
 *     }
 *
 *     template: 'default',
 *     folderName: 'test'
 * }
 * @param {function} cb
 */
Generator.prototype.createMcapApplicationInFolder = function (options, cb) {
    assert(cb, 'Missing argument cb');
    assert.equal(typeof cb, 'function', 'callback must be a function');

    var _cwd = process.cwd();
    var that = this;
    fs.exists(options.folderName, function (exists) {
        if (exists) {
            cb(new Error('Folder already exists'));
            return;
        }
        fs.mkdirSync(options.folderName);
        var dest = path.normalize(_cwd + '/' + options.folderName);
        process.chdir(dest);
        delete options.folderName;
        options.dest = dest;
        if (options.template === TEMPLATES.BIKINI) {
            that.createBikiniApplication(options, _cwd, dest, cb);
        } else {
            that.createMcapApplication(options, function (err) {
                process.chdir(_cwd);
                if (err) {
                    // Remove folder when an error occurred.
                    rimraf.sync(dest);
                    cb(err);
                    return;
                }
                cb(null);
            });
        }
    });
};

/**
 * Runs the default mcap app generation. After successfully generating the application generate a model and add it
 * @param {object} options
 * @param {string} _cwd
 * @param {string} dest
 * @param {function} cb
 */
Generator.prototype.createBikiniApplication = function (options, _cwd, dest, cb) {
    var that = this;
    this.createMcapApplication(options, function (err) {
        process.chdir(_cwd);
        if (err) {
            // Remove folder when an error occurred.
            rimraf.sync(dest);
            cb(err);
            return;
        }
        that.generateTodoModel(dest, cb);
    });
};

/**
 * Generates a to do Model based on the given destination path. If no path is set use cwd
 * @param {string} dest
 * @param {function} cb
 */
Generator.prototype.generateTodoModel = function (dest, cb) {
    // save the current working directory to change back in the callback
    var _cwd = process.cwd();
    // change the cwd to the destination to run the command directly inside the given folder
    process.chdir(dest || _cwd);
    // create a todo model
    this.createModel({
        dest: 'todo.json',
        data: {
            "name": TODO_NAME,
            "label": TODO_NAME,
            "attributes": {
                "title": {
                    "type": "String",
                    "mandatory": true,
                    "key": false
                },
                "order": {
                    "type": "Integer",
                    "mandatory": false,
                    "key": false
                },
                "completed": {
                    "type": "Boolean",
                    "mandatory": false,
                    "key": false
                },
                "_id": {
                    "type": "String",
                    "mandatory": true,
                    "key": true
                }
            }
        }
    }, function (err) {
        // change back the cwd
        process.chdir(_cwd);
        cb(err);
    });
};

/**
 * Generate a json file by the given options in the current working directory
 * @param {object} options
 * {
 *  dest: 'filename[.json]'
 *  data: String | Buffer | Object of the content - object will be stringified
 *  [encoding]: optional - the encoding of the file - default is see fs default
 *  [mode]: optional - the mode of the file - default is see fs default
 *  [flag]: optional - the flag of the file - default is see fs default
 * }
 * @param {function} cb
 */
Generator.prototype.createJson = function (options, cb) {
    assert(cb, 'Missing argument cb');
    assert.equal(typeof cb, 'function', 'callback must be a function');
    assert.equal(typeof options, 'object', 'options must be defined');

    options.dest = options.dest.replace(/\.\W+/g,'');

    // add json if it doesn't exists
    if (path.extname(options.dest) !== '.json'){
        options.dest += '.json';
    }
    // set encodings if defined - if not use fs defaults by keeping empty
    var fsOptions = null;
    if (options.encoding){
        fsOptions = fsOptions || {};
        fsOptions.encoding = options.encoding;
    }
    if (options.mode){
        fsOptions = fsOptions || {};
        fsOptions.mode = options.mode;
    }

    if (options.flag){
        fsOptions = fsOptions || {};
        fsOptions.flag = options.flag;
    }

    // if options is a object and no buffer stringify it
    if (typeof options.data === 'object' && !Buffer.isBuffer(options.data)){
        try {
            options.data = JSON.stringify(options.data, null, 3);
        } catch (e) {
            cb(e);
            return;
        }
    }
    // do not overwrite the file
    fs.exists(options.dest, function(err){
        if (err){
            cb(new Error('File already exists'));
            return;
        }
        // save
        fs.writeFile(options.dest, options.data, fsOptions, function(err){
            if (err){
                cb(err);
                return;
            }
            cb();
        });
    });
};

/**
 * Create a json inside the given folderName - options see createJson
 * @param {string} folderName - the folderName to be executed on - gets created if none exists
 * @param {object} options
 * @param {function} cb
 * @private
 */
Generator.prototype._createComponent = function (folderName, options, cb) {
    assert(cb, 'Missing argument cb');
    assert.equal(typeof cb, 'function', 'callback must be a function');

    var _cwd = process.cwd();
    var that = this;
    fs.exists(folderName, function(exists){
        if (!exists){
            fs.mkdirSync(folderName);
        }
        process.chdir(path.normalize(_cwd + '/' + folderName));
        that.createJson(options, function(err){
            process.chdir(_cwd);
            if (err) {
                return cb(err);
            }

            var out = path.normalize('/' + folderName + '/' + options.dest);
            cb(null, out);
        });
    });
};

/**
 * Creates a json inside the models folder - creates the folder if it doesn't exists - files aren't overwritten
 * @param {object} options see createJson
 * @param {function} cb
 */
Generator.prototype.createModel = function (options, cb) {
    this._createComponent('models', options, cb);
};

/**
 * Creates a json inside the connections folder - creates the folder if it doesn't exists - files aren't overwritten
 * @param {object} options see createJson
 * @param {function} cb
 */
Generator.prototype.createConnection = function (options, cb) {
    this._createComponent('connections', options, cb);
};

/**
 * Creates a json inside the connectionConfigurations folder - creates the folder if it doesn't exists - files aren't overwritten
 * @param {object} options see createJson
 * @param {function} cb
 */
Generator.prototype.createConnectionConfiguration = function (options, cb) {
    this._createComponent('connectionConfigurations', options, cb);
};

/**
 * Creates a json inside the bikini folder - creates the folder if it doesn't exists - files aren't overwritten
 * @param {object} options see createJson
 * @param {function} cb
 */
Generator.prototype.createBikini = function (options, cb) {
    this._createComponent('bikini', options, cb);
};

Generator.prototype.getAppTemplateDir = function () {
    return path.join(__dirname, '../templates/client/');
};

Generator.prototype.getServerTemplateDir = function () {
    return path.join(__dirname, '../templates/server/');
};

Generator.prototype.getRootTemplateDir = function () {
    return path.join(__dirname, '../templates/');
};

Generator.prototype.getDefaultServerTemplate = function (templateString, defaultTemplate) {
    var ret = templateString;

    if (!TEMPLATES[templateString] && TEMPLATES[defaultTemplate]){
        ret = defaultTemplate;
    }

    return ret;
};

Generator.prototype.getDefaultClientTemplate = function (templateString, defaultTemplate) {
    var ret = templateString;

    if (!TEMPLATES[templateString] && TEMPLATES[defaultTemplate]){
        ret = defaultTemplate;
    }

    if (ret === TEMPLATES.BIKINI){
        ret = TEMPLATES.DEFAULT;
    }

    return ret;
};

Generator.prototype.createServerModule = function (type, options, cb) {
    if (type === 'bikini') {

        this.readAppConfig(function(err, appConfig) {
            if (err) {
                return cb(err);
            }

            options.metaModel.container = util.format('%s %s', appConfig.name, 'MetaModelContainer');
            options.metaModel.model = options.metaModel.name;
            moduleServerBikini(options, cb);
        });
    } else {
        cb(null, {});
    }
};

Generator.prototype.readAppConfig = function (cb) {
    var mcapConfigPath = path.resolve(process.cwd(), 'mcap.json');
    fs.readFile(mcapConfigPath, function(err, content) {
        if (err) {
            return cb(err);
        }
        try {
            cb(null, JSON.parse(content));
        } catch (e) {
            cb(e);
        }
    });
};

////////////////////////////////////////////////////
// Static
Generator.test = require('./test/helpers');
 at SyntaxError: Unexpected token (18:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
