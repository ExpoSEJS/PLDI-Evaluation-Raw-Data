/root/Targets/ast-path
└─┬ ast-path@0.1.4 
  ├─┬ mocha@1.13.0 
  │ ├── commander@0.6.1 
  │ ├─┬ debug@3.1.0 
  │ │ └── ms@2.0.0 
  │ ├── diff@1.0.7 
  │ ├─┬ glob@3.2.3 
  │ │ ├── graceful-fs@2.0.3 
  │ │ ├── inherits@2.0.3 
  │ │ └─┬ minimatch@0.2.14 
  │ │   ├── lru-cache@2.7.3 
  │ │   └── sigmund@1.0.1 
  │ ├── growl@1.7.0 
  │ ├─┬ jade@0.26.3 
  │ │ └── mkdirp@0.3.0 
  │ └── mkdirp@0.3.5 
  └── private@0.0.5 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/ast-path/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0425 took 3.6589s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (1:82) on program var assert = require("assert");
var getChildCache = require("private").makeAccessor();
var Op = Object.prototype;
var hasOwn = Op.hasOwnProperty;
var toString = Op.toString;
var arrayToString = toString.call([]);
var Ap = Array.prototype;
var slice = Ap.slice;
var map = Ap.map;

function Path(value, parentPath, name) {
  assert.ok(this instanceof Path);

  if (parentPath) {
    assert.ok(parentPath instanceof Path);
  } else {
    parentPath = null;
    name = null;
  }

  Object.defineProperties(this, {
    // The value encapsulated by this Path, generally equal to
    // parentPath.value[name] if we have a parentPath.
    value: { value: value },

    // The immediate parent Path of this Path.
    parentPath: { value: parentPath },

    // The name of the property of parentPath.value through which this
    // Path's value was reached.
    name: {
      value: name,
      configurable: true
    }
  });
}

var Pp = Path.prototype;

function getChildPath(path, name) {
  var cache = getChildCache(path);
  return hasOwn.call(cache, name)
    ? cache[name]
    : cache[name] = new path.constructor(
        path.getValueProperty(name), path, name);
}

// This method is designed to be overridden by subclasses that need to
// handle missing properties, etc.
Pp.getValueProperty = function(name) {
  return this.value[name];
};

Pp.get = function(name) {
  var path = this;
  var names = arguments;
  var count = names.length;

  for (var i = 0; i < count; ++i) {
    path = getChildPath(path, names[i]);
  }

  return path;
};

Pp.each = function(callback, context) {
  var childPaths = [];
  var len = this.value.length;
  var i = 0;

  // Collect all the original child paths before invoking the callback.
  for (var i = 0; i < len; ++i) {
    if (hasOwn.call(this.value, i)) {
      childPaths[i] = this.get(i);
    }
  }

  // Invoke the callback on just the original child paths, regardless of
  // any modifications made to the array by the callback. I chose these
  // semantics over cleverly invoking the callback on new elements because
  // this way is much easier to reason about.
  context = context || this;
  for (i = 0; i < len; ++i) {
    if (hasOwn.call(childPaths, i)) {
      callback.call(context, childPaths[i]);
    }
  }
};

Pp.map = function(callback, context) {
  var result = [];

  this.each(function(childPath) {
    result.push(callback.call(this, childPath));
  }, context);

  return result;
};

Pp.filter = function(callback, context) {
  var result = [];

  this.each(function(childPath) {
    if (callback.call(this, childPath)) {
      result.push(childPath);
    }
  }, context);

  return result;
};

Pp.replace = function(replacement) {
  var count = arguments.length;

  assert.ok(
    this.parentPath instanceof Path,
    "Instead of replacing the root of the tree, create a new tree."
  );

  var name = this.name;
  var parentValue = this.parentPath.value;
  var parentCache = getChildCache(this.parentPath);
  var results = [];

  if (toString.call(parentValue) === arrayToString) {
    delete parentCache.length;
    delete parentCache[name];

    var moved = {};

    for (var i = name + 1; i < parentValue.length; ++i) {
      var child = parentCache[i];
      if (child) {
        var newIndex = i - 1 + count;
        moved[newIndex] = child;
        Object.defineProperty(child, "name", { value: newIndex });
        delete parentCache[i];
      }
    }

    var args = slice.call(arguments);
    args.unshift(name, 1);
    parentValue.splice.apply(parentValue, args);

    for (newIndex in moved) {
      if (hasOwn.call(moved, newIndex)) {
        parentCache[newIndex] = moved[newIndex];
      }
    }

    for (i = name; i < name + count; ++i) {
      results.push(this.parentPath.get(i));
    }

  } else if (count === 1) {
    delete parentCache[name];
    parentValue[name] = replacement;
    results.push(this.parentPath.get(name));

  } else if (count === 0) {
    delete parentCache[name];
    delete parentValue[name];

  } else {
    assert.ok(false, "Could not replace Path.");
  }

  return results;
};

exports.Path = Path;
 at SyntaxError: Unexpected token (1:82)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/ast-path/node_modules/ast-path/main.js. Coverage (Term): 76% Coverage (LOC): 100%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
