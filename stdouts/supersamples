/root/Targets/supersamples
├─┬ supersamples@1.3.0 
│ ├── async@0.9.2 
│ ├─┬ cjson@0.3.3 
│ │ └─┬ json-parse-helpfulerror@1.0.3 
│ │   └── jju@1.3.0 
│ ├─┬ deep@0.0.2 
│ │ └── underscore@1.4.4 
│ ├─┬ fs-extra@0.10.0 
│ │ ├── jsonfile@1.2.0 
│ │ ├─┬ mkdirp@0.5.1 
│ │ │ └── minimist@0.0.8 
│ │ ├── ncp@0.5.1 
│ │ └─┬ rimraf@2.6.2 
│ │   └─┬ glob@7.1.2 
│ │     ├── fs.realpath@1.0.0 
│ │     ├── inflight@1.0.6 
│ │     ├─┬ minimatch@3.0.4 
│ │     │ └─┬ brace-expansion@1.1.8 
│ │     │   ├── balanced-match@1.0.0 
│ │     │   └── concat-map@0.0.1 
│ │     └── path-is-absolute@1.0.1 
│ ├─┬ glob@4.0.6 
│ │ ├─┬ graceful-fs@3.0.11 
│ │ │ └── natives@1.1.0 
│ │ ├── inherits@2.0.3 
│ │ ├─┬ minimatch@1.0.0 
│ │ │ ├── lru-cache@2.7.3 
│ │ │ └── sigmund@1.0.1 
│ │ └─┬ once@1.4.0 
│ │   └── wrappy@1.0.2 
│ ├─┬ handlebars@1.3.0 
│ │ ├─┬ optimist@0.3.7 
│ │ │ └── wordwrap@0.0.3 
│ │ └─┬ uglify-js@2.3.6 
│ │   ├── async@0.2.10 
│ │   └─┬ source-map@0.1.43 
│ │     └── amdefine@1.0.1 
│ ├── highlight.js@8.1.0 
│ ├── http-status-codes@1.0.6 
│ ├── lodash@2.4.2 
│ ├── markit@0.1.0 
│ ├── moment@2.7.0 
│ ├─┬ sinon@1.10.3 
│ │ ├─┬ formatio@1.0.2 
│ │ │ └── samsam@1.1.3 
│ │ └─┬ util@0.10.3 
│ │   └── inherits@2.0.1 
│ └── wrench@1.5.9 
└── UNMET PEER DEPENDENCY supertest@>1.0.0

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/supersamples/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 27% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","call"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.06 took 7.8467s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (88:11) on program /**
 * @depend ../sinon.js
 * @depend stub.js
 */
/*jslint eqeqeq: false, onevar: false, nomen: false, plusplus: false*/
/*global module, require, sinon*/
/**
 * Assertions matching the test spy retrieval interface.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
"use strict";

(function (sinon, global) {
    var commonJSModule = typeof module !== "undefined" && module.exports && typeof require == "function";
    var slice = Array.prototype.slice;
    var assert;

    if (!sinon && commonJSModule) {
        sinon = require("../sinon");
    }

    if (!sinon) {
        return;
    }

    function verifyIsStub() {
        var method;

        for (var i = 0, l = arguments.length; i < l; ++i) {
            method = arguments[i];

            if (!method) {
                assert.fail("fake is not a spy");
            }

            if (typeof method != "function") {
                assert.fail(method + " is not a function");
            }

            if (typeof method.getCall != "function") {
                assert.fail(method + " is not stubbed");
            }
        }
    }

    function failAssertion(object, msg) {
        object = object || global;
        var failMethod = object.fail || assert.fail;
        failMethod.call(object, msg);
    }

    function mirrorPropAsAssertion(name, method, message) {
        if (arguments.length == 2) {
            message = method;
            method = name;
        }

        assert[name] = function (fake) {
            verifyIsStub(fake);

            var args = slice.call(arguments, 1);
            var failed = false;

            if (typeof method == "function") {
                failed = !method(fake);
            } else {
                failed = typeof fake[method] == "function" ?
                    !fake[method].apply(fake, args) : !fake[method];
            }

            if (failed) {
                failAssertion(this, fake.printf.apply(fake, [message].concat(args)));
            } else {
                assert.pass(name);
            }
        };
    }

    function exposedName(prefix, prop) {
        return !prefix || /^fail/.test(prop) ? prop :
            prefix + prop.slice(0, 1).toUpperCase() + prop.slice(1);
    }

    assert = {
        failException: "AssertError",

        fail: function fail(message) {
            var error = new Error(message);
            error.name = this.failException || assert.failException;

            throw error;
        },

        pass: function pass(assertion) {},

        callOrder: function assertCallOrder() {
            verifyIsStub.apply(null, arguments);
            var expected = "", actual = "";

            if (!sinon.calledInOrder(arguments)) {
                try {
                    expected = [].join.call(arguments, ", ");
                    var calls = slice.call(arguments);
                    var i = calls.length;
                    while (i) {
                        if (!calls[--i].called) {
                            calls.splice(i, 1);
                        }
                    }
                    actual = sinon.orderByFirstCall(calls).join(", ");
                } catch (e) {
                    // If this fails, we'll just fall back to the blank string
                }

                failAssertion(this, "expected " + expected + " to be " +
                              "called in order but were called as " + actual);
            } else {
                assert.pass("callOrder");
            }
        },

        callCount: function assertCallCount(method, count) {
            verifyIsStub(method);

            if (method.callCount != count) {
                var msg = "expected %n to be called " + sinon.timesInWords(count) +
                    " but was called %c%C";
                failAssertion(this, method.printf(msg));
            } else {
                assert.pass("callCount");
            }
        },

        expose: function expose(target, options) {
            if (!target) {
                throw new TypeError("target is null or undefined");
            }

            var o = options || {};
            var prefix = typeof o.prefix == "undefined" && "assert" || o.prefix;
            var includeFail = typeof o.includeFail == "undefined" || !!o.includeFail;

            for (var method in this) {
                if (method != "export" && (includeFail || !/^(fail)/.test(method))) {
                    target[exposedName(prefix, method)] = this[method];
                }
            }

            return target;
        },

        match: function match(actual, expectation) {
            var matcher = sinon.match(expectation);
            if (matcher.test(actual)) {
                assert.pass("match");
            } else {
                var formatted = [
                    "expected value to match",
                    "    expected = " + sinon.format(expectation),
                    "    actual = " + sinon.format(actual)
                ]
                failAssertion(this, formatted.join("\n"));
            }
        }
    };

    mirrorPropAsAssertion("called", "expected %n to have been called at least once but was never called");
    mirrorPropAsAssertion("notCalled", function (spy) { return !spy.called; },
                          "expected %n to not have been called but was called %c%C");
    mirrorPropAsAssertion("calledOnce", "expected %n to be called once but was called %c%C");
    mirrorPropAsAssertion("calledTwice", "expected %n to be called twice but was called %c%C");
    mirrorPropAsAssertion("calledThrice", "expected %n to be called thrice but was called %c%C");
    mirrorPropAsAssertion("calledOn", "expected %n to be called with %1 as this but was called with %t");
    mirrorPropAsAssertion("alwaysCalledOn", "expected %n to always be called with %1 as this but was called with %t");
    mirrorPropAsAssertion("calledWithNew", "expected %n to be called with new");
    mirrorPropAsAssertion("alwaysCalledWithNew", "expected %n to always be called with new");
    mirrorPropAsAssertion("calledWith", "expected %n to be called with arguments %*%C");
    mirrorPropAsAssertion("calledWithMatch", "expected %n to be called with match %*%C");
    mirrorPropAsAssertion("alwaysCalledWith", "expected %n to always be called with arguments %*%C");
    mirrorPropAsAssertion("alwaysCalledWithMatch", "expected %n to always be called with match %*%C");
    mirrorPropAsAssertion("calledWithExactly", "expected %n to be called with exact arguments %*%C");
    mirrorPropAsAssertion("alwaysCalledWithExactly", "expected %n to always be called with exact arguments %*%C");
    mirrorPropAsAssertion("neverCalledWith", "expected %n to never be called with arguments %*%C");
    mirrorPropAsAssertion("neverCalledWithMatch", "expected %n to never be called with match %*%C");
    mirrorPropAsAssertion("threw", "%n did not throw exception%C");
    mirrorPropAsAssertion("alwaysThrew", "%n did not always throw exception%C");

    sinon.assert = assert;

    if (typeof define === "function" && define.amd) {
        define(["module"], function(module) { module.exports = assert; });
    } else if (commonJSModule) {
        module.exports = assert;
    }
}(typeof sinon == "object" && sinon || null, typeof window != "undefined" ? window : (typeof self != "undefined") ? self : global));
 at SyntaxError: Unexpected token (88:11)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$3.parseExprAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1822:12)
    at Parser.parseExprAtom (/root/ExpoSE/lib/Tropigate/bin/Expression.js:28:30)
    at Parser.pp$3.parseExprSubscripts (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1715:21)
    at Parser.parseMaybeUnary (/root/ExpoSE/lib/Tropigate/bin/Unary.js:34:29)
    at Parser.pp$3.parseExprOps (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1637:21)
    at Parser.pp$3.parseMaybeConditional (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1620:21)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1597:21)
    at Parser.pp$3.parseExpression (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1573:21)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/supersamples/node_modules/supersamples/index.js. Coverage (Term): 35% Coverage (LOC): 50%
*- File /root/Targets/supersamples/node_modules/supersamples/lib/instrument.js. Coverage (Term): 9% Coverage (LOC): 13%
*- File /root/Targets/supersamples/node_modules/sinon/lib/sinon.js. Coverage (Term): 20% Coverage (LOC): 29%
*- File /root/Targets/supersamples/node_modules/formatio/lib/formatio.js. Coverage (Term): 13% Coverage (LOC): 26%
*- File /root/Targets/supersamples/node_modules/samsam/lib/samsam.js. Coverage (Term): 8% Coverage (LOC): 15%
*- File /root/Targets/supersamples/node_modules/sinon/lib/sinon/spy.js. Coverage (Term): 18% Coverage (LOC): 28%
*- File /root/Targets/supersamples/node_modules/sinon/lib/sinon/call.js. Coverage (Term): 14% Coverage (LOC): 30%
*- File /root/Targets/supersamples/node_modules/sinon/lib/sinon/behavior.js. Coverage (Term): 15% Coverage (LOC): 24%
*- File /root/Targets/supersamples/node_modules/sinon/lib/sinon/stub.js. Coverage (Term): 23% Coverage (LOC): 35%
*- File /root/Targets/supersamples/node_modules/sinon/lib/sinon/mock.js. Coverage (Term): 11% Coverage (LOC): 22%
*- File /root/Targets/supersamples/node_modules/sinon/lib/sinon/match.js. Coverage (Term): 31% Coverage (LOC): 39%
*- File /root/Targets/supersamples/node_modules/sinon/lib/sinon/collection.js. Coverage (Term): 21% Coverage (LOC): 30%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
