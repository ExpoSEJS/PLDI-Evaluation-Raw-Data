/root/Targets/air-drop
└─┬ air-drop@0.2.3 
  ├─┬ async@2.5.0 
  │ └── lodash@4.17.4 
  ├─┬ burrito@0.2.12 
  │ ├── traverse@0.5.2 
  │ └── uglify-js@1.1.1 
  ├── coffee-script@1.12.7 
  ├─┬ connect@3.6.5 
  │ ├─┬ debug@2.6.9 
  │ │ └── ms@2.0.0 
  │ ├─┬ finalhandler@1.0.6 
  │ │ ├── encodeurl@1.0.1 
  │ │ ├── escape-html@1.0.3 
  │ │ ├─┬ on-finished@2.3.0 
  │ │ │ └── ee-first@1.1.1 
  │ │ ├── statuses@1.3.1 
  │ │ └── unpipe@1.0.0 
  │ ├── parseurl@1.3.2 
  │ └── utils-merge@1.0.1 
  ├─┬ detective@4.5.0 
  │ ├── acorn@4.0.13 
  │ └── defined@1.0.0 
  ├─┬ glob@7.1.2 
  │ ├── fs.realpath@1.0.0 
  │ ├─┬ inflight@1.0.6 
  │ │ └── wrappy@1.0.2 
  │ ├── inherits@2.0.3 
  │ ├─┬ minimatch@3.0.4 
  │ │ └─┬ brace-expansion@1.1.8 
  │ │   ├── balanced-match@1.0.0 
  │ │   └── concat-map@0.0.1 
  │ ├── once@1.4.0 
  │ └── path-is-absolute@1.0.1 
  ├─┬ less@2.7.2 
  │ ├─┬ errno@0.1.4 
  │ │ └── prr@0.0.0 
  │ ├── graceful-fs@4.1.11 
  │ ├── image-size@0.5.5 
  │ ├── mime@1.4.1 
  │ ├─┬ mkdirp@0.5.1 
  │ │ └── minimist@0.0.8 
  │ ├─┬ promise@7.3.1 
  │ │ └── asap@2.0.6 
  │ ├─┬ request@2.83.0 
  │ │ ├── aws-sign2@0.7.0 
  │ │ ├── aws4@1.6.0 
  │ │ ├── caseless@0.12.0 
  │ │ ├─┬ combined-stream@1.0.5 
  │ │ │ └── delayed-stream@1.0.0 
  │ │ ├── extend@3.0.1 
  │ │ ├── forever-agent@0.6.1 
  │ │ ├─┬ form-data@2.3.1 
  │ │ │ └── asynckit@0.4.0 
  │ │ ├─┬ har-validator@5.0.3 
  │ │ │ ├─┬ ajv@5.2.3 
  │ │ │ │ ├── co@4.6.0 
  │ │ │ │ ├── fast-deep-equal@1.0.0 
  │ │ │ │ ├── json-schema-traverse@0.3.1 
  │ │ │ │ └─┬ json-stable-stringify@1.0.1 
  │ │ │ │   └── jsonify@0.0.0 
  │ │ │ └── har-schema@2.0.0 
  │ │ ├─┬ hawk@6.0.2 
  │ │ │ ├── boom@4.3.1 
  │ │ │ ├─┬ cryptiles@3.1.2 
  │ │ │ │ └── boom@5.2.0 
  │ │ │ ├── hoek@4.2.0 
  │ │ │ └── sntp@2.0.2 
  │ │ ├─┬ http-signature@1.2.0 
  │ │ │ ├── assert-plus@1.0.0 
  │ │ │ ├─┬ jsprim@1.4.1 
  │ │ │ │ ├── extsprintf@1.3.0 
  │ │ │ │ ├── json-schema@0.2.3 
  │ │ │ │ └─┬ verror@1.10.0 
  │ │ │ │   └── core-util-is@1.0.2 
  │ │ │ └─┬ sshpk@1.13.1 
  │ │ │   ├── asn1@0.2.3 
  │ │ │   ├── bcrypt-pbkdf@1.0.1 
  │ │ │   ├── dashdash@1.14.1 
  │ │ │   ├── ecc-jsbn@0.1.1 
  │ │ │   ├── getpass@0.1.7 
  │ │ │   ├── jsbn@0.1.1 
  │ │ │   └── tweetnacl@0.14.5 
  │ │ ├── is-typedarray@1.0.0 
  │ │ ├── isstream@0.1.2 
  │ │ ├── json-stringify-safe@5.0.1 
  │ │ ├─┬ mime-types@2.1.17 
  │ │ │ └── mime-db@1.30.0 
  │ │ ├── oauth-sign@0.8.2 
  │ │ ├── performance-now@2.1.0 
  │ │ ├── qs@6.5.1 
  │ │ ├── safe-buffer@5.1.1 
  │ │ ├── stringstream@0.0.5 
  │ │ ├─┬ tough-cookie@2.3.3 
  │ │ │ └── punycode@1.4.1 
  │ │ ├── tunnel-agent@0.6.0 
  │ │ └── uuid@3.1.0 
  │ └── source-map@0.5.7 
  ├─┬ stylus@0.54.5 
  │ ├── css-parse@1.7.0 
  │ ├── glob@7.0.6 
  │ ├── sax@0.5.8 
  │ └─┬ source-map@0.1.43 
  │   └── amdefine@1.0.1 
  ├─┬ uglify-js@3.1.3 
  │ └── commander@2.11.0 
  └── underscore@1.3.1 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/air-drop/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0262 took 2.0935s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: The keyword 'package' is reserved (13:6) on program var pathLib = require("path"),
    glob = require("glob"),
    async = require("async"),
    _ = require("underscore"),
    router = require("./router"),
    orderedAsync = require("./ordered-async"),
    Minimizers = require("./minimizers"),
    Cachers = require("./cachers"),
    Path = require("./path"),
    Compilers = require("./compilers");

var AirDrop = module.exports = function(url) {
  var package = function(req, res, next) {
    return package.router(req, res, next);
  };

  _.extend(package, {
    url: url,
    paths: [],
    pathsToAdd: [],
    functionsToStrip: [],
    minimizer: Minimizers.None,
    shouldPackage: false,
    cacher: null,
    explicitlyUseBrowserRequire: null
  });

  _.extend(package, packageMethods);
  
  package.router = package._buildRouter();

  return package;
};

AirDrop.Minimizers = Minimizers;
AirDrop.Cachers = Cachers;
AirDrop.Compilers = Compilers;
AirDrop.Path = Path;

var packageMethods = {
  _deferredAddPath: function(path, options) {
    var package = this;
    package.pathsToAdd.push([path, options]);
    setTimeout(function() {
      orderedAsync.concat(package.pathsToAdd, _.bind(package._addPath, package), function(err, paths) {
        if (err) throw err;
        var currentFilePaths = _(package.paths).map(function(p) { return p.path; });
        paths.forEach(function(p) {
          if (currentFilePaths.indexOf(p.path) == -1) {
            package.paths.push(p);
            currentFilePaths.push(p.path);
          }
        });
      });
    }, 0);
  },
      
  _addPath: function(tuple, cb) {
    var path = tuple[0],
        options = tuple[1],
        package = this,
        out = [];
    options = options || {};
    options.isCss = package.isCss();
    pathsFromGlob(path, function(err, paths) {
      if (err) cb(err);
      var newPaths = [];
      paths.forEach(function(filepath) {
        var opts = _.clone(options);
        opts.path = filepath;
        newPaths.push(new Path(opts));
      });
      expandPaths(newPaths, cb);
    });
  },

  require: function(path, options) {
    options = options || {};
    options.type = "require";
    this._deferredAddPath(path, options);
    return this;
  },

  include: function(path, options) {
    options = options || {};
    options.type = "include";
    this._deferredAddPath(path, options);
    return this;
  },

  minimize: function(boolOrMinimizer) {
    if(_.isUndefined(boolOrMinimizer) || boolOrMinimizer === true) {
      this.minimizer = Minimizers.Default;
    }
    else if(!boolOrMinimizer) {
      this.minimizer = Minimizers.None;
    }
    else if(_.isFunction(boolOrMinimizer)) {
      this.minimizer = boolOrMinimizer;
    }
    return this;
  },

  package: function(bool) {
    this.shouldPackage = (typeof bool === "undefined") ? true : bool;
    return this;
  },

  cache: function(boolOrCacher) {
    if(_.isUndefined(boolOrCacher) || boolOrCacher === true) {
      this.cacher = Cachers.Default;
    }
    else if(!boolOrCacher) {
      this.cacher = Cachers.None;
    }
    else if(_.isFunction(boolOrCacher)) {
      this.cacher = boolOrCacher;
    }
    return this;
  },

  stripFunction: function(functionName) {
    this.functionsToStrip.push(functionName);
    return this;
  },

  useCachedResult: function cache(key, fetchFunc, cb) {
    this.cacher ? this.cacher(key, _.bind(fetchFunc, this), cb) : fetchFunc(cb);
  },

  useBrowserRequire: function(bool) {
    this.explicitlyUseBrowserRequire = (typeof bool === "undefined") ? true : bool;
    return this;
  },

  isCss: function() {
    return /\.css$/.test(this.url);
  },

  _shouldUseBrowserRequire: function() {
    if(!_.isNull(this.explicitlyUseBrowserRequire)) {
      return this.explicitlyUseBrowserRequire;
    }
    var implicitUse = _(this.paths).any(function(path) {
      return path.type === "require"; 
    });
    return implicitUse;
  },

  source: function(cb) {
    var package = this;
    orderedAsync.map(package.allPaths(), _.bind(package._fetchCode, package), function(err, parts) {
      if(err) { return cb(err) }
      package.minimizer(parts.join("\n"), cb);
    });
  },

  allPaths: function() {
    var all = this.paths;
    if(this._shouldUseBrowserRequire()) {
      var browserRequirePath = new Path({
        type: "include", 
        path: __dirname + "/browser-require.js"
      });
      var browserRequireHackPath = new Path({
        type: "include",
        path: __dirname + "/browser-require-hack.js"
      });
      all = [browserRequirePath, browserRequireHackPath].concat(all);
    }
    return all;
  },

  _buildRouter: function() {
    var package = this;

    return router(function(app) {
      function deliverSource(req, res) {
        return function(err, data) {
          var contentType;
          if(err) throw err;
          if (package.isCss()) {
            contentType = "text/css";
          } else {
            contentType = "application/javascript";
          }
          res.setHeader("Content-Type", contentType);
          res.write(data);
          res.end();
        };
      }

      app.get(package.url, function(req, res) {
        package.useCachedResult(package.url, _.bind(package.source, package), deliverSource(req, res));
      });
    
      app.get(package.url + "/include/:filepath", function(req, res) {
        var filepath = req.params.filepath.replace(/\|/g, "/"),
            key = package.url + "/include/" + filepath,
            fetchFunc = function(cb) {
              var path = new Path({type: "include", path: filepath, isCss: package.isCss()});
              package.readWrapFile(path, cb);
            };
        package.useCachedResult(key, fetchFunc, deliverSource(req, res));
      });

      //@todo: routing should accept optional module_name param
      //    eg: package.url + "/require/:filepath[/:module_name]" provided by path.name
      app.get(package.url + "/require/:filepath", function(req, res) {
        var filepath = req.params.filepath.replace(/\|/g, "/"),
            key = package.url + "/require/" + filepath,
            fetchFunc = function(cb) {
              var path = new Path({type: "require", path: filepath, isCss: package.isCss()});
              package.readWrapFile(path, cb);
            };
        package.useCachedResult(key, fetchFunc, deliverSource(req, res));
      });
    });
  },

  _fetchCode: function(path, cb) {
    var package = this;
    if(package.shouldPackage) {
      package.readWrapFile(path, cb);
    }
    else {
      var encodedPath = path.relativePath.replace(/\//g, "|");
      if (package.isCss()) {
        cb(null, "@import url(\"" + package.url + "/" + path.type + "/" + encodedPath + "\");");
      } else {
        cb(null, "document.write('<scr'+'ipt src=\"" + package.url + "/" + path.type + "/" + encodedPath + "\" type=\"text/javascript\"></scr'+'ipt>');");
      }
    }
  },

  _applyMinimization: function(code) {
    return this.minimizer(code);
  },

  _stripFunctions: function(code) {
    var nodeName, i,
        burrito = require('burrito'),
        package = this,
        includesStrippedFunction = false;

    // Only use burrito to parse the code if at least one of the functionsToStrip is present in the code.
    includesStrippedFunction = _(package.functionsToStrip).detect(function(s) { return code.indexOf(s) > -1; });
    if (!includesStrippedFunction) return code;

    return burrito(code, function (node) {
      if (node.name === 'call') {
        nodeName = node.start.value;
        for(i=0; i < package.functionsToStrip.length; i++) {
          if (nodeName === package.functionsToStrip[i]) {
            node.wrap('');
          }
        }
      }
    });
  },

  readWrapFile: function(path, cb) {
    var package = this, code;
    path.source(function(err, code) {
      if(err) { return cb(err); }
      if (package.isCss()) {
        cb(null, code);
      } else {
        cb(null, package._stripFunctions(code));
      }
    });
  }
};

function expandPaths(paths, cb) {
  orderedAsync.concat(paths, buildDependentPaths, function(err, deps) {
    if(err) { return cb(err); }
    try {
      var allPaths = deps,
          compacted = [],
          nameIndex = [];
    
      for(var i=0; i < allPaths.length; i++) {
        var path = allPaths[i];
        if(nameIndex.indexOf(path.path) === -1) {
          nameIndex.push(path.path);
          compacted.push(path);
        }
      }
      cb(null, compacted);
    } catch (e) {
      cb(err || e);
    }
  });
}

function buildDependentPaths(path, list, cb) {
  if (!Array.isArray(list)) {
    cb = list;
    list = [path];
  }

  var walkDeps = function(depPath, cb) {
    list.unshift(depPath);
    buildDependentPaths(depPath, list, function(err, cb2) {
      cb(err, list);
    });
  };

  path.dependencyPaths(function(err, paths) {
    if (err) return cb(err);
    orderedAsync.map(paths, walkDeps, function(err) {
      cb(err, list);
    });
  });
}

function pathsFromGlob(path, cb) {
  var filepath = path;
  // add extension wildcard
  if (pathLib.extname(filepath) === "") {
    filepath += ".*"
  }
  if (process.platform === "win32") {
    filepath = filepath.replace(/\\/g, '/');
  }
  glob(filepath, function(err, paths) {
    if (paths.length == 0) {
      cb(err, [path]);
    } else {
      cb(err, paths);
    }
  });
}
 at SyntaxError: The keyword 'package' is reserved (13:6)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$3.parseIdent (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2182:14)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:41:34)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseBlock (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:981:25)
    at Parser.pp$3.parseFunctionBody (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2105:24)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
