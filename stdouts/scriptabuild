/root/Targets/scriptabuild
└── scriptabuild@0.1.47 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/scriptabuild/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0471 took 2.6694s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected character '#' (1:78) on program #!/usr/bin/env node

const express = require("express");
const server = require('http').createServer();
const url = require('url');
const WebSocketServer = require('ws').Server;
const cors = require("cors");
const bodyparser = require("@aeinbu/bodyparser");

const _ = require("lodash");
const Q = require("q");
const path = require("path");
const moment = require("moment");

const fs = require("fs");

const ensureFolder = require("./blocks/ensureFolder");
const copyFolder = require("./blocks/copyFolder");
const executeTask = require("./blocks/executeTask");
const log = require("./blocks/log");
const block = require("./blocks/block");
const git = require("./blocks/git");
const mark = require("./blocks/mark");

const ensureFolderSync = require("./buildContextUtils/ensureFolderSync");
const createBuildContext = require("./buildContextUtils/createBuildContext");
const getConfig = require("./buildContextUtils/getConfig");
const {
	getProjectSandbox
} = require("./dataUtils/projectSandbox")
const {
	getLatestBuildNoSync
} = require("./dataUtils/buildNo");
const {
	getBuildSettingsSync
} = require("./dataUtils/buildSettings");
const {
	getStatusSync
} = require("./dataUtils/status");
const {
	getLogSync
} = require("./dataUtils/log");
const load = require("./dataUtils/load");

const config = getConfig();
const projects = load.json(path.resolve(process.cwd(), config.projectsConfigurationFile));


// setup WS application
const wss = new WebSocketServer({
	server
});

wss.on('connection', function connection(ws) {
	var location = url.parse(ws.upgradeReq.url, true);
	// you might use location.query.access_token to authenticate or share sessions
	// or ws.upgradeReq.headers.cookie (see http://stackoverflow.com/a/16395220/151312)

	ws.on('message', function incoming(message) {
		console.log('received: %s', message);
	});

});

wss.broadcast = function broadcast(data) {
	wss.clients.forEach(function each(client) {
		console.log("WS send", JSON.stringify(data));
		client.send(JSON.stringify(data));
	});
};


// setup EXPRESS application
const app = express();

app.use("/app/", express.static(path.join(__dirname, "wwwroot")));

app.use(cors());

app.get("/", function (req, resp) {
	resp.redirect("/app/projects");
})

app.get("/app/*", function (req, resp) {
	resp.sendFile(__dirname + "/wwwroot/index.html");
});



app.get("/api/project-list",
	function (req, resp) {
		results = _(projects)
			.map(p => {
				var projectSandbox = getProjectSandbox(config, p);

				let buildNo = getLatestBuildNoSync(projectSandbox);
				let status = getStatusSync(projectSandbox, buildNo);
				return {
					name: p.name,
					buildStatus: status.status,
					timestamp: status.timestamp
				};
			})
			.value();

		resp.json(results);
	});



app.get("/api/project-detail/:projectName",
	function (req, resp) {
		const name = req.params.projectName;
		const project = _(projects).find({
			name
		});

		const projectSandbox = getProjectSandbox(config, project);
		const buildNo = getLatestBuildNoSync(projectSandbox);
		const buildSettings = getBuildSettingsSync(projectSandbox, buildNo);
		const status = getStatusSync(projectSandbox, buildNo);

		const projectDetail = {
			name,
			branch: buildSettings.branch,
			commitHash: buildSettings.commitHash,
			buildNo,
			timestamp: status.timestamp,
			buildStatus: status.status
		};

		resp.json(projectDetail);
	});



app.get("/api/project-log/:projectName/:buildNo?",
	function (req, resp) {
		const name = req.params.projectName;
		const project = _(projects).find({
			name
		});

		const projectSandbox = getProjectSandbox(config, project);
		const buildNo = req.params.buildNo || getLatestBuildNoSync(projectSandbox);

		const log = getLogSync(projectSandbox, buildNo);

		resp.json({
			buildNo,
			log
		});
	});



app.post("/api/project-build/:projectname",
	function (req, resp) {
		let projectname = req.params.projectname;

		let pathspec = "HEAD";
		// let branch = config.source.branch;
		build(projectname, pathspec);

		resp.sendStatus(200);
	});



app.post("/api/hook/bitbucket/",
	bodyparser.json(),
	function (req, resp) {
		let projectname = req.body.repository.name;
		let commitHash = req.body.changesets.values[0].toCommit.id;
		//let author = req.body.changesets.values[0].toCommit.author;

		// TODO: Remove the logging when it is no longer neccessary
		console.log(req.method, req.path, req.params);
		console.log(req.body);

		let project = projects.find(p => p.name == projectname);
		if (!project) {
			// TODO: Auto register project in projects.json
			return resp.sendStatus(404);
		}

		let ctx = createBuildContext(config, project);
		let filename = path.join(ctx.paths.sandbox, ctx.paths.buildNo.toString(), "hook-data.json");
		let fd = fs.openSync(filename, "w");
		fs.writeSync(fd, JSON.stringify({
			method: req.method,
			path: req.path,
			params: req.params,
			headers: req.headers,
			body: req.body
		}));
		fs.close(fd);

		build(projectname, commitHash);

		resp.sendStatus(200);
	});


function build(projectname, pathspec) {

	let project = projects.find(p => p.name == projectname);
	let ctx = createBuildContext(config, project, pathspec);

	let buildInfo = {
		pathspec,
		projectname,
		buildNo: ctx.paths.buildNo
	};

	wss.broadcast({
		messageType: "buildStatusChanged",
		messagePayload: {
			buildInfo,
			buildStatus: "running"
		}
	});

	Q(ctx)
		.then(mark.asStarted())
		.then(git.load(project, pathspec))
		.then(executeTask(project.run))
		// .then(log("Copying output files"))
		// .then(copyFolder("%build%", "%output%/"))
		.then(log("Scripts completed successfully"))
		.then(mark.asCompleted())
		// .then(git.tag( ... ))
		// .then(git.push( ... ))
		.then(block(ctx => {
			wss.broadcast({
				messageType: "buildStatusChanged",
				messagePayload: {
					buildInfo,
					buildStatus: "ok"
				}
			});
		}))
		.catch(err => {
			ctx.logger.error(err);
			console.error("Scripts failed", err);
			mark.asFailed()(ctx);

			wss.broadcast({
				messageType: "buildStatusChanged",
				messagePayload: {
					buildInfo,
					buildStatus: "failed"
				}
			});
		});

	console.log();
	console.log("*** Starting the build for " + projectname);
}



app.all("/api/hook/record",
	bodyparser.raw(),
	function (req, resp) {
		console.log(req.method, req.path, req.params);
		console.log(req.headers);
		console.log(req.body);

		let parentfolder = path.join(config.workingDirectory, "recordings");
		let buildNo = getLatestBuildNoSync(parentfolder) + 1;
		let folder = path.join(parentfolder, buildNo.toString());
		ensureFolderSync(folder);

		let hookDataFilename = path.join(folder, "hook-data.json");
		let fd1 = fs.openSync(hookDataFilename, "w");
		fs.writeSync(fd, JSON.stringify({
			method: req.method,
			path: req.path,
			params: req.params,
			headers: req.headers,
			body: req.body
		}));
		fs.close(fd1);

		let requstBodyFilename = path.join(folder, "request-body.txt");
		let fd2 = fs.openSync(requstBodyFilename, "w");
		fs.writeSync(fd, req.body);
		fs.close(fd2);

		resp.sendStatus(200);
	});

// Server STARTUP code

console.log("Starting Scriptabuild");
ensureFolderSync(config.workingDirectory);
// ensureFolderSync(path.join(config.workingDirectory, "logs"));
// ensureFolderSync(path.join(config.workingDirectory, "recordings"));

server.on('request', app);
server.listen(config.http.port, function () {
	console.log('Scriptabuild http server listening on port ' + server.address().port);
}); at SyntaxError: Unexpected character '#' (1:78)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$7.getTokenFromCode (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2756:10)
    at Parser.pp$7.readToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2477:17)
    at Parser.readToken (/root/ExpoSE/lib/Tropigate/bin/Tokens.js:124:26)
    at Parser.pp$7.nextToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2468:15)
    at Parser.pp$7.next (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2413:10)
    at Parser.pp.eat (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:536:12)
    at Parser.pp.semicolon (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:581:15)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:918:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
