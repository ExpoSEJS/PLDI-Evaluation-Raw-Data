/root/Targets/html5-papandreou
└─┬ html5-papandreou@0.3.15-patch3 
  ├── html5-entities@0.5.1 
  ├─┬ jsdom@11.2.0 
  │ ├── abab@1.0.4 
  │ ├── acorn@4.0.13 
  │ ├── acorn-globals@3.1.0 
  │ ├── array-equal@1.0.0 
  │ ├── content-type-parser@1.0.1 
  │ ├── cssom@0.3.2 
  │ ├── cssstyle@0.2.37 
  │ ├─┬ escodegen@1.9.0 
  │ │ ├── esprima@3.1.3 
  │ │ ├── estraverse@4.2.0 
  │ │ ├── esutils@2.0.2 
  │ │ ├─┬ optionator@0.8.2 
  │ │ │ ├── deep-is@0.1.3 
  │ │ │ ├── fast-levenshtein@2.0.6 
  │ │ │ ├── levn@0.3.0 
  │ │ │ ├── prelude-ls@1.1.2 
  │ │ │ ├── type-check@0.3.2 
  │ │ │ └── wordwrap@1.0.0 
  │ │ └── source-map@0.5.7 
  │ ├── html-encoding-sniffer@1.0.1 
  │ ├── nwmatcher@1.4.1 
  │ ├─┬ parse5@3.0.2 
  │ │ └── @types/node@6.0.88 
  │ ├── pn@1.0.0 
  │ ├─┬ request@2.82.0 
  │ │ ├── aws-sign2@0.7.0 
  │ │ ├── aws4@1.6.0 
  │ │ ├── caseless@0.12.0 
  │ │ ├─┬ combined-stream@1.0.5 
  │ │ │ └── delayed-stream@1.0.0 
  │ │ ├── extend@3.0.1 
  │ │ ├── forever-agent@0.6.1 
  │ │ ├─┬ form-data@2.3.1 
  │ │ │ └── asynckit@0.4.0 
  │ │ ├─┬ har-validator@5.0.3 
  │ │ │ ├─┬ ajv@5.2.2 
  │ │ │ │ ├── co@4.6.0 
  │ │ │ │ ├── fast-deep-equal@1.0.0 
  │ │ │ │ ├── json-schema-traverse@0.3.1 
  │ │ │ │ └─┬ json-stable-stringify@1.0.1 
  │ │ │ │   └── jsonify@0.0.0 
  │ │ │ └── har-schema@2.0.0 
  │ │ ├─┬ hawk@6.0.2 
  │ │ │ ├── boom@4.3.1 
  │ │ │ ├─┬ cryptiles@3.1.2 
  │ │ │ │ └── boom@5.2.0 
  │ │ │ ├── hoek@4.2.0 
  │ │ │ └── sntp@2.0.2 
  │ │ ├─┬ http-signature@1.2.0 
  │ │ │ ├── assert-plus@1.0.0 
  │ │ │ ├─┬ jsprim@1.4.1 
  │ │ │ │ ├── extsprintf@1.3.0 
  │ │ │ │ ├── json-schema@0.2.3 
  │ │ │ │ └─┬ verror@1.10.0 
  │ │ │ │   └── core-util-is@1.0.2 
  │ │ │ └─┬ sshpk@1.13.1 
  │ │ │   ├── asn1@0.2.3 
  │ │ │   ├── bcrypt-pbkdf@1.0.1 
  │ │ │   ├── dashdash@1.14.1 
  │ │ │   ├── ecc-jsbn@0.1.1 
  │ │ │   ├── getpass@0.1.7 
  │ │ │   ├── jsbn@0.1.1 
  │ │ │   └── tweetnacl@0.14.5 
  │ │ ├── is-typedarray@1.0.0 
  │ │ ├── isstream@0.1.2 
  │ │ ├── json-stringify-safe@5.0.1 
  │ │ ├─┬ mime-types@2.1.17 
  │ │ │ └── mime-db@1.30.0 
  │ │ ├── oauth-sign@0.8.2 
  │ │ ├── performance-now@2.1.0 
  │ │ ├── qs@6.5.1 
  │ │ ├── safe-buffer@5.1.1 
  │ │ ├── stringstream@0.0.5 
  │ │ ├── tunnel-agent@0.6.0 
  │ │ └── uuid@3.1.0 
  │ ├─┬ request-promise-native@1.0.4 
  │ │ ├─┬ request-promise-core@1.1.1 
  │ │ │ └── lodash@4.17.4 
  │ │ └── stealthy-require@1.1.1 
  │ ├── sax@1.2.4 
  │ ├── symbol-tree@3.2.2 
  │ ├─┬ tough-cookie@2.3.3 
  │ │ └── punycode@1.4.1 
  │ ├── webidl-conversions@4.0.2 
  │ ├─┬ whatwg-encoding@1.0.1 
  │ │ └── iconv-lite@0.4.13 
  │ ├─┬ whatwg-url@6.2.1 
  │ │ ├── lodash.sortby@4.7.0 
  │ │ └─┬ tr46@1.0.1 
  │ │   └── punycode@2.1.0 
  │ └── xml-name-validator@2.0.1 
  └── opts@1.2.6 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/html5-papandreou/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 61% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","toUpperCase","RegExp"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.1227 took 20.7048s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (3:4) on program require('../core-upgrade');
var HTML5 = require('../html5');
var assert = require('assert');

var b = HTML5.TreeBuilder = function TreeBuilder(document) {
	this.document = document;
	this.reset();
}

b.prototype.reset = function() {
	this.open_elements = [];
	this.activeFormattingElements = [];
}

// from http://www.w3.org/TR/2011/WD-html5-20110405/namespaces.html
var NAMESPACE_URI = {
	html: "http://www.w3.org/1999/xhtml",
	math: "http://www.w3.org/1998/Math/MathML",
	svg: "http://www.w3.org/2000/svg",
	xlink: "http://www.w3.org/1999/xlink",
	xml: "http://www.w3.org/XML/1998/namespace",
	xmlns: "http://www.w3.org/2000/xmlns/"
}

b.prototype.copyAttributeToElement = function(element, attribute) {
	if(attribute.nodeType && attribute.nodeType == attribute.ATTRIBUTE_NODE) {
		element.setAttributeNode(attribute.cloneNode());
		if(attribute.namespace) {
			var at = element.getAttributeNode(attribute.nodeName);
			at.namespace = attribute.namespace;
		}
	} else {
		var name, value, namespace;
		try {
			if (attribute.nodeName) {
				name = attribute.nodeName;
				value = attribute.nodeValue;
				if (attribute.namespace) {
					name = attribute.namespace + ":" + name;
					namespace = NAMESPACE_URI[ attribute.namespace ];
				}
			} else {
				name = attribute.name;
				value = attribute.value;
				namespace = attribute.namespaceURI;
			}
			if (namespace) {
				element.setAttributeNS(namespace, name, value);
			} else {
				element.setAttribute(name, value);
			}
		} catch(e) {
			HTML5.debug("Can't set attribute '" + name + "' to value '" + value + "': (" + e + ')', e.stack);
		}
	}
}

b.prototype.createElement = function (name, attributes, namespace) {
	var el;
    try {
        if ( this.document._elementBuilders && this.document._defaultElementBuilder ) {
          el = (this.document._elementBuilders[name.toLowerCase()] || this.document._defaultElementBuilder)(this.document, name);
          el._created = true;
        } else {
          el = this.document.createElement( name );
        }
    } catch(e) {
        console.log("Can't create element '"+ name + "' (" + e + ") Using a div for now. FIXME!")
		el = this.document.createElement('div');
    }
    el.namespace = namespace;
    if(attributes) {
        if(attributes.item) {
            for(var i = 0; i < attributes.length; i++) {
HTML5.debug('treebuilder.copyAttributes', attributes.item(i));
                this.copyAttributeToElement(el, attributes.item(i));
            }
        } else {
            for(var i = 0; i < attributes.length; i++) {
HTML5.debug('treebuilder.copyAttributes', attributes[i]);
                this.copyAttributeToElement(el, attributes[i]);
            }
        }
    }
    return el;
}

b.prototype.insert_root = function(name, attributes, namespace) {
	var root = this.document.documentElement;
	if (root) {
		if (root.tagName != 'HTML')
			HTML5.debug('parser.before_html_phase', 'Non-HTML root element!');
		while (root.childNodes.length >= 1)
			root.removeChild(root.firstChild);
	} else {
		root = this.createElement(name, attributes, namespace);
		this.document.appendChild(root);
	}
	this.root_pointer = root;
	this.open_elements.push(root);
}

b.prototype.insert_element = function(name, attributes, namespace) {
	HTML5.debug('treebuilder.insert_element', name)
	if(this.insert_from_table) {
		return this.insert_element_from_table(name, attributes, namespace)
	} else {
		return this.insert_element_normal(name, attributes, namespace)
	}
}

b.prototype.insert_foreign_element = function(name, attributes, namespace) {
	return this.insert_element(name, attributes, namespace);
}

b.prototype.insert_element_normal = function(name, attributes, namespace) {
	var element = this.createElement(name, attributes, namespace);
	this.open_elements.last().appendChild(element);
	this.open_elements.push(element);
	return element;
}

b.prototype.insert_element_from_table = function(name, attributes, namespace) {
	var element = this.createElement(name, attributes, namespace)
	if(HTML5.TABLE_INSERT_MODE_ELEMENTS.indexOf(this.open_elements.last().tagName.toLowerCase()) != -1) {
		// We should be in the InTable mode. This means we want to do
		// special magic element rearranging 
		var t = this.getTableMisnestedNodePosition()
		if(!t.insertBefore) {
			t.parent.appendChild(element)
		} else {
			t.parent.insertBefore(element, t.insertBefore)
		}
		this.open_elements.push(element)
	} else {
		return this.insert_element_normal(name, attributes, namespace);
	}
	return element;
}

b.prototype.insert_comment = function(data, parent) {
    try {
        var c = this.document.createComment(data);
        if(!parent) parent = this.open_elements.last();
        parent.appendChild(c);
    } catch(e) {
        console.log("Can't create comment ("+ data + ")")
    }
}

b.prototype.insert_doctype = function (name, publicId, systemId) {
    try {
        var doctype = this.document.implementation.createDocumentType(name, publicId, systemId);
        this.document.appendChild(doctype);
    } catch(e) {
        console.log("Can't create doctype ("+ name + " / " + publicId + " / " + systemId + ")")
    }
}
	

b.prototype.insert_text = function(data, parent) {
	if(!parent) parent = this.open_elements.last();
	HTML5.debug('treebuilder.insert_text', data);
	if(!this.insert_from_table || HTML5.TABLE_INSERT_MODE_ELEMENTS.indexOf(this.open_elements.last().tagName.toLowerCase()) == -1) {
		if(parent.lastChild && parent.lastChild.nodeType == parent.TEXT_NODE) {
			parent.lastChild.appendData(data);
		} else {
            try {
                var tn = this.document.createTextNode(data);
                parent.appendChild(tn);
            } catch(e) {
                console.log("Can't create text node (" + data + ")");
            }
		}
	} else {
		// We should be in the inTable phase. This means we want to do special
		// magic element rearranging.
		var t = this.getTableMisnestedNodePosition();
		insertText(t.parent, data, t.insertBefore)
	}
}
	
b.prototype.remove_open_elements_until = function(nameOrCb) {
	HTML5.debug('treebuilder.remove_open_elements_until', nameOrCb)
	var finished = false;
	while(!finished) {
		var element = this.pop_element();
		finished = (typeof nameOrCb == 'function' ? nameOrCb(element) : element.tagName.toLowerCase() == nameOrCb);
	}
	return element;
}

b.prototype.pop_element = function() {
	var el = this.open_elements.pop()
	HTML5.debug('treebuilder.pop_element', el.tagName)
	return el
}

function insertText(node, data, before) {
	var t = node.ownerDocument.createTextNode(data)
	if(before) {
		if(before.previousSibling && before.previousSibling.nodeType == before.previousSibling.TEXT_NODE) {
			before.previousSibling.nodeValue += data;
		} else {
			node.insertBefore(t, before)
		}
	} else {
		node.appendChild(t)
	}
}

b.prototype.getTableMisnestedNodePosition = function() {
	// The foster parent element is the one which comes before the most
	// recently opened table element
	// XXX - this is really inelegant
	var lastTable, fosterParent, insertBefore
	
	for(var i = this.open_elements.length - 1; i >= 0; i--) {
		var element = this.open_elements[i]
		if(element.tagName.toLowerCase() == 'table') {
			lastTable = element
			break
		}
	}

	if(lastTable) {
		// XXX - we should check that the parent really is a node here
		if(lastTable.parentNode) {
			fosterParent = lastTable.parentNode
			insertBefore = lastTable
		} else {
			fosterParent = this.open_elements[this.open_elements.indexOf(lastTable) - 1]
		}
	} else {
		fosterParent = this.open_elements[0]
	}
	
	return {parent: fosterParent, insertBefore: insertBefore}
}

b.prototype.generateImpliedEndTags = function(exclude) {
	if(exclude) exclude = exclude.toLowerCase()
	if(this.open_elements.length == 0) {
		HTML5.debug('treebuilder.generateImpliedEndTags', 'no open elements')
		return
	}
	var name = this.open_elements.last().tagName.toLowerCase();
	if(['dd', 'dt', 'li', 'p', 'td', 'th', 'tr'].indexOf(name) != -1 && name != exclude) {
		var p  = this.pop_element();
		this.generateImpliedEndTags(exclude);
	}
}

b.prototype.reconstructActiveFormattingElements = function() {
	// Within this algorithm the order of steps decribed in the specification
	// is not quite the same as the order of steps in the code. It should still
	// do the same though.

	// Step 1: stop if there's nothing to do
	if(this.activeFormattingElements.length == 0) return;

	// Step 2 and 3: start with the last element
	var i = this.activeFormattingElements.length - 1;
	var entry = this.activeFormattingElements[i];
	if(entry == HTML5.Marker || this.open_elements.indexOf(entry) != -1) return;

	while(entry != HTML5.Marker && this.open_elements.indexOf(entry) == -1) {
		i -= 1;
		entry = this.activeFormattingElements[i];
		if(!entry) break;
	}

	while(true) {
		i += 1;
		var clone = this.activeFormattingElements[i].cloneNode();

		var element = this.insert_element(clone.tagName, clone.attributes);

		this.activeFormattingElements[i] = element;

		if(element == this.activeFormattingElements.last()) break;
	}

}

b.prototype.elementInActiveFormattingElements = function(name) {
	var els = this.activeFormattingElements;
	for(var i = els.length - 1; i >= 0; i--) {
		if(els[i] == HTML5.Marker) break;
		if(els[i].tagName.toLowerCase() == name) return els[i];
	}
	return false;
}

b.prototype.reparentChildren = function(o, n) {
	while(o.childNodes.length > 0) {
		var el = o.removeChild(o.childNodes[0]);
		n.appendChild(el);
	}
}

b.prototype.clearActiveFormattingElements = function() {
	while(!(this.activeFormattingElements.length == 0 || this.activeFormattingElements.pop() == HTML5.Marker));
}

b.prototype.getFragment = function() {
	// assert.ok(this.parser.inner_html)
	var fragment = this.document.createDocumentFragment()
	this.reparentChildren(this.root_pointer, fragment)
	return fragment
}
 at SyntaxError: Unexpected token (3:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/html5-papandreou/node_modules/html5-papandreou/lib/html5/index.js. Coverage (Term): 63% Coverage (LOC): 73%
*- File /root/Targets/html5-papandreou/node_modules/html5-papandreou/lib/html5/constants.js. Coverage (Term): 99% Coverage (LOC): 100%
*- File /root/Targets/html5-papandreou/node_modules/html5-entities/index.js. Coverage (Term): 100% Coverage (LOC): 100%
*- File /root/Targets/html5-papandreou/node_modules/html5-papandreou/lib/html5/tokenizer.js. Coverage (Term): 1% Coverage (LOC): 1%
*- File /root/Targets/html5-papandreou/node_modules/html5-papandreou/lib/core-upgrade.js. Coverage (Term): 68% Coverage (LOC): 86%
*- File /root/Targets/html5-papandreou/node_modules/html5-papandreou/lib/html5/buffer.js. Coverage (Term): 8% Coverage (LOC): 22%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
