/root/Targets/dmn-elex-race-tracker
└─┬ dmn-elex-race-tracker@1.2.9 
  ├─┬ d3@4.10.2 
  │ ├── d3-array@1.2.0 
  │ ├── d3-axis@1.0.8 
  │ ├── d3-brush@1.0.4 
  │ ├── d3-chord@1.0.4 
  │ ├── d3-collection@1.0.4 
  │ ├── d3-color@1.0.3 
  │ ├── d3-dispatch@1.0.3 
  │ ├── d3-drag@1.1.1 
  │ ├─┬ d3-dsv@1.0.7 
  │ │ ├── commander@2.11.0 
  │ │ ├── iconv-lite@0.4.19 
  │ │ └── rw@1.3.3 
  │ ├── d3-ease@1.0.3 
  │ ├── d3-force@1.0.6 
  │ ├── d3-format@1.2.0 
  │ ├── d3-geo@1.6.4 
  │ ├── d3-hierarchy@1.1.5 
  │ ├── d3-interpolate@1.1.5 
  │ ├── d3-path@1.0.5 
  │ ├── d3-polygon@1.0.3 
  │ ├── d3-quadtree@1.0.3 
  │ ├── d3-queue@3.0.7 
  │ ├── d3-random@1.1.0 
  │ ├─┬ d3-request@1.0.6 
  │ │ └── xmlhttprequest@1.8.0 
  │ ├── d3-scale@1.0.6 
  │ ├── d3-selection@1.1.0 
  │ ├── d3-shape@1.2.0 
  │ ├── d3-time@1.0.7 
  │ ├── d3-time-format@2.0.5 
  │ ├── d3-timer@1.0.7 
  │ ├── d3-transition@1.1.0 
  │ ├── d3-voronoi@1.1.2 
  │ └── d3-zoom@1.5.0 
  ├── jquery@3.2.1 
  └── lodash@4.17.4 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/dmn-elex-race-tracker/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0696 took 4.8807s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (220:8) on program import * as d3 from "d3";
import _ from 'lodash';
import $ from 'jquery';

d3.selection.prototype.moveToBack = function() {
    return this.each(function() {
        var firstChild = this.parentNode.firstChild;
        if (firstChild) {
            this.parentNode.insertBefore(this, firstChild);
        }
    });
};

// this function turns integers less than 10 into actual words, because we work
// in journalism, and journalism has rules, damn it --Mayo
function spellNumber(x) {
    var numbers = ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"];
    if (x < 10) {
        return numbers[x];
    } else {
        return x;
    }
}

// This is the chart function that will be exported
export default () => ({

  // Develop the reusable function for you chart in this init function.
  // cf. https://bost.ocks.org/mike/chart/
  init: function() {

    const uncertainty = this._uncertaintyData;


    // Inner chart function
    function chart(selection){
      selection.each(function(rawData){

        // CHART DIMENSIONS
        const margins = {
          top: 20,
          right: 20,
          left: 37,
          bottom: 30
        };
        const bbox = this.getBoundingClientRect();
        const width = bbox.width;
        const height = bbox.height;
        const textLineHeight = 20;
        const innerWidth = width - margins.right - margins.left;
        const innerHeight = height - margins.top - margins.bottom - textLineHeight;

        const t = d3.transition()
            .duration(750)
            .ease(d3.easeLinear);
        const delay = d3.transition()
            .delay(1000)
            .duration(0);

        // CHART AXES
        const xScale = d3.scaleLinear()
            .domain([0, 1])
            .range([0, innerWidth]);
        const xAxis = d3.axisBottom(xScale)
            .tickFormat(d3.format(".0%"))
            .tickValues([.05,.25,.5,.75,1])
            .tickSize(-innerHeight)
            .tickPadding(5);

        const yScale = d3.scaleLinear()
            .domain([.3, -.3])
            .range([0, innerHeight]);
        const yAxis = d3.axisLeft(yScale)
            .tickFormat((d) => d===0 ? '0' : `+${(Math.round(Math.abs(d * 100)))}`)
            .ticks(5)
            .tickSize(-innerWidth)
            .tickPadding(5);


        // STATIC ELEMENTS IN CHART
        const static_furniture = () => {

          d3.select(this).append("p");

          const g = d3.select(this).append("svg")
              .attr("width", width)
              .attr("height", height)
              .style("display", "block")
              .style("margin", "auto")
            .append("g")
              .attr("transform","translate(" + margins.left + "," + margins.top + ")");

          g.append("g")
            .attr("class", "x axis")
            .attr("transform","translate(0," + (innerHeight) +")");

          const yAxisG = g.append("g")
            .attr("class", "y axis");

          yAxisG.append("text")
            .attr("class", "party rep")
            .attr("x", -25)
            .attr("y", 4)
            .text("R");
          yAxisG.append("text")
            .attr("class", "party dem")
            .attr("x", -25)
            .attr("y", innerHeight + 5)
            .text("D");

          yAxisG.append("text")
            .attr("class", "key")
            .attr("x", 14)
            .attr("y", -8)
            .text("Points");
          yAxisG.append("text")
            .attr("class", "key precincts-reporting")
            .attr("x", innerWidth + 15)
            .attr("y", innerHeight + 27)
            .text("Precincts reporting");


          yAxisG.append("rect")
            .attr("class", "key")
            .attr("x", innerWidth - 68)
            .attr("y", -15)
            .attr("width", 10)
            .attr("height", 10);
          yAxisG.append("text")
            .attr("class", "key")
            .attr("x", innerWidth )
            .attr("y", -6)
            .text("Likely error");

          g.append("line")
            .attr("class", "center-line");
        }

        const callIt = (percent, rep) => {
          const rect = d3.select(this).select('svg').select('g')
          .append("rect");

          rect
            .transition(delay)
            .attr("class", 'called')
            .attr("x", xScale(percent))
            .attr("width", 2)
            .attr("y", 0)
            .attr("height", innerHeight);

          rect.moveToBack();

          d3.select(this).select('svg').select('g')
            .append("text")
            .transition(delay)
            .attr("x", () => percent > .25 ? xScale(percent) - 45 : xScale(percent) + 5)
            .attr("y", 13)
            .attr("class", () => rep ? "called rep" : "called dem")
            .text("Called");
        }


        if (d3.select(this).select('svg').select('g').size() === 0) {
          static_furniture();
        }

        const svg = d3.select(this).select('svg').select('g');
        const xAxisG = d3.select(this).select('.x.axis');
        const yAxisG = d3.select(this).select('.y.axis');
        const p = d3.select(this).select('p');

        svg.select(".center-line")
        .attr("x1", xScale(0))
        .attr("x2", xScale(1))
        .attr("y1", yScale(0))
        .attr("y2", yScale(0));


        let data = _.filter(rawData, d => d.total > 0 || d.precintReportingPct > 0)
          .map((d) => {
            const margin = (d.rep/(d.total)) - (d.dem/(d.total));
            const u = Math.round(d.precintReportingPct * 100).toString();
            const unc = d.precintReportingPct === 1 ? 0 : uncertainty[u];
            return {
              x: d.precintReportingPct,
              y: margin,
              y0: margin - unc,
              y1: margin + unc,
              called: d.called
            }
          });

        data.push({
          x: 0,
          y: _.minBy(data, 'x').y,
          y0: _.minBy(data, 'x').y - uncertainty['1'],
          y1: _.minBy(data, 'x').y + uncertainty['1']
        });

        data = _.orderBy(data, 'x')

        data.forEach((d) => {
          if (d.called && !this._called){
            this._percentCalled = d.x;
            callIt(d.x, (d.y > 0));
            this._called = true;
          } else {
            d3.select(this).select('svg').select('rect.called')
            .attr("x", xScale(this._percentCalled))
            .attr("height", innerHeight);

            d3.select(this).select('svg').select('text.called')
            .attr("x", () => this._percentCalled > .25 ? xScale(this._percentCalled) - 45 : xScale(this._percentCalled) + 5);
          }
        });

        const maxPoint = Math.max(
          Math.abs(_.minBy(data, 'y0').y0),
          Math.abs(_.maxBy(data, 'y1').y1),
        );

        const latest = _.maxBy(data,'x');

        yScale.domain([
          maxPoint, -maxPoint
        ]).nice();

        yAxisG.transition(t).call(yAxis);
        xAxisG.call(xAxis);

        p.text(() => {
          const y = _.maxBy(data, 'x').y;
          let verb = this._called ? 'beat' : 'leads';
          let text;
          if (y > 0) {
            text = `Trump ${verb} Clinton by ${spellNumber(Math.round(y * 100))} points.`;
          } else if (y < 0){
            text = `Clinton ${verb} Trump by ${spellNumber(Math.round(Math.abs(y * 100)))} points.`;
          } else {
            text = `Clinton and Trump are tied!`;
          }
          return text;
        });

        const line = d3.line()
          .x((d) => xScale(d.x))
          .y((d) => yScale(d.y))
          .curve(d3.curveCardinal);
        const area = d3.area()
          .x((d) => xScale(d.x))
          .y0((d) => yScale(d.y0))
          .y1((d) => yScale(d.y1))
          .curve(d3.curveCardinal);


        const errorArea = svg.selectAll("path.uncertainty")
          .data([data]);

        errorArea.enter().append("path")
          .attr("class", "uncertainty")
        .merge(errorArea)
          .transition(delay)
          .attr("d", area);

        const voteLine = svg.selectAll("path.line")
          .data([data]);


        voteLine.enter().append("path")
          .attr("class", "line")
        .merge(voteLine)
          .attr("d", line)
          .attr("stroke-dasharray", function(){
            return `${this.getTotalLength()} ${this.getTotalLength()}`;
          })
          .attr("stroke-dashoffset", function(){
            return `${this.getTotalLength()}`;
          })
          .transition(t)
            .style("stroke", () => latest.y > 0 ? "#E34E36" : "#4895D0")
            .attr("stroke-dashoffset", 0);

        // Placeholder allows for smooth animation between updates
        const placeholder = svg.selectAll("path.placeholder")
          .data([data]);

        placeholder.enter().append("path")
            .attr("class", "placeholder")
            .style("stroke", () => latest.y > 0 ? "#E34E36" : "#4895D0")
          .merge(placeholder)
            .transition(delay)
            .attr("d", line);
        placeholder.transition(t)
          .style("stroke", () => latest.y > 0 ? "#E34E36" : "#4895D0");

        const latest_data = _.maxBy(data, 'x');

        const circle = svg.selectAll("circle.points")
          .data([latest_data]);

        circle.enter().append("circle")
          .attr("class", "points")
          .attr("r", 4)
        .merge(circle)
          .style("opacity", 0)
          .attr("cx", (d) => xScale(d.x))
          .attr("cy", (d) => yScale(d.y))
          .transition(delay)
          .style("stroke", () => latest.y > 0 ? "#E34E36" : "#4895D0")
          .style("opacity", 1);

        const tip = svg.selectAll("text.tip")
          .data([latest_data]);

        tip.enter().append("text")

        .merge(tip)
          .attr("class", (d) => d.y > 0 ? "tip rep" : "tip dem")
          .style("opacity", 0)
          .attr("x", (d) => xScale(d.x) - 7)
          .attr("y", (d) => {
            return yScale(d.y) > 25 ? yScale(d.y) - 10 : yScale(d.y) + 17;
          })
          .text((d) => `+${Math.round(Math.abs(d.y) * 100)}`)
          .transition(delay)
          .style("opacity", 1);


      });
    }

    return chart;
  },


  // This function actually draws the chart using the
  // reusable init function.
  draw: function(){
    var chart = this.init();

    d3.select(this._selection)
      .datum(this._data)
      .call(chart);
  },

  // Call this function to initially create the chart.
  create: function(selection, data){
    this._selection = selection;
    this._data = data;
    // Initial state of race...
    this._called = true;

    $.getJSON("http://elections.dallasnews.com.s3-website-us-east-1.amazonaws.com/data/monte_carlo_error/state_precinct_estimates.json",
    (data) => {
      this._uncertaintyData = data;
      this.draw();
    })


  },

  // This updates the data and elements.
  update: function(data){
    this._data = data;
    this.draw();
  },

  redraw: function(){
    this.draw();
  },
});
 at SyntaxError: Unexpected token (220:8)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$3.parseExprAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1822:12)
    at Parser.parseExprAtom (/root/ExpoSE/lib/Tropigate/bin/Expression.js:28:30)
    at Parser.pp$3.parseExprSubscripts (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1715:21)
    at Parser.parseMaybeUnary (/root/ExpoSE/lib/Tropigate/bin/Unary.js:34:29)
    at Parser.pp$3.parseExprOps (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1637:21)
    at Parser.pp$3.parseMaybeConditional (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1620:21)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1597:21)
    at Parser.pp$3.parseExprList (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2165:22)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
