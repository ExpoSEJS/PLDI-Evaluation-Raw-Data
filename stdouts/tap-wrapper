/root/Targets/tap-wrapper
└─┬ tap-wrapper@0.0.2 
  ├─┬ abstract-factory@0.2.0 
  │ └── custom-errors@1.5.1 
  ├── curry@0.0.4 
  ├── custom-errors@1.4.1 
  ├─┬ tap@10.7.2 
  │ ├── bind-obj-methods@1.0.0 
  │ ├── bluebird@3.5.0 
  │ ├── clean-yaml-object@0.1.0 
  │ ├── color-support@1.1.3 
  │ ├─┬ coveralls@2.13.2 
  │ │ ├── lcov-parse@0.0.10 
  │ │ ├── log-driver@1.2.5 
  │ │ ├── minimist@1.2.0 
  │ │ └─┬ request@2.83.0 
  │ │   ├── aws-sign2@0.7.0 
  │ │   ├── aws4@1.6.0 
  │ │   ├── caseless@0.12.0 
  │ │   ├─┬ combined-stream@1.0.5 
  │ │   │ └── delayed-stream@1.0.0 
  │ │   ├── extend@3.0.1 
  │ │   ├── forever-agent@0.6.1 
  │ │   ├─┬ form-data@2.3.1 
  │ │   │ └── asynckit@0.4.0 
  │ │   ├─┬ har-validator@5.0.3 
  │ │   │ ├─┬ ajv@5.2.3 
  │ │   │ │ ├── co@4.6.0 
  │ │   │ │ ├── fast-deep-equal@1.0.0 
  │ │   │ │ ├── json-schema-traverse@0.3.1 
  │ │   │ │ └─┬ json-stable-stringify@1.0.1 
  │ │   │ │   └── jsonify@0.0.0 
  │ │   │ └── har-schema@2.0.0 
  │ │   ├─┬ hawk@6.0.2 
  │ │   │ ├── boom@4.3.1 
  │ │   │ ├─┬ cryptiles@3.1.2 
  │ │   │ │ └── boom@5.2.0 
  │ │   │ ├── hoek@4.2.0 
  │ │   │ └── sntp@2.0.2 
  │ │   ├─┬ http-signature@1.2.0 
  │ │   │ ├── assert-plus@1.0.0 
  │ │   │ ├─┬ jsprim@1.4.1 
  │ │   │ │ ├── extsprintf@1.3.0 
  │ │   │ │ ├── json-schema@0.2.3 
  │ │   │ │ └── verror@1.10.0 
  │ │   │ └─┬ sshpk@1.13.1 
  │ │   │   ├── asn1@0.2.3 
  │ │   │   ├── bcrypt-pbkdf@1.0.1 
  │ │   │   ├── dashdash@1.14.1 
  │ │   │   ├── ecc-jsbn@0.1.1 
  │ │   │   ├── getpass@0.1.7 
  │ │   │   ├── jsbn@0.1.1 
  │ │   │   └── tweetnacl@0.14.5 
  │ │   ├── is-typedarray@1.0.0 
  │ │   ├── isstream@0.1.2 
  │ │   ├── json-stringify-safe@5.0.1 
  │ │   ├─┬ mime-types@2.1.17 
  │ │   │ └── mime-db@1.30.0 
  │ │   ├── oauth-sign@0.8.2 
  │ │   ├── performance-now@2.1.0 
  │ │   ├── qs@6.5.1 
  │ │   ├── stringstream@0.0.5 
  │ │   ├── tough-cookie@2.3.3 
  │ │   ├── tunnel-agent@0.6.0 
  │ │   └── uuid@3.1.0 
  │ ├─┬ foreground-child@1.5.6 
  │ │ └─┬ cross-spawn@4.0.2 
  │ │   ├─┬ lru-cache@4.1.1 
  │ │   │ ├── pseudomap@1.0.2 
  │ │   │ └── yallist@2.1.2 
  │ │   └── which@1.3.0 
  │ ├── fs-exists-cached@1.0.0 
  │ ├── function-loop@1.0.1 
  │ ├─┬ glob@7.1.2 
  │ │ ├── fs.realpath@1.0.0 
  │ │ ├─┬ inflight@1.0.6 
  │ │ │ └── wrappy@1.0.2 
  │ │ ├── inherits@2.0.3 
  │ │ ├─┬ minimatch@3.0.4 
  │ │ │ └─┬ brace-expansion@1.1.8 
  │ │ │   ├── balanced-match@1.0.0 
  │ │ │   └── concat-map@0.0.1 
  │ │ ├── once@1.4.0 
  │ │ └── path-is-absolute@1.0.1 
  │ ├── isexe@2.0.0 
  │ ├─┬ js-yaml@3.10.0 
  │ │ ├─┬ argparse@1.0.9 
  │ │ │ └── sprintf-js@1.0.3 
  │ │ └── esprima@4.0.0 
  │ ├─┬ nyc@11.2.1 
  │ │ ├── archy@1.0.0 
  │ │ ├── arrify@1.0.1 
  │ │ ├─┬ caching-transform@1.0.1 
  │ │ │ └─┬ write-file-atomic@1.3.4 
  │ │ │   ├── graceful-fs@4.1.11 
  │ │ │   ├── imurmurhash@0.1.4 
  │ │ │   └── slide@1.1.6 
  │ │ ├── convert-source-map@1.5.0 
  │ │ ├── debug-log@1.0.1 
  │ │ ├─┬ default-require-extensions@1.0.0 
  │ │ │ └─┬ strip-bom@2.0.0 
  │ │ │   └── is-utf8@0.2.1 
  │ │ ├─┬ find-cache-dir@0.1.1 
  │ │ │ ├── commondir@1.0.1 
  │ │ │ └─┬ pkg-dir@1.0.0 
  │ │ │   └─┬ find-up@1.1.2 
  │ │ │     ├── path-exists@2.1.0 
  │ │ │     └─┬ pinkie-promise@2.0.1 
  │ │ │       └── pinkie@2.0.4 
  │ │ ├─┬ find-up@2.1.0 
  │ │ │ └─┬ locate-path@2.0.0 
  │ │ │   ├─┬ p-locate@2.0.0 
  │ │ │   │ └── p-limit@1.1.0 
  │ │ │   └── path-exists@3.0.0 
  │ │ ├─┬ foreground-child@1.5.6 
  │ │ │ └─┬ cross-spawn@4.0.2 
  │ │ │   └─┬ lru-cache@4.1.1 
  │ │ │     ├── pseudomap@1.0.2 
  │ │ │     └── yallist@2.1.2 
  │ │ ├─┬ glob@7.1.2 
  │ │ │ ├── fs.realpath@1.0.0 
  │ │ │ ├─┬ inflight@1.0.6 
  │ │ │ │ └── wrappy@1.0.2 
  │ │ │ ├── inherits@2.0.3 
  │ │ │ ├─┬ minimatch@3.0.4 
  │ │ │ │ └─┬ brace-expansion@1.1.8 
  │ │ │ │   ├── balanced-match@1.0.0 
  │ │ │ │   └── concat-map@0.0.1 
  │ │ │ ├── once@1.4.0 
  │ │ │ └── path-is-absolute@1.0.1 
  │ │ ├── istanbul-lib-coverage@1.1.1 
  │ │ ├─┬ istanbul-lib-hook@1.0.7 
  │ │ │ └── append-transform@0.4.0 
  │ │ ├─┬ istanbul-lib-instrument@1.8.0 
  │ │ │ ├─┬ babel-generator@6.26.0 
  │ │ │ │ ├── babel-messages@6.23.0 
  │ │ │ │ ├─┬ babel-runtime@6.26.0 
  │ │ │ │ │ ├── core-js@2.5.1 
  │ │ │ │ │ └── regenerator-runtime@0.11.0 
  │ │ │ │ ├─┬ detect-indent@4.0.0 
  │ │ │ │ │ └─┬ repeating@2.0.1 
  │ │ │ │ │   └── is-finite@1.0.2 
  │ │ │ │ ├── jsesc@1.3.0 
  │ │ │ │ ├── lodash@4.17.4 
  │ │ │ │ └── trim-right@1.0.1 
  │ │ │ ├── babel-template@6.26.0 
  │ │ │ ├─┬ babel-traverse@6.26.0 
  │ │ │ │ ├─┬ babel-code-frame@6.26.0 
  │ │ │ │ │ ├─┬ chalk@1.1.3 
  │ │ │ │ │ │ ├── ansi-styles@2.2.1 
  │ │ │ │ │ │ ├── escape-string-regexp@1.0.5 
  │ │ │ │ │ │ ├── has-ansi@2.0.0 
  │ │ │ │ │ │ └── supports-color@2.0.0 
  │ │ │ │ │ └── js-tokens@3.0.2 
  │ │ │ │ ├── globals@9.18.0 
  │ │ │ │ └─┬ invariant@2.2.2 
  │ │ │ │   └── loose-envify@1.3.1 
  │ │ │ ├─┬ babel-types@6.26.0 
  │ │ │ │ ├── esutils@2.0.2 
  │ │ │ │ └── to-fast-properties@1.0.3 
  │ │ │ ├── babylon@6.18.0 
  │ │ │ └── semver@5.4.1 
  │ │ ├─┬ istanbul-lib-report@1.1.1 
  │ │ │ ├── path-parse@1.0.5 
  │ │ │ └─┬ supports-color@3.2.3 
  │ │ │   └── has-flag@1.0.0 
  │ │ ├─┬ istanbul-lib-source-maps@1.2.1 
  │ │ │ ├─┬ debug@2.6.8 
  │ │ │ │ └── ms@2.0.0 
  │ │ │ └── source-map@0.5.7 
  │ │ ├─┬ istanbul-reports@1.1.2 
  │ │ │ └─┬ handlebars@4.0.10 
  │ │ │   ├── async@1.5.2 
  │ │ │   ├─┬ optimist@0.6.1 
  │ │ │   │ └── wordwrap@0.0.3 
  │ │ │   ├─┬ source-map@0.4.4 
  │ │ │   │ └── amdefine@1.0.1 
  │ │ │   └─┬ uglify-js@2.8.29 
  │ │ │     ├── uglify-to-browserify@1.0.2 
  │ │ │     └─┬ yargs@3.10.0 
  │ │ │       ├── camelcase@1.2.1 
  │ │ │       ├─┬ cliui@2.1.0 
  │ │ │       │ ├─┬ center-align@0.1.3 
  │ │ │       │ │ ├─┬ align-text@0.1.4 
  │ │ │       │ │ │ └── longest@1.0.1 
  │ │ │       │ │ └── lazy-cache@1.0.4 
  │ │ │       │ ├── right-align@0.1.3 
  │ │ │       │ └── wordwrap@0.0.2 
  │ │ │       └── window-size@0.1.0 
  │ │ ├─┬ md5-hex@1.3.0 
  │ │ │ └── md5-o-matic@0.1.1 
  │ │ ├── merge-source-map@1.0.4 
  │ │ ├─┬ micromatch@2.3.11 
  │ │ │ ├─┬ arr-diff@2.0.0 
  │ │ │ │ └── arr-flatten@1.1.0 
  │ │ │ ├── array-unique@0.2.1 
  │ │ │ ├─┬ braces@1.8.5 
  │ │ │ │ ├─┬ expand-range@1.8.2 
  │ │ │ │ │ └─┬ fill-range@2.2.3 
  │ │ │ │ │   ├── is-number@2.1.0 
  │ │ │ │ │   ├─┬ isobject@2.1.0 
  │ │ │ │ │   │ └── isarray@1.0.0 
  │ │ │ │ │   ├─┬ randomatic@1.1.7 
  │ │ │ │ │   │ ├─┬ is-number@3.0.0 
  │ │ │ │ │   │ │ └── kind-of@3.2.2 
  │ │ │ │ │   │ └── kind-of@4.0.0 
  │ │ │ │ │   └── repeat-string@1.6.1 
  │ │ │ │ ├── preserve@0.2.0 
  │ │ │ │ └── repeat-element@1.1.2 
  │ │ │ ├─┬ expand-brackets@0.1.5 
  │ │ │ │ └── is-posix-bracket@0.1.1 
  │ │ │ ├── extglob@0.3.2 
  │ │ │ ├── filename-regex@2.0.1 
  │ │ │ ├── is-extglob@1.0.0 
  │ │ │ ├── is-glob@2.0.1 
  │ │ │ ├─┬ kind-of@3.2.2 
  │ │ │ │ └── is-buffer@1.1.5 
  │ │ │ ├─┬ normalize-path@2.1.1 
  │ │ │ │ └── remove-trailing-separator@1.1.0 
  │ │ │ ├─┬ object.omit@2.0.1 
  │ │ │ │ ├─┬ for-own@0.1.5 
  │ │ │ │ │ └── for-in@1.0.2 
  │ │ │ │ └── is-extendable@0.1.1 
  │ │ │ ├─┬ parse-glob@3.0.4 
  │ │ │ │ ├─┬ glob-base@0.3.0 
  │ │ │ │ │ └── glob-parent@2.0.0 
  │ │ │ │ └── is-dotfile@1.0.3 
  │ │ │ └─┬ regex-cache@0.4.4 
  │ │ │   └─┬ is-equal-shallow@0.1.3 
  │ │ │     └── is-primitive@2.0.0 
  │ │ ├─┬ mkdirp@0.5.1 
  │ │ │ └── minimist@0.0.8 
  │ │ ├── resolve-from@2.0.0 
  │ │ ├── rimraf@2.6.1 
  │ │ ├── signal-exit@3.0.2 
  │ │ ├─┬ spawn-wrap@1.3.8 
  │ │ │ ├── os-homedir@1.0.2 
  │ │ │ └─┬ which@1.3.0 
  │ │ │   └── isexe@2.0.0 
  │ │ ├─┬ test-exclude@4.1.1 
  │ │ │ ├── object-assign@4.1.1 
  │ │ │ ├─┬ read-pkg-up@1.0.1 
  │ │ │ │ ├── find-up@1.1.2 
  │ │ │ │ └─┬ read-pkg@1.1.0 
  │ │ │ │   ├─┬ load-json-file@1.1.0 
  │ │ │ │   │ ├─┬ parse-json@2.2.0 
  │ │ │ │   │ │ └─┬ error-ex@1.3.1 
  │ │ │ │   │ │   └── is-arrayish@0.2.1 
  │ │ │ │   │ └── pify@2.3.0 
  │ │ │ │   ├─┬ normalize-package-data@2.4.0 
  │ │ │ │   │ ├── hosted-git-info@2.5.0 
  │ │ │ │   │ ├─┬ is-builtin-module@1.0.0 
  │ │ │ │   │ │ └── builtin-modules@1.1.1 
  │ │ │ │   │ └─┬ validate-npm-package-license@3.0.1 
  │ │ │ │   │   ├─┬ spdx-correct@1.0.2 
  │ │ │ │   │   │ └── spdx-license-ids@1.2.2 
  │ │ │ │   │   └── spdx-expression-parse@1.0.4 
  │ │ │ │   └── path-type@1.1.0 
  │ │ │ └── require-main-filename@1.0.1 
  │ │ ├─┬ yargs@8.0.2 
  │ │ │ ├── camelcase@4.1.0 
  │ │ │ ├─┬ cliui@3.2.0 
  │ │ │ │ ├─┬ string-width@1.0.2 
  │ │ │ │ │ ├── code-point-at@1.1.0 
  │ │ │ │ │ └─┬ is-fullwidth-code-point@1.0.0 
  │ │ │ │ │   └── number-is-nan@1.0.1 
  │ │ │ │ ├─┬ strip-ansi@3.0.1 
  │ │ │ │ │ └── ansi-regex@2.1.1 
  │ │ │ │ └─┬ wrap-ansi@2.1.0 
  │ │ │ │   └── string-width@1.0.2 
  │ │ │ ├── decamelize@1.2.0 
  │ │ │ ├── get-caller-file@1.0.2 
  │ │ │ ├─┬ os-locale@2.1.0 
  │ │ │ │ ├─┬ execa@0.7.0 
  │ │ │ │ │ ├─┬ cross-spawn@5.1.0 
  │ │ │ │ │ │ └─┬ shebang-command@1.2.0 
  │ │ │ │ │ │   └── shebang-regex@1.0.0 
  │ │ │ │ │ ├── get-stream@3.0.0 
  │ │ │ │ │ ├── is-stream@1.1.0 
  │ │ │ │ │ ├─┬ npm-run-path@2.0.2 
  │ │ │ │ │ │ └── path-key@2.0.1 
  │ │ │ │ │ ├── p-finally@1.0.0 
  │ │ │ │ │ └── strip-eof@1.0.0 
  │ │ │ │ ├─┬ lcid@1.0.0 
  │ │ │ │ │ └── invert-kv@1.0.0 
  │ │ │ │ └─┬ mem@1.1.0 
  │ │ │ │   └── mimic-fn@1.1.0 
  │ │ │ ├─┬ read-pkg-up@2.0.0 
  │ │ │ │ └─┬ read-pkg@2.0.0 
  │ │ │ │   ├─┬ load-json-file@2.0.0 
  │ │ │ │   │ └── strip-bom@3.0.0 
  │ │ │ │   └── path-type@2.0.0 
  │ │ │ ├── require-directory@2.1.1 
  │ │ │ ├── set-blocking@2.0.0 
  │ │ │ ├─┬ string-width@2.1.1 
  │ │ │ │ ├── is-fullwidth-code-point@2.0.0 
  │ │ │ │ └─┬ strip-ansi@4.0.0 
  │ │ │ │   └── ansi-regex@3.0.0 
  │ │ │ ├── which-module@2.0.0 
  │ │ │ ├── y18n@3.2.1 
  │ │ │ └── yargs-parser@7.0.0 
  │ │ └─┬ yargs-parser@5.0.0 
  │ │   └── camelcase@3.0.0 
  │ ├── opener@1.4.3 
  │ ├── os-homedir@1.0.2 
  │ ├── own-or@1.0.0 
  │ ├── own-or-env@1.0.0 
  │ ├─┬ readable-stream@2.3.3 
  │ │ ├── core-util-is@1.0.2 
  │ │ ├── isarray@1.0.0 
  │ │ ├── process-nextick-args@1.0.7 
  │ │ ├── safe-buffer@5.1.1 
  │ │ ├── string_decoder@1.0.3 
  │ │ └── util-deprecate@1.0.2 
  │ ├── signal-exit@3.0.2 
  │ ├─┬ source-map-support@0.4.18 
  │ │ └── source-map@0.5.7 
  │ ├── stack-utils@1.0.1 
  │ ├─┬ tap-mocha-reporter@3.0.6 
  │ │ ├─┬ debug@2.6.9 
  │ │ │ └── ms@2.0.0 
  │ │ ├── diff@1.4.0 
  │ │ ├── escape-string-regexp@1.0.5 
  │ │ └─┬ unicode-length@1.0.3 
  │ │   ├── punycode@1.4.1 
  │ │   └─┬ strip-ansi@3.0.1 
  │ │     └── ansi-regex@2.1.1 
  │ ├─┬ tap-parser@5.4.0 
  │ │ └── events-to-array@1.1.2 
  │ ├── tmatch@3.1.0 
  │ ├── trivial-deferred@1.0.1 
  │ ├── tsame@1.1.2 
  │ └── yapool@1.0.0 
  └── underscore@1.8.3 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/tap-wrapper/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 22% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0751 took 8.3916s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (30:4) on program // We need TWO queues (work and subtest) and one jobs pool
//
// The pool stores buffered subtests being run in parallel.
//
// When new subtests are created, they get put in the work queue and also
// in the subtests queue if they are buffered and jobs>0.  When we put a
// test in the subtest queue, we also process it.
//
// Processing the subtest queue means moving tests into the jobs pool until
// the jobs pool length is at this.jobs
//
// Any output functions get put in the work queue if its length > 0 (ie,
// no cutting the line)
//
// Processing the work queue means walking until we run out of things, or
// encounter an unfinished test.  When we encounter ANY kind of test, we
// block until its output is completed, dumping it all into the parser.

var Base = require('./base.js')
var Spawn = require('./spawn.js')
var Stdin = require('./stdin.js')
var Deferred = require('trivial-deferred')
var Pool = require('yapool')
var TestPoint = require('./point.js')
var parseTestArgs = require('./parse-test-args.js')
var loop = require('function-loop')

var extraFromError = require('./extra-from-error.js')
var stack = require('./stack.js')
var assert = require('assert')
var util = require('util')
util.inherits(Test, Base)
var ownOr = require('own-or')
var ownOrEnv = require('own-or-env')
var tapAsserts = require('./asserts.js')
var Promise = require('bluebird')
var bindObj = require('bind-obj-methods')

// A sigil object for implicit end() calls that should not
// trigger an error if the user then calls t.end()
var IMPLICIT = {}

// Sigil to put in the queue to signal the end of all things
var EOF = { EOF: true }

function hasOwn (obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key)
}

module.exports = Test

function Test (options) {
  options = options || {}
  if (!(this instanceof Test))
    return new Test(options)

  Base.call(this, options)
  this.pushedEnd = false
  this.jobs = ownOr(options, 'jobs', 1)
  this.subtests = []
  this.pool = new Pool()
  this.queue = ['TAP version 13\n']
  this.noparallel = false
  this.cb = this.domain.bind(options.cb)
  this.occupied = false
  this.currentAssert = null
  this.count = 0
  this.n = 0
  this.ended = false
  this.explicitEnded = false
  this.multiEndThrew = false
  this.currentAssert = null
  this.assertAt = null
  this.assertStack = null
  this.planEnd = -1
  this.onBeforeEach = []
  this.onAfterEach = []
  this.ranAfterEach = false

  // bind all methods to this object, so we can pass t.end as a callback
  // and do `var test = require('tap').test` like people do.
  var bound = Object.create(null)
  bindObj(this, this, bound)
  bindObj(this, Object.getPrototypeOf(this), bound)
  bindObj(this, Test.prototype, bound)
}

Test.prototype.current = function () {
  throw new Error('Test.current() as been removed and is no more')
}

Test.prototype.spawn = function spawn (cmd, args, options, name) {
  if (typeof args === 'string') {
    args = [ args ]
  }

  args = args || []

  if (typeof options === 'string') {
    name = options
    options = {}
  }

  options = options || {}
  options.name = ownOr(options, 'name', name)
  options.command = cmd
  options.args = args

  return this.sub(Spawn, options, spawn)
}

Test.prototype.sub = function (Class, extra, caller) {
  extra = extra || {}
  if (!extra.skip && this.grep.length) {
    var match = this.grep[0].test(extra.name)
    if (this.grepInvert) {
      match = !match
    }
    if (!match) {
      var p = 'filter' + (this.grepInvert ? ' out' : '') + ': '
      extra.skip = p + this.grep[0]
    }
  }

  if (extra.only && !this.runOnly) {
    this.comment('%j has `only` set but all tests run', extra.name)
  }

  if (this.runOnly && !extra.only) {
    extra.skip = 'filter: only'
  }

  if (extra.todo || extra.skip) {
    this.pass(extra.name, extra)
    return Promise.resolve(this)
  }

  if (!extra.grep) {
    extra.grep = this.grep.slice(1)
    extra.grepInvert = this.grepInvert
  }

  extra.indent = '    '
  if (this.jobs > 1 && process.env.TAP_BUFFER === undefined)
    extra.buffered = ownOr(extra, 'buffered', true)
  else
    extra.buffered = ownOrEnv(extra, 'buffered', 'TAP_BUFFER', true)

  extra.bail = ownOr(extra, 'bail', this.bail)
  extra.parent = this
  extra.stack = stack.captureString(80, caller)
  var t = new Class(extra)

  this.queue.push(t)
  this.subtests.push(t)

  var d = new Deferred()
  t.deferred = d
  this.process()
  return d.promise
}

Test.prototype.only = function test (name, extra, cb) {
  extra = parseTestArgs(name, extra, cb)
  extra.only = true
  return this.sub(Test, extra, test)
}

Test.prototype.test = function test (name, extra, cb) {
  extra = parseTestArgs(name, extra, cb)
  return this.sub(Test, extra, test)
}

Test.prototype.stdin = function stdin (name, extra) {
  extra = parseTestArgs(name, extra, function () {}, '/dev/stdin')
  return this.sub(Stdin, extra || {}, stdin)
}

Test.prototype.bailout = function (message) {
  if (this.parent && (this.results || this.ended))
    this.parent.bailout(message)
  else {
    this.process()
    message = message ? ' ' + ('' + message).trim() : ''
    message = message.replace(/[\r\n]/g, ' ')
    this.parser.write('Bail out!' + message + '\n')
  }
  this.end(IMPLICIT)
  this.process()
}

Test.prototype.comment = function () {
  var message = util.format.apply(util, arguments)
  message = '# ' + message.split(/\r?\n/).join('\n# ') + '\n'

  if (this.results)
    this.push(message)
  else
    this.queue.push(message)
  this.process()
}

Test.prototype.timeout = function (options) {
  options = options || {}
  options.expired = options.expired || this.name
  if (this.occupied)
    this.occupied.timeout(options)
  else
    Base.prototype.timeout.call(this, options)
  this.end(IMPLICIT)
}

Test.prototype.main = function (cb) {
  this.setTimeout(this.options.timeout)
  this.debug('MAIN pre', this)

  var self = this
  try {
    var ret = this.cb(this)
  } catch (er) {
    this.threw(er)
  }

  if (ret && ret.then) {
    this.promise = ret
    ret.tapAbortPromise = done
    ret.then(end, done)
  } else
    done()

  function end () {
    self.debug(' > implicit end for promise')
    self.end(IMPLICIT)
    done()
  }

  function done (er) {
    if (er)
      self.threw(er)

    if (self.results || self.bailedOut)
      cb()
    else
      self.ondone = cb
  }

  this.debug('MAIN post', this)
}

Test.prototype.process = function () {
  if (this.processing)
    return this.debug(' < already processing')

  this.debug('\nPROCESSING(%s)', this.name, this.queue.length)
  this.processing = true

  var p

  while (!this.occupied && (p = this.queue.shift())) {
    this.debug('PROCESS(%s)', this.name, p)
    if (p instanceof Base) {
      this.processSubtest(p)
    } else if (p === EOF) {
      this.debug(' > EOF', this.name)
      // I AM BECOME EOF, DESTROYER OF STREAMS
      this.parser.end()
    } else if (p instanceof TestPoint) {
      this.debug(' > TESTPOINT')
      this.parser.write(p.ok + (++this.n) + p.message)
    } else if (typeof p === 'string') {
      this.debug(' > STRING')
      this.parser.write(p)
    } else if (Array.isArray(p)) {
      this.debug(' > METHOD')
      var m = p.shift()
      this[m].apply(this, p)
    } else {
      throw new Error('weird thing got in the queue')
    }
  }

  while (!this.noparallel &&
         this.pool.length < this.jobs &&
         (p = this.subtests.shift())) {
    if (!p.buffered) {
      this.noparallel = true
      break
    }
    this.debug('start subtest', p)
    this.pool.add(p)
    if (this.bailedOut)
      this.onbufferedend(p)
    else
      this.runBeforeEach(p,
        p.main.bind(p,
          this.onbufferedend.bind(this, p)))
  }

  this.debug('done processing', this.queue, this.occupied)
  this.processing = false

  // just in case any tests ended, and we have sync stuff still
  // waiting around in the queue to be processed
  if (!this.occupied && this.queue.length)
    this.process()

  this.maybeAutoend()
}

Test.prototype.processSubtest = function (p) {
  this.debug(' > subtest')
  this.occupied = p
  if (!p.buffered) {
    if (this.bailedOut)
      return this.onindentedend(p)
    this.debug(' > subtest indented')
    p.pipe(this.parser, { end: false })
    this.runBeforeEach(p,
      this.writeSubComment.bind(this, p,
        p.main.bind(p,
          this.onindentedend.bind(this, p))))
  } else if (p.readyToProcess) {
    this.debug(' > subtest buffered, finished')
    // finished!  do the thing!
    this.occupied = null
    if (!p.passing() || !p.silent) {
      this.queue.unshift(['emitSubTeardown', p])
      this.printResult(p.passing(), p.name, p.options, true)
    }
  } else {
    this.occupied = p
    this.debug(' > subtest buffered, unfinished', p)
    // unfinished buffered test.
    // nothing to do yet, just leave it there.
    this.queue.unshift(p)
  }
}

Test.prototype.emitSubTeardown = function (p) {
  try {
    p.emit('teardown')
  } catch (er) {
    delete p.options.time
    p.threw(er)
  }
}

Test.prototype.writeSubComment = function (p, cb) {
  var comment = '# Subtest'
  if (p.name)
    comment += ': ' + p.name
  comment += '\n'
  this.parser.write(comment)
  cb()
}

Test.prototype.onbufferedend = function (p, er) {
  delete p.ondone
  p.results = p.results || {}
  p.readyToProcess = true
  var to = p.options.timeout
  if (to && p.passing())
    var dur = Date.now() - p.start
  if (dur && dur > to)
    p.timeout()
  else
    p.setTimeout(false)
  this.debug('%s.onbufferedend', this.name, p.name, p.results.bailout)
  this.pool.remove(p)
  p.options.tapChildBuffer = p.output || ''
  p.options.stack = ''
  if (p.time)
    p.options.time = p.time
  if (this.occupied === p)
    this.occupied = null
  if (er)
    this.threw(er)
  p.deferred.resolve(this)
  this.process()
}

Test.prototype.onindentedend = function (p, er) {
  delete p.ondone
  this.debug('onindentedend', p)
  this.noparallel = false
  var sti = this.subtests.indexOf(p)
  if (sti !== -1)
    this.subtests.splice(sti, 1)
  p.readyToProcess = true
  p.results = p.results || {}
  if (p.time)
    p.options.time = p.time
  var to = p.options.timeout
  if (to && p.passing())
    var dur = Date.now() - p.start
  if (dur && dur > to)
    p.timeout()
  else
    p.setTimeout(false)
  this.debug('onindentedend %s(%s)', this.name, p.name, er || 'ok')
  assert(this.occupied === p)
  this.occupied = null
  this.debug('OIE(%s) b>shift into queue', this.name, this.queue)
  p.options.stack = ''

  this.queue.unshift(['emitSubTeardown', p])
  this.printResult(p.passing(), p.name, p.options, true)

  this.debug('OIE(%s) shifted into queue', this.name, this.queue)
  if (er)
    this.threw(er)
  p.deferred.resolve(this)
  this.process()
}

Test.prototype.addAssert = function (name, length, fn) {
  if (!name)
    throw new TypeError('name is required for addAssert')

  if (!(typeof length === 'number' && length >= 0))
    throw new TypeError('number of args required')

  if (typeof fn !== 'function')
    throw new TypeError('function required for addAssert')

  if (Test.prototype[name] || this[name])
    throw new TypeError('attempt to re-define `' + name + '` assert')

  this[name] = function ASSERT () {
    if (!this.currentAssert) {
      this.currentAssert = ASSERT
    }
    var args = new Array(length + 2)
    for (var i = 0; i < length; i++) {
      args[i] = arguments[i]
    }
    if (typeof arguments[length] === 'object') {
      args[length] = ''
      args[length + 1] = arguments[length]
    } else {
      args[length] = arguments[length] || ''
      args[length + 1] = arguments[length + 1] || {}
    }

    return fn.apply(this, args)
  }
}

Test.prototype.fail = function fail (message, extra) {
  if (!this.currentAssert) {
    this.currentAssert = fail
  }

  if (message && typeof message === 'object') {
    extra = message
    message = ''
  } else {
    if (!message) {
      message = ''
    }
    if (!extra) {
      extra = {}
    }
  }

  this.printResult(false, message, extra)

  var ret = true
  if (!extra.todo && !extra.skip)
    ret = false

  return ret
}

Test.prototype.pass = function pass (message, extra) {
  if (!this.currentAssert) {
    this.currentAssert = pass
  }
  this.printResult(true, message || '(unnamed test)', extra)
  return true
}

Test.prototype.printResult = function pR (ok, message, extra, front) {
  var n = this.count + 1
  if (this.planEnd !== -1 && n > this.planEnd) {
    if (!this.passing())
      return

    var failMessage = this.explicitEnded
        ? 'test after end() was called'
        : 'test count exceeds plan'

    var er = new Error(failMessage)
    Error.captureStackTrace(er, this.currentAssert || pR)
    er.test = this.name
    er.plan = this.planEnd
    this.threw(er)
    return
  }

  extra = extra || {}

  if (this.assertAt) {
    extra.at = this.assertAt
    this.assertAt = null
  }

  if (this.assertStack) {
    extra.stack = this.assertStack
    this.assertStack = null
  }

  if (hasOwn(extra, 'stack') && !hasOwn(extra, 'at'))
    extra.at = stack.parseLine(extra.stack.split('\n')[0])

  var fn = this.currentAssert || pR
  this.currentAssert = null
  if (!ok && !extra.skip && !hasOwn(extra, 'at')) {
    assert.equal(typeof fn, 'function')
    extra.at = stack.at(fn)
    if (!extra.todo)
      extra.stack = stack.captureString(80, fn)
  }

  var diagnostic
  if (!ok)
    diagnostic = true

  if (extra.skip)
    diagnostic = false

  if (process.env.TAP_DIAG === '0')
    diagnostic = false

  if (typeof extra.diagnostic === 'boolean')
    diagnostic = extra.diagnostic

  if (diagnostic)
    extra.diagnostic = true

  this.count = n
  var res = { ok: ok, message: message, extra: extra }
  var output = new TestPoint(ok, message, extra)
  // when we jump the queue, skip an extra line
  if (front)
    output.message = output.message.trimRight() + '\n\n'

  if (front) {
    this.emit('result', res)
    this.parser.write(output.ok + (++this.n) + output.message)
  } else
    this.queue.push(['emit', 'result', res], output)

  if (this.planEnd === this.count)
    this.end(IMPLICIT)

  this.process()
}

Test.prototype.pragma = function (set) {
  var p = ''
  Object.keys(set).forEach(function (i) {
    p += 'pragma ' + (set[i] ? '+' : '-') + i + '\n'
  })
  this.queue.push(p)
  this.process()
}

Test.prototype.plan = function (n, comment) {
  if (this.bailedOut)
    return

  if (this.planEnd !== -1) {
    throw new Error('Cannot set plan more than once')
  }

  if (typeof n !== 'number' || n < 0) {
    throw new TypeError('plan must be a number')
  }

  // Cannot get any tests after a trailing plan, or a plan of 0
  var ending = false
  if (this.count !== 0 || n === 0) {
    ending = true
  }

  if (n === 0)
    this.skip = comment || true

  this.planEnd = n
  comment = comment ? ' # ' + comment.trim() : ''
  this.queue.push('1..' + n + comment + '\n')

  if (ending)
    this.end(IMPLICIT)
  else
    this.process()
}

Test.prototype.done = Test.prototype.end = function (implicit) {
  this.debug('END implicit=%j', implicit === IMPLICIT)
  if (this.ended && implicit === IMPLICIT)
    return

  // beyond here we have to be actually done with things, or else
  // the semantic checks on counts and such will be off.
  if (!queueEmpty(this) || this.occupied) {
    if (!this.pushedEnd)
      this.queue.push(['end', implicit])
    this.pushedEnd = true
    return this.process()
  }

  if (!this.ranAfterEach && this.parent) {
    this.ranAfterEach = true
    this.parent.runAfterEach(this, end.bind(this, implicit))
  } else
    end.call(this, implicit)
}

function end (implicit) {
  this.ended = true

  if (implicit !== IMPLICIT && !this.multiEndThrew) {
    if (this.explicitEnded) {
      this.multiEndThrew = true
      var er = new Error('test end() method called more than once')
      Error.captureStackTrace(er, this.currentAssert || end)
      er.test = this.name
      this.threw(er)
      return
    }
    this.explicitEnded = true
  }

  if (this.planEnd === -1) {
    this.debug('END(%s) implicit plan', this.name, this.count)
    this.plan(this.count)
  }

  this.queue.push(EOF)
  this.process()
}

Test.prototype.threw = function (er, extra, proxy) {
  this.debug('THREW', er.message, extra, proxy)

  // event emitters 'error' events need to re-throw so that they
  // can jump out of the flow like a normal throw.  They'll just
  // end up back here once that happens, though, unless there's a
  // try/catch somewhere in the call stack.
  if (er.domainEmitter) {
    delete er.domainEmitter
    throw er
  }

  if (this.name && !proxy)
    er.test = this.name
  if (!proxy)
    extra = extraFromError(er, extra, this.options)
  Base.prototype.threw.call(this, er, extra, proxy)

  if (!this.results) {
    this.fail(extra.message || er.message, extra)
    if (!proxy)
      this.end(IMPLICIT)
  }
  this.process()
}

Test.prototype.runBeforeEach = function (who, cb) {
  var self = this
  if (this.parent)
    this.parent.runBeforeEach(who, function () {
      loop(who, self.onBeforeEach, cb, who.threw)
    })
  else
    loop(who, self.onBeforeEach, cb, who.threw)
}

Test.prototype.runAfterEach = function (who, cb) {
  var self = this
  loop(who, self.onAfterEach, function () {
    if (self.parent)
      self.parent.runAfterEach(who, cb)
    else
      cb()
  }, who.threw)
}

Test.prototype.beforeEach = function (fn) {
  this.onBeforeEach.push(fn)
}

Test.prototype.afterEach = function (fn) {
  this.onAfterEach.push(fn)
}

Test.prototype.teardown = Test.prototype.tearDown = function (fn) {
  this.on('teardown', fn)
}

Test.prototype.shouldAutoend = function () {
  var should = (
    this.options.autoend &&
    !this.ended &&
    !this.occupied &&
    queueEmpty(this) &&
    !this.pool.length &&
    !this.subtests.length &&
    this.planEnd === -1
  )
  return should
}

Test.prototype.autoend = function () {
  this.options.autoend = true
  this.maybeAutoend()
}

Test.prototype.maybeAutoend = function () {
  if (this.autoendTimer)
    clearTimeout(this.autoendTimer)

  if (this.shouldAutoend()) {
    var self = this
    self.autoendTimer = setTimeout(function () {
      if (self.shouldAutoend()) {
        self.autoendTimer = setTimeout(function () {
          if (self.shouldAutoend()) {
            self.end(IMPLICIT)
          }
        })
      }
    })
  }
}

function endAllQueue (queue) {
  queue.forEach(function (p, i) {
    if ((p instanceof Base) && !p.readyToProcess)
      queue[i] = new TestPoint(false,
        'child test left in queue ' + p.constructor.name + ': ' +
        p.name, p.options)
  })
  queue.push(['end', IMPLICIT])
}

function queueEmpty (t) {
  return t.queue.length === 0 ||
    t.queue.length === 1 && t.queue[0] === 'TAP version 13\n'
}

Test.prototype.endAll = function (sub) {
  this.processing = true
  if (this.occupied) {
    var p = this.occupied
    if (p.endAll)
      p.endAll(true)
    else {
      p.parser.abort('test unfinished')
    }
  } else if (sub) {
    this.process()
    if (queueEmpty(this)) {
      var options = Object.keys(this.options).reduce(function (o, k) {
        o[k] = this.options[k]
        return o
      }.bind(this), {})
      this.options.at = null
      this.options.stack = ''
      options.test = this.name
      this.fail('test unfinished', options)
    }
  }
  if (this.promise && this.promise.tapAbortPromise)
    this.promise.tapAbortPromise()
  if (this.occupied) {
    this.queue.unshift(this.occupied)
    this.occupied = null
  }
  endAllQueue(this.queue)
  this.processing = false
  this.process()
  this.parser.end()
}

// Add all the asserts
tapAsserts.decorate(Test.prototype)
 at SyntaxError: Unexpected token (30:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/tap-wrapper/node_modules/tap-wrapper/index.js. Coverage (Term): 67% Coverage (LOC): 100%
*- File /root/Targets/tap-wrapper/node_modules/tap-wrapper/lib/main.js. Coverage (Term): 37% Coverage (LOC): 29%
*- File /root/Targets/tap-wrapper/node_modules/curry/curry.js. Coverage (Term): 15% Coverage (LOC): 25%
*- File /root/Targets/tap-wrapper/node_modules/tap/lib/tap.js. Coverage (Term): 4% Coverage (LOC): 5%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
