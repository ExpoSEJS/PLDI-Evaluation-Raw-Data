
> dtrace-provider@0.8.5 install /root/Targets/webseeded-torrent-generator/node_modules/dtrace-provider
> node scripts/install.js

/root/Targets/webseeded-torrent-generator
└─┬ webseeded-torrent-generator@0.9.0 
  ├─┬ assert@0.4.9 
  │ └─┬ util@0.10.3 
  │   └── inherits@2.0.1 
  ├── bencode@0.5.2 
  ├─┬ bunyan-promise@0.1.4 
  │ ├─┬ bunyan@1.8.12 
  │ │ ├─┬ dtrace-provider@0.8.5 
  │ │ │ └── nan@2.7.0 
  │ │ ├── moment@2.18.1 
  │ │ ├─┬ mv@2.1.1 
  │ │ │ ├─┬ mkdirp@0.5.1 
  │ │ │ │ └── minimist@0.0.8 
  │ │ │ ├── ncp@2.0.0 
  │ │ │ └─┬ rimraf@2.4.5 
  │ │ │   └─┬ glob@6.0.4 
  │ │ │     ├─┬ inflight@1.0.6 
  │ │ │     │ └── wrappy@1.0.2 
  │ │ │     ├─┬ minimatch@3.0.4 
  │ │ │     │ └─┬ brace-expansion@1.1.8 
  │ │ │     │   ├── balanced-match@1.0.0 
  │ │ │     │   └── concat-map@0.0.1 
  │ │ │     ├── once@1.4.0 
  │ │ │     └── path-is-absolute@1.0.1 
  │ │ └── safe-json-stringify@1.0.4 
  │ ├── colors@0.6.2 
  │ └── moment@2.0.0 
  ├── lodash@1.1.1 
  ├─┬ nomnom@1.6.2 
  │ ├── colors@0.5.1 
  │ └── underscore@1.4.4 
  ├── q@0.9.7 
  └─┬ url@0.7.9 
    ├── punycode@1.0.0 
    └── querystring@0.1.0 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/webseeded-torrent-generator/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0476 took 4.6241s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (7:4) on program 'use strict';

var _ = require('lodash');
var q = require('q');
var qsequence = require('../util/qsequence');
var bencode = require('bencode');
var assert = require('assert');
var crypto = require('crypto');
var HttpHasher = require('./http-hasher');
var HttpFile = require('./http-fs');
var BunyanPromiseLogger = require('bunyan-promise');

var promiseLog = new BunyanPromiseLogger({
    name: 'torrent'
});

// http://torrentfreak.com/how-to-make-the-best-torrents-081121/
// recommends between 1200 and 2200 pieces
// lets use a nice round number in the middle (2048)
var MAX_SUGGESTED_NUM_PIECES = 0x800;
// 256kB is the smallest allowable piece size
var MIN_PIECE_SIZE = 0x40000;
// regardless of size, piece size must be 4 ^ x
var PIECE_SIZE_EXPONENT_MULTIPLE = 4;
// there is an absolute max piece size of 32 Mb enforced by utorrent
var MAX_PIECE_SIZE = 0x2000000;

var DEFAULT_ANNOUNCE = 'udp://tracker.publicbt.com:80/announce';
var DEFAULT_ANNOUNCE_LIST = [
    ['udp://tracker.publicbt.com:80/announce'],
    ['udp://tracker.openbittorrent.com:80/announce']
];

var memoizeAll = function (obj) {
    var funcs = _.functions(obj);
    _.each(funcs, function (f) {
        obj[f] = _.memoize(obj[f]);
    });
    return obj;
};

function pemToDer(pem) {
    if (typeof pem !== 'string') {
        pem = pem.toString();
    }

    var m;
    if ((m = pem.match(/^-----BEGIN CERTIFICATE-----\n([^\-]+)\n-----END CERTIFICATE-----/))) {
        var encoded = m[1];
        return new Buffer(encoded, 'base64');
    } else {
        throw new Error('Invalid PEM certificate');
    }
}

/**
 * options: {
 *   optional 'announce': tracker_url,
 *   optional 'announce-list': [[tracker_url]],
 *   optional 'similar': [info_hash_hex],
 *   optional 'collections': [collection_name],
 *   optional 'signing': {
 *     'key': key_string (PEM),
 *     'signCallack': (buf -> promise buf) as alternative to key,
 *     optional 'cert': cert_string (PEM),
 *     optional 'info': Object
 *   }
 *   optional 'originator': cert_string
 * }
 **/
var Torrent = function (base, name, files, options) {
    memoizeAll(this);
    this.base = base;
    this.name = name;
    this.files = files;
    this.options = options || {};
};

Torrent.prototype.getMetadata = function () {
    var defer = q.defer();
    var getInfoRequest = this.getInfo();
    var getAnnounceRequest = this.getAnnounce();
    var getAnnounceListRequest = this.getAnnounceList();
    var getSignaturesRequest = this.getSignatures();
    var getUrlListRequest = this.getUrlList();

    promiseLog.trace(getInfoRequest, 'get info');
    promiseLog.trace(getAnnounceRequest, 'get announce');
    promiseLog.trace(getAnnounceListRequest, 'get announce list');
    promiseLog.trace(getSignaturesRequest, 'get signatures');
    promiseLog.trace(getUrlListRequest, 'get url list');

    getInfoRequest.progress(function (progress) {
        defer.notify(progress);
    });

    var allRequests = q.all([
        getInfoRequest,
        getAnnounceRequest,
        getAnnounceListRequest,
        getUrlListRequest,
        getSignaturesRequest
    ]);
    allRequests.spread(function (info, announce, announceList, urlList, signatures) {
        var data = {
            info: info,
            announce: announce,
            'announce-list': announceList,
            'url-list': urlList,
            'creation date': Math.floor(Date.now() / 1000)
        };
        /* BEP-35: Torrent Signing */
        if (signatures) {
            data.signatures = signatures;
        }

        var metadata = bencode.encode(data);
        defer.resolve(metadata);
    });
    allRequests.fail(function (err) {
        defer.reject(err);
    });
    return defer.promise;
};

Torrent.prototype.getPrivate = function () {
    return q.resolve(!!this.options.private);
};

Torrent.prototype.getOriginator = function () {
    return q.resolve(this.options.originator);
};

Torrent.prototype.getUpdateUrl = function () {
    return q.resolve();
};

Torrent.prototype.getAnnounce = function () {
    return q.resolve(this.options.announce || DEFAULT_ANNOUNCE);
};

Torrent.prototype.getAnnounceList = function () {
    return q.resolve(this.options['announce-list'] || DEFAULT_ANNOUNCE_LIST);
};

Torrent.prototype.getSimilar = function () {
    var similar = this.options.similar;
    return q.resolve(
        similar &&
        similar.map(function (s) {
            return new Buffer(s, 'hex');
        })
    );
};

Torrent.prototype.getCollections = function () {
    return q.resolve(this.options.collections);
};

Torrent.prototype.getInfo = function () {
    var defer = q.defer();
    var getNameRequest = this.getName();
    var getPieceLengthRequest = this.getPieceLength();
    var getPiecesRequest = this.getPieces();
    var getFilesRequest = this.getFiles();
    var getOriginatorRequest = this.getOriginator();
    var getUpdateUrlRequest = this.getUpdateUrl();
    var getSimilarRequest = this.getSimilar();
    var getCollectionsRequest = this.getCollections();
    var getPrivateRequest = this.getPrivate();

    promiseLog.trace(getNameRequest, 'get name');
    promiseLog.trace(getPieceLengthRequest, 'get piece length');
    promiseLog.trace(getPiecesRequest, 'get pieces');
    promiseLog.trace(getFilesRequest, 'get files');
    promiseLog.trace(getOriginatorRequest, 'get originator');
    promiseLog.trace(getUpdateUrlRequest, 'get update url');
    promiseLog.trace(getSimilarRequest, 'get similar');
    promiseLog.trace(getCollectionsRequest, 'get collections');
    promiseLog.trace(getPrivateRequest, 'get private');

    getPiecesRequest.progress(function (progress) {
        defer.notify(progress);
    });

    var allRequests = q.all([
        getNameRequest,
        getPieceLengthRequest,
        getPiecesRequest,
        getFilesRequest,
        getOriginatorRequest,
        getUpdateUrlRequest,
        getSimilarRequest,
        getCollectionsRequest,
        getPrivateRequest
    ]);
    allRequests.spread(function (
        name,
        pieceLength,
        pieces,
        files,
        originator,
        updateUrl,
        similar,
        collections,
        priv
    ) {
        var res = {
            name: name,
            'piece length': pieceLength,
            pieces: pieces,
            files: files
        };
        /* BEP-27: Private Torrents */
        if (priv) {
            res['private'] = 1;
        }
        /* BEP-39: Updating Torrents Via Feed URL */
        if (originator) {
            res.originator = pemToDer(originator);
        }
        if (updateUrl) {
            res['update-url'] = updateUrl;
        }
        /* BEP-38: Finding Local Data Via Torrent File Hints */
        if (similar) {
            res.similar = similar;
        }
        if (collections) {
            res.collections = collections;
        }
        defer.resolve(res);
    });
    allRequests.fail(function (err) {
        defer.reject(err);
    });
    return defer.promise;
};

Torrent.prototype.getSigning = function () {
    return q.resolve(this.options.signing);
};

Torrent.prototype.getSigningAlgorithm = function () {
    /* ut-signing-tool uses SHA1 */
    return q.resolve('RSA-SHA1');
};

function createDefaultSignCallback(algorithm, key) {
    return function (buf) {
        var rsaSign = crypto.createSign(algorithm);
        rsaSign.update(buf);
        return q.resolve(rsaSign.sign(key));
    };
}

Torrent.prototype.getSignatures = function () {
    return q.all([
        this.getInfo(),
        this.getSigning(),
        this.getSigningAlgorithm()
    ]).spread(function (info, signing, algorithm) {
        return q.all(
            _.map(signing || {}, function (signingOptions, signingEntity) {
                var signCallback = signingOptions.signCallback ||
                        createDefaultSignCallback(algorithm, signingOptions.key);

                var signatureDict = {};
                var buf = bencode.encode(info);
                if (signingOptions.info) {
                    buf = Buffer.concat([buf, bencode.encode(signingOptions.info)]);
                    signatureDict.info = signingOptions.info;
                }
                if (signingOptions.cert) {
                    signatureDict.certificate = pemToDer(signingOptions.cert);
                }

                return q.resolve().then(function () {
                    return signCallback(buf);
                }).then(function (signature) {
                    signatureDict.signature = signature;
                    return q.resolve({
                        entity: signingEntity,
                        dict: signatureDict
                    });
                });
            })
        );
    }).then(function (sigList) {
        if (sigList.length > 0) {
            var signatures = {};
            sigList.forEach(function (sig) {
                signatures[sig.entity] = sig.dict;
            });
            return signatures;
        }
    });
};

Torrent.prototype.getInfoHash = function () {
    return q.all([
        this.getInfo()
    ]).spread(function (info) {
        var shasum = crypto.createHash('sha1');
        shasum.update(bencode.encode(info));
        var infoHash = shasum.digest('hex');
        return q.resolve(infoHash);
    });
};

Torrent.prototype.getUrlList = function () {
    return q.resolve([this.base]);
};

Torrent.prototype.getName = function () {
    return q.resolve(this.name);
};

Torrent.prototype.getPieceLength = function () {
    return q.all([
        this.getTotalContentSize()
    ]).spread(function (totalContentSize) {
        var unalignedPieceSize = Math.min(Math.max(totalContentSize / MAX_SUGGESTED_NUM_PIECES, MIN_PIECE_SIZE), MAX_PIECE_SIZE);

        // get an even number exponent that we can use to generate piece sizes that are multiples of 4
        var rawExponent = Math.log(unalignedPieceSize) / Math.log(PIECE_SIZE_EXPONENT_MULTIPLE);
        var ceiledExponent = Math.ceil(rawExponent);

        var alignedPieceSize = Math.pow(PIECE_SIZE_EXPONENT_MULTIPLE, ceiledExponent);
        return q.resolve(alignedPieceSize);
    });
};

Torrent.prototype.getPieces = function () {
    return q.all([
        this.getPieceLength(),
        this.getTotalContentSize()
    ]).spread(function (pieceLength, totalContentSize) {
        var expectedPieceCount = Math.ceil(totalContentSize / pieceLength);

        var httpFiles = _.map(this.files, function (file) {
            return new HttpFile(this.base + this.name + '/' + file);
        }.bind(this));

        var hasher = new HttpHasher(httpFiles, pieceLength);
        return hasher.hash().then(function (pieceHashes) {
            assert(expectedPieceCount === pieceHashes.length, 'incorrect number of pieces generated');
            var pieces = _.reduce(pieceHashes, function (memo, hash) {
                return memo + hash;
            }, '');
            assert(pieces.length % 20 === 0, 'incorrect pieces length');
            return new Buffer(pieces, 'hex');
        });
    }.bind(this));
};

Torrent.prototype.getTotalContentSize = function () {
    return q.all([
        this.getFiles()
    ]).spread(function (files) {
        return _.reduce(files, function (memo, file) {
            return memo + file.length;
        }, 0);
    });
};

Torrent.prototype.getFiles = function () {
    return qsequence(_.map(this.files, function (file) {
        return function () {
            var httpFile = new HttpFile(this.base + this.name + '/' + file);
            return httpFile.size().then(function (size) {
                return q.resolve({
                    path: file.split('/'),
                    length: size
                });
            });
        }.bind(this);
    }.bind(this)));
};

module.exports = Torrent;
 at SyntaxError: Unexpected token (7:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
