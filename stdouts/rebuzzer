/root/Targets/rebuzzer
└─┬ rebuzzer@1.3.1 
  ├─┬ async@2.5.0 
  │ └── lodash@4.17.4 
  ├─┬ express@4.16.1 
  │ ├─┬ accepts@1.3.4 
  │ │ ├─┬ mime-types@2.1.17 
  │ │ │ └── mime-db@1.30.0 
  │ │ └── negotiator@0.6.1 
  │ ├── array-flatten@1.1.1 
  │ ├─┬ body-parser@1.18.2 
  │ │ ├── bytes@3.0.0 
  │ │ ├─┬ http-errors@1.6.2 
  │ │ │ ├── inherits@2.0.3 
  │ │ │ └── setprototypeof@1.0.3 
  │ │ ├── iconv-lite@0.4.19 
  │ │ └── raw-body@2.3.2 
  │ ├── content-disposition@0.5.2 
  │ ├── content-type@1.0.4 
  │ ├── cookie@0.3.1 
  │ ├── cookie-signature@1.0.6 
  │ ├─┬ debug@2.6.9 
  │ │ └── ms@2.0.0 
  │ ├── depd@1.1.1 
  │ ├── encodeurl@1.0.1 
  │ ├── escape-html@1.0.3 
  │ ├── etag@1.8.1 
  │ ├─┬ finalhandler@1.1.0 
  │ │ └── unpipe@1.0.0 
  │ ├── fresh@0.5.2 
  │ ├── merge-descriptors@1.0.1 
  │ ├── methods@1.1.2 
  │ ├─┬ on-finished@2.3.0 
  │ │ └── ee-first@1.1.1 
  │ ├── parseurl@1.3.2 
  │ ├── path-to-regexp@0.1.7 
  │ ├─┬ proxy-addr@2.0.2 
  │ │ ├── forwarded@0.1.2 
  │ │ └── ipaddr.js@1.5.2 
  │ ├── qs@6.5.1 
  │ ├── range-parser@1.2.0 
  │ ├── safe-buffer@5.1.1 
  │ ├─┬ send@0.16.1 
  │ │ ├── destroy@1.0.4 
  │ │ └── mime@1.4.1 
  │ ├── serve-static@1.13.1 
  │ ├── setprototypeof@1.1.0 
  │ ├── statuses@1.3.1 
  │ ├─┬ type-is@1.6.15 
  │ │ └── media-typer@0.3.0 
  │ ├── utils-merge@1.0.1 
  │ └── vary@1.1.2 
  ├── is-running@2.1.0 
  ├── minimist@1.2.0 
  ├─┬ ps-tree@1.1.0 
  │ └─┬ event-stream@3.3.4 
  │   ├── duplexer@0.1.1 
  │   ├── from@0.1.7 
  │   ├── map-stream@0.1.0 
  │   ├── pause-stream@0.0.11 
  │   ├── split@0.3.3 
  │   ├── stream-combiner@0.0.4 
  │   └── through@2.3.8 
  ├─┬ socket.io@1.7.4 
  │ ├─┬ debug@2.3.3 
  │ │ └── ms@0.7.2 
  │ ├─┬ engine.io@1.8.4 
  │ │ ├── accepts@1.3.3 
  │ │ ├── base64id@1.0.0 
  │ │ ├─┬ debug@2.3.3 
  │ │ │ └── ms@0.7.2 
  │ │ ├─┬ engine.io-parser@1.3.2 
  │ │ │ ├── after@0.8.2 
  │ │ │ ├── arraybuffer.slice@0.0.6 
  │ │ │ ├── base64-arraybuffer@0.1.5 
  │ │ │ ├── blob@0.0.4 
  │ │ │ └── wtf-8@1.0.0 
  │ │ └─┬ ws@1.1.4 
  │ │   ├── options@0.0.6 
  │ │   └── ultron@1.0.2 
  │ ├─┬ has-binary@0.1.7 
  │ │ └── isarray@0.0.1 
  │ ├── object-assign@4.1.0 
  │ ├─┬ socket.io-adapter@0.5.0 
  │ │ └─┬ debug@2.3.3 
  │ │   └── ms@0.7.2 
  │ ├─┬ socket.io-client@1.7.4 
  │ │ ├── backo2@1.0.2 
  │ │ ├── component-bind@1.0.0 
  │ │ ├── component-emitter@1.2.1 
  │ │ ├─┬ debug@2.3.3 
  │ │ │ └── ms@0.7.2 
  │ │ ├─┬ engine.io-client@1.8.4 
  │ │ │ ├── component-emitter@1.2.1 
  │ │ │ ├── component-inherit@0.0.3 
  │ │ │ ├─┬ debug@2.3.3 
  │ │ │ │ └── ms@0.7.2 
  │ │ │ ├── has-cors@1.1.0 
  │ │ │ ├── parsejson@0.0.3 
  │ │ │ ├── parseqs@0.0.5 
  │ │ │ ├── ws@1.1.2 
  │ │ │ ├── xmlhttprequest-ssl@1.5.3 
  │ │ │ └── yeast@0.1.2 
  │ │ ├── indexof@0.0.1 
  │ │ ├── object-component@0.0.3 
  │ │ ├─┬ parseuri@0.0.5 
  │ │ │ └─┬ better-assert@1.0.2 
  │ │ │   └── callsite@1.0.0 
  │ │ └── to-array@0.1.4 
  │ └─┬ socket.io-parser@2.3.1 
  │   ├── component-emitter@1.1.2 
  │   ├─┬ debug@2.2.0 
  │   │ └── ms@0.7.1 
  │   └── json3@3.3.2 
  └── tree-kill@1.2.0 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/rebuzzer/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0675 took 4.58s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected character '#' (1:78) on program #! /usr/bin/env node

const fs = require('fs')
const path = require('path')
const childProcess = require('child_process')
const async = require('async')
const isRunning = require('is-running')
const psTree = require('ps-tree')
const kill = require('tree-kill')
const app = require('express')()
const http = require('http').Server(app)
const io = require('socket.io')(http)
const argv = require('minimist')(process.argv.slice(2));
const page = {}
const color = argv.color ? argv.color : '255,255,255'
const interval = parseInt(argv.interval ? argv.interval : 0)
const nowait = argv.nowait ? true : false
const name = argv.name ? argv.name : 'rebuzzer'
const port = argv.port ? argv.port : 7000
var commands = argv.command
const processStatusPollingInterval = 100
var currentProc = {}
var readyToRerun = true

function verifyColor() {
	const error = new Error(
		'Wrong color: "'
		+ color
		+ '", RGB value expected'
	)
	if(!/^\d{1,3},\d{1,3},\d{1,3}$/.test(color)) {
		throw error
	}
	const rgb = color.split(',')
	for(index in rgb) {
		if(rgb[index] < 0 || rgb[index] > 255) {
			throw error
		}
	}
}

function verifyCommands() {
	if(!(argv.command instanceof Array)) {
		commands = [argv.command]
	}
	for(index in commands) {
		if(
			commands[index] === false
			|| commands[index] === true
			|| commands[index] === undefined
		) {
			commands.splice(index, 1)
			continue
		}
		commands[index] = '' + commands[index]
	}
	if(commands.length < 1) {
		throw new Error('No commands, expected at least one command')
	}
}

function verifyInterval() {
	if(!/^\d+$/.test(interval)) {
		throw new Error(
			'Invalid interval: "'
			+ interval
			+ '", milliseconds expected'
		)
	}
}

function getAllChildProcessId(pid, callback) {
	const result = []
	psTree(pid, function (err, children) {
		for(index in children) {
			result.push(children[index].PID)
		}
		callback(result)
	})
}

function startProcesses() {
	var proc
	for(index in commands) {
		proc = childProcess.exec(
			commands[index],
			{maxBuffer: 1048576},
			function(error, stdout, stderr) {}
		)
		proc.stdout.on('data', function(data) {
			process.stdout.write(data)
			proc.stdout = new Buffer(1048576)
		})
		proc.stderr.on('data', function(data) {
			process.stdout.write(data)
			proc.stderr = new Buffer(1048576)
		})
		currentProc[proc.pid] = proc
	}
}

function waitUntilKilled(processList, callback) {
	async.whilst(
		function() {
			return processList.length > 0
		},
		function(evaluate) {
			for(proc in processList) {
				var res = isRunning(processList[proc])
				if(!res) {
					processList.splice(proc, 1)
				}
			}
			if(processList.length < 1) {
				evaluate()
				return
			}
			setTimeout(function() {
				evaluate()
			}, processStatusPollingInterval)
		},
		function() {
			callback(processList)
		}
	)
}

function resolveProcesses(callback) {
	const commandProcs = Object.keys(currentProc)
	const allProcs = []
	async.whilst(
		function() {
			return commandProcs.length > 0
		},
		function(evaluate) {
			allProcs.push(commandProcs[0])
			getAllChildProcessId(commandProcs[0], function(children) {
				for(index in children) {
					allProcs.push(children[index])
				}
				commandProcs.splice(0, 1)
				evaluate()
			})
		},
		function() {
			callback(allProcs)
		}
	)
}

function killProcesses(callback) {
	resolveProcesses(function(toBeKilled) {
		for(index in toBeKilled) {
			try {
				process.kill(toBeKilled[index], 'SIGTERM')
			} catch(error) {
				//ignore process termination failure
			}
		}
		waitUntilKilled(toBeKilled, function(killed) {
			for(index in killed) {
				if(killed[index] in currentProc) {
					delete currentProc[killed[index]]
				}
			}
			if(callback) {
				callback()
			}
		})
	})
}

function rerun() {
	if(Object.keys(currentProc).length > 0) {
		readyToRerun = false
		io.emit('clickable', false)
		if(nowait) {
			killProcesses()
			startProcesses()
			readyToRerun = true
			io.emit('clickable', true)
		} else {
			killProcesses(function() {
				startProcesses()
				readyToRerun = true
				io.emit('clickable', true)
			})
		}
	} else if(readyToRerun) {
		readyToRerun = false
		io.emit('clickable', false)
		startProcesses()
		readyToRerun = true
		io.emit('clickable', true)
	}
}

io.on('connection', function(socket){
	//user connected
	socket.emit('data', JSON.stringify({
		color: color,
		commands: commands,
		name: name,
		interval: interval
	}))
	socket.on('rerun', rerun)
})

app.get('/', function(req, res) {
	res.set('Content-Type', 'text/html')
	res.send(page.index)
})

app.get('/index.html', function(req, res) {
	res.set('Content-Type', 'text/html')
	res.send(page.index)
})

app.get('/socketio.js', function(req, res) {
	res.set('Content-Type', 'text/html')
	res.send(page.socketio)
})

app.get('/jquery.js', function(req, res) {
	res.set('Content-Type', 'text/html')
	res.send(page.jquery)
})

page.index = fs.readFileSync(path.resolve(__dirname, './page/index.html'))
page.socketio = fs.readFileSync(path.resolve(__dirname, './page/socketio.js'))
page.jquery = fs.readFileSync(path.resolve(__dirname, './page/jquery.js'))

verifyColor()
verifyCommands()
verifyInterval()

http.listen(port, function() {
	console.log('rebuzzer started')
	console.log('  name: ' + name)
	console.log('  commands:')
	for(index in commands) {
		console.log('    ' + (parseInt(index) + 1) + ': "' + commands[index] + '"')
	}
	console.log('  port ' + port)
	if(interval > 0) {
		console.log('  interval: ' + interval)
	}
})
 at SyntaxError: Unexpected character '#' (1:78)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$7.getTokenFromCode (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2756:10)
    at Parser.pp$7.readToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2477:17)
    at Parser.readToken (/root/ExpoSE/lib/Tropigate/bin/Tokens.js:124:26)
    at Parser.pp$7.nextToken (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2468:15)
    at Parser.pp$7.next (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2413:10)
    at Parser.pp.eat (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:536:12)
    at Parser.pp.semicolon (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:581:15)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:918:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
