
> weex-lint@0.1.10 postinstall /root/Targets/weex-lint/node_modules/weex-lint
> echo '

  NOTICE: 请使用 tnpm 安装本工具，npm 中将不再更新！

'



  NOTICE: 请使用 tnpm 安装本工具，npm 中将不再更新！


/root/Targets/weex-lint
└─┬ weex-lint@0.1.10 
  ├─┬ chai@3.5.0 
  │ ├── assertion-error@1.0.2 
  │ ├─┬ deep-eql@0.1.3 
  │ │ └── type-detect@0.1.1 
  │ └── type-detect@1.0.0 
  ├── commander@2.11.0 
  ├─┬ eslint@3.19.0 
  │ ├─┬ babel-code-frame@6.26.0 
  │ │ └── js-tokens@3.0.2 
  │ ├─┬ chalk@1.1.3 
  │ │ ├── ansi-styles@2.2.1 
  │ │ ├── has-ansi@2.0.0 
  │ │ ├── strip-ansi@3.0.1 
  │ │ └── supports-color@2.0.0 
  │ ├─┬ concat-stream@1.6.0 
  │ │ ├── inherits@2.0.3 
  │ │ ├─┬ readable-stream@2.3.3 
  │ │ │ ├── core-util-is@1.0.2 
  │ │ │ ├── process-nextick-args@1.0.7 
  │ │ │ ├── safe-buffer@5.1.1 
  │ │ │ ├── string_decoder@1.0.3 
  │ │ │ └── util-deprecate@1.0.2 
  │ │ └── typedarray@0.0.6 
  │ ├─┬ debug@2.6.9 
  │ │ └── ms@2.0.0 
  │ ├─┬ doctrine@2.0.0 
  │ │ └── isarray@1.0.0 
  │ ├─┬ escope@3.6.0 
  │ │ ├─┬ es6-map@0.1.5 
  │ │ │ ├── d@1.0.0 
  │ │ │ ├── es5-ext@0.10.30 
  │ │ │ ├── es6-iterator@2.0.1 
  │ │ │ ├── es6-set@0.1.5 
  │ │ │ ├── es6-symbol@3.1.1 
  │ │ │ └── event-emitter@0.3.5 
  │ │ ├── es6-weak-map@2.0.2 
  │ │ └── esrecurse@4.2.0 
  │ ├─┬ espree@3.5.1 
  │ │ ├── acorn@5.1.2 
  │ │ └─┬ acorn-jsx@3.0.1 
  │ │   └── acorn@3.3.0 
  │ ├── esquery@1.0.0 
  │ ├── estraverse@4.2.0 
  │ ├── esutils@2.0.2 
  │ ├─┬ file-entry-cache@2.0.0 
  │ │ ├─┬ flat-cache@1.3.0 
  │ │ │ ├── circular-json@0.3.3 
  │ │ │ ├─┬ del@2.2.2 
  │ │ │ │ ├─┬ globby@5.0.0 
  │ │ │ │ │ ├─┬ array-union@1.0.2 
  │ │ │ │ │ │ └── array-uniq@1.0.3 
  │ │ │ │ │ └── arrify@1.0.1 
  │ │ │ │ ├── is-path-cwd@1.0.0 
  │ │ │ │ ├─┬ is-path-in-cwd@1.0.0 
  │ │ │ │ │ └── is-path-inside@1.0.0 
  │ │ │ │ ├── pify@2.3.0 
  │ │ │ │ └─┬ pinkie-promise@2.0.1 
  │ │ │ │   └── pinkie@2.0.4 
  │ │ │ └── write@0.2.1 
  │ │ └── object-assign@4.1.1 
  │ ├─┬ glob@7.1.2 
  │ │ ├── fs.realpath@1.0.0 
  │ │ ├─┬ inflight@1.0.6 
  │ │ │ └── wrappy@1.0.2 
  │ │ ├─┬ minimatch@3.0.4 
  │ │ │ └─┬ brace-expansion@1.1.8 
  │ │ │   ├── balanced-match@1.0.0 
  │ │ │   └── concat-map@0.0.1 
  │ │ ├── once@1.4.0 
  │ │ └── path-is-absolute@1.0.1 
  │ ├── globals@9.18.0 
  │ ├── ignore@3.3.5 
  │ ├── imurmurhash@0.1.4 
  │ ├─┬ inquirer@0.12.0 
  │ │ ├── ansi-escapes@1.4.0 
  │ │ ├── ansi-regex@2.1.1 
  │ │ ├─┬ cli-cursor@1.0.2 
  │ │ │ └─┬ restore-cursor@1.0.1 
  │ │ │   ├── exit-hook@1.1.1 
  │ │ │   └── onetime@1.1.0 
  │ │ ├── cli-width@2.2.0 
  │ │ ├── figures@1.7.0 
  │ │ ├─┬ readline2@1.0.1 
  │ │ │ ├── code-point-at@1.1.0 
  │ │ │ ├─┬ is-fullwidth-code-point@1.0.0 
  │ │ │ │ └── number-is-nan@1.0.1 
  │ │ │ └── mute-stream@0.0.5 
  │ │ ├── run-async@0.1.0 
  │ │ ├── rx-lite@3.1.2 
  │ │ ├── string-width@1.0.2 
  │ │ └── through@2.3.8 
  │ ├─┬ is-my-json-valid@2.16.1 
  │ │ ├── generate-function@2.0.0 
  │ │ ├─┬ generate-object-property@1.2.0 
  │ │ │ └── is-property@1.0.2 
  │ │ ├── jsonpointer@4.0.1 
  │ │ └── xtend@4.0.1 
  │ ├─┬ is-resolvable@1.0.0 
  │ │ └── tryit@1.0.3 
  │ ├─┬ js-yaml@3.10.0 
  │ │ ├─┬ argparse@1.0.9 
  │ │ │ └── sprintf-js@1.0.3 
  │ │ └── esprima@4.0.0 
  │ ├─┬ json-stable-stringify@1.0.1 
  │ │ └── jsonify@0.0.0 
  │ ├─┬ levn@0.3.0 
  │ │ ├── prelude-ls@1.1.2 
  │ │ └── type-check@0.3.2 
  │ ├── lodash@4.17.4 
  │ ├─┬ mkdirp@0.5.1 
  │ │ └── minimist@0.0.8 
  │ ├── natural-compare@1.4.0 
  │ ├─┬ optionator@0.8.2 
  │ │ ├── deep-is@0.1.3 
  │ │ ├── fast-levenshtein@2.0.6 
  │ │ └── wordwrap@1.0.0 
  │ ├── path-is-inside@1.0.2 
  │ ├── pluralize@1.2.1 
  │ ├── progress@1.1.8 
  │ ├─┬ require-uncached@1.0.3 
  │ │ ├─┬ caller-path@0.1.0 
  │ │ │ └── callsites@0.2.0 
  │ │ └── resolve-from@1.0.1 
  │ ├─┬ shelljs@0.7.8 
  │ │ ├── interpret@1.0.4 
  │ │ └─┬ rechoir@0.6.2 
  │ │   └─┬ resolve@1.4.0 
  │ │     └── path-parse@1.0.5 
  │ ├── strip-bom@3.0.0 
  │ ├── strip-json-comments@2.0.1 
  │ ├─┬ table@3.8.3 
  │ │ ├─┬ ajv@4.11.8 
  │ │ │ └── co@4.6.0 
  │ │ ├── ajv-keywords@1.5.1 
  │ │ ├── slice-ansi@0.0.4 
  │ │ └─┬ string-width@2.1.1 
  │ │   ├── is-fullwidth-code-point@2.0.0 
  │ │   └─┬ strip-ansi@4.0.0 
  │ │     └── ansi-regex@3.0.0 
  │ ├── text-table@0.2.0 
  │ └─┬ user-home@2.0.0 
  │   └── os-homedir@1.0.2 
  ├── eslint-config-weex@0.1.4 
  ├── eslint-plugin-weex-bundle@0.0.8 
  ├─┬ mocha@3.5.3 
  │ ├── browser-stdout@1.3.0 
  │ ├─┬ commander@2.9.0 
  │ │ └── graceful-readlink@1.0.1 
  │ ├── debug@2.6.8 
  │ ├── diff@3.2.0 
  │ ├── escape-string-regexp@1.0.5 
  │ ├── glob@7.1.1 
  │ ├── growl@1.9.2 
  │ ├── he@1.1.1 
  │ ├── json3@3.3.2 
  │ ├─┬ lodash.create@3.1.1 
  │ │ ├─┬ lodash._baseassign@3.2.0 
  │ │ │ ├── lodash._basecopy@3.0.1 
  │ │ │ └─┬ lodash.keys@3.1.2 
  │ │ │   ├── lodash._getnative@3.9.1 
  │ │ │   ├── lodash.isarguments@3.1.0 
  │ │ │   └── lodash.isarray@3.0.4 
  │ │ ├── lodash._basecreate@3.0.3 
  │ │ └── lodash._isiterateecall@3.0.9 
  │ └─┬ supports-color@3.1.2 
  │   └── has-flag@1.0.0 
  ├── parse5@2.2.3 
  └─┬ weex-transformer@0.3.1 
    ├── commander@2.9.0 
    ├─┬ fs-extra@0.26.7 
    │ ├── graceful-fs@4.1.11 
    │ ├── jsonfile@2.4.0 
    │ ├── klaw@1.3.1 
    │ └── rimraf@2.6.2 
    ├─┬ md5@2.1.0 
    │ ├── charenc@0.0.2 
    │ ├── crypt@0.0.2 
    │ └── is-buffer@1.1.5 
    ├── parse5@2.1.5 
    ├── printf@0.2.5 
    ├─┬ weex-scripter@0.1.5 
    │ ├─┬ browserify@13.0.1 
    │ │ ├── assert@1.3.0 
    │ │ ├─┬ browser-pack@6.0.2 
    │ │ │ ├─┬ combine-source-map@0.7.2 
    │ │ │ │ ├── convert-source-map@1.1.3 
    │ │ │ │ ├── inline-source-map@0.6.2 
    │ │ │ │ ├── lodash.memoize@3.0.4 
    │ │ │ │ └── source-map@0.5.7 
    │ │ │ └── umd@3.0.1 
    │ │ ├─┬ browser-resolve@1.11.2 
    │ │ │ └── resolve@1.1.7 
    │ │ ├─┬ browserify-zlib@0.1.4 
    │ │ │ └── pako@0.2.9 
    │ │ ├─┬ buffer@4.9.1 
    │ │ │ ├── base64-js@1.2.1 
    │ │ │ └── ieee754@1.1.8 
    │ │ ├─┬ concat-stream@1.5.2 
    │ │ │ └── readable-stream@2.0.6 
    │ │ ├─┬ console-browserify@1.1.0 
    │ │ │ └── date-now@0.1.4 
    │ │ ├── constants-browserify@1.0.0 
    │ │ ├─┬ crypto-browserify@3.11.1 
    │ │ │ ├─┬ browserify-cipher@1.0.0 
    │ │ │ │ ├─┬ browserify-aes@1.0.8 
    │ │ │ │ │ └── buffer-xor@1.0.3 
    │ │ │ │ ├─┬ browserify-des@1.0.0 
    │ │ │ │ │ └── des.js@1.0.0 
    │ │ │ │ └─┬ evp_bytestokey@1.0.3 
    │ │ │ │   └─┬ md5.js@1.3.4 
    │ │ │ │     └── hash-base@3.0.4 
    │ │ │ ├─┬ browserify-sign@4.0.4 
    │ │ │ │ ├── bn.js@4.11.8 
    │ │ │ │ ├── browserify-rsa@4.0.1 
    │ │ │ │ ├─┬ elliptic@6.4.0 
    │ │ │ │ │ ├── brorand@1.1.0 
    │ │ │ │ │ ├── hash.js@1.1.3 
    │ │ │ │ │ ├── hmac-drbg@1.0.1 
    │ │ │ │ │ ├── minimalistic-assert@1.0.0 
    │ │ │ │ │ └── minimalistic-crypto-utils@1.0.1 
    │ │ │ │ └─┬ parse-asn1@5.1.0 
    │ │ │ │   └── asn1.js@4.9.1 
    │ │ │ ├── create-ecdh@4.0.0 
    │ │ │ ├─┬ create-hash@1.1.3 
    │ │ │ │ ├── cipher-base@1.0.4 
    │ │ │ │ └─┬ ripemd160@2.0.1 
    │ │ │ │   └── hash-base@2.0.2 
    │ │ │ ├── create-hmac@1.1.6 
    │ │ │ ├─┬ diffie-hellman@5.0.2 
    │ │ │ │ └── miller-rabin@4.0.1 
    │ │ │ ├── pbkdf2@3.0.14 
    │ │ │ ├── public-encrypt@4.0.0 
    │ │ │ └── randombytes@2.0.5 
    │ │ ├── defined@1.0.0 
    │ │ ├── deps-sort@2.0.0 
    │ │ ├── domain-browser@1.1.7 
    │ │ ├── duplexer2@0.1.4 
    │ │ ├── events@1.1.1 
    │ │ ├── glob@5.0.15 
    │ │ ├─┬ has@1.0.1 
    │ │ │ └── function-bind@1.1.1 
    │ │ ├── htmlescape@1.1.1 
    │ │ ├── https-browserify@0.0.1 
    │ │ ├─┬ insert-module-globals@7.0.1 
    │ │ │ ├─┬ concat-stream@1.5.2 
    │ │ │ │ └─┬ readable-stream@2.0.6 
    │ │ │ │   └── string_decoder@0.10.31 
    │ │ │ └─┬ lexical-scope@1.2.0 
    │ │ │   └─┬ astw@2.2.0 
    │ │ │     └── acorn@4.0.13 
    │ │ ├─┬ JSONStream@1.3.1 
    │ │ │ └── jsonparse@1.3.1 
    │ │ ├─┬ labeled-stream-splicer@2.0.0 
    │ │ │ ├── isarray@0.0.1 
    │ │ │ └── stream-splicer@2.0.0 
    │ │ ├─┬ module-deps@4.1.1 
    │ │ │ ├── cached-path-relative@1.0.1 
    │ │ │ ├─┬ concat-stream@1.5.2 
    │ │ │ │ └─┬ readable-stream@2.0.6 
    │ │ │ │   └── string_decoder@0.10.31 
    │ │ │ ├─┬ detective@4.5.0 
    │ │ │ │ └── acorn@4.0.13 
    │ │ │ └── stream-combiner2@1.1.1 
    │ │ ├── os-browserify@0.1.2 
    │ │ ├─┬ parents@1.0.1 
    │ │ │ └── path-platform@0.11.15 
    │ │ ├── path-browserify@0.0.0 
    │ │ ├── process@0.11.10 
    │ │ ├── punycode@1.4.1 
    │ │ ├── querystring-es3@0.2.1 
    │ │ ├── read-only-stream@2.0.0 
    │ │ ├─┬ shasum@1.0.2 
    │ │ │ ├── json-stable-stringify@0.0.1 
    │ │ │ └── sha.js@2.4.9 
    │ │ ├─┬ shell-quote@1.6.1 
    │ │ │ ├── array-filter@0.0.1 
    │ │ │ ├── array-map@0.0.0 
    │ │ │ └── array-reduce@0.0.0 
    │ │ ├── stream-browserify@2.0.1 
    │ │ ├─┬ stream-http@2.7.2 
    │ │ │ ├── builtin-status-codes@3.0.0 
    │ │ │ └── to-arraybuffer@1.0.1 
    │ │ ├── string_decoder@0.10.31 
    │ │ ├─┬ subarg@1.0.0 
    │ │ │ └── minimist@1.2.0 
    │ │ ├─┬ syntax-error@1.3.0 
    │ │ │ └── acorn@4.0.13 
    │ │ ├── through2@2.0.3 
    │ │ ├── timers-browserify@1.4.2 
    │ │ ├── tty-browserify@0.0.0 
    │ │ ├─┬ url@0.11.0 
    │ │ │ ├── punycode@1.3.2 
    │ │ │ └── querystring@0.2.0 
    │ │ ├─┬ util@0.10.3 
    │ │ │ └── inherits@2.0.1 
    │ │ └─┬ vm-browserify@0.0.4 
    │ │   └── indexof@0.0.1 
    │ ├─┬ escodegen@1.7.1 
    │ │ ├── esprima@1.2.5 
    │ │ ├── estraverse@1.9.3 
    │ │ ├─┬ optionator@0.5.0 
    │ │ │ ├── fast-levenshtein@1.0.7 
    │ │ │ ├── levn@0.2.5 
    │ │ │ └── wordwrap@0.0.3 
    │ │ └─┬ source-map@0.2.0 
    │ │   └── amdefine@1.0.1 
    │ ├── esprima@2.7.3 
    │ └─┬ resolve-bin@0.4.0 
    │   └── find-parent-dir@0.3.0 
    ├─┬ weex-styler@0.0.17 
    │ └─┬ css@2.2.1 
    │   ├── source-map@0.1.43 
    │   ├─┬ source-map-resolve@0.3.1 
    │   │ ├── atob@1.1.3 
    │   │ ├── resolve-url@0.2.1 
    │   │ └── source-map-url@0.3.0 
    │   └── urix@0.1.0 
    └─┬ weex-templater@0.2.3 
      └── parse5@2.1.5 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/weex-lint/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 56.00000000000001% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","create","freeze","Array","cwd","RegExp"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0704 took 125.7516s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (12:6) on program /**
 * @fileoverview Main ESLint object.
 * @author Nicholas C. Zakas
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const assert = require("assert"),
    EventEmitter = require("events").EventEmitter,
    escope = require("escope"),
    levn = require("levn"),
    blankScriptAST = require("../conf/blank-script.json"),
    DEFAULT_PARSER = require("../conf/eslint-recommended").parser,
    replacements = require("../conf/replacements.json"),
    CodePathAnalyzer = require("./code-path-analysis/code-path-analyzer"),
    ConfigOps = require("./config/config-ops"),
    validator = require("./config/config-validator"),
    Environments = require("./config/environments"),
    CommentEventGenerator = require("./util/comment-event-generator"),
    NodeEventGenerator = require("./util/node-event-generator"),
    SourceCode = require("./util/source-code"),
    Traverser = require("./util/traverser"),
    RuleContext = require("./rule-context"),
    rules = require("./rules"),
    timing = require("./timing"),

    pkg = require("../package.json");


//------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------

/**
 * The result of a parsing operation from parseForESLint()
 * @typedef {Object} CustomParseResult
 * @property {ASTNode} ast The ESTree AST Program node.
 * @property {Object} services An object containing additional services related
 *      to the parser.
 */

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Parses a list of "name:boolean_value" or/and "name" options divided by comma or
 * whitespace.
 * @param {string} string The string to parse.
 * @param {Comment} comment The comment node which has the string.
 * @returns {Object} Result map object of names and boolean values
 */
function parseBooleanConfig(string, comment) {
    const items = {};

    // Collapse whitespace around `:` and `,` to make parsing easier
    string = string.replace(/\s*([:,])\s*/g, "$1");

    string.split(/\s|,+/).forEach(name => {
        if (!name) {
            return;
        }
        const pos = name.indexOf(":");
        let value;

        if (pos !== -1) {
            value = name.substring(pos + 1, name.length);
            name = name.substring(0, pos);
        }

        items[name] = {
            value: (value === "true"),
            comment
        };

    });
    return items;
}

/**
 * Parses a JSON-like config.
 * @param {string} string The string to parse.
 * @param {Object} location Start line and column of comments for potential error message.
 * @param {Object[]} messages The messages queue for potential error message.
 * @returns {Object} Result map object
 */
function parseJsonConfig(string, location, messages) {
    let items = {};

    // Parses a JSON-like comment by the same way as parsing CLI option.
    try {
        items = levn.parse("Object", string) || {};

        // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.
        // Also, commaless notations have invalid severity:
        //     "no-alert: 2 no-console: 2" --> {"no-alert": "2 no-console: 2"}
        // Should ignore that case as well.
        if (ConfigOps.isEverySeverityValid(items)) {
            return items;
        }
    } catch (ex) {

        // ignore to parse the string by a fallback.
    }

    // Optionator cannot parse commaless notations.
    // But we are supporting that. So this is a fallback for that.
    items = {};
    string = string.replace(/([a-zA-Z0-9\-/]+):/g, "\"$1\":").replace(/(]|[0-9])\s+(?=")/, "$1,");
    try {
        items = JSON.parse(`{${string}}`);
    } catch (ex) {

        messages.push({
            ruleId: null,
            fatal: true,
            severity: 2,
            source: null,
            message: `Failed to parse JSON from '${string}': ${ex.message}`,
            line: location.start.line,
            column: location.start.column + 1
        });

    }

    return items;
}

/**
 * Parses a config of values separated by comma.
 * @param {string} string The string to parse.
 * @returns {Object} Result map of values and true values
 */
function parseListConfig(string) {
    const items = {};

    // Collapse whitespace around ,
    string = string.replace(/\s*,\s*/g, ",");

    string.split(/,+/).forEach(name => {
        name = name.trim();
        if (!name) {
            return;
        }
        items[name] = true;
    });
    return items;
}

/**
 * Ensures that variables representing built-in properties of the Global Object,
 * and any globals declared by special block comments, are present in the global
 * scope.
 * @param {ASTNode} program The top node of the AST.
 * @param {Scope} globalScope The global scope.
 * @param {Object} config The existing configuration data.
 * @returns {void}
 */
function addDeclaredGlobals(program, globalScope, config) {
    const declaredGlobals = {},
        exportedGlobals = {},
        explicitGlobals = {},
        builtin = Environments.get("builtin");

    Object.assign(declaredGlobals, builtin);

    Object.keys(config.env).forEach(name => {
        if (config.env[name]) {
            const env = Environments.get(name),
                environmentGlobals = env && env.globals;

            if (environmentGlobals) {
                Object.assign(declaredGlobals, environmentGlobals);
            }
        }
    });

    Object.assign(exportedGlobals, config.exported);
    Object.assign(declaredGlobals, config.globals);
    Object.assign(explicitGlobals, config.astGlobals);

    Object.keys(declaredGlobals).forEach(name => {
        let variable = globalScope.set.get(name);

        if (!variable) {
            variable = new escope.Variable(name, globalScope);
            variable.eslintExplicitGlobal = false;
            globalScope.variables.push(variable);
            globalScope.set.set(name, variable);
        }
        variable.writeable = declaredGlobals[name];
    });

    Object.keys(explicitGlobals).forEach(name => {
        let variable = globalScope.set.get(name);

        if (!variable) {
            variable = new escope.Variable(name, globalScope);
            variable.eslintExplicitGlobal = true;
            variable.eslintExplicitGlobalComment = explicitGlobals[name].comment;
            globalScope.variables.push(variable);
            globalScope.set.set(name, variable);
        }
        variable.writeable = explicitGlobals[name].value;
    });

    // mark all exported variables as such
    Object.keys(exportedGlobals).forEach(name => {
        const variable = globalScope.set.get(name);

        if (variable) {
            variable.eslintUsed = true;
        }
    });

    /*
     * "through" contains all references which definitions cannot be found.
     * Since we augment the global scope using configuration, we need to update
     * references and remove the ones that were added by configuration.
     */
    globalScope.through = globalScope.through.filter(reference => {
        const name = reference.identifier.name;
        const variable = globalScope.set.get(name);

        if (variable) {

            /*
             * Links the variable and the reference.
             * And this reference is removed from `Scope#through`.
             */
            reference.resolved = variable;
            variable.references.push(reference);

            return false;
        }

        return true;
    });
}

/**
 * Add data to reporting configuration to disable reporting for list of rules
 * starting from start location
 * @param  {Object[]} reportingConfig Current reporting configuration
 * @param  {Object} start Position to start
 * @param  {string[]} rulesToDisable List of rules
 * @returns {void}
 */
function disableReporting(reportingConfig, start, rulesToDisable) {

    if (rulesToDisable.length) {
        rulesToDisable.forEach(rule => {
            reportingConfig.push({
                start,
                end: null,
                rule
            });
        });
    } else {
        reportingConfig.push({
            start,
            end: null,
            rule: null
        });
    }
}

/**
 * Add data to reporting configuration to enable reporting for list of rules
 * starting from start location
 * @param  {Object[]} reportingConfig Current reporting configuration
 * @param  {Object} start Position to start
 * @param  {string[]} rulesToEnable List of rules
 * @returns {void}
 */
function enableReporting(reportingConfig, start, rulesToEnable) {
    let i;

    if (rulesToEnable.length) {
        rulesToEnable.forEach(rule => {
            for (i = reportingConfig.length - 1; i >= 0; i--) {
                if (!reportingConfig[i].end && reportingConfig[i].rule === rule) {
                    reportingConfig[i].end = start;
                    break;
                }
            }
        });
    } else {

        // find all previous disabled locations if they was started as list of rules
        let prevStart;

        for (i = reportingConfig.length - 1; i >= 0; i--) {
            if (prevStart && prevStart !== reportingConfig[i].start) {
                break;
            }

            if (!reportingConfig[i].end) {
                reportingConfig[i].end = start;
                prevStart = reportingConfig[i].start;
            }
        }
    }
}

/**
 * Parses comments in file to extract file-specific config of rules, globals
 * and environments and merges them with global config; also code blocks
 * where reporting is disabled or enabled and merges them with reporting config.
 * @param {string} filename The file being checked.
 * @param {ASTNode} ast The top node of the AST.
 * @param {Object} config The existing configuration data.
 * @param {Object[]} reportingConfig The existing reporting configuration data.
 * @param {Object[]} messages The messages queue.
 * @returns {Object} Modified config object
 */
function modifyConfigsFromComments(filename, ast, config, reportingConfig, messages) {

    let commentConfig = {
        exported: {},
        astGlobals: {},
        rules: {},
        env: {}
    };
    const commentRules = {};

    ast.comments.forEach(comment => {

        let value = comment.value.trim();
        const match = /^(eslint(-\w+){0,3}|exported|globals?)(\s|$)/.exec(value);

        if (match) {
            value = value.substring(match.index + match[1].length);

            if (comment.type === "Block") {
                switch (match[1]) {
                    case "exported":
                        Object.assign(commentConfig.exported, parseBooleanConfig(value, comment));
                        break;

                    case "globals":
                    case "global":
                        Object.assign(commentConfig.astGlobals, parseBooleanConfig(value, comment));
                        break;

                    case "eslint-env":
                        Object.assign(commentConfig.env, parseListConfig(value));
                        break;

                    case "eslint-disable":
                        disableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));
                        break;

                    case "eslint-enable":
                        enableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));
                        break;

                    case "eslint": {
                        const items = parseJsonConfig(value, comment.loc, messages);

                        Object.keys(items).forEach(name => {
                            const ruleValue = items[name];

                            validator.validateRuleOptions(name, ruleValue, `${filename} line ${comment.loc.start.line}`);
                            commentRules[name] = ruleValue;
                        });
                        break;
                    }

                    // no default
                }
            } else {        // comment.type === "Line"
                if (match[1] === "eslint-disable-line") {
                    disableReporting(reportingConfig, { line: comment.loc.start.line, column: 0 }, Object.keys(parseListConfig(value)));
                    enableReporting(reportingConfig, comment.loc.end, Object.keys(parseListConfig(value)));
                } else if (match[1] === "eslint-disable-next-line") {
                    disableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));
                    enableReporting(reportingConfig, { line: comment.loc.start.line + 2 }, Object.keys(parseListConfig(value)));
                }
            }
        }
    });

    // apply environment configs
    Object.keys(commentConfig.env).forEach(name => {
        const env = Environments.get(name);

        if (env) {
            commentConfig = ConfigOps.merge(commentConfig, env);
        }
    });
    Object.assign(commentConfig.rules, commentRules);

    return ConfigOps.merge(config, commentConfig);
}

/**
 * Check if message of rule with ruleId should be ignored in location
 * @param  {Object[]} reportingConfig  Collection of ignore records
 * @param  {string} ruleId   Id of rule
 * @param  {Object} location Location of message
 * @returns {boolean}          True if message should be ignored, false otherwise
 */
function isDisabledByReportingConfig(reportingConfig, ruleId, location) {

    for (let i = 0, c = reportingConfig.length; i < c; i++) {

        const ignore = reportingConfig[i];

        if ((!ignore.rule || ignore.rule === ruleId) &&
            (location.line > ignore.start.line || (location.line === ignore.start.line && location.column >= ignore.start.column)) &&
            (!ignore.end || (location.line < ignore.end.line || (location.line === ignore.end.line && location.column <= ignore.end.column)))) {
            return true;
        }
    }

    return false;
}

/**
 * Normalize ECMAScript version from the initial config
 * @param  {number} ecmaVersion ECMAScript version from the initial config
 * @param  {boolean} isModule Whether the source type is module or not
 * @returns {number} normalized ECMAScript version
 */
function normalizeEcmaVersion(ecmaVersion, isModule) {

    // Need at least ES6 for modules
    if (isModule && (!ecmaVersion || ecmaVersion < 6)) {
        ecmaVersion = 6;
    }

    // Calculate ECMAScript edition number from official year version starting with
    // ES2015, which corresponds with ES6 (or a difference of 2009).
    if (ecmaVersion >= 2015) {
        ecmaVersion -= 2009;
    }

    return ecmaVersion;
}

/**
 * Process initial config to make it safe to extend by file comment config
 * @param  {Object} config Initial config
 * @returns {Object}        Processed config
 */
function prepareConfig(config) {

    config.globals = config.globals || config.global || {};
    delete config.global;

    const copiedRules = {};
    let parserOptions = {};

    if (typeof config.rules === "object") {
        Object.keys(config.rules).forEach(k => {
            const rule = config.rules[k];

            if (rule === null) {
                throw new Error(`Invalid config for rule '${k}'.`);
            }
            if (Array.isArray(rule)) {
                copiedRules[k] = rule.slice();
            } else {
                copiedRules[k] = rule;
            }
        });
    }

    // merge in environment parserOptions
    if (typeof config.env === "object") {
        Object.keys(config.env).forEach(envName => {
            const env = Environments.get(envName);

            if (config.env[envName] && env && env.parserOptions) {
                parserOptions = ConfigOps.merge(parserOptions, env.parserOptions);
            }
        });
    }

    const preparedConfig = {
        rules: copiedRules,
        parser: config.parser || DEFAULT_PARSER,
        globals: ConfigOps.merge({}, config.globals),
        env: ConfigOps.merge({}, config.env || {}),
        settings: ConfigOps.merge({}, config.settings || {}),
        parserOptions: ConfigOps.merge(parserOptions, config.parserOptions || {})
    };
    const isModule = preparedConfig.parserOptions.sourceType === "module";

    if (isModule) {
        if (!preparedConfig.parserOptions.ecmaFeatures) {
            preparedConfig.parserOptions.ecmaFeatures = {};
        }

        // can't have global return inside of modules
        preparedConfig.parserOptions.ecmaFeatures.globalReturn = false;
    }

    preparedConfig.parserOptions.ecmaVersion = normalizeEcmaVersion(preparedConfig.parserOptions.ecmaVersion, isModule);

    return preparedConfig;
}

/**
 * Provide a stub rule with a given message
 * @param  {string} message The message to be displayed for the rule
 * @returns {Function}      Stub rule function
 */
function createStubRule(message) {

    /**
     * Creates a fake rule object
     * @param {Object} context context object for each rule
     * @returns {Object} collection of node to listen on
     */
    function createRuleModule(context) {
        return {
            Program(node) {
                context.report(node, message);
            }
        };
    }

    if (message) {
        return createRuleModule;
    }
    throw new Error("No message passed to stub rule");

}

/**
 * Provide a rule replacement message
 * @param  {string} ruleId Name of the rule
 * @returns {string}       Message detailing rule replacement
 */
function getRuleReplacementMessage(ruleId) {
    if (ruleId in replacements.rules) {
        const newRules = replacements.rules[ruleId];

        return `Rule '${ruleId}' was removed and replaced by: ${newRules.join(", ")}`;
    }

    return null;
}

const eslintEnvPattern = /\/\*\s*eslint-env\s(.+?)\*\//g;

/**
 * Checks whether or not there is a comment which has "eslint-env *" in a given text.
 * @param {string} text - A source code text to check.
 * @returns {Object|null} A result of parseListConfig() with "eslint-env *" comment.
 */
function findEslintEnv(text) {
    let match, retv;

    eslintEnvPattern.lastIndex = 0;

    while ((match = eslintEnvPattern.exec(text))) {
        retv = Object.assign(retv || {}, parseListConfig(match[1]));
    }

    return retv;
}

/**
 * Strips Unicode BOM from a given text.
 *
 * @param {string} text - A text to strip.
 * @returns {string} The stripped text.
 */
function stripUnicodeBOM(text) {

    /*
     * Check Unicode BOM.
     * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.
     * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters
     */
    if (text.charCodeAt(0) === 0xFEFF) {
        return text.slice(1);
    }
    return text;
}

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * Object that is responsible for verifying JavaScript text
 * @name eslint
 */
module.exports = (function() {

    const api = Object.create(new EventEmitter());
    let messages = [],
        currentConfig = null,
        currentScopes = null,
        scopeManager = null,
        currentFilename = null,
        traverser = null,
        reportingConfig = [],
        sourceCode = null;

    /**
     * Parses text into an AST. Moved out here because the try-catch prevents
     * optimization of functions, so it's best to keep the try-catch as isolated
     * as possible
     * @param {string} text The text to parse.
     * @param {Object} config The ESLint configuration object.
     * @param {string} filePath The path to the file being parsed.
     * @returns {ASTNode|CustomParseResult} The AST or parse result if successful,
     *      or null if not.
     * @private
     */
    function parse(text, config, filePath) {

        let parser,
            parserOptions = {
                loc: true,
                range: true,
                raw: true,
                tokens: true,
                comment: true,
                attachComment: true,
                filePath
            };

        try {
            parser = require(config.parser);
        } catch (ex) {
            messages.push({
                ruleId: null,
                fatal: true,
                severity: 2,
                source: null,
                message: ex.message,
                line: 0,
                column: 0
            });

            return null;
        }

        // merge in any additional parser options
        if (config.parserOptions) {
            parserOptions = Object.assign({}, config.parserOptions, parserOptions);
        }

        /*
         * Check for parsing errors first. If there's a parsing error, nothing
         * else can happen. However, a parsing error does not throw an error
         * from this method - it's just considered a fatal error message, a
         * problem that ESLint identified just like any other.
         */
        try {
            if (typeof parser.parseForESLint === "function") {
                return parser.parseForESLint(text, parserOptions);
            }
            return parser.parse(text, parserOptions);

        } catch (ex) {

            // If the message includes a leading line number, strip it:
            const message = ex.message.replace(/^line \d+:/i, "").trim();
            const source = (ex.lineNumber) ? SourceCode.splitLines(text)[ex.lineNumber - 1] : null;

            messages.push({
                ruleId: null,
                fatal: true,
                severity: 2,
                source,
                message: `Parsing error: ${message}`,

                line: ex.lineNumber,
                column: ex.column
            });

            return null;
        }
    }

    /**
     * Get the severity level of a rule (0 - none, 1 - warning, 2 - error)
     * Returns 0 if the rule config is not valid (an Array or a number)
     * @param {Array|number} ruleConfig rule configuration
     * @returns {number} 0, 1, or 2, indicating rule severity
     */
    function getRuleSeverity(ruleConfig) {
        if (typeof ruleConfig === "number") {
            return ruleConfig;
        } else if (Array.isArray(ruleConfig)) {
            return ruleConfig[0];
        }
        return 0;

    }

    /**
     * Get the options for a rule (not including severity), if any
     * @param {Array|number} ruleConfig rule configuration
     * @returns {Array} of rule options, empty Array if none
     */
    function getRuleOptions(ruleConfig) {
        if (Array.isArray(ruleConfig)) {
            return ruleConfig.slice(1);
        }
        return [];

    }

    // set unlimited listeners (see https://github.com/eslint/eslint/issues/524)
    api.setMaxListeners(0);

    /**
     * Resets the internal state of the object.
     * @returns {void}
     */
    api.reset = function() {
        this.removeAllListeners();
        messages = [];
        currentConfig = null;
        currentScopes = null;
        scopeManager = null;
        traverser = null;
        reportingConfig = [];
        sourceCode = null;
    };

    /**
     * Configuration object for the `verify` API. A JS representation of the eslintrc files.
     * @typedef {Object} ESLintConfig
     * @property {Object} rules The rule configuration to verify against.
     * @property {string} [parser] Parser to use when generatig the AST.
     * @property {Object} [parserOptions] Options for the parsed used.
     * @property {Object} [settings] Global settings passed to each rule.
     * @property {Object} [env] The environment to verify in.
     * @property {Object} [globals] Available globalsto the code.
     */

    /**
     * Verifies the text against the rules specified by the second argument.
     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.
     * @param {ESLintConfig} config An ESLintConfig instance to configure everything.
     * @param {(string|Object)} [filenameOrOptions] The optional filename of the file being checked.
     *      If this is not set, the filename will default to '<input>' in the rule context. If
     *      an object, then it has "filename", "saveState", and "allowInlineConfig" properties.
     * @param {boolean} [saveState] Indicates if the state from the last run should be saved.
     *      Mostly useful for testing purposes.
     * @param {boolean} [filenameOrOptions.allowInlineConfig] Allow/disallow inline comments' ability to change config once it is set. Defaults to true if not supplied.
     *      Useful if you want to validate JS without comments overriding rules.
     * @returns {Object[]} The results as an array of messages or null if no messages.
     */
    api.verify = function(textOrSourceCode, config, filenameOrOptions, saveState) {
        const text = (typeof textOrSourceCode === "string") ? textOrSourceCode : null;
        let ast,
            parseResult,
            shebang,
            allowInlineConfig;

        // evaluate arguments
        if (typeof filenameOrOptions === "object") {
            currentFilename = filenameOrOptions.filename;
            allowInlineConfig = filenameOrOptions.allowInlineConfig;
            saveState = filenameOrOptions.saveState;
        } else {
            currentFilename = filenameOrOptions;
        }

        if (!saveState) {
            this.reset();
        }

        // search and apply "eslint-env *".
        const envInFile = findEslintEnv(text || textOrSourceCode.text);

        config = Object.assign({}, config);

        if (envInFile) {
            if (config.env) {
                config.env = Object.assign({}, config.env, envInFile);
            } else {
                config.env = envInFile;
            }
        }

        // process initial config to make it safe to extend
        config = prepareConfig(config);

        // only do this for text
        if (text !== null) {

            // there's no input, just exit here
            if (text.trim().length === 0) {
                sourceCode = new SourceCode(text, blankScriptAST);
                return messages;
            }

            parseResult = parse(
                stripUnicodeBOM(text).replace(/^#!([^\r\n]+)/, (match, captured) => {
                    shebang = captured;
                    return `//${captured}`;
                }),
                config,
                currentFilename
            );

            // if this result is from a parseForESLint() method, normalize
            if (parseResult && parseResult.ast) {
                ast = parseResult.ast;
            } else {
                ast = parseResult;
                parseResult = null;
            }

            if (ast) {
                sourceCode = new SourceCode(text, ast);
            }

        } else {
            sourceCode = textOrSourceCode;
            ast = sourceCode.ast;
        }

        // if espree failed to parse the file, there's no sense in setting up rules
        if (ast) {

            // parse global comments and modify config
            if (allowInlineConfig !== false) {
                config = modifyConfigsFromComments(currentFilename, ast, config, reportingConfig, messages);
            }

            // ensure that severities are normalized in the config
            ConfigOps.normalize(config);

            // enable appropriate rules
            Object.keys(config.rules).filter(key => getRuleSeverity(config.rules[key]) > 0).forEach(key => {
                let ruleCreator;

                ruleCreator = rules.get(key);

                if (!ruleCreator) {
                    const replacementMsg = getRuleReplacementMessage(key);

                    if (replacementMsg) {
                        ruleCreator = createStubRule(replacementMsg);
                    } else {
                        ruleCreator = createStubRule(`Definition for rule '${key}' was not found`);
                    }
                    rules.define(key, ruleCreator);
                }

                const severity = getRuleSeverity(config.rules[key]);
                const options = getRuleOptions(config.rules[key]);

                try {
                    const ruleContext = new RuleContext(
                        key, api, severity, options,
                        config.settings, config.parserOptions, config.parser,
                        ruleCreator.meta,
                        (parseResult && parseResult.services ? parseResult.services : {})
                    );

                    const rule = ruleCreator.create ? ruleCreator.create(ruleContext)
                        : ruleCreator(ruleContext);

                    // add all the selectors from the rule as listeners
                    Object.keys(rule).forEach(selector => {
                        api.on(selector, timing.enabled
                            ? timing.time(key, rule[selector])
                            : rule[selector]
                        );
                    });
                } catch (ex) {
                    ex.message = `Error while loading rule '${key}': ${ex.message}`;
                    throw ex;
                }
            });

            // save config so rules can access as necessary
            currentConfig = config;
            traverser = new Traverser();

            const ecmaFeatures = currentConfig.parserOptions.ecmaFeatures || {};
            const ecmaVersion = currentConfig.parserOptions.ecmaVersion || 5;

            // gather scope data that may be needed by the rules
            scopeManager = escope.analyze(ast, {
                ignoreEval: true,
                nodejsScope: ecmaFeatures.globalReturn,
                impliedStrict: ecmaFeatures.impliedStrict,
                ecmaVersion,
                sourceType: currentConfig.parserOptions.sourceType || "script",
                fallback: Traverser.getKeys
            });

            currentScopes = scopeManager.scopes;

            // augment global scope with declared global variables
            addDeclaredGlobals(ast, currentScopes[0], currentConfig);

            // remove shebang comments
            if (shebang && ast.comments.length && ast.comments[0].value === shebang) {
                ast.comments.splice(0, 1);

                if (ast.body.length && ast.body[0].leadingComments && ast.body[0].leadingComments[0].value === shebang) {
                    ast.body[0].leadingComments.splice(0, 1);
                }
            }

            let eventGenerator = new NodeEventGenerator(api);

            eventGenerator = new CodePathAnalyzer(eventGenerator);
            eventGenerator = new CommentEventGenerator(eventGenerator, sourceCode);

            /*
             * Each node has a type property. Whenever a particular type of
             * node is found, an event is fired. This allows any listeners to
             * automatically be informed that this type of node has been found
             * and react accordingly.
             */
            traverser.traverse(ast, {
                enter(node, parent) {
                    node.parent = parent;
                    eventGenerator.enterNode(node);
                },
                leave(node) {
                    eventGenerator.leaveNode(node);
                }
            });
        }

        // sort by line and column
        messages.sort((a, b) => {
            const lineDiff = a.line - b.line;

            if (lineDiff === 0) {
                return a.column - b.column;
            }
            return lineDiff;

        });

        return messages;
    };

    /**
     * Reports a message from one of the rules.
     * @param {string} ruleId The ID of the rule causing the message.
     * @param {number} severity The severity level of the rule as configured.
     * @param {ASTNode} node The AST node that the message relates to.
     * @param {Object=} location An object containing the error line and column
     *      numbers. If location is not provided the node's start location will
     *      be used.
     * @param {string} message The actual message.
     * @param {Object} opts Optional template data which produces a formatted message
     *     with symbols being replaced by this object's values.
     * @param {Object} fix A fix command description.
     * @param {Object} meta Metadata of the rule
     * @returns {void}
     */
    api.report = function(ruleId, severity, node, location, message, opts, fix, meta) {
        if (node) {
            assert.strictEqual(typeof node, "object", "Node must be an object");
        }

        if (typeof location === "string") {
            assert.ok(node, "Node must be provided when reporting error if location is not provided");

            meta = fix;
            fix = opts;
            opts = message;
            message = location;
            location = node.loc.start;
        }

        // Store end location.
        const endLocation = location.end;

        location = location.start || location;

        if (isDisabledByReportingConfig(reportingConfig, ruleId, location)) {
            return;
        }

        if (opts) {
            message = message.replace(/\{\{\s*([^{}]+?)\s*\}\}/g, (fullMatch, term) => {
                if (term in opts) {
                    return opts[term];
                }

                // Preserve old behavior: If parameter name not provided, don't replace it.
                return fullMatch;
            });
        }

        const problem = {
            ruleId,
            severity,
            message,
            line: location.line,
            column: location.column + 1,   // switch to 1-base instead of 0-base
            nodeType: node && node.type,
            source: sourceCode.lines[location.line - 1] || ""
        };

        // Define endLine and endColumn if exists.
        if (endLocation) {
            problem.endLine = endLocation.line;
            problem.endColumn = endLocation.column + 1;   // switch to 1-base instead of 0-base
        }

        // ensure there's range and text properties, otherwise it's not a valid fix
        if (fix && Array.isArray(fix.range) && (typeof fix.text === "string")) {

            // If rule uses fix, has metadata, but has no metadata.fixable, we should throw
            if (meta && !meta.fixable) {
                throw new Error("Fixable rules should export a `meta.fixable` property.");
            }

            problem.fix = fix;
        }

        messages.push(problem);
    };

    /**
     * Gets the SourceCode object representing the parsed source.
     * @returns {SourceCode} The SourceCode object.
     */
    api.getSourceCode = function() {
        return sourceCode;
    };

    // methods that exist on SourceCode object
    const externalMethods = {
        getSource: "getText",
        getSourceLines: "getLines",
        getAllComments: "getAllComments",
        getNodeByRangeIndex: "getNodeByRangeIndex",
        getComments: "getComments",
        getJSDocComment: "getJSDocComment",
        getFirstToken: "getFirstToken",
        getFirstTokens: "getFirstTokens",
        getLastToken: "getLastToken",
        getLastTokens: "getLastTokens",
        getTokenAfter: "getTokenAfter",
        getTokenBefore: "getTokenBefore",
        getTokenByRangeStart: "getTokenByRangeStart",
        getTokens: "getTokens",
        getTokensAfter: "getTokensAfter",
        getTokensBefore: "getTokensBefore",
        getTokensBetween: "getTokensBetween"
    };

    // copy over methods
    Object.keys(externalMethods).forEach(methodName => {
        const exMethodName = externalMethods[methodName];

        // All functions expected to have less arguments than 5.
        api[methodName] = function(a, b, c, d, e) {
            if (sourceCode) {
                return sourceCode[exMethodName](a, b, c, d, e);
            }
            return null;
        };
    });

    /**
     * Gets nodes that are ancestors of current node.
     * @returns {ASTNode[]} Array of objects representing ancestors.
     */
    api.getAncestors = function() {
        return traverser.parents();
    };

    /**
     * Gets the scope for the current node.
     * @returns {Object} An object representing the current node's scope.
     */
    api.getScope = function() {
        const parents = traverser.parents();

        // Don't do this for Program nodes - they have no parents
        if (parents.length) {

            // if current node introduces a scope, add it to the list
            const current = traverser.current();

            if (currentConfig.parserOptions.ecmaVersion >= 6) {
                if (["BlockStatement", "SwitchStatement", "CatchClause", "FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"].indexOf(current.type) >= 0) {
                    parents.push(current);
                }
            } else {
                if (["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"].indexOf(current.type) >= 0) {
                    parents.push(current);
                }
            }

            // Ascend the current node's parents
            for (let i = parents.length - 1; i >= 0; --i) {

                // Get the innermost scope
                const scope = scopeManager.acquire(parents[i], true);

                if (scope) {
                    if (scope.type === "function-expression-name") {
                        return scope.childScopes[0];
                    }
                    return scope;

                }

            }

        }

        return currentScopes[0];
    };

    /**
     * Record that a particular variable has been used in code
     * @param {string} name The name of the variable to mark as used
     * @returns {boolean} True if the variable was found and marked as used,
     *      false if not.
     */
    api.markVariableAsUsed = function(name) {
        const hasGlobalReturn = currentConfig.parserOptions.ecmaFeatures && currentConfig.parserOptions.ecmaFeatures.globalReturn,
            specialScope = hasGlobalReturn || currentConfig.parserOptions.sourceType === "module";
        let scope = this.getScope(),
            i,
            len;

        // Special Node.js scope means we need to start one level deeper
        if (scope.type === "global" && specialScope) {
            scope = scope.childScopes[0];
        }

        do {
            const variables = scope.variables;

            for (i = 0, len = variables.length; i < len; i++) {
                if (variables[i].name === name) {
                    variables[i].eslintUsed = true;
                    return true;
                }
            }
        } while ((scope = scope.upper));

        return false;
    };

    /**
     * Gets the filename for the currently parsed source.
     * @returns {string} The filename associated with the source being parsed.
     *     Defaults to "<input>" if no filename info is present.
     */
    api.getFilename = function() {
        if (typeof currentFilename === "string") {
            return currentFilename;
        }
        return "<input>";

    };

    /**
     * Defines a new linting rule.
     * @param {string} ruleId A unique rule identifier
     * @param {Function} ruleModule Function from context to object mapping AST node types to event handlers
     * @returns {void}
     */
    const defineRule = api.defineRule = function(ruleId, ruleModule) {
        rules.define(ruleId, ruleModule);
    };

    /**
     * Defines many new linting rules.
     * @param {Object} rulesToDefine map from unique rule identifier to rule
     * @returns {void}
     */
    api.defineRules = function(rulesToDefine) {
        Object.getOwnPropertyNames(rulesToDefine).forEach(ruleId => {
            defineRule(ruleId, rulesToDefine[ruleId]);
        });
    };

    /**
     * Gets the default eslint configuration.
     * @returns {Object} Object mapping rule IDs to their default configurations
     */
    api.defaults = function() {
        return require("../conf/eslint-recommended");
    };

    /**
     * Gets an object with all loaded rules.
     * @returns {Map} All loaded rules
     */
    api.getRules = function() {
        return rules.getAllLoadedRules();
    };

    api.version = pkg.version;

    /**
     * Gets variables that are declared by a specified node.
     *
     * The variables are its `defs[].node` or `defs[].parent` is same as the specified node.
     * Specifically, below:
     *
     * - `VariableDeclaration` - variables of its all declarators.
     * - `VariableDeclarator` - variables.
     * - `FunctionDeclaration`/`FunctionExpression` - its function name and parameters.
     * - `ArrowFunctionExpression` - its parameters.
     * - `ClassDeclaration`/`ClassExpression` - its class name.
     * - `CatchClause` - variables of its exception.
     * - `ImportDeclaration` - variables of  its all specifiers.
     * - `ImportSpecifier`/`ImportDefaultSpecifier`/`ImportNamespaceSpecifier` - a variable.
     * - others - always an empty array.
     *
     * @param {ASTNode} node A node to get.
     * @returns {escope.Variable[]} Variables that are declared by the node.
     */
    api.getDeclaredVariables = function(node) {
        return (scopeManager && scopeManager.getDeclaredVariables(node)) || [];
    };

    return api;

}());
 at SyntaxError: Unexpected token (12:6)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/weex-lint/node_modules/weex-lint/index.js. Coverage (Term): 22% Coverage (LOC): 29%
*- File /root/Targets/weex-lint/node_modules/weex-lint/lib/diagnose.js. Coverage (Term): 15% Coverage (LOC): 20%
*- File /root/Targets/weex-lint/node_modules/weex-lint/lib/utils/index.js. Coverage (Term): 22% Coverage (LOC): 52%
*- File /root/Targets/weex-lint/node_modules/weex-lint/lib/utils/env.js. Coverage (Term): 20% Coverage (LOC): 15%
*- File /root/Targets/weex-lint/node_modules/weex-lint/lib/utils/copy.js. Coverage (Term): 31% Coverage (LOC): 45%
*- File /root/Targets/weex-lint/node_modules/weex-lint/lib/utils/download.js. Coverage (Term): 23% Coverage (LOC): 24%
*- File /root/Targets/weex-lint/node_modules/weex-lint/lib/process/index.js. Coverage (Term): 23% Coverage (LOC): 24%
*- File /root/Targets/weex-lint/node_modules/weex-lint/lib/process/convert.js. Coverage (Term): 40% Coverage (LOC): 44%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/index.js. Coverage (Term): 13% Coverage (LOC): 24%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/lib/parser.js. Coverage (Term): 9% Coverage (LOC): 10%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/lib/blocker.js. Coverage (Term): 10% Coverage (LOC): 12%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/index.js. Coverage (Term): 48% Coverage (LOC): 61%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/parser/index.js. Coverage (Term): 19% Coverage (LOC): 25%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/tokenizer/index.js. Coverage (Term): 13% Coverage (LOC): 20%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/tokenizer/preprocessor.js. Coverage (Term): 16% Coverage (LOC): 28%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/common/unicode.js. Coverage (Term): 99% Coverage (LOC): 100%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/location_info/tokenizer_mixin.js. Coverage (Term): 6% Coverage (LOC): 7%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/tokenizer/named_entity_trie.js. Coverage (Term): 100% Coverage (LOC): 100%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/parser/open_element_stack.js. Coverage (Term): 11% Coverage (LOC): 26%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/common/html.js. Coverage (Term): 100% Coverage (LOC): 100%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/parser/formatting_element_list.js. Coverage (Term): 12% Coverage (LOC): 23%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/location_info/parser_mixin.js. Coverage (Term): 6% Coverage (LOC): 7%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/tree_adapters/default.js. Coverage (Term): 21% Coverage (LOC): 42%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/common/doctype.js. Coverage (Term): 39% Coverage (LOC): 74%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/common/foreign_content.js. Coverage (Term): 61% Coverage (LOC): 86%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/common/merge_options.js. Coverage (Term): 27% Coverage (LOC): 36%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/serializer/index.js. Coverage (Term): 15% Coverage (LOC): 27%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/tree_adapters/htmlparser2.js. Coverage (Term): 19% Coverage (LOC): 36%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/parser/stream.js. Coverage (Term): 25% Coverage (LOC): 37%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/serializer/stream.js. Coverage (Term): 49% Coverage (LOC): 50%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/sax/index.js. Coverage (Term): 24% Coverage (LOC): 31%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/sax/dev_null_stream.js. Coverage (Term): 69% Coverage (LOC): 82%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/node_modules/parse5/lib/sax/parser_feedback_simulator.js. Coverage (Term): 18% Coverage (LOC): 27%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/lib/finder.js. Coverage (Term): 34% Coverage (LOC): 45%
*- File /root/Targets/weex-lint/node_modules/weex-transformer/lib/join.js. Coverage (Term): 15% Coverage (LOC): 22%
*- File /root/Targets/weex-lint/node_modules/weex-scripter/index.js. Coverage (Term): 98% Coverage (LOC): 100%
*- File /root/Targets/weex-lint/node_modules/weex-scripter/lib/fix.js. Coverage (Term): 21% Coverage (LOC): 41%
*- File /root/Targets/weex-lint/node_modules/weex-scripter/node_modules/esprima/esprima.js. Coverage (Term): 4% Coverage (LOC): 11%
*- File /root/Targets/weex-lint/node_modules/escodegen/escodegen.js. Coverage (Term): 6% Coverage (LOC): 14%
*- File /root/Targets/weex-lint/node_modules/escodegen/node_modules/estraverse/estraverse.js. Coverage (Term): 20% Coverage (LOC): 45%
*- File /root/Targets/weex-lint/node_modules/esutils/lib/utils.js. Coverage (Term): 95% Coverage (LOC): 100%
*- File /root/Targets/weex-lint/node_modules/esutils/lib/ast.js. Coverage (Term): 12% Coverage (LOC): 17%
*- File /root/Targets/weex-lint/node_modules/esutils/lib/code.js. Coverage (Term): 42% Coverage (LOC): 79%
*- File /root/Targets/weex-lint/node_modules/esutils/lib/keyword.js. Coverage (Term): 10% Coverage (LOC): 25%
*- File /root/Targets/weex-lint/node_modules/weex-scripter/lib/require-parse.js. Coverage (Term): 21% Coverage (LOC): 21%
*- File /root/Targets/weex-lint/node_modules/md5/md5.js. Coverage (Term): 5% Coverage (LOC): 14%
*- File /root/Targets/weex-lint/node_modules/crypt/crypt.js. Coverage (Term): 7% Coverage (LOC): 29%
*- File /root/Targets/weex-lint/node_modules/charenc/charenc.js. Coverage (Term): 20% Coverage (LOC): 56%
*- File /root/Targets/weex-lint/node_modules/is-buffer/index.js. Coverage (Term): 22% Coverage (LOC): 67%
*- File /root/Targets/weex-lint/node_modules/weex-scripter/lib/require-bundle.js. Coverage (Term): 26% Coverage (LOC): 32%
*- File /root/Targets/weex-lint/node_modules/resolve-bin/index.js. Coverage (Term): 15% Coverage (LOC): 24%
*- File /root/Targets/weex-lint/node_modules/find-parent-dir/index.js. Coverage (Term): 23% Coverage (LOC): 30%
*- File /root/Targets/weex-lint/node_modules/weex-templater/index.js. Coverage (Term): 7% Coverage (LOC): 6%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/index.js. Coverage (Term): 48% Coverage (LOC): 61%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/parser/index.js. Coverage (Term): 19% Coverage (LOC): 25%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/tokenizer/index.js. Coverage (Term): 13% Coverage (LOC): 20%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/tokenizer/preprocessor.js. Coverage (Term): 16% Coverage (LOC): 28%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/common/unicode.js. Coverage (Term): 99% Coverage (LOC): 100%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/location_info/tokenizer_mixin.js. Coverage (Term): 6% Coverage (LOC): 7%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/tokenizer/named_entity_trie.js. Coverage (Term): 100% Coverage (LOC): 100%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/parser/open_element_stack.js. Coverage (Term): 11% Coverage (LOC): 26%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/common/html.js. Coverage (Term): 100% Coverage (LOC): 100%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/parser/formatting_element_list.js. Coverage (Term): 12% Coverage (LOC): 23%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/location_info/parser_mixin.js. Coverage (Term): 6% Coverage (LOC): 7%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/tree_adapters/default.js. Coverage (Term): 21% Coverage (LOC): 42%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/common/doctype.js. Coverage (Term): 39% Coverage (LOC): 74%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/common/foreign_content.js. Coverage (Term): 61% Coverage (LOC): 86%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/common/merge_options.js. Coverage (Term): 27% Coverage (LOC): 36%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/serializer/index.js. Coverage (Term): 15% Coverage (LOC): 27%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/tree_adapters/htmlparser2.js. Coverage (Term): 19% Coverage (LOC): 36%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/parser/stream.js. Coverage (Term): 25% Coverage (LOC): 37%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/serializer/stream.js. Coverage (Term): 49% Coverage (LOC): 50%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/sax/index.js. Coverage (Term): 24% Coverage (LOC): 31%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/sax/dev_null_stream.js. Coverage (Term): 69% Coverage (LOC): 82%
*- File /root/Targets/weex-lint/node_modules/weex-templater/node_modules/parse5/lib/sax/parser_feedback_simulator.js. Coverage (Term): 18% Coverage (LOC): 27%
*- File /root/Targets/weex-lint/node_modules/weex-templater/lib/validator.js. Coverage (Term): 17% Coverage (LOC): 29%
*- File /root/Targets/weex-lint/node_modules/weex-templater/lib/exp.js. Coverage (Term): 25% Coverage (LOC): 24%
*- File /root/Targets/weex-lint/node_modules/weex-templater/lib/parsers/expression.js. Coverage (Term): 35% Coverage (LOC): 49%
*- File /root/Targets/weex-lint/node_modules/weex-templater/lib/parsers/text.js. Coverage (Term): 24% Coverage (LOC): 26%
*- File /root/Targets/weex-lint/node_modules/weex-styler/index.js. Coverage (Term): 15% Coverage (LOC): 28%
*- File /root/Targets/weex-lint/node_modules/weex-styler/lib/util.js. Coverage (Term): 29% Coverage (LOC): 50%
*- File /root/Targets/weex-lint/node_modules/weex-styler/lib/validator.js. Coverage (Term): 36% Coverage (LOC): 72%
*- File /root/Targets/weex-lint/node_modules/css/index.js. Coverage (Term): 96% Coverage (LOC): 100%
*- File /root/Targets/weex-lint/node_modules/css/lib/parse/index.js. Coverage (Term): 2% Coverage (LOC): 2%
*- File /root/Targets/weex-lint/node_modules/css/lib/stringify/index.js. Coverage (Term): 27% Coverage (LOC): 30%
*- File /root/Targets/weex-lint/node_modules/css/lib/stringify/compress.js. Coverage (Term): 20% Coverage (LOC): 63%
*- File /root/Targets/weex-lint/node_modules/css/lib/stringify/compiler.js. Coverage (Term): 26% Coverage (LOC): 48%
*- File /root/Targets/weex-lint/node_modules/inherits/inherits.js. Coverage (Term): 74% Coverage (LOC): 88%
*- File /root/Targets/weex-lint/node_modules/css/lib/stringify/identity.js. Coverage (Term): 15% Coverage (LOC): 55%
*- File /root/Targets/weex-lint/node_modules/weex-lint/lib/process/eslint.js. Coverage (Term): 23% Coverage (LOC): 26%
*- File /root/Targets/weex-lint/node_modules/eslint/lib/api.js. Coverage (Term): 56% Coverage (LOC): 67%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
