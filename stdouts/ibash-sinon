/root/Targets/ibash-sinon
└─┬ ibash-sinon@2.0.0-pre 
  ├── formatio@1.1.1 
  ├── lolex@1.3.2 
  ├── samsam@1.1.2 
  ├── text-encoding@0.5.2 
  └─┬ util@0.10.3 
    └── inherits@2.0.1 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/ibash-sinon/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 31% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","call"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0445 took 8.5195s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (84:7) on program /**
 * Assertions matching the test spy retrieval interface.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
"use strict";

var calledInOrder = require("./util/core/called-in-order");
var orderByFirstCall = require("./util/core/order-by-first-call");
var timesInWords = require("./util/core/times-in-words");
var format = require("./util/core/format");
var sinonMatch = require("./match");

var slice = Array.prototype.slice;

var assert;

function verifyIsStub() {
    var method;

    for (var i = 0, l = arguments.length; i < l; ++i) {
        method = arguments[i];

        if (!method) {
            assert.fail("fake is not a spy");
        }

        if (method.proxy && method.proxy.isSinonProxy) {
            verifyIsStub(method.proxy);
        } else {
            if (typeof method !== "function") {
                assert.fail(method + " is not a function");
            }

            if (typeof method.getCall !== "function") {
                assert.fail(method + " is not stubbed");
            }
        }

    }
}

function failAssertion(object, msg) {
    object = object || global;
    var failMethod = object.fail || assert.fail;
    failMethod.call(object, msg);
}

function mirrorPropAsAssertion(name, method, message) {
    if (arguments.length === 2) {
        message = method;
        method = name;
    }

    assert[name] = function (fake) {
        verifyIsStub(fake);

        var args = slice.call(arguments, 1);
        var failed = false;

        if (typeof method === "function") {
            failed = !method(fake);
        } else {
            failed = typeof fake[method] === "function" ?
                !fake[method].apply(fake, args) : !fake[method];
        }

        if (failed) {
            failAssertion(this, (fake.printf || fake.proxy.printf).apply(fake, [message].concat(args)));
        } else {
            assert.pass(name);
        }
    };
}

function exposedName(prefix, prop) {
    return !prefix || /^fail/.test(prop) ? prop :
        prefix + prop.slice(0, 1).toUpperCase() + prop.slice(1);
}

assert = {
    failException: "AssertError",

    fail: function fail(message) {
        var error = new Error(message);
        error.name = this.failException || assert.failException;

        throw error;
    },

    pass: function pass() {},

    callOrder: function assertCallOrder() {
        verifyIsStub.apply(null, arguments);
        var expected = "";
        var actual = "";

        if (!calledInOrder(arguments)) {
            try {
                expected = [].join.call(arguments, ", ");
                var calls = slice.call(arguments);
                var i = calls.length;
                while (i) {
                    if (!calls[--i].called) {
                        calls.splice(i, 1);
                    }
                }
                actual = orderByFirstCall(calls).join(", ");
            } catch (e) {
                // If this fails, we'll just fall back to the blank string
            }

            failAssertion(this, "expected " + expected + " to be " +
                        "called in order but were called as " + actual);
        } else {
            assert.pass("callOrder");
        }
    },

    callCount: function assertCallCount(method, count) {
        verifyIsStub(method);

        if (method.callCount !== count) {
            var msg = "expected %n to be called " + timesInWords(count) +
                " but was called %c%C";
            failAssertion(this, method.printf(msg));
        } else {
            assert.pass("callCount");
        }
    },

    expose: function expose(target, options) {
        if (!target) {
            throw new TypeError("target is null or undefined");
        }

        var o = options || {};
        var prefix = typeof o.prefix === "undefined" && "assert" || o.prefix;
        var includeFail = typeof o.includeFail === "undefined" || !!o.includeFail;

        for (var method in this) {
            if (method !== "expose" && (includeFail || !/^(fail)/.test(method))) {
                target[exposedName(prefix, method)] = this[method];
            }
        }

        return target;
    },

    match: function match(actual, expectation) {
        var matcher = sinonMatch(expectation);
        if (matcher.test(actual)) {
            assert.pass("match");
        } else {
            var formatted = [
                "expected value to match",
                "    expected = " + format(expectation),
                "    actual = " + format(actual)
            ];

            failAssertion(this, formatted.join("\n"));
        }
    }
};

mirrorPropAsAssertion("called", "expected %n to have been called at least once but was never called");
mirrorPropAsAssertion("notCalled", function (spy) {
    return !spy.called;
}, "expected %n to not have been called but was called %c%C");
mirrorPropAsAssertion("calledOnce", "expected %n to be called once but was called %c%C");
mirrorPropAsAssertion("calledTwice", "expected %n to be called twice but was called %c%C");
mirrorPropAsAssertion("calledThrice", "expected %n to be called thrice but was called %c%C");
mirrorPropAsAssertion("calledOn", "expected %n to be called with %1 as this but was called with %t");
mirrorPropAsAssertion(
    "alwaysCalledOn",
    "expected %n to always be called with %1 as this but was called with %t"
);
mirrorPropAsAssertion("calledWithNew", "expected %n to be called with new");
mirrorPropAsAssertion("alwaysCalledWithNew", "expected %n to always be called with new");
mirrorPropAsAssertion("calledWith", "expected %n to be called with arguments %*%C");
mirrorPropAsAssertion("calledWithMatch", "expected %n to be called with match %*%C");
mirrorPropAsAssertion("alwaysCalledWith", "expected %n to always be called with arguments %*%C");
mirrorPropAsAssertion("alwaysCalledWithMatch", "expected %n to always be called with match %*%C");
mirrorPropAsAssertion("calledWithExactly", "expected %n to be called with exact arguments %*%C");
mirrorPropAsAssertion("alwaysCalledWithExactly", "expected %n to always be called with exact arguments %*%C");
mirrorPropAsAssertion("neverCalledWith", "expected %n to never be called with arguments %*%C");
mirrorPropAsAssertion("neverCalledWithMatch", "expected %n to never be called with match %*%C");
mirrorPropAsAssertion("threw", "%n did not throw exception%C");
mirrorPropAsAssertion("alwaysThrew", "%n did not always throw exception%C");

module.exports = assert;
 at SyntaxError: Unexpected token (84:7)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$3.parseExprAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1822:12)
    at Parser.parseExprAtom (/root/ExpoSE/lib/Tropigate/bin/Expression.js:28:30)
    at Parser.pp$3.parseExprSubscripts (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1715:21)
    at Parser.parseMaybeUnary (/root/ExpoSE/lib/Tropigate/bin/Unary.js:34:29)
    at Parser.pp$3.parseExprOps (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1637:21)
    at Parser.pp$3.parseMaybeConditional (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1620:21)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1597:21)
    at Parser.pp$3.parseExpression (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1573:21)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/ibash-sinon/node_modules/ibash-sinon/lib/sinon.js. Coverage (Term): 16% Coverage (LOC): 18%
*- File /root/Targets/ibash-sinon/node_modules/ibash-sinon/lib/sinon/match.js. Coverage (Term): 29% Coverage (LOC): 39%
*- File /root/Targets/ibash-sinon/node_modules/ibash-sinon/lib/sinon/util/core/create.js. Coverage (Term): 93% Coverage (LOC): 100%
*- File /root/Targets/ibash-sinon/node_modules/ibash-sinon/lib/sinon/util/core/deep-equal.js. Coverage (Term): 12% Coverage (LOC): 17%
*- File /root/Targets/ibash-sinon/node_modules/ibash-sinon/lib/sinon/util/core/function-name.js. Coverage (Term): 35% Coverage (LOC): 50%
*- File /root/Targets/ibash-sinon/node_modules/ibash-sinon/lib/sinon/typeOf.js. Coverage (Term): 87% Coverage (LOC): 83%
*- File /root/Targets/ibash-sinon/node_modules/ibash-sinon/lib/sinon/util/core/index.js. Coverage (Term): 99% Coverage (LOC): 100%
*- File /root/Targets/ibash-sinon/node_modules/ibash-sinon/lib/sinon/util/core/wrap-method.js. Coverage (Term): 10% Coverage (LOC): 12%
*- File /root/Targets/ibash-sinon/node_modules/ibash-sinon/lib/sinon/util/core/get-property-descriptor.js. Coverage (Term): 37% Coverage (LOC): 50%
*- File /root/Targets/ibash-sinon/node_modules/ibash-sinon/lib/sinon/util/core/object-keys.js. Coverage (Term): 37% Coverage (LOC): 38%
*- File /root/Targets/ibash-sinon/node_modules/ibash-sinon/lib/sinon/util/core/format.js. Coverage (Term): 71% Coverage (LOC): 91%
*- File /root/Targets/ibash-sinon/node_modules/formatio/lib/formatio.js. Coverage (Term): 15% Coverage (LOC): 28%
*- File /root/Targets/ibash-sinon/node_modules/samsam/lib/samsam.js. Coverage (Term): 8% Coverage (LOC): 15%
*- File /root/Targets/ibash-sinon/node_modules/ibash-sinon/lib/sinon/util/core/function-to-string.js. Coverage (Term): 26% Coverage (LOC): 29%
*- File /root/Targets/ibash-sinon/node_modules/ibash-sinon/lib/sinon/util/core/get-config.js. Coverage (Term): 35% Coverage (LOC): 43%
*- File /root/Targets/ibash-sinon/node_modules/ibash-sinon/lib/sinon/util/core/default-config.js. Coverage (Term): 97% Coverage (LOC): 100%
*- File /root/Targets/ibash-sinon/node_modules/ibash-sinon/lib/sinon/util/core/times-in-words.js. Coverage (Term): 60% Coverage (LOC): 91%
*- File /root/Targets/ibash-sinon/node_modules/ibash-sinon/lib/sinon/util/core/called-in-order.js. Coverage (Term): 27% Coverage (LOC): 45%
*- File /root/Targets/ibash-sinon/node_modules/ibash-sinon/lib/sinon/util/core/order-by-first-call.js. Coverage (Term): 23% Coverage (LOC): 42%
*- File /root/Targets/ibash-sinon/node_modules/ibash-sinon/lib/sinon/util/core/walk.js. Coverage (Term): 15% Coverage (LOC): 25%
*- File /root/Targets/ibash-sinon/node_modules/ibash-sinon/lib/sinon/util/core/restore.js. Coverage (Term): 24% Coverage (LOC): 38%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
