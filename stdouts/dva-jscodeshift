/root/Targets/dva-jscodeshift
└─┬ dva-jscodeshift@0.3.29 
  ├── async@1.5.2 
  ├─┬ babel-core@5.8.38 
  │ ├── babel-plugin-constant-folding@1.0.1 
  │ ├── babel-plugin-dead-code-elimination@1.0.2 
  │ ├── babel-plugin-eval@1.0.1 
  │ ├── babel-plugin-inline-environment-variables@1.0.1 
  │ ├── babel-plugin-jscript@1.0.4 
  │ ├── babel-plugin-member-expression-literals@1.0.1 
  │ ├── babel-plugin-property-literals@1.0.1 
  │ ├─┬ babel-plugin-proto-to-assign@1.0.4 
  │ │ └── lodash@3.10.1 
  │ ├── babel-plugin-react-constant-elements@1.0.3 
  │ ├── babel-plugin-react-display-name@1.0.3 
  │ ├── babel-plugin-remove-console@1.0.1 
  │ ├── babel-plugin-remove-debugger@1.0.1 
  │ ├── babel-plugin-runtime@1.0.7 
  │ ├─┬ babel-plugin-undeclared-variables-check@1.0.2 
  │ │ └── leven@1.0.2 
  │ ├── babel-plugin-undefined-to-void@1.1.6 
  │ ├── babylon@5.8.38 
  │ ├── bluebird@2.11.0 
  │ ├─┬ chalk@1.1.3 
  │ │ ├── ansi-styles@2.2.1 
  │ │ ├── escape-string-regexp@1.0.5 
  │ │ ├─┬ has-ansi@2.0.0 
  │ │ │ └── ansi-regex@2.1.1 
  │ │ ├── strip-ansi@3.0.1 
  │ │ └── supports-color@2.0.0 
  │ ├── convert-source-map@1.5.0 
  │ ├── core-js@1.2.7 
  │ ├─┬ debug@2.6.9 
  │ │ └── ms@2.0.0 
  │ ├─┬ detect-indent@3.0.1 
  │ │ ├── get-stdin@4.0.1 
  │ │ └── minimist@1.2.0 
  │ ├── esutils@2.0.2 
  │ ├── fs-readdir-recursive@0.1.2 
  │ ├── globals@6.4.1 
  │ ├─┬ home-or-tmp@1.0.0 
  │ │ └── user-home@1.1.1 
  │ ├─┬ is-integer@1.0.7 
  │ │ └─┬ is-finite@1.0.2 
  │ │   └── number-is-nan@1.0.1 
  │ ├── js-tokens@1.0.1 
  │ ├── json5@0.4.0 
  │ ├── lodash@3.10.1 
  │ ├─┬ minimatch@2.0.10 
  │ │ └─┬ brace-expansion@1.1.8 
  │ │   ├── balanced-match@1.0.0 
  │ │   └── concat-map@0.0.1 
  │ ├─┬ output-file-sync@1.1.2 
  │ │ ├── graceful-fs@4.1.11 
  │ │ └── object-assign@4.1.1 
  │ ├── path-exists@1.0.0 
  │ ├── path-is-absolute@1.0.1 
  │ ├── private@0.1.7 
  │ ├─┬ regenerator@0.8.40 
  │ │ ├─┬ commoner@0.10.8 
  │ │ │ ├── commander@2.11.0 
  │ │ │ ├─┬ detective@4.5.0 
  │ │ │ │ ├── acorn@4.0.13 
  │ │ │ │ └── defined@1.0.0 
  │ │ │ ├─┬ glob@5.0.15 
  │ │ │ │ ├─┬ inflight@1.0.6 
  │ │ │ │ │ └── wrappy@1.0.2 
  │ │ │ │ ├── inherits@2.0.3 
  │ │ │ │ └── once@1.4.0 
  │ │ │ ├── iconv-lite@0.4.19 
  │ │ │ └── q@1.5.0 
  │ │ ├─┬ defs@1.1.1 
  │ │ │ ├─┬ alter@0.2.0 
  │ │ │ │ └── stable@0.1.6 
  │ │ │ ├── ast-traverse@0.1.1 
  │ │ │ ├── breakable@1.0.0 
  │ │ │ ├── simple-fmt@0.1.0 
  │ │ │ ├── simple-is@0.2.0 
  │ │ │ ├── stringmap@0.2.2 
  │ │ │ ├── stringset@0.2.1 
  │ │ │ ├── tryor@0.1.2 
  │ │ │ └─┬ yargs@3.27.0 
  │ │ │   ├── camelcase@1.2.1 
  │ │ │   ├─┬ cliui@2.1.0 
  │ │ │   │ ├─┬ center-align@0.1.3 
  │ │ │   │ │ ├─┬ align-text@0.1.4 
  │ │ │   │ │ │ └── longest@1.0.1 
  │ │ │   │ │ └── lazy-cache@1.0.4 
  │ │ │   │ ├── right-align@0.1.3 
  │ │ │   │ └── wordwrap@0.0.2 
  │ │ │   ├── decamelize@1.2.0 
  │ │ │   ├─┬ os-locale@1.4.0 
  │ │ │   │ └─┬ lcid@1.0.0 
  │ │ │   │   └── invert-kv@1.0.0 
  │ │ │   ├── window-size@0.1.4 
  │ │ │   └── y18n@3.2.1 
  │ │ ├── esprima-fb@15001.1001.0-dev-harmony-fb 
  │ │ ├─┬ recast@0.10.33 
  │ │ │ └── ast-types@0.8.12 
  │ │ └── through@2.3.8 
  │ ├─┬ regexpu@1.3.0 
  │ │ ├── esprima@2.7.3 
  │ │ ├─┬ recast@0.10.43 
  │ │ │ └── ast-types@0.8.15 
  │ │ ├── regenerate@1.3.3 
  │ │ ├── regjsgen@0.2.0 
  │ │ └─┬ regjsparser@0.1.5 
  │ │   └── jsesc@0.5.0 
  │ ├── repeating@1.1.3 
  │ ├─┬ resolve@1.4.0 
  │ │ └── path-parse@1.0.5 
  │ ├── shebang-regex@1.0.0 
  │ ├── slash@1.0.0 
  │ ├── source-map@0.5.7 
  │ ├─┬ source-map-support@0.2.10 
  │ │ └─┬ source-map@0.1.32 
  │ │   └── amdefine@1.0.1 
  │ ├── to-fast-properties@1.0.3 
  │ ├── trim-right@1.0.1 
  │ └── try-resolve@1.0.1 
  ├─┬ babel-plugin-transform-flow-strip-types@6.22.0 
  │ ├── babel-plugin-syntax-flow@6.18.0 
  │ └─┬ babel-runtime@6.26.0 
  │   ├── core-js@2.5.1 
  │   └── regenerator-runtime@0.11.0 
  ├─┬ babel-preset-es2015@6.24.1 
  │ ├── babel-plugin-check-es2015-constants@6.22.0 
  │ ├── babel-plugin-transform-es2015-arrow-functions@6.22.0 
  │ ├── babel-plugin-transform-es2015-block-scoped-functions@6.22.0 
  │ ├─┬ babel-plugin-transform-es2015-block-scoping@6.26.0 
  │ │ ├── babel-template@6.26.0 
  │ │ ├─┬ babel-traverse@6.26.0 
  │ │ │ ├── globals@9.18.0 
  │ │ │ └─┬ invariant@2.2.2 
  │ │ │   └─┬ loose-envify@1.3.1 
  │ │ │     └── js-tokens@3.0.2 
  │ │ └── babel-types@6.26.0 
  │ ├─┬ babel-plugin-transform-es2015-classes@6.24.1 
  │ │ ├── babel-helper-define-map@6.26.0 
  │ │ ├── babel-helper-function-name@6.24.1 
  │ │ ├── babel-helper-optimise-call-expression@6.24.1 
  │ │ ├── babel-helper-replace-supers@6.24.1 
  │ │ └── babel-messages@6.23.0 
  │ ├── babel-plugin-transform-es2015-computed-properties@6.24.1 
  │ ├── babel-plugin-transform-es2015-destructuring@6.23.0 
  │ ├── babel-plugin-transform-es2015-duplicate-keys@6.24.1 
  │ ├── babel-plugin-transform-es2015-for-of@6.23.0 
  │ ├── babel-plugin-transform-es2015-function-name@6.24.1 
  │ ├── babel-plugin-transform-es2015-literals@6.22.0 
  │ ├── babel-plugin-transform-es2015-modules-amd@6.24.1 
  │ ├─┬ babel-plugin-transform-es2015-modules-commonjs@6.26.0 
  │ │ └── babel-plugin-transform-strict-mode@6.24.1 
  │ ├─┬ babel-plugin-transform-es2015-modules-systemjs@6.24.1 
  │ │ └── babel-helper-hoist-variables@6.24.1 
  │ ├── babel-plugin-transform-es2015-modules-umd@6.24.1 
  │ ├── babel-plugin-transform-es2015-object-super@6.24.1 
  │ ├─┬ babel-plugin-transform-es2015-parameters@6.24.1 
  │ │ ├── babel-helper-call-delegate@6.24.1 
  │ │ └── babel-helper-get-function-arity@6.24.1 
  │ ├── babel-plugin-transform-es2015-shorthand-properties@6.24.1 
  │ ├── babel-plugin-transform-es2015-spread@6.22.0 
  │ ├─┬ babel-plugin-transform-es2015-sticky-regex@6.24.1 
  │ │ └── babel-helper-regex@6.26.0 
  │ ├── babel-plugin-transform-es2015-template-literals@6.22.0 
  │ ├── babel-plugin-transform-es2015-typeof-symbol@6.23.0 
  │ ├─┬ babel-plugin-transform-es2015-unicode-regex@6.24.1 
  │ │ └── regexpu-core@2.0.0 
  │ └─┬ babel-plugin-transform-regenerator@6.26.0 
  │   └── regenerator-transform@0.10.1 
  ├─┬ babel-preset-stage-1@6.24.1 
  │ ├─┬ babel-plugin-transform-class-constructor-call@6.24.1 
  │ │ └── babel-plugin-syntax-class-constructor-call@6.18.0 
  │ ├─┬ babel-plugin-transform-export-extensions@6.22.0 
  │ │ └── babel-plugin-syntax-export-extensions@6.13.0 
  │ └─┬ babel-preset-stage-2@6.24.1 
  │   ├── babel-plugin-syntax-dynamic-import@6.18.0 
  │   ├─┬ babel-plugin-transform-class-properties@6.24.1 
  │   │ └── babel-plugin-syntax-class-properties@6.13.0 
  │   ├─┬ babel-plugin-transform-decorators@6.24.1 
  │   │ ├─┬ babel-helper-explode-class@6.24.1 
  │   │ │ └── babel-helper-bindify-decorators@6.24.1 
  │   │ └── babel-plugin-syntax-decorators@6.13.0 
  │   └─┬ babel-preset-stage-3@6.24.1 
  │     ├── babel-plugin-syntax-trailing-function-commas@6.22.0 
  │     ├─┬ babel-plugin-transform-async-generator-functions@6.24.1 
  │     │ ├── babel-helper-remap-async-to-generator@6.24.1 
  │     │ └── babel-plugin-syntax-async-generators@6.13.0 
  │     ├─┬ babel-plugin-transform-async-to-generator@6.24.1 
  │     │ └── babel-plugin-syntax-async-functions@6.13.0 
  │     ├─┬ babel-plugin-transform-exponentiation-operator@6.24.1 
  │     │ ├─┬ babel-helper-builder-binary-assignment-operator-visitor@6.24.1 
  │     │ │ └── babel-helper-explode-assignable-expression@6.24.1 
  │     │ └── babel-plugin-syntax-exponentiation-operator@6.13.0 
  │     └─┬ babel-plugin-transform-object-rest-spread@6.26.0 
  │       └── babel-plugin-syntax-object-rest-spread@6.13.0 
  ├─┬ babel-register@6.26.0 
  │ ├─┬ babel-core@6.26.0 
  │ │ ├─┬ babel-code-frame@6.26.0 
  │ │ │ └── js-tokens@3.0.2 
  │ │ ├─┬ babel-generator@6.26.0 
  │ │ │ ├─┬ detect-indent@4.0.0 
  │ │ │ │ └── repeating@2.0.1 
  │ │ │ └── jsesc@1.3.0 
  │ │ ├── babel-helpers@6.24.1 
  │ │ ├── json5@0.5.1 
  │ │ └── minimatch@3.0.4 
  │ ├── core-js@2.5.1 
  │ ├─┬ home-or-tmp@2.0.0 
  │ │ └── os-homedir@1.0.2 
  │ ├─┬ mkdirp@0.5.1 
  │ │ └── minimist@0.0.8 
  │ └── source-map-support@0.4.18 
  ├── babylon@6.18.0 
  ├── colors@1.1.2 
  ├── es6-promise@3.3.1 
  ├── flow-parser@0.56.0 
  ├── lodash@4.17.4 
  ├─┬ micromatch@2.3.11 
  │ ├─┬ arr-diff@2.0.0 
  │ │ └── arr-flatten@1.1.0 
  │ ├── array-unique@0.2.1 
  │ ├─┬ braces@1.8.5 
  │ │ ├─┬ expand-range@1.8.2 
  │ │ │ └─┬ fill-range@2.2.3 
  │ │ │   ├── is-number@2.1.0 
  │ │ │   ├─┬ isobject@2.1.0 
  │ │ │   │ └── isarray@1.0.0 
  │ │ │   ├─┬ randomatic@1.1.7 
  │ │ │   │ ├─┬ is-number@3.0.0 
  │ │ │   │ │ └── kind-of@3.2.2 
  │ │ │   │ └── kind-of@4.0.0 
  │ │ │   └── repeat-string@1.6.1 
  │ │ ├── preserve@0.2.0 
  │ │ └── repeat-element@1.1.2 
  │ ├─┬ expand-brackets@0.1.5 
  │ │ └── is-posix-bracket@0.1.1 
  │ ├── extglob@0.3.2 
  │ ├── filename-regex@2.0.1 
  │ ├── is-extglob@1.0.0 
  │ ├── is-glob@2.0.1 
  │ ├─┬ kind-of@3.2.2 
  │ │ └── is-buffer@1.1.5 
  │ ├─┬ normalize-path@2.1.1 
  │ │ └── remove-trailing-separator@1.1.0 
  │ ├─┬ object.omit@2.0.1 
  │ │ ├─┬ for-own@0.1.5 
  │ │ │ └── for-in@1.0.2 
  │ │ └── is-extendable@0.1.1 
  │ ├─┬ parse-glob@3.0.4 
  │ │ ├─┬ glob-base@0.3.0 
  │ │ │ └── glob-parent@2.0.0 
  │ │ └── is-dotfile@1.0.3 
  │ └─┬ regex-cache@0.4.4 
  │   └─┬ is-equal-shallow@0.1.3 
  │     └── is-primitive@2.0.0 
  ├── node-dir@0.1.8 
  ├─┬ nomnom@1.8.1 
  │ ├─┬ chalk@0.4.0 
  │ │ ├── ansi-styles@1.0.0 
  │ │ ├── has-color@0.1.7 
  │ │ └── strip-ansi@0.1.1 
  │ └── underscore@1.6.0 
  ├─┬ recast@0.11.23 
  │ ├── ast-types@0.9.6 
  │ └── esprima@3.1.3 
  └─┬ temp@0.8.3 
    ├── os-tmpdir@1.0.2 
    └── rimraf@2.2.8 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/dva-jscodeshift/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 28.999999999999996% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0543 took 3.0638s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (17:4) on program /*
 *  Copyright (c) 2015-present, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var assert = require('assert');
var recast = require('recast');
var _ = require('lodash');

var astTypes = recast.types;
var types = astTypes.namedTypes;
var NodePath = astTypes.NodePath;
var Node = types.Node;

/**
 * This represents a generic collection of node paths. It only has a generic
 * API to access and process the elements of the list. It doesn't know anything
 * about AST types.
 *
 * @mixes traversalMethods
 * @mixes mutationMethods
 * @mixes transformMethods
 * @mixes globalMethods
 */

var Collection = function () {

  /**
   * @param {Array} paths An array of AST paths
   * @param {Collection} parent A parent collection
   * @param {Array} types An array of types all the paths in the collection
   *  have in common. If not passed, it will be inferred from the paths.
   * @return {Collection}
   */
  function Collection(paths, parent, types) {
    _classCallCheck(this, Collection);

    assert.ok(Array.isArray(paths), 'Collection is passed an array');
    assert.ok(paths.every(function (p) {
      return p instanceof NodePath;
    }), 'Array contains only paths');
    this._parent = parent;
    this.__paths = paths;
    if (types && !Array.isArray(types)) {
      types = _toTypeArray(types);
    } else if (!types || Array.isArray(types) && types.length === 0) {
      types = _inferTypes(paths);
    }
    this._types = types.length === 0 ? _defaultType : types;
  }

  /**
   * Returns a new collection containing the nodes for which the callback
   * returns true.
   *
   * @param {function} callback
   * @return {Collection}
   */


  _createClass(Collection, [{
    key: 'filter',
    value: function filter(callback) {
      return new this.constructor(this.__paths.filter(callback), this);
    }

    /**
     * Executes callback for each node/path in the collection.
     *
     * @param {function} callback
     * @return {Collection} The collection itself
     */

  }, {
    key: 'forEach',
    value: function forEach(callback) {
      this.__paths.forEach(function (path, i, paths) {
        return callback.call(path, path, i, paths);
      });
      return this;
    }

    /**
     * Executes the callback for every path in the collection and returns a new
     * collection from the return values (which must be paths).
     *
     * The callback can return null to indicate to exclude the element from the
     * new collection.
     *
     * If an array is returned, the array will be flattened into the result
     * collection.
     *
     * @param {function} callback
     * @param {Type} type Force the new collection to be of a specific type
     */

  }, {
    key: 'map',
    value: function map(callback, type) {
      var paths = [];
      this.forEach(function (path) {
        /*jshint eqnull:true*/
        var result = callback.apply(path, arguments);
        if (result == null) return;
        if (!Array.isArray(result)) {
          result = [result];
        }
        for (var i = 0; i < result.length; i++) {
          if (paths.indexOf(result[i]) === -1) {
            paths.push(result[i]);
          }
        }
      });
      return fromPaths(paths, this, type);
    }

    /**
     * Returns the number of elements in this collection.
     *
     * @return {number}
     */

  }, {
    key: 'size',
    value: function size() {
      return this.__paths.length;
    }

    /**
     * Returns the number of elements in this collection.
     *
     * @return {number}
     */

  }, {
    key: 'nodes',


    /**
     * Returns an array of AST nodes in this collection.
     *
     * @return {Array}
     */
    value: function nodes() {
      return this.__paths.map(function (p) {
        return p.value;
      });
    }
  }, {
    key: 'paths',
    value: function paths() {
      return this.__paths;
    }
  }, {
    key: 'getAST',
    value: function getAST() {
      if (this._parent) {
        return this._parent.getAST();
      }
      return this.__paths;
    }
  }, {
    key: 'toSource',
    value: function toSource(options) {
      if (this._parent) {
        return this._parent.toSource(options);
      }
      if (this.__paths.length === 1) {
        return recast.print(this.__paths[0], options).code;
      } else {
        return this.__paths.map(function (p) {
          return recast.print(p, options).code;
        });
      }
    }

    /**
     * Returns a new collection containing only the element at position index.
     *
     * In case of a negative index, the element is taken from the end:
     *
     *   .at(0)  - first element
     *   .at(-1) - last element
     *
     * @param {number} index
     * @return {Collection}
     */

  }, {
    key: 'at',
    value: function at(index) {
      return fromPaths(this.__paths.slice(index, index === -1 ? undefined : index + 1), this);
    }

    /**
     * Proxies to NodePath#get of the first path.
     *
     * @param {string|number} ...fields
     */

  }, {
    key: 'get',
    value: function get() {
      var path = this.__paths[0];
      if (!path) {
        throw Error('You cannot call "get" on a collection with no paths. ' + 'Instead, check the "length" property first to verify at least 1 path exists.');
      }
      return path.get.apply(path, arguments);
    }

    /**
     * Returns the type(s) of the collection. This is only used for unit tests,
     * I don't think other consumers would need it.
     *
     * @return {Array<string>}
     */

  }, {
    key: 'getTypes',
    value: function getTypes() {
      return this._types;
    }

    /**
     * Returns true if this collection has the type 'type'.
     *
     * @param {Type} type
     * @return {boolean}
     */

  }, {
    key: 'isOfType',
    value: function isOfType(type) {
      return !!type && this._types.indexOf(type.toString()) > -1;
    }
  }, {
    key: 'length',
    get: function get() {
      return this.__paths.length;
    }
  }]);

  return Collection;
}();

/**
 * Given a set of paths, this infers the common types of all paths.
 * @private
 * @param {Array} paths An array of paths.
 * @return {Type} type An AST type
 */


function _inferTypes(paths) {
  var _types = [];

  if (paths.length > 0 && Node.check(paths[0].node)) {
    var nodeType = types[paths[0].node.type];
    var sameType = paths.length === 1 || paths.every(function (path) {
      return nodeType.check(path.node);
    });

    if (sameType) {
      _types = [nodeType.toString()].concat(astTypes.getSupertypeNames(nodeType.toString()));
    } else {
      // try to find a common type
      _types = _.intersection.apply(null, paths.map(function (path) {
        return astTypes.getSupertypeNames(path.node.type);
      }));
    }
  }

  return _types;
}

function _toTypeArray(value) {
  value = !Array.isArray(value) ? [value] : value;
  value = value.map(function (v) {
    return v.toString();
  });
  if (value.length > 1) {
    return _.union(value, _.intersection.apply(null, value.map(function (type) {
      return astTypes.getSupertypeNames(type);
    })));
  } else {
    return value.concat(astTypes.getSupertypeNames(value[0]));
  }
}

/**
 * Creates a new collection from an array of node paths.
 *
 * If type is passed, it will create a typed collection if such a collection
 * exists. The nodes or path values must be of the same type.
 *
 * Otherwise it will try to infer the type from the path list. If every
 * element has the same type, a typed collection is created (if it exists),
 * otherwise, a generic collection will be created.
 *
 * @ignore
 * @param {Array} paths An array of paths
 * @param {Collection} parent A parent collection
 * @param {Type} type An AST type
 * @return {Collection}
 */
function fromPaths(paths, parent, type) {
  assert.ok(paths.every(function (n) {
    return n instanceof NodePath;
  }), 'Every element in the array should be a NodePath');

  return new Collection(paths, parent, type);
}

/**
 * Creates a new collection from an array of nodes. This is a convenience
 * method which converts the nodes to node paths first and calls
 *
 *    Collections.fromPaths(paths, parent, type)
 *
 * @ignore
 * @param {Array} nodes An array of AST nodes
 * @param {Collection} parent A parent collection
 * @param {Type} type An AST type
 * @return {Collection}
 */
function fromNodes(nodes, parent, type) {
  assert.ok(nodes.every(function (n) {
    return Node.check(n);
  }), 'Every element in the array should be a Node');
  return fromPaths(nodes.map(function (n) {
    return new NodePath(n);
  }), parent, type);
}

var CPt = Collection.prototype;

/**
 * This function adds the provided methods to the prototype of the corresponding
 * typed collection. If no type is passed, the methods are added to
 * Collection.prototype and are available for all collections.
 *
 * @param {Object} methods Methods to add to the prototype
 * @param {Type=} type Optional type to add the methods to
 */
function registerMethods(methods, type) {
  for (var methodName in methods) {
    if (!methods.hasOwnProperty(methodName)) {
      return;
    }
    if (hasConflictingRegistration(methodName, type)) {
      var msg = 'There is a conflicting registration for method with name "' + methodName + '".\nYou tried to register an additional method with ';

      if (type) {
        msg += 'type "' + type.toString() + '".';
      } else {
        msg += 'universal type.';
      }

      msg += '\nThere are existing registrations for that method with ';

      var conflictingRegistrations = CPt[methodName].typedRegistrations;

      if (conflictingRegistrations) {
        msg += 'type ' + Object.keys(conflictingRegistrations).join(', ') + '.';
      } else {
        msg += 'universal type.';
      }

      throw Error(msg);
    }
    if (!type) {
      CPt[methodName] = methods[methodName];
    } else {
      type = type.toString();
      if (!CPt.hasOwnProperty(methodName)) {
        installTypedMethod(methodName);
      }
      var registrations = CPt[methodName].typedRegistrations;
      registrations[type] = methods[methodName];
      astTypes.getSupertypeNames(type).forEach(function (name) {
        registrations[name] = false;
      });
    }
  }
}

function installTypedMethod(methodName) {
  if (CPt.hasOwnProperty(methodName)) {
    throw new Error('Internal Error: "' + methodName + '" method is already installed');
  }

  var registrations = {};

  function typedMethod() {
    var types = Object.keys(registrations);

    for (var i = 0; i < types.length; i++) {
      var currentType = types[i];
      if (registrations[currentType] && this.isOfType(currentType)) {
        return registrations[currentType].apply(this, arguments);
      }
    }

    throw Error('You have a collection of type [' + this.getTypes() + ']. ' + ('"' + methodName + '" is only defined for one of [' + types.join('|') + '].'));
  }

  typedMethod.typedRegistrations = registrations;

  CPt[methodName] = typedMethod;
}

function hasConflictingRegistration(methodName, type) {
  if (!type) {
    return CPt.hasOwnProperty(methodName);
  }

  if (!CPt.hasOwnProperty(methodName)) {
    return false;
  }

  var registrations = CPt[methodName] && CPt[methodName].typedRegistrations;

  if (!registrations) {
    return true;
  }

  type = type.toString();

  if (registrations.hasOwnProperty(type)) {
    return true;
  }

  return astTypes.getSupertypeNames(type.toString()).some(function (name) {
    return !!registrations[name];
  });
}

var _defaultType = [];

/**
 * Sets the default collection type. In case a collection is created form an
 * empty set of paths and no type is specified, we return a collection of this
 * type.
 *
 * @ignore
 * @param {Type} type
 */
function setDefaultCollectionType(type) {
  _defaultType = _toTypeArray(type);
}

exports.fromPaths = fromPaths;
exports.fromNodes = fromNodes;
exports.registerMethods = registerMethods;
exports.hasConflictingRegistration = hasConflictingRegistration;
exports.setDefaultCollectionType = setDefaultCollectionType; at SyntaxError: Unexpected token (17:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/dva-jscodeshift/node_modules/dva-jscodeshift/index.js. Coverage (Term): 80% Coverage (LOC): 100%
*- File /root/Targets/dva-jscodeshift/node_modules/dva-jscodeshift/dist/core.js. Coverage (Term): 9% Coverage (LOC): 14%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
