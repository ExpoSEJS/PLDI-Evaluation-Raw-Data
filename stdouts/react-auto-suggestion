/root/Targets/react-auto-suggestion
└─┬ react-auto-suggestion@0.0.1 
  ├── blueimp-md5@2.10.0 
  └── jquery@1.12.4 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/react-auto-suggestion/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 34% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0232 took 1.5898s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (84:17) on program import React from 'react'
import RegexUtil from '../utils/regex.util'
import md5 from 'blueimp-md5';
import $ from 'jquery';
window.$ = $;

export default class ReactAutoSuggestion extends React.Component {

    constructor(props) {
        super(props);
        this.state = {
            is_show_suggestion: false
        };
    }
    /**
     *
     * @param html 全体のHTML
     * @param replace_target 置換対象の文字
     * @param replace_value 置換後の文字
     * @private
     */
    _replaceSuggestion(html, replace_target, replace_value) {
        var timestamp = new Date().getUTCMilliseconds();
        var hash = md5(timestamp.toString());
        html = html.replace(replace_target, "<input id='" + hash + "' type=\"button\" class=\"highlight\" value=\"" + replace_value + "\">");


        console.log(window.getSelection());

        if (this.props.onChange && html !== this.lastHtml) {
            this.props.onChange({
                target: {
                    value: html,
                    text: this.escape(html),
                    name: this.props.name,
                    cursor_hash: hash
                }
            });
        }
        this.lastHtml = html;

        this.setState({is_show_suggestion: false});
    }

    escape(html) {
        if (typeof html !== 'string') {
            return html;
        }
        var prefix = this.props.replace_prefix;
        html = html.replace(/<input(.*?) value=\"(.*?)\">/g, prefix + "$2");
        html = html.replace(/<div>(.*?)<\/div>/g, '\n$1');
        html = html.replace(/<(?:.|\n)*?>/gm, '');
        return html;
    }

    /**
     * 補完対象の文字が選択されたとき
     * @param suggestion
     * @param manual_suggestion
     */
    onClickSuggestion (suggestion, manual_suggestion) {
        var html = this.refs.editor.innerHTML;
        var replace_key = this.props.replace_key;
        var replace_prefix = this.props.replace_prefix;
        var title_key = this.props.title_key;
        var hash_tags_array = RegexUtil.getHashTag(html);
        var replace_target;// = suggestion[replace_key];//自動補完で選択された変換前テキスト
        if (hash_tags_array.length) {
            replace_target = replace_prefix + hash_tags_array[0];//置換対象は入力中のハッシュタグ
        }
        var replace_value = (manual_suggestion) ? manual_suggestion : suggestion[title_key];//自動補完で選択された変換後テキスト
        this._replaceSuggestion(html, replace_target, replace_value);
    }

    /**
     * HTMLを置換する
     * @param suggestion
     * @param title_key
     * @param subtitle_key
     * @param amount
     * @returns {XML}
     */
    replaceSuggestionHTML (index, suggestion, title_key, subtitle_key, value_key, amount) {
         return (<div key={index} className="suggestion sub-title-type"
                              onClick={()=>this.onClickSuggestion(suggestion)}>
            <div className="sub-title-container">
                <div className="title">{suggestion[title_key]}</div>
                <div className="sub-title">{suggestion[subtitle_key]}</div>
            </div>
            <div className="value">{suggestion[value_key]} {amount}</div>
        </div>);
    }

    /**
     * 補完候補の表示
     * @returns {*}
     */
    renderSuggestion() {
        var self = this;
        if (!this.state.is_show_suggestion)return null;
        var suggestion_container;
        var suggestion_list = [];
        var html = this.refs.editor.innerHTML;
        var hash_tags_array = RegexUtil.getHashTag(html);
        var is_first = true;

        this.props.suggestions.filter(function (suggestion, index) {
            var title_key = self.props.title_key;
            var subtitle_key = self.props.subtitle_key;
            var value_key = self.props.value_key;
            var amount = self.props.value_amount;
            if (suggestion[title_key].indexOf(hash_tags_array[0]) == -1) {
                //オートコンプリート内容に見つからない場合
                return false;
            }
            suggestion_list.push(self.replaceSuggestionHTML(index, suggestion, title_key, subtitle_key, value_key, amount));
        });
        var nothing_suggestion;
        if (!suggestion_list.length) {
            nothing_suggestion = (
                <div className="suggestion title-type" onClick={()=>self.onClickSuggestion(null, hash_tags_array[0])}>
                    <div className="title">{hash_tags_array[0]}</div>
                    <div className="value">{this.props.add_suggestion_message}</div>
                </div>);
        }

        suggestion_container = <div className="suggestions-popup-container">
            <div className="suggestions-popup">
                <div>
                    {nothing_suggestion}
                    {suggestion_list}
                </div>
            </div>
        </div>;
        return suggestion_container;
    }

    /**
     * 描画処理
     * @returns {XML}
     */
    render() {
        var self = this;
        return <div className="auto-complete-editor-container">
            <div id="editor" ref="editor" onInput={this.emitChange.bind(this)}
                 onBlur={this.emitChange.bind(this)}
                 className="auto-complete-editor"
                 contentEditable dangerouslySetInnerHTML={{__html: this.props.html}} onKeyPress={this.emitChange.bind(this)}>
            </div>
            {this.renderSuggestion()}
        </div>
    }

    /**
     * 文字変更時のイベント
     * @param e
     * @returns {boolean}
     */
    emitChange(e) {
        console.log("emitChange");
        var html = this.refs.editor.innerHTML;
        var editorDOM = this.refs.editor;
        //文中にハッシュタグが含まれている場合は、オートコンプリートを表示する
        var hash_tags_array = RegexUtil.getHashTag(html);


        if (e.key === 'Enter' || e.key === ' ') {
            if (hash_tags_array[0]) {
                this.setState({is_show_suggestion: false});
                this.onClickSuggestion(null, hash_tags_array[0]);
                e.preventDefault();
                return false;
            }
            return false;
        }

        if (hash_tags_array.length) {
            this.setState({is_show_suggestion: true});
        } else {
            this.setState({is_show_suggestion: false});
        }

        var replace_prefix = this.props.replace_prefix;
        this.lastHtml = html;
    }

} at SyntaxError: Unexpected token (84:17)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$3.parseExprAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1822:12)
    at Parser.parseExprAtom (/root/ExpoSE/lib/Tropigate/bin/Expression.js:28:30)
    at Parser.pp$3.parseExprSubscripts (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1715:21)
    at Parser.parseMaybeUnary (/root/ExpoSE/lib/Tropigate/bin/Unary.js:34:29)
    at Parser.pp$3.parseExprOps (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1637:21)
    at Parser.pp$3.parseMaybeConditional (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1620:21)
    at Parser.pp$3.parseMaybeAssign (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1597:21)
    at Parser.pp$3.parseParenAndDistinguishExpression (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1861:32)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/react-auto-suggestion/node_modules/react-auto-suggestion/index.js. Coverage (Term): 67% Coverage (LOC): 100%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
