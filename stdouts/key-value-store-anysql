/root/Targets/key-value-store-anysql
└─┬ key-value-store-anysql@0.2.1 
  ├─┬ anysql@0.2.1 
  │ ├─┬ anysql-cordova-sqlite@0.5.1 
  │ │ ├── await-lock@1.1.2 
  │ │ └── sleep-promise@1.0.0 
  │ ├─┬ anysql-mysql@0.2.1 
  │ │ └─┬ mysql-as-promised@0.2.2 
  │ │   └─┬ mysql@2.14.1 
  │ │     ├── bignumber.js@4.0.2 
  │ │     ├─┬ readable-stream@2.3.3 
  │ │     │ ├── core-util-is@1.0.2 
  │ │     │ ├── inherits@2.0.3 
  │ │     │ ├── isarray@1.0.0 
  │ │     │ ├── process-nextick-args@1.0.7 
  │ │     │ ├── string_decoder@1.0.3 
  │ │     │ └── util-deprecate@1.0.2 
  │ │     ├── safe-buffer@5.1.1 
  │ │     └── sqlstring@2.2.0 
  │ └── anysql-websql@0.4.1 
  ├─┬ key-value-store-abstract@0.2.1 
  │ ├─┬ bytewise@1.1.0 
  │ │ ├─┬ bytewise-core@1.2.3 
  │ │ │ └── typewise-core@1.2.0 
  │ │ └── typewise@1.0.3 
  │ └── lodash.clone@4.5.0 
  └── set-immediate-promise@1.0.7 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/key-value-store-anysql/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 17% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0604 took 10.6362s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (1:82) on program var assert = require('./util').assert
var base = require('./base')
var codecs = require('./codecs')

var bytewise = exports

//
// expose type information
//
var sorts = bytewise.sorts = base.sorts
bytewise.bound = base.bound
bytewise.compare = base.compare
bytewise.equal = base.equal

//
// generate a buffer with type's byte prefix from source value
//
function serialize(type, source, options) {
  var codec = type.codec
  if (!codec)
    return postEncode(new Buffer([ type.byte ]), options)

  var buffer = codec.encode(source, bytewise)

  if (options && options.nested && codec.escape)
    buffer = codec.escape(buffer)

  var hint = typeof codec.length === 'number' ? (codec.length + 1) : void 0 
  var buffers = [ new Buffer([ type.byte ]), buffer ]
  return postEncode(Buffer.concat(buffers, hint), options)
}

//
// core encode logic
//
bytewise.encode = function(source, options) {

  // check for invalid/incomparable values
  assert(!base.invalid(source), 'Invalid value')

  // encode bound types (ranges)
  var boundary = base.bound.getBoundary(source)
  if (boundary)
    return boundary.encode(source, bytewise)

  // encode standard value-typed sorts
  var order = base.order
  var sort
  for (var i = 0, length = order.length; i < length; ++i) {
    sort = sorts[order[i]]

    if (sort.is(source)) {

      // loop over any subsorts defined on sort
      // TODO: clean up
      var subsorts = sort.sorts ||  { '': sort }
      for (key in subsorts) {
        var subsort = subsorts[key]
        if (subsort.is(source)) 
          return serialize(subsort, source, options)
      }

      // source is an unsupported subsort
      assert(false, 'Unsupported sort value')
    }
  }

  // no type descriptor found
  assert(false, 'Unknown value')
}

//
// core decode logic
//
bytewise.decode = function (buffer, options) {
  // attempt to decode string input using configurable codec
  if (typeof buffer === 'string') {
    buffer = bytewise.stringCodec.encode(buffer)
  }

  assert(!buffer || !buffer.undecodable, 'Encoded value not decodable')

  var byte = buffer[0]
  var type = bytewise.getType(byte)
  assert(type, 'Invalid encoding: ' + buffer)

  // if type provides a decoder it is passed the base type system as second arg
  var codec = type.codec
  if (codec) {
    var decoded = codec.decode(buffer.slice(1), bytewise)

    if (options && options.nested && codec.unescape)
      decoded = codec.unescape(decoded)

    return postDecode(decoded, options)
  }

  // nullary types without a codec must provide a value for their decoded form
  assert('value' in type, 'Unsupported encoding: ' + buffer)
  return postDecode(type.value, options)
}

//
// process top level
//
function postEncode(encoded, options) {
  if (options === null)
    return encoded

  return bytewise.postEncode(encoded, options)
}

//
// invoked after encoding with encoded buffer instance
//
bytewise.postEncode = function (encoded, options) {

  // override buffer toString method to default to hex to help coercion issues
  // TODO: just return pure buffer, do this toString hackery in bytewise
  encoded.toString = function (encoding) {
    if (!encoding)
      return bytewise.stringCodec.decode(encoded)

    return Buffer.prototype.toString.apply(encoded, arguments)
  }

  return encoded
}

function postDecode(decoded, options) {
  if (options === null)
    return decoded

  return bytewise.postDecode(decoded, options)
}

//
// invoked after decoding with decoded value
//
bytewise.postDecode = function (decoded, options) {
  return decoded
}


//
// registry mapping byte prefixes to type descriptors
//
var PREFIX_REGISTRY

function registerType(type) {
  var byte = type && type.byte
  if (byte == null)
    return

  if (byte in PREFIX_REGISTRY)
    assert.deepEqual(type, PREFIX_REGISTRY[byte], 'Duplicate prefix: ' + byte)

  PREFIX_REGISTRY[type.byte] = type
}

function registerTypes(types) {
  for (var key in types) {
    registerType(types[key])
  }
}

//
// look up type descriptor associated with a given byte prefix
//
bytewise.getType = function (byte) {

  // construct and memoize byte prefix registry on first run
  if (!PREFIX_REGISTRY) {
    PREFIX_REGISTRY = {}

    // register sorts
    var sort
    for (var key in sorts) {
      sort = sorts[key]

      // if sort has subsorts register these instead
      sort.sorts ? registerTypes(sort.sorts) : registerType(sort)
    }
  }

  return PREFIX_REGISTRY[byte]
}

bytewise.buffer = true
bytewise.stringCodec = codecs.HEX
bytewise.type = 'bytewise-core'

 at SyntaxError: Unexpected token (1:82)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseTopLevel (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:638:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/key-value-store-anysql/node_modules/key-value-store-anysql/lib/index.js. Coverage (Term): 3% Coverage (LOC): 3%
*- File /root/Targets/key-value-store-anysql/node_modules/key-value-store-abstract/lib/index.js. Coverage (Term): 4% Coverage (LOC): 5%
*- File /root/Targets/key-value-store-anysql/node_modules/bytewise/index.js. Coverage (Term): 80% Coverage (LOC): 100%
*- File /root/Targets/key-value-store-anysql/node_modules/bytewise/encoding/index.js. Coverage (Term): 80% Coverage (LOC): 100%
*- File /root/Targets/key-value-store-anysql/node_modules/bytewise/encoding/binary.js. Coverage (Term): 83% Coverage (LOC): 100%
*- File /root/Targets/key-value-store-anysql/node_modules/typewise/index.js. Coverage (Term): 95% Coverage (LOC): 100%
*- File /root/Targets/key-value-store-anysql/node_modules/typewise/base.js. Coverage (Term): 96% Coverage (LOC): 100%
*- File /root/Targets/key-value-store-anysql/node_modules/typewise/collation.js. Coverage (Term): 96% Coverage (LOC): 100%
*- File /root/Targets/key-value-store-anysql/node_modules/typewise-core/collation.js. Coverage (Term): 21% Coverage (LOC): 36%
*- File /root/Targets/key-value-store-anysql/node_modules/typewise-core/base.js. Coverage (Term): 44% Coverage (LOC): 63%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
