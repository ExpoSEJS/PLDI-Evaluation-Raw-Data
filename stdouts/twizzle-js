/root/Targets/twizzle-js
└─┬ twizzle-js@0.2.1 
  ├─┬ axios@0.13.1 
  │ └─┬ follow-redirects@0.0.7 
  │   ├─┬ debug@2.6.9 
  │   │ └── ms@2.0.0 
  │   └── stream-consume@0.1.0 
  ├── fs@0.0.2 
  └─┬ node-localstorage@1.3.0 
    └─┬ write-file-atomic@1.3.4 
      ├── graceful-fs@4.1.11 
      ├── imurmurhash@0.1.4 
      └── slide@1.1.6 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/twizzle-js/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0191 took 4.4531s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (1719:5) on program module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/*!
	* ThingSpace
	* Copyright(c) 2016 Verizon Irving UI <irvui@verizon.com>
	* MIT Licensed
	*/

	module.exports = __webpack_require__(1);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	* ThingSpace
	* Copyright(c) 2016 Verizon Irving UI <irvui@verizon.com>
	* MIT Licensed
	*/

	'use strict';

	var Proxy = __webpack_require__(2);
	var Config = __webpack_require__(43);

	var isBrowser = new Function("try {return this===window;}catch(e){ return false;}");
	var localStorage = void 0;
	var fs = void 0;
	if (isBrowser()) {
		localStorage = window.localStorage;
	} else {
		var LocalStorage = __webpack_require__(44).LocalStorage;
		localStorage = new LocalStorage('./localstorage');

		fs = __webpack_require__(33);
	}

	/**
	 * Library to interact with platform APIs
	 * @param  {object} args -- args.token - qrcode for the device token to access device api
	 *                       -- args.host (optional) - target url for the platform api. Defaults to twizzle.dhcp.verizon.com
	 * @returns {module}
	 */
	module.exports = function (args) {
		var self = this;
		if (!args) args = {};
		if (!args.token || args.token === null) {
			var file = readKeyFile();
			if (file && file.token) args.token = file.token;
			if (file && file.host) args.host = file.host;
		}

		var config = new Config(args);
		var http = new Proxy(config);
		var LocalStorageKey = 'TZ_Device';

		//////////////////////////////////////////////////////////////

		/**
	  * Initialize a device with the qr code - Checks if the device is initalize already using localstorage.
	  * @param {object} data - device information to be saved represented as an object
	  * @param {callback} done - callback method for the ajax api call.
	  */
		self.initDevice = function (data, done) {
			if (!done) throw new ReferenceError('invalid input');
			return checkIfDeviceInitDone(data, done);
		};

		/**
	  * Cleans up local storage data.
	  */
		self.clearLocalStorage = function () {
			localStorage.removeItem(LocalStorageKey);
		};

		//////////////////////////////////////////////////////////////
		// Private Methods

		function checkIfDeviceInitDone(data, done) {
			var isRegistered = localStorage.getItem(LocalStorageKey);
			if (isRegistered) {
				return done('Device already registered', { data: JSON.parse(isRegistered) });
			} else {
				initDevice(data, function (err, result) {
					if (result.data.status === true) {
						localStorage.setItem(LocalStorageKey, JSON.stringify(result.data));
					}
					return done(err, result.data);
				});
			}
		}

		function initDevice(data, done) {
			if (!data || data === null) data = {};

			data.qrcode = args.token;
			var request = {
				url: http.buildUrl('tz/api/adapter'),
				data: data,
				method: 'POST'
			};

			//console.log(request);

			http.send(request, function (res) {
				//console.log(res.data);
				return done(null, res);
			});
		}

		function readKeyFile() {
			try {
				var filepath = 'device.json';
				var content = fs.readFileSync(filepath, 'utf8');
				if (content.length > 0) {
					return JSON.parse(content);
				}
			} catch (error) {
				return;
			}
		}
		return self;
	};

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	* ThingSpace
	* Copyright(c) 2016 Verizon Irving UI <irvui@verizon.com>
	* MIT Licensed
	*/

	"use strict";

	var axios = __webpack_require__(3);
	var cookieRegex = /^(\w*=\w*)/;

	var Proxy = function Proxy(args) {
		var self = this;
		self.cookie = [];
		self.token = args.token;
		self.host = args.host;
		self.key = args.key;
		self.secret = args.secret;

		var debug = args.debug;

		var Debug = function Debug(location, data) {
			if (debug) {
				console.log(location, data);
			}
		};

		var SetCookie = function SetCookie(input) {

			if (input === null) {
				return;
			}

			for (var i = 0, count = input.length; i < count; i++) {
				var newCookie = cookieRegex.exec(input[i]);

				if (newCookie && newCookie.length > 0) {
					self.cookie.push(newCookie[0]);
				}
			}

			Debug('Proxy.SetCookie', input);
		};

		var GetCookieHeader = function GetCookieHeader() {
			var cookies = "";

			for (var i = 0, count = self.cookie.length; i < count; i++) {
				if (i > 0) {
					cookies += "; ";
				}
				cookies += self.cookie[i];
			}
			Debug('Proxy.CookieHeader', cookies);

			return cookies;
		};

		var Encode = function Encode(data) {
			var form = '';
			for (var name in data) {
				if (data.hasOwnProperty(name)) {
					if (form !== '') form += '&';
					form += encodeURIComponent(name) + '=' + encodeURIComponent(data[name]);
					form.replace(/%20/g, '+');
				}
			}
			Debug('Proxy.encode', [data, form]);

			return form;
		};

		self.buildUrl = function (args) {
			var result = self.host;

			for (var i = 0, l = arguments.length; i < l; i++) {
				result += '/' + arguments[i];
			}

			return result;
		};

		self.send = function (request, callback) {
			var isGet = request.method === 'GET';
			var hasCookies = self.cookie && self.cookie.length > 0;
			var hasToken = self.token && self.token.length > 0;
			var hasBasicAuth = self.key && self.secret;
			var response;
			var headers = {};
			var params = {};
			if (hasCookies) {
				headers.Cookie = GetCookieHeader();
			}

			if (hasToken) {
				//todo: token goes as part payload
				//headers['Authorization'] = 'Bearer ' + self.token;
				params.data = request.data;
				headers['content-type'] = 'application/json';
				headers['accept'] = 'application/json';
			} else if (hasBasicAuth) {
				params.auth = {
					username: self.key,
					password: self.secret
				};
				headers['content-type'] = 'application/x-www-form-urlencoded';
				//params.data = querystring.stringify(request.data);
			}
			params.method = request.method || 'GET';
			params.headers = headers;
			params.url = request.url + (isGet ? '?' + Encode(request.data) : '');

			Debug('-------------------------------------');
			Debug(params);
			Debug('-------------------------------------');
			axios(params).then(function (resp) {
				var cookie;
				response = resp;

				if (cookie = resp.headers['set-cookie']) {
					SetCookie(cookie);
				}

				return callback(null, resp);
			}).catch(function (err) {
				callback(response, err);
			});
			return self;
		};
	};

	module.exports = Proxy;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(4);

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(5);
	var bind = __webpack_require__(6);
	var Axios = __webpack_require__(7);

	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 * @return {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  var context = new Axios(defaultConfig);
	  var instance = bind(Axios.prototype.request, context);

	  // Copy axios.prototype to instance
	  utils.extend(instance, Axios.prototype, context);

	  // Copy context to instance
	  utils.extend(instance, context);

	  return instance;
	}

	// Create the default instance to be exported
	var axios = module.exports = createInstance();

	// Expose Axios class to allow class inheritance
	axios.Axios = Axios;

	// Factory for creating new instances
	axios.create = function create(defaultConfig) {
	  return createInstance(defaultConfig);
	};

	// Expose all/spread
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios.spread = __webpack_require__(42);

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var bind = __webpack_require__(6);

	/*global toString:true*/

	// utils is a library of generic helper functions non-specific to axios

	var toString = Object.prototype.toString;

	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	function isArray(val) {
	  return toString.call(val) === '[object Array]';
	}

	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	function isArrayBuffer(val) {
	  return toString.call(val) === '[object ArrayBuffer]';
	}

	/**
	 * Determine if a value is a FormData
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	function isFormData(val) {
	  return typeof FormData !== 'undefined' && val instanceof FormData;
	}

	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  var result;
	  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
	  }
	  return result;
	}

	/**
	 * Determine if a value is a String
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	function isString(val) {
	  return typeof val === 'string';
	}

	/**
	 * Determine if a value is a Number
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	function isNumber(val) {
	  return typeof val === 'number';
	}

	/**
	 * Determine if a value is undefined
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	function isUndefined(val) {
	  return typeof val === 'undefined';
	}

	/**
	 * Determine if a value is an Object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	function isObject(val) {
	  return val !== null && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object';
	}

	/**
	 * Determine if a value is a Date
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	function isDate(val) {
	  return toString.call(val) === '[object Date]';
	}

	/**
	 * Determine if a value is a File
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	function isFile(val) {
	  return toString.call(val) === '[object File]';
	}

	/**
	 * Determine if a value is a Blob
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	function isBlob(val) {
	  return toString.call(val) === '[object Blob]';
	}

	/**
	 * Determine if a value is a Function
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	function isFunction(val) {
	  return toString.call(val) === '[object Function]';
	}

	/**
	 * Determine if a value is a Stream
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	function isStream(val) {
	  return isObject(val) && isFunction(val.pipe);
	}

	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	function isURLSearchParams(val) {
	  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
	}

	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 * @returns {String} The String freed of excess whitespace
	 */
	function trim(str) {
	  return str.replace(/^\s*/, '').replace(/\s*$/, '');
	}

	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  typeof document.createElement -> undefined
	 */
	function isStandardBrowserEnv() {
	  return typeof window !== 'undefined' && typeof document !== 'undefined' && typeof document.createElement === 'function';
	}

	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 */
	function forEach(obj, fn) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }

	  // Force an array if not already something iterable
	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' && !isArray(obj)) {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }

	  if (isArray(obj)) {
	    // Iterate over array values
	    for (var i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    for (var key in obj) {
	      if (obj.hasOwnProperty(key)) {
	        fn.call(null, obj[key], key, obj);
	      }
	    }
	  }
	}

	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function merge() /* obj1, obj2, obj3, ... */{
	  var result = {};
	  function assignValue(val, key) {
	    if (_typeof(result[key]) === 'object' && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
	      result[key] = merge(result[key], val);
	    } else {
	      result[key] = val;
	    }
	  }

	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 * @return {Object} The resulting value of object a
	 */
	function extend(a, b, thisArg) {
	  forEach(b, function assignValue(val, key) {
	    if (thisArg && typeof val === 'function') {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  });
	  return a;
	}

	module.exports = {
	  isArray: isArray,
	  isArrayBuffer: isArrayBuffer,
	  isFormData: isFormData,
	  isArrayBufferView: isArrayBufferView,
	  isString: isString,
	  isNumber: isNumber,
	  isObject: isObject,
	  isUndefined: isUndefined,
	  isDate: isDate,
	  isFile: isFile,
	  isBlob: isBlob,
	  isFunction: isFunction,
	  isStream: isStream,
	  isURLSearchParams: isURLSearchParams,
	  isStandardBrowserEnv: isStandardBrowserEnv,
	  forEach: forEach,
	  merge: merge,
	  extend: extend,
	  trim: trim
	};

/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function bind(fn, thisArg) {
	  return function wrap() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    return fn.apply(thisArg, args);
	  };
	};

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(8);
	var utils = __webpack_require__(5);
	var InterceptorManager = __webpack_require__(10);
	var dispatchRequest = __webpack_require__(11);
	var isAbsoluteURL = __webpack_require__(40);
	var combineURLs = __webpack_require__(41);

	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 */
	function Axios(defaultConfig) {
	  this.defaults = utils.merge(defaults, defaultConfig);
	  this.interceptors = {
	    request: new InterceptorManager(),
	    response: new InterceptorManager()
	  };
	}

	/**
	 * Dispatch a request
	 *
	 * @param {Object} config The config specific for this request (merged with this.defaults)
	 */
	Axios.prototype.request = function request(config) {
	  /*eslint no-param-reassign:0*/
	  // Allow for axios('example/url'[, config]) a la fetch API
	  if (typeof config === 'string') {
	    config = utils.merge({
	      url: arguments[0]
	    }, arguments[1]);
	  }

	  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);

	  // Support baseURL config
	  if (config.baseURL && !isAbsoluteURL(config.url)) {
	    config.url = combineURLs(config.baseURL, config.url);
	  }

	  // Hook up interceptors middleware
	  var chain = [dispatchRequest, undefined];
	  var promise = Promise.resolve(config);

	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	    chain.unshift(interceptor.fulfilled, interceptor.rejected);
	  });

	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	    chain.push(interceptor.fulfilled, interceptor.rejected);
	  });

	  while (chain.length) {
	    promise = promise.then(chain.shift(), chain.shift());
	  }

	  return promise;
	};

	// Provide aliases for supported request methods
	utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function (url, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url
	    }));
	  };
	});

	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function (url, data, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url,
	      data: data
	    }));
	  };
	});

	module.exports = Axios;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(5);
	var normalizeHeaderName = __webpack_require__(9);

	var PROTECTION_PREFIX = /^\)\]\}',?\n/;
	var DEFAULT_CONTENT_TYPE = {
	  'Content-Type': 'application/x-www-form-urlencoded'
	};

	function setContentTypeIfUnset(headers, value) {
	  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
	    headers['Content-Type'] = value;
	  }
	}

	module.exports = {
	  transformRequest: [function transformRequest(data, headers) {
	    normalizeHeaderName(headers, 'Content-Type');
	    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
	      return data;
	    }
	    if (utils.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils.isURLSearchParams(data)) {
	      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
	      return data.toString();
	    }
	    if (utils.isObject(data)) {
	      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
	      return JSON.stringify(data);
	    }
	    return data;
	  }],

	  transformResponse: [function transformResponse(data) {
	    /*eslint no-param-reassign:0*/
	    if (typeof data === 'string') {
	      data = data.replace(PROTECTION_PREFIX, '');
	      try {
	        data = JSON.parse(data);
	      } catch (e) {/* Ignore */}
	    }
	    return data;
	  }],

	  headers: {
	    common: {
	      'Accept': 'application/json, text/plain, */*'
	    },
	    patch: utils.merge(DEFAULT_CONTENT_TYPE),
	    post: utils.merge(DEFAULT_CONTENT_TYPE),
	    put: utils.merge(DEFAULT_CONTENT_TYPE)
	  },

	  timeout: 0,

	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',

	  maxContentLength: -1,

	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  }
	};

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(5);

	module.exports = function normalizeHeaderName(headers, normalizedName) {
	  utils.forEach(headers, function processHeader(value, name) {
	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
	      headers[normalizedName] = value;
	      delete headers[name];
	    }
	  });
	};

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(5);

	function InterceptorManager() {
	  this.handlers = [];
	}

	/**
	 * Add a new interceptor to the stack
	 *
	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
	 * @param {Function} rejected The function to handle `reject` for a `Promise`
	 *
	 * @return {Number} An ID used to remove interceptor later
	 */
	InterceptorManager.prototype.use = function use(fulfilled, rejected) {
	  this.handlers.push({
	    fulfilled: fulfilled,
	    rejected: rejected
	  });
	  return this.handlers.length - 1;
	};

	/**
	 * Remove an interceptor from the stack
	 *
	 * @param {Number} id The ID that was returned by `use`
	 */
	InterceptorManager.prototype.eject = function eject(id) {
	  if (this.handlers[id]) {
	    this.handlers[id] = null;
	  }
	};

	/**
	 * Iterate over all the registered interceptors
	 *
	 * This method is particularly useful for skipping over any
	 * interceptors that may have become `null` calling `eject`.
	 *
	 * @param {Function} fn The function to call for each interceptor
	 */
	InterceptorManager.prototype.forEach = function forEach(fn) {
	  utils.forEach(this.handlers, function forEachHandler(h) {
	    if (h !== null) {
	      fn(h);
	    }
	  });
	};

	module.exports = InterceptorManager;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(5);
	var transformData = __webpack_require__(12);

	/**
	 * Dispatch a request to the server using whichever adapter
	 * is supported by the current environment.
	 *
	 * @param {object} config The config that is to be used for the request
	 * @returns {Promise} The Promise to be fulfilled
	 */
	module.exports = function dispatchRequest(config) {
	  // Ensure headers exist
	  config.headers = config.headers || {};

	  // Transform request data
	  config.data = transformData(config.data, config.headers, config.transformRequest);

	  // Flatten headers
	  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});

	  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
	    delete config.headers[method];
	  });

	  var adapter;

	  if (typeof config.adapter === 'function') {
	    // For custom adapter support
	    adapter = config.adapter;
	  } else if (typeof XMLHttpRequest !== 'undefined') {
	    // For browsers use XHR adapter
	    adapter = __webpack_require__(13);
	  } else if (typeof process !== 'undefined') {
	    // For node use HTTP adapter
	    adapter = __webpack_require__(22);
	  }

	  return Promise.resolve(config)
	  // Wrap synchronous adapter errors and pass configuration
	  .then(adapter).then(function onFulfilled(response) {
	    // Transform response data
	    response.data = transformData(response.data, response.headers, config.transformResponse);

	    return response;
	  }, function onRejected(error) {
	    // Transform response data
	    if (error && error.response) {
	      error.response.data = transformData(error.response.data, error.response.headers, config.transformResponse);
	    }

	    return Promise.reject(error);
	  });
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(5);

	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Object|String} data The data to be transformed
	 * @param {Array} headers The headers for the request or response
	 * @param {Array|Function} fns A single function or Array of functions
	 * @returns {*} The resulting transformed data
	 */
	module.exports = function transformData(data, headers, fns) {
	  /*eslint no-param-reassign:0*/
	  utils.forEach(fns, function transform(fn) {
	    data = fn(data, headers);
	  });

	  return data;
	};

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(5);
	var settle = __webpack_require__(14);
	var buildURL = __webpack_require__(17);
	var parseHeaders = __webpack_require__(18);
	var isURLSameOrigin = __webpack_require__(19);
	var createError = __webpack_require__(15);
	var btoa = typeof window !== 'undefined' && window.btoa || __webpack_require__(20);

	module.exports = function xhrAdapter(config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    var requestData = config.data;
	    var requestHeaders = config.headers;

	    if (utils.isFormData(requestData)) {
	      delete requestHeaders['Content-Type']; // Let the browser set it
	    }

	    var request = new XMLHttpRequest();
	    var loadEvent = 'onreadystatechange';
	    var xDomain = false;

	    // For IE 8/9 CORS support
	    // Only supports POST and GET calls and doesn't returns the response headers.
	    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
	    if (process.env.NODE_ENV !== 'test' && typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) {
	      request = new window.XDomainRequest();
	      loadEvent = 'onload';
	      xDomain = true;
	      request.onprogress = function handleProgress() {};
	      request.ontimeout = function handleTimeout() {};
	    }

	    // HTTP basic authentication
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password || '';
	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	    }

	    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

	    // Set the request timeout in MS
	    request.timeout = config.timeout;

	    // Listen for ready state
	    request[loadEvent] = function handleLoad() {
	      if (!request || request.readyState !== 4 && !xDomain) {
	        return;
	      }

	      // The request errored out and we didn't get a response, this will be
	      // handled by onerror instead
	      if (request.status === 0) {
	        return;
	      }

	      // Prepare the response
	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
	      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
	      var response = {
	        data: responseData,
	        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)
	        status: request.status === 1223 ? 204 : request.status,
	        statusText: request.status === 1223 ? 'No Content' : request.statusText,
	        headers: responseHeaders,
	        config: config,
	        request: request
	      };

	      settle(resolve, reject, response);

	      // Clean up request
	      request = null;
	    };

	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(createError('Network Error', config));

	      // Clean up request
	      request = null;
	    };

	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED'));

	      // Clean up request
	      request = null;
	    };

	    // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.
	    if (utils.isStandardBrowserEnv()) {
	      var cookies = __webpack_require__(21);

	      // Add xsrf header
	      var xsrfValue = config.withCredentials || isURLSameOrigin(config.url) ? cookies.read(config.xsrfCookieName) : undefined;

	      if (xsrfValue) {
	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
	      }
	    }

	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	          // Remove Content-Type if data is undefined
	          delete requestHeaders[key];
	        } else {
	          // Otherwise add header to the request
	          request.setRequestHeader(key, val);
	        }
	      });
	    }

	    // Add withCredentials to request if needed
	    if (config.withCredentials) {
	      request.withCredentials = true;
	    }

	    // Add responseType to request if needed
	    if (config.responseType) {
	      try {
	        request.responseType = config.responseType;
	      } catch (e) {
	        if (request.responseType !== 'json') {
	          throw e;
	        }
	      }
	    }

	    // Handle progress if needed
	    if (typeof config.progress === 'function') {
	      if (config.method === 'post' || config.method === 'put') {
	        request.upload.addEventListener('progress', config.progress);
	      } else if (config.method === 'get') {
	        request.addEventListener('progress', config.progress);
	      }
	    }

	    if (requestData === undefined) {
	      requestData = null;
	    }

	    // Send the request
	    request.send(requestData);
	  });
	};

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var createError = __webpack_require__(15);

	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 */
	module.exports = function settle(resolve, reject, response) {
	  var validateStatus = response.config.validateStatus;
	  // Note: status is not exposed by XDomainRequest
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(createError('Request failed with status code ' + response.status, response.config, null, response));
	  }
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var enhanceError = __webpack_require__(16);

	/**
	 * Create an Error with the specified message, config, error code, and response.
	 *
	 * @param {string} message The error message.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 @ @param {Object} [response] The response.
	 * @returns {Error} The created error.
	 */
	module.exports = function createError(message, config, code, response) {
	  var error = new Error(message);
	  return enhanceError(error, config, code, response);
	};

/***/ },
/* 16 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Update an Error with the specified config, error code, and response.
	 *
	 * @param {Error} error The error to update.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 @ @param {Object} [response] The response.
	 * @returns {Error} The error.
	 */

	module.exports = function enhanceError(error, config, code, response) {
	  error.config = config;
	  if (code) {
	    error.code = code;
	  }
	  error.response = response;
	  return error;
	};

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(5);

	function encode(val) {
	  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
	}

	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @returns {string} The formatted url
	 */
	module.exports = function buildURL(url, params, paramsSerializer) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }

	  var serializedParams;
	  if (paramsSerializer) {
	    serializedParams = paramsSerializer(params);
	  } else if (utils.isURLSearchParams(params)) {
	    serializedParams = params.toString();
	  } else {
	    var parts = [];

	    utils.forEach(params, function serialize(val, key) {
	      if (val === null || typeof val === 'undefined') {
	        return;
	      }

	      if (utils.isArray(val)) {
	        key = key + '[]';
	      }

	      if (!utils.isArray(val)) {
	        val = [val];
	      }

	      utils.forEach(val, function parseValue(v) {
	        if (utils.isDate(v)) {
	          v = v.toISOString();
	        } else if (utils.isObject(v)) {
	          v = JSON.stringify(v);
	        }
	        parts.push(encode(key) + '=' + encode(v));
	      });
	    });

	    serializedParams = parts.join('&');
	  }

	  if (serializedParams) {
	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }

	  return url;
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(5);

	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} headers Headers needing to be parsed
	 * @returns {Object} Headers parsed into an object
	 */
	module.exports = function parseHeaders(headers) {
	  var parsed = {};
	  var key;
	  var val;
	  var i;

	  if (!headers) {
	    return parsed;
	  }

	  utils.forEach(headers.split('\n'), function parser(line) {
	    i = line.indexOf(':');
	    key = utils.trim(line.substr(0, i)).toLowerCase();
	    val = utils.trim(line.substr(i + 1));

	    if (key) {
	      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	    }
	  });

	  return parsed;
	};

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(5);

	module.exports = utils.isStandardBrowserEnv() ?

	// Standard browser envs have full support of the APIs needed to test
	// whether the request URL is of the same origin as current location.
	function standardBrowserEnv() {
	  var msie = /(msie|trident)/i.test(navigator.userAgent);
	  var urlParsingNode = document.createElement('a');
	  var originURL;

	  /**
	  * Parse a URL to discover it's components
	  *
	  * @param {String} url The URL to be parsed
	  * @returns {Object}
	  */
	  function resolveURL(url) {
	    var href = url;

	    if (msie) {
	      // IE needs attribute set twice to normalize properties
	      urlParsingNode.setAttribute('href', href);
	      href = urlParsingNode.href;
	    }

	    urlParsingNode.setAttribute('href', href);

	    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	    return {
	      href: urlParsingNode.href,
	      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	      host: urlParsingNode.host,
	      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	      hostname: urlParsingNode.hostname,
	      port: urlParsingNode.port,
	      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
	    };
	  }

	  originURL = resolveURL(window.location.href);

	  /**
	  * Determine if a URL shares the same origin as the current location
	  *
	  * @param {String} requestURL The URL to test
	  * @returns {boolean} True if URL shares the same origin, otherwise false
	  */
	  return function isURLSameOrigin(requestURL) {
	    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
	    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
	  };
	}() :

	// Non standard browser envs (web workers, react-native) lack needed support.
	function nonStandardBrowserEnv() {
	  return function isURLSameOrigin() {
	    return true;
	  };
	}();

/***/ },
/* 20 */
/***/ function(module, exports) {

	'use strict';

	// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	function E() {
	  this.message = 'String contains an invalid character';
	}
	E.prototype = new Error();
	E.prototype.code = 5;
	E.prototype.name = 'InvalidCharacterError';

	function btoa(input) {
	  var str = String(input);
	  var output = '';
	  for (
	  // initialize result and counter
	  var block, charCode, idx = 0, map = chars;
	  // if the next str index does not exist:
	  //   change the mapping table to "="
	  //   check if d has no fractional digits
	  str.charAt(idx | 0) || (map = '=', idx % 1);
	  // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
	    charCode = str.charCodeAt(idx += 3 / 4);
	    if (charCode > 0xFF) {
	      throw new E();
	    }
	    block = block << 8 | charCode;
	  }
	  return output;
	}

	module.exports = btoa;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(5);

	module.exports = utils.isStandardBrowserEnv() ?

	// Standard browser envs support document.cookie
	function standardBrowserEnv() {
	  return {
	    write: function write(name, value, expires, path, domain, secure) {
	      var cookie = [];
	      cookie.push(name + '=' + encodeURIComponent(value));

	      if (utils.isNumber(expires)) {
	        cookie.push('expires=' + new Date(expires).toGMTString());
	      }

	      if (utils.isString(path)) {
	        cookie.push('path=' + path);
	      }

	      if (utils.isString(domain)) {
	        cookie.push('domain=' + domain);
	      }

	      if (secure === true) {
	        cookie.push('secure');
	      }

	      document.cookie = cookie.join('; ');
	    },

	    read: function read(name) {
	      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	      return match ? decodeURIComponent(match[3]) : null;
	    },

	    remove: function remove(name) {
	      this.write(name, '', Date.now() - 86400000);
	    }
	  };
	}() :

	// Non standard browser env (web workers, react-native) lack needed support.
	function nonStandardBrowserEnv() {
	  return {
	    write: function write() {},
	    read: function read() {
	      return null;
	    },
	    remove: function remove() {}
	  };
	}();

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(5);
	var settle = __webpack_require__(14);
	var buildURL = __webpack_require__(17);
	var http = __webpack_require__(23);
	var https = __webpack_require__(24);
	var httpFollow = __webpack_require__(25).http;
	var httpsFollow = __webpack_require__(25).https;
	var url = __webpack_require__(27);
	var zlib = __webpack_require__(37);
	var pkg = __webpack_require__(38);
	var Buffer = __webpack_require__(39).Buffer;
	var createError = __webpack_require__(15);
	var enhanceError = __webpack_require__(16);

	/*eslint consistent-return:0*/
	module.exports = function httpAdapter(config) {
	  return new Promise(function dispatchHttpRequest(resolve, reject) {
	    var data = config.data;
	    var headers = config.headers;
	    var timer;
	    var aborted = false;

	    // Set User-Agent (required by some servers)
	    // Only set header if it hasn't been set in config
	    // See https://github.com/mzabriskie/axios/issues/69
	    if (!headers['User-Agent'] && !headers['user-agent']) {
	      headers['User-Agent'] = 'axios/' + pkg.version;
	    }

	    if (data && !utils.isStream(data)) {
	      if (utils.isArrayBuffer(data)) {
	        data = new Buffer(new Uint8Array(data));
	      } else if (utils.isString(data)) {
	        data = new Buffer(data, 'utf-8');
	      } else {
	        return reject(createError('Data after transformation must be a string, an ArrayBuffer, or a Stream', config));
	      }

	      // Add Content-Length header if data exists
	      headers['Content-Length'] = data.length;
	    }

	    // HTTP basic authentication
	    var auth = undefined;
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password || '';
	      auth = username + ':' + password;
	    }

	    // Parse url
	    var parsed = url.parse(config.url);
	    if (!auth && parsed.auth) {
	      var urlAuth = parsed.auth.split(':');
	      var urlUsername = urlAuth[0] || '';
	      var urlPassword = urlAuth[1] || '';
	      auth = urlUsername + ':' + urlPassword;
	    }
	    var options = {
	      hostname: parsed.hostname,
	      port: parsed.port,
	      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ''),
	      method: config.method,
	      headers: headers,
	      agent: config.agent,
	      auth: auth
	    };

	    if (config.proxy) {
	      options.host = config.proxy.host;
	      options.port = config.proxy.port;
	      options.path = parsed.protocol + '//' + parsed.hostname + options.path;
	    }

	    var transport;
	    if (config.maxRedirects === 0) {
	      transport = parsed.protocol === 'https:' ? https : http;
	    } else {
	      if (config.maxRedirects) {
	        options.maxRedirects = config.maxRedirects;
	      }
	      transport = parsed.protocol === 'https:' ? httpsFollow : httpFollow;
	    }

	    // Create the request
	    var req = transport.request(options, function handleResponse(res) {
	      if (aborted) return;

	      // Response has been received so kill timer that handles request timeout
	      clearTimeout(timer);
	      timer = null;

	      // uncompress the response body transparently if required
	      var stream = res;
	      switch (res.headers['content-encoding']) {
	        /*eslint default-case:0*/
	        case 'gzip':
	        case 'compress':
	        case 'deflate':
	          // add the unzipper to the body stream processing pipeline
	          stream = stream.pipe(zlib.createUnzip());

	          // remove the content-encoding in order to not confuse downstream operations
	          delete res.headers['content-encoding'];
	          break;
	      }

	      var response = {
	        status: res.statusCode,
	        statusText: res.statusMessage,
	        headers: res.headers,
	        config: config,
	        request: req
	      };

	      if (config.responseType === 'stream') {
	        response.data = stream;
	        settle(resolve, reject, response);
	      } else {
	        var responseBuffer = [];
	        stream.on('data', function handleStreamData(chunk) {
	          responseBuffer.push(chunk);

	          // make sure the content length is not over the maxContentLength if specified
	          if (config.maxContentLength > -1 && Buffer.concat(responseBuffer).length > config.maxContentLength) {
	            reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded', config));
	          }
	        });

	        stream.on('error', function handleStreamError(err) {
	          if (aborted) return;
	          reject(enhanceError(err, config));
	        });

	        stream.on('end', function handleStreamEnd() {
	          var responseData = Buffer.concat(responseBuffer);
	          if (config.responseType !== 'arraybuffer') {
	            responseData = responseData.toString('utf8');
	          }

	          response.data = responseData;
	          settle(resolve, reject, response);
	        });
	      }
	    });

	    // Handle errors
	    req.on('error', function handleRequestError(err) {
	      if (aborted) return;
	      reject(enhanceError(err, config));
	    });

	    // Handle request timeout
	    if (config.timeout && !timer) {
	      timer = setTimeout(function handleRequestTimeout() {
	        req.abort();
	        reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED'));
	        aborted = true;
	      }, config.timeout);
	    }

	    // Send the request
	    if (utils.isStream(data)) {
	      data.pipe(req);
	    } else {
	      req.end(data);
	    }
	  });
	};

/***/ },
/* 23 */
/***/ function(module, exports) {

	module.exports = require("http");

/***/ },
/* 24 */
/***/ function(module, exports) {

	module.exports = require("https");

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(26)({
	  'http': __webpack_require__(23),
	  'https': __webpack_require__(24)
	});

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var url = __webpack_require__(27);
	var debug = __webpack_require__(28)('follow-redirects');
	var assert = __webpack_require__(35);
	var consume = __webpack_require__(36);

	module.exports = function (_nativeProtocols) {
	  var nativeProtocols = {};

	  var publicApi = {
	    maxRedirects: 5
	  };

	  for (var p in _nativeProtocols) {
	    /* istanbul ignore else */
	    if (_nativeProtocols.hasOwnProperty(p)) {
	      // http://www.ietf.org/rfc/rfc2396.txt - Section 3.1
	      assert(/^[A-Z][A-Z\+\-\.]*$/i.test(p), JSON.stringify(p) + ' is not a valid scheme name');
	      generateWrapper(p, _nativeProtocols[p]);
	    }
	  }

	  return publicApi;

	  function execute(options) {
	    var clientRequest;
	    var fetchedUrls = [];

	    return clientRequest = cb();

	    function cb(res) {
	      // skip the redirection logic on the first call.
	      if (res) {
	        var fetchedUrl = url.format(options);
	        fetchedUrls.unshift(fetchedUrl);

	        if (!isRedirect(res)) {
	          res.fetchedUrls = fetchedUrls;
	          return options.userCallback(res);
	        }

	        // we are going to follow the redirect, but in node 0.10 we must first attach a data listener
	        // to consume the stream and send the 'end' event
	        consume(res);

	        // need to use url.resolve() in case location is a relative URL
	        var redirectUrl = url.resolve(fetchedUrl, res.headers.location);
	        debug('redirecting to', redirectUrl);

	        // clean all the properties related to the old url away, and copy from the redirect url
	        wipeUrlProps(options);
	        extend(options, url.parse(redirectUrl));
	      }

	      if (fetchedUrls.length > options.maxRedirects) {
	        var err = new Error('Max redirects exceeded.');
	        return forwardError(err);
	      }

	      options.nativeProtocol = nativeProtocols[options.protocol];
	      options.defaultRequest = defaultMakeRequest;

	      var req = (options.makeRequest || defaultMakeRequest)(options, cb, res);

	      if (res) {
	        req.on('error', forwardError);
	      }
	      return req;
	    }

	    function defaultMakeRequest(options, cb, res) {
	      if (res) {
	        // This is a redirect, so use only GET methods
	        options.method = 'GET';
	      }

	      var req = options.nativeProtocol.request(options, cb);

	      if (res) {
	        // We leave the user to call `end` on the first request
	        req.end();
	      }

	      return req;
	    }

	    // bubble errors that occur on the redirect back up to the initiating client request
	    // object, otherwise they wind up killing the process.
	    function forwardError(err) {
	      clientRequest.emit('error', err);
	    }
	  }

	  function generateWrapper(scheme, nativeProtocol) {
	    var wrappedProtocol = scheme + ':';
	    var H = function H() {};
	    H.prototype = nativeProtocols[wrappedProtocol] = nativeProtocol;
	    H = new H();
	    publicApi[scheme] = H;

	    H.request = function (options, callback) {
	      return execute(parseOptions(options, callback, wrappedProtocol));
	    };

	    // see https://github.com/joyent/node/blob/master/lib/http.js#L1623
	    H.get = function (options, callback) {
	      options = parseOptions(options, callback, wrappedProtocol);
	      var req = execute(options);
	      req.end();
	      return req;
	    };
	  }

	  // returns a safe copy of options (or a parsed url object if options was a string).
	  // validates that the supplied callback is a function
	  function parseOptions(options, callback, wrappedProtocol) {
	    assert.equal(typeof callback === 'undefined' ? 'undefined' : _typeof(callback), 'function', 'callback must be a function');
	    if ('string' === typeof options) {
	      options = url.parse(options);
	      options.maxRedirects = publicApi.maxRedirects;
	    } else {
	      options = extend({
	        maxRedirects: publicApi.maxRedirects,
	        protocol: wrappedProtocol
	      }, options);
	    }
	    assert.equal(options.protocol, wrappedProtocol, 'protocol mismatch');
	    options.protocol = wrappedProtocol;
	    options.userCallback = callback;

	    debug('options', options);
	    return options;
	  }
	};

	// copies source's own properties onto destination and returns destination
	function extend(destination, source) {
	  for (var i in source) {
	    if (source.hasOwnProperty(i)) {
	      destination[i] = source[i];
	    }
	  }
	  return destination;
	}

	// to redirect the result must have
	// a statusCode between 300-399
	// and a `Location` header
	function isRedirect(res) {
	  return res.statusCode >= 300 && res.statusCode <= 399 && 'location' in res.headers;
	}

	// nulls all url related properties on the object.
	// required on node <10
	function wipeUrlProps(options) {
	  for (var i = 0, l = urlProps.length; i < l; ++i) {
	    options[urlProps[i]] = null;
	  }
	}
	var urlProps = ['protocol', 'slashes', 'auth', 'host', 'port', 'hostname', 'hash', 'search', 'query', 'pathname', 'path', 'href'];

/***/ },
/* 27 */
/***/ function(module, exports) {

	module.exports = require("url");

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Module dependencies.
	 */

	var tty = __webpack_require__(29);
	var util = __webpack_require__(30);

	/**
	 * This is the Node.js implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = __webpack_require__(31);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;

	/**
	 * Colors.
	 */

	exports.colors = [6, 2, 3, 4, 5, 1];

	/**
	 * The file descriptor to write the `debug()` calls to.
	 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
	 *
	 *   $ DEBUG_FD=3 node script.js 3>debug.log
	 */

	var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
	var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);

	/**
	 * Is stdout a TTY? Colored output is enabled when `true`.
	 */

	function useColors() {
	  var debugColors = (process.env.DEBUG_COLORS || '').trim().toLowerCase();
	  if (0 === debugColors.length) {
	    return tty.isatty(fd);
	  } else {
	    return '0' !== debugColors && 'no' !== debugColors && 'false' !== debugColors && 'disabled' !== debugColors;
	  }
	}

	/**
	 * Map %o to `util.inspect()`, since Node doesn't do that out of the box.
	 */

	var inspect = 4 === util.inspect.length ?
	// node <= 0.8.x
	function (v, colors) {
	  return util.inspect(v, void 0, void 0, colors);
	} :
	// node > 0.8.x
	function (v, colors) {
	  return util.inspect(v, { colors: colors });
	};

	exports.formatters.o = function (v) {
	  return inspect(v, this.useColors).replace(/\s*\n\s*/g, ' ');
	};

	/**
	 * Adds ANSI color escape codes if enabled.
	 *
	 * @api public
	 */

	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	  var name = this.namespace;

	  if (useColors) {
	    var c = this.color;

	    args[0] = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m' + args[0] + '\u001b[3' + c + 'm' + ' +' + exports.humanize(this.diff) + '\u001b[0m';
	  } else {
	    args[0] = new Date().toUTCString() + ' ' + name + ' ' + args[0];
	  }
	  return args;
	}

	/**
	 * Invokes `console.error()` with the specified arguments.
	 */

	function log() {
	  return stream.write(util.format.apply(this, arguments) + '\n');
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  if (null == namespaces) {
	    // If you set a process.env field to null or undefined, it gets cast to the
	    // string 'null' or 'undefined'. Just delete instead.
	    delete process.env.DEBUG;
	  } else {
	    process.env.DEBUG = namespaces;
	  }
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  return process.env.DEBUG;
	}

	/**
	 * Copied from `node/src/node.js`.
	 *
	 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
	 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
	 */

	function createWritableStdioStream(fd) {
	  var stream;
	  var tty_wrap = process.binding('tty_wrap');

	  // Note stream._type is used for test-module-load-list.js

	  switch (tty_wrap.guessHandleType(fd)) {
	    case 'TTY':
	      stream = new tty.WriteStream(fd);
	      stream._type = 'tty';

	      // Hack to have stream not keep the event loop alive.
	      // See https://github.com/joyent/node/issues/1726
	      if (stream._handle && stream._handle.unref) {
	        stream._handle.unref();
	      }
	      break;

	    case 'FILE':
	      var fs = __webpack_require__(33);
	      stream = new fs.SyncWriteStream(fd, { autoClose: false });
	      stream._type = 'fs';
	      break;

	    case 'PIPE':
	    case 'TCP':
	      var net = __webpack_require__(34);
	      stream = new net.Socket({
	        fd: fd,
	        readable: false,
	        writable: true
	      });

	      // FIXME Should probably have an option in net.Socket to create a
	      // stream from an existing fd which is writable only. But for now
	      // we'll just add this hack and set the `readable` member to false.
	      // Test: ./node test/fixtures/echo.js < /etc/passwd
	      stream.readable = false;
	      stream.read = null;
	      stream._type = 'pipe';

	      // FIXME Hack to have stream not keep the event loop alive.
	      // See https://github.com/joyent/node/issues/1726
	      if (stream._handle && stream._handle.unref) {
	        stream._handle.unref();
	      }
	      break;

	    default:
	      // Probably an error on in uv_guess_handle()
	      throw new Error('Implement me. Unknown stream file type!');
	  }

	  // For supporting legacy API we put the FD here.
	  stream.fd = fd;

	  stream._isStdio = true;

	  return stream;
	}

	/**
	 * Enable namespaces listed in `process.env.DEBUG` initially.
	 */

	exports.enable(load());

/***/ },
/* 29 */
/***/ function(module, exports) {

	module.exports = require("tty");

/***/ },
/* 30 */
/***/ function(module, exports) {

	module.exports = require("util");

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(32);

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	exports.names = [];
	exports.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */

	exports.formatters = {};

	/**
	 * Previously assigned color.
	 */

	var prevColor = 0;

	/**
	 * Previous log timestamp.
	 */

	var prevTime;

	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */

	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function debug(namespace) {

	  // define the `disabled` version
	  function disabled() {}
	  disabled.enabled = false;

	  // define the `enabled` version
	  function enabled() {

	    var self = enabled;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();

	    var args = Array.prototype.slice.call(arguments);

	    args[0] = exports.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;

	  var fn = exports.enabled(namespace) ? enabled : disabled;

	  fn.namespace = namespace;

	  return fn;
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  exports.save(namespaces);

	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;

	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  exports.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}

/***/ },
/* 32 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */

	module.exports = function (val, options) {
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long ? long(val) : short(val);
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function long(ms) {
	  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}

/***/ },
/* 33 */
/***/ function(module, exports) {

	module.exports = require("fs");

/***/ },
/* 34 */
/***/ function(module, exports) {

	module.exports = require("net");

/***/ },
/* 35 */
/***/ function(module, exports) {

	module.exports = require("assert");

/***/ },
/* 36 */
/***/ function(module, exports) {

	"use strict";

	module.exports = function (stream) {
	    if (stream.readable && typeof stream.resume === 'function') {
	        var state = stream._readableState;
	        if (!state || state.pipesCount === 0) {
	            // Either a classic stream or streams2 that's not piped to another destination
	            try {
	                stream.resume();
	            } catch (err) {
	                console.error("Got error: " + err);
	                // If we can't, it's not worth dying over
	            }
	        }
	    }
	};

/***/ },
/* 37 */
/***/ function(module, exports) {

	module.exports = require("zlib");

/***/ },
/* 38 */
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				"axios@^0.13.1",
				"/Users/v223172/source/stash/irvui/twizzle/twizzle-js"
			]
		],
		"_from": "axios@>=0.13.1 <0.14.0",
		"_id": "axios@0.13.1",
		"_inCache": true,
		"_installable": true,
		"_location": "/axios",
		"_nodeVersion": "3.3.1",
		"_npmOperationalInternal": {
			"host": "packages-12-west.internal.npmjs.com",
			"tmp": "tmp/axios-0.13.1.tgz_1468689204636_0.7909611663781106"
		},
		"_npmUser": {
			"email": "mzabriskie@gmail.com",
			"name": "mzabriskie"
		},
		"_npmVersion": "3.9.5",
		"_phantomChildren": {},
		"_requested": {
			"name": "axios",
			"raw": "axios@^0.13.1",
			"rawSpec": "^0.13.1",
			"scope": null,
			"spec": ">=0.13.1 <0.14.0",
			"type": "range"
		},
		"_requiredBy": [
			"/"
		],
		"_resolved": "https://registry.npmjs.org/axios/-/axios-0.13.1.tgz",
		"_shasum": "3e67abfe4333bc9d2d5fe6fbd13b4694eafc8df8",
		"_shrinkwrap": null,
		"_spec": "axios@^0.13.1",
		"_where": "/Users/v223172/source/stash/irvui/twizzle/twizzle-js",
		"author": {
			"name": "Matt Zabriskie"
		},
		"browser": {
			"./lib/adapters/http.js": "./lib/adapters/xhr.js"
		},
		"bugs": {
			"url": "https://github.com/mzabriskie/axios/issues"
		},
		"dependencies": {
			"follow-redirects": "0.0.7"
		},
		"description": "Promise based HTTP client for the browser and node.js",
		"devDependencies": {
			"coveralls": "^2.11.9",
			"es6-promise": "^3.2.1",
			"grunt": "0.4.5",
			"grunt-banner": "0.6.0",
			"grunt-cli": "0.1.13",
			"grunt-contrib-clean": "1.0.0",
			"grunt-contrib-nodeunit": "1.0.0",
			"grunt-contrib-watch": "0.6.1",
			"grunt-eslint": "18.0.0",
			"grunt-karma": "0.12.1",
			"grunt-ts": "5.3.2",
			"grunt-webpack": "1.0.11",
			"istanbul-instrumenter-loader": "^0.2.0",
			"jasmine-core": "^2.4.1",
			"karma": "^0.13.22",
			"karma-chrome-launcher": "^1.0.1",
			"karma-coverage": "^1.0.0",
			"karma-firefox-launcher": "^1.0.0",
			"karma-jasmine": "^1.0.2",
			"karma-jasmine-ajax": "^0.1.13",
			"karma-opera-launcher": "^1.0.0",
			"karma-phantomjs-launcher": "^1.0.0",
			"karma-safari-launcher": "^1.0.0",
			"karma-sauce-launcher": "^1.0.0",
			"karma-sinon": "^1.0.5",
			"karma-sourcemap-loader": "^0.3.7",
			"karma-webpack": "^1.7.0",
			"load-grunt-tasks": "3.4.1",
			"minimist": "^1.2.0",
			"phantomjs-prebuilt": "^2.1.7",
			"sinon": "^1.17.4",
			"url-search-params": "^0.5.0",
			"webpack": "^1.13.1",
			"webpack-dev-server": "^1.14.1"
		},
		"directories": {},
		"dist": {
			"shasum": "3e67abfe4333bc9d2d5fe6fbd13b4694eafc8df8",
			"tarball": "https://registry.npmjs.org/axios/-/axios-0.13.1.tgz"
		},
		"gitHead": "377efb89aed819ed1cd416b69f057632ad5664a5",
		"homepage": "https://github.com/mzabriskie/axios",
		"keywords": [
			"xhr",
			"http",
			"ajax",
			"promise",
			"node"
		],
		"license": "MIT",
		"main": "index.js",
		"maintainers": [
			{
				"email": "mzabriskie@gmail.com",
				"name": "mzabriskie"
			},
			{
				"email": "nick.uraltsev@gmail.com",
				"name": "nickuraltsev"
			}
		],
		"name": "axios",
		"optionalDependencies": {},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git+https://github.com/mzabriskie/axios.git"
		},
		"scripts": {
			"build": "NODE_ENV=production grunt build",
			"coveralls": "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
			"examples": "node ./examples/server.js",
			"postversion": "git push && git push --tags",
			"preversion": "npm test",
			"start": "node ./sandbox/server.js",
			"test": "grunt test",
			"version": "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json"
		},
		"typescript": {
			"definition": "./axios.d.ts"
		},
		"version": "0.13.1"
	};

/***/ },
/* 39 */
/***/ function(module, exports) {

	module.exports = require("buffer");

/***/ },
/* 40 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */

	module.exports = function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return (/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url)
	  );
	};

/***/ },
/* 41 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 * @returns {string} The combined URL
	 */

	module.exports = function combineURLs(baseURL, relativeURL) {
	  return baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '');
	};

/***/ },
/* 42 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 * @returns {Function}
	 */

	module.exports = function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	};

/***/ },
/* 43 */
/***/ function(module, exports) {

	/*!
	* ThingSpace
	* Copyright(c) 2016 Verizon Irving UI <irvui@verizon.com>
	* MIT Licensed
	*/

	'use strict';
	/**
	 * Defines the configurations to interact with platform APIs
	 * @param  {object} args
	 * 				args.token (required) - qrcode for device 
	 * 				args.host (optional) - the target url of platform apis. Defaults to twizzle.dhcp.verizon.com
	 * 				args.base (optional) - the target uri
	 * @returns {module}
	 */

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	module.exports = function (args) {
		var config = { message: {}, ajax: {} };
		config.debug = false;
		config.host = 'http://twizzle.verizon.com';

		if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object') {
			if (typeof args.host !== 'undefined' && args.host.length > 0) {
				config.host = args.host;
			}

			if (typeof args.base !== 'undefined' && args.base.length > 0) {
				config.host += args.base;
			}

			if (args.token && args.token.length > 0) {
				config.token = args.token;
			}
		}
		return config;
	};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// Generated by CoffeeScript 1.10.0
	(function () {
	  var JSONStorage,
	      KEY_FOR_EMPTY_STRING,
	      LocalStorage,
	      MetaKey,
	      QUOTA_EXCEEDED_ERR,
	      StorageEvent,
	      _emptyDirectory,
	      _escapeKey,
	      _rm,
	      createMap,
	      events,
	      fs,
	      path,
	      writeSync,
	      extend = function extend(child, parent) {
	    for (var key in parent) {
	      if (hasProp.call(parent, key)) child[key] = parent[key];
	    }function ctor() {
	      this.constructor = child;
	    }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
	  },
	      hasProp = {}.hasOwnProperty;

	  path = __webpack_require__(45);

	  fs = __webpack_require__(33);

	  events = __webpack_require__(46);

	  writeSync = __webpack_require__(47).sync;

	  KEY_FOR_EMPTY_STRING = '---.EMPTY_STRING.---';

	  _emptyDirectory = function _emptyDirectory(target) {
	    var i, len, p, ref, results;
	    ref = fs.readdirSync(target);
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      p = ref[i];
	      results.push(_rm(path.join(target, p)));
	    }
	    return results;
	  };

	  _rm = function _rm(target) {
	    if (fs.statSync(target).isDirectory()) {
	      _emptyDirectory(target);
	      return fs.rmdirSync(target);
	    } else {
	      return fs.unlinkSync(target);
	    }
	  };

	  _escapeKey = function _escapeKey(key) {
	    var newKey;
	    if (key === '') {
	      newKey = KEY_FOR_EMPTY_STRING;
	    } else {
	      newKey = key.toString();
	    }
	    return newKey;
	  };

	  QUOTA_EXCEEDED_ERR = function (superClass) {
	    extend(QUOTA_EXCEEDED_ERR, superClass);

	    function QUOTA_EXCEEDED_ERR(message) {
	      this.message = message != null ? message : 'Unknown error.';
	      if (Error.captureStackTrace != null) {
	        Error.captureStackTrace(this, this.constructor);
	      }
	      this.name = this.constructor.name;
	    }

	    QUOTA_EXCEEDED_ERR.prototype.toString = function () {
	      return this.name + ": " + this.message;
	    };

	    return QUOTA_EXCEEDED_ERR;
	  }(Error);

	  StorageEvent = function () {
	    function StorageEvent(key1, oldValue1, newValue1, url, storageArea) {
	      this.key = key1;
	      this.oldValue = oldValue1;
	      this.newValue = newValue1;
	      this.url = url;
	      this.storageArea = storageArea != null ? storageArea : 'localStorage';
	    }

	    return StorageEvent;
	  }();

	  MetaKey = function () {
	    function MetaKey(key1, index1) {
	      this.key = key1;
	      this.index = index1;
	      if (!(this instanceof MetaKey)) {
	        return new MetaKey(this.key, this.index);
	      }
	    }

	    return MetaKey;
	  }();

	  createMap = function createMap() {
	    var Map;
	    Map = function Map() {};
	    Map.prototype = Object.create(null);
	    return new Map();
	  };

	  LocalStorage = function (superClass) {
	    var instanceMap;

	    extend(LocalStorage, superClass);

	    instanceMap = {};

	    function LocalStorage(_location, quota) {
	      this._location = _location;
	      this.quota = quota != null ? quota : 5 * 1024 * 1024;
	      if (!(this instanceof LocalStorage)) {
	        return new LocalStorage(this._location, this.quota);
	      }
	      this._location = path.resolve(this._location);
	      if (instanceMap[this._location] != null) {
	        return instanceMap[this._location];
	      }
	      this.length = 0;
	      this._bytesInUse = 0;
	      this._keys = [];
	      this._metaKeyMap = createMap();
	      this._eventUrl = "pid:" + process.pid;
	      this._init();
	      this._QUOTA_EXCEEDED_ERR = QUOTA_EXCEEDED_ERR;
	      instanceMap[this._location] = this;
	      return instanceMap[this._location];
	    }

	    LocalStorage.prototype._init = function () {
	      var _MetaKey, _decodedKey, _keys, error, i, index, k, len, stat;
	      try {
	        stat = fs.statSync(this._location);
	        if (stat != null && !stat.isDirectory()) {
	          throw new Error("A file exists at the location '" + this._location + "' when trying to create/open localStorage");
	        }
	        this._bytesInUse = 0;
	        this.length = 0;
	        _keys = fs.readdirSync(this._location);
	        for (index = i = 0, len = _keys.length; i < len; index = ++i) {
	          k = _keys[index];
	          _decodedKey = decodeURIComponent(k);
	          this._keys.push(_decodedKey);
	          _MetaKey = new MetaKey(k, index);
	          this._metaKeyMap[_decodedKey] = _MetaKey;
	          stat = this._getStat(k);
	          if ((stat != null ? stat.size : void 0) != null) {
	            _MetaKey.size = stat.size;
	            this._bytesInUse += stat.size;
	          }
	        }
	        this.length = _keys.length;
	      } catch (error) {
	        fs.mkdirSync(this._location);
	      }
	    };

	    LocalStorage.prototype.setItem = function (key, value) {
	      var encodedKey, evnt, existsBeforeSet, filename, hasListeners, metaKey, oldLength, oldValue, valueString, valueStringLength;
	      hasListeners = events.EventEmitter.listenerCount(this, 'storage');
	      oldValue = null;
	      if (hasListeners) {
	        oldValue = this.getItem(key);
	      }
	      key = _escapeKey(key);
	      encodedKey = encodeURIComponent(key);
	      filename = path.join(this._location, encodedKey);
	      valueString = value.toString();
	      valueStringLength = valueString.length;
	      metaKey = this._metaKeyMap[key];
	      existsBeforeSet = !!metaKey;
	      if (existsBeforeSet) {
	        oldLength = metaKey.size;
	      } else {
	        oldLength = 0;
	      }
	      if (this._bytesInUse - oldLength + valueStringLength > this.quota) {
	        throw new QUOTA_EXCEEDED_ERR();
	      }
	      writeSync(filename, valueString, 'utf8');
	      if (!existsBeforeSet) {
	        metaKey = new MetaKey(encodedKey, this._keys.push(key) - 1);
	        metaKey.size = valueStringLength;
	        this._metaKeyMap[key] = metaKey;
	        this.length += 1;
	        this._bytesInUse += valueStringLength;
	      }
	      if (hasListeners) {
	        evnt = new StorageEvent(key, oldValue, value, this._eventUrl);
	        return this.emit('storage', evnt);
	      }
	    };

	    LocalStorage.prototype.getItem = function (key) {
	      var filename, metaKey;
	      key = _escapeKey(key);
	      metaKey = this._metaKeyMap[key];
	      if (!!metaKey) {
	        filename = path.join(this._location, metaKey.key);
	        return fs.readFileSync(filename, 'utf8');
	      } else {
	        return null;
	      }
	    };

	    LocalStorage.prototype._getStat = function (key) {
	      var error, filename;
	      key = _escapeKey(key);
	      filename = path.join(this._location, encodeURIComponent(key));
	      try {
	        return fs.statSync(filename);
	      } catch (error) {
	        return null;
	      }
	    };

	    LocalStorage.prototype.removeItem = function (key) {
	      var evnt, filename, hasListeners, k, meta, metaKey, oldValue, ref, v;
	      key = _escapeKey(key);
	      metaKey = this._metaKeyMap[key];
	      if (!!metaKey) {
	        hasListeners = events.EventEmitter.listenerCount(this, 'storage');
	        oldValue = null;
	        if (hasListeners) {
	          oldValue = this.getItem(key);
	        }
	        delete this._metaKeyMap[key];
	        this.length -= 1;
	        this._bytesInUse -= metaKey.size;
	        filename = path.join(this._location, metaKey.key);
	        this._keys.splice(metaKey.index, 1);
	        ref = this._metaKeyMap;
	        for (k in ref) {
	          v = ref[k];
	          meta = this._metaKeyMap[k];
	          if (meta.index > metaKey.index) {
	            meta.index -= 1;
	          }
	        }
	        _rm(filename);
	        if (hasListeners) {
	          evnt = new StorageEvent(key, oldValue, null, this._eventUrl);
	          return this.emit('storage', evnt);
	        }
	      }
	    };

	    LocalStorage.prototype.key = function (n) {
	      return this._keys[n];
	    };

	    LocalStorage.prototype.clear = function () {
	      var evnt;
	      _emptyDirectory(this._location);
	      this._metaKeyMap = createMap();
	      this._keys = [];
	      this.length = 0;
	      this._bytesInUse = 0;
	      if (events.EventEmitter.listenerCount(this, 'storage')) {
	        evnt = new StorageEvent(null, null, null, this._eventUrl);
	        return this.emit('storage', evnt);
	      }
	    };

	    LocalStorage.prototype._getBytesInUse = function () {
	      return this._bytesInUse;
	    };

	    LocalStorage.prototype._deleteLocation = function () {
	      delete instanceMap[this._location];
	      _rm(this._location);
	      this._metaKeyMap = {};
	      this._keys = [];
	      this.length = 0;
	      return this._bytesInUse = 0;
	    };

	    return LocalStorage;
	  }(events.EventEmitter);

	  JSONStorage = function (superClass) {
	    extend(JSONStorage, superClass);

	    function JSONStorage() {
	      return JSONStorage.__super__.constructor.apply(this, arguments);
	    }

	    JSONStorage.prototype.setItem = function (key, value) {
	      var newValue;
	      newValue = JSON.stringify(value);
	      return JSONStorage.__super__.setItem.call(this, key, newValue);
	    };

	    JSONStorage.prototype.getItem = function (key) {
	      return JSON.parse(JSONStorage.__super__.getItem.call(this, key));
	    };

	    return JSONStorage;
	  }(LocalStorage);

	  exports.LocalStorage = LocalStorage;

	  exports.JSONStorage = JSONStorage;

	  exports.QUOTA_EXCEEDED_ERR = QUOTA_EXCEEDED_ERR;
	}).call(undefined);

/***/ },
/* 45 */
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 46 */
/***/ function(module, exports) {

	module.exports = require("events");

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';

	var fs = __webpack_require__(48);
	var chain = __webpack_require__(54).chain;
	var MurmurHash3 = __webpack_require__(58);
	var extend = Object.assign || __webpack_require__(30)._extend;

	function murmurhex() {
	  var hash = new MurmurHash3();
	  for (var ii = 0; ii < arguments.length; ++ii) {
	    hash.hash('' + arguments[ii]);
	  }return hash.result();
	}
	var invocations = 0;
	var getTmpname = function getTmpname(filename) {
	  return filename + '.' + murmurhex(__filename, process.pid, ++invocations);
	};

	module.exports = function writeFile(filename, data, options, callback) {
	  if (options instanceof Function) {
	    callback = options;
	    options = null;
	  }
	  if (!options) options = {};
	  var tmpfile = getTmpname(filename);

	  if (options.mode && options.chmod) {
	    return thenWriteFile();
	  } else {
	    // Either mode or chown is not explicitly set
	    // Default behavior is to copy it from original file
	    return fs.stat(filename, function (err, stats) {
	      options = extend({}, options);
	      if (!err && stats && !options.mode) {
	        options.mode = stats.mode;
	      }
	      if (!err && stats && !options.chown && process.getuid) {
	        options.chown = { uid: stats.uid, gid: stats.gid };
	      }
	      return thenWriteFile();
	    });
	  }

	  function thenWriteFile() {
	    chain([[fs, fs.writeFile, tmpfile, data, options.encoding || 'utf8'], options.mode && [fs, fs.chmod, tmpfile, options.mode], options.chown && [fs, fs.chown, tmpfile, options.chown.uid, options.chown.gid], [fs, fs.rename, tmpfile, filename]], function (err) {
	      err ? fs.unlink(tmpfile, function () {
	        callback(err);
	      }) : callback();
	    });
	  }
	};

	module.exports.sync = function writeFileSync(filename, data, options) {
	  if (!options) options = {};
	  var tmpfile = getTmpname(filename);

	  try {
	    if (!options.mode || !options.chmod) {
	      // Either mode or chown is not explicitly set
	      // Default behavior is to copy it from original file
	      try {
	        var stats = fs.statSync(filename);

	        options = extend({}, options);
	        if (!options.mode) {
	          options.mode = stats.mode;
	        }
	        if (!options.chown && process.getuid) {
	          options.chown = { uid: stats.uid, gid: stats.gid };
	        }
	      } catch (ex) {
	        // ignore stat errors
	      }
	    }

	    fs.writeFileSync(tmpfile, data, options.encoding || 'utf8');
	    if (options.chown) fs.chownSync(tmpfile, options.chown.uid, options.chown.gid);
	    if (options.mode) fs.chmodSync(tmpfile, options.mode);
	    fs.renameSync(tmpfile, filename);
	  } catch (err) {
	    try {
	      fs.unlinkSync(tmpfile);
	    } catch (e) {}
	    throw err;
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, "/index.js"))

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var fs = __webpack_require__(33);
	var polyfills = __webpack_require__(49);
	var legacy = __webpack_require__(52);
	var queue = [];

	var util = __webpack_require__(30);

	function noop() {}

	var debug = noop;
	if (util.debuglog) debug = util.debuglog('gfs4');else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) debug = function debug() {
	  var m = util.format.apply(util, arguments);
	  m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
	  console.error(m);
	};

	if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
	  process.on('exit', function () {
	    debug(queue);
	    __webpack_require__(35).equal(queue.length, 0);
	  });
	}

	module.exports = patch(__webpack_require__(50));
	if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH) {
	  module.exports = patch(fs);
	}

	// Always patch fs.close/closeSync, because we want to
	// retry() whenever a close happens *anywhere* in the program.
	// This is essential when multiple graceful-fs instances are
	// in play at the same time.
	module.exports.close = fs.close = function (fs$close) {
	  return function (fd, cb) {
	    return fs$close.call(fs, fd, function (err) {
	      if (!err) retry();

	      if (typeof cb === 'function') cb.apply(this, arguments);
	    });
	  };
	}(fs.close);

	module.exports.closeSync = fs.closeSync = function (fs$closeSync) {
	  return function (fd) {
	    // Note that graceful-fs also retries when fs.closeSync() fails.
	    // Looks like a bug to me, although it's probably a harmless one.
	    var rval = fs$closeSync.apply(fs, arguments);
	    retry();
	    return rval;
	  };
	}(fs.closeSync);

	function patch(fs) {
	  // Everything that references the open() function needs to be in here
	  polyfills(fs);
	  fs.gracefulify = patch;
	  fs.FileReadStream = ReadStream; // Legacy name.
	  fs.FileWriteStream = WriteStream; // Legacy name.
	  fs.createReadStream = createReadStream;
	  fs.createWriteStream = createWriteStream;
	  var fs$readFile = fs.readFile;
	  fs.readFile = readFile;
	  function readFile(path, options, cb) {
	    if (typeof options === 'function') cb = options, options = null;

	    return go$readFile(path, options, cb);

	    function go$readFile(path, options, cb) {
	      return fs$readFile(path, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$readFile, [path, options, cb]]);else {
	          if (typeof cb === 'function') cb.apply(this, arguments);
	          retry();
	        }
	      });
	    }
	  }

	  var fs$writeFile = fs.writeFile;
	  fs.writeFile = writeFile;
	  function writeFile(path, data, options, cb) {
	    if (typeof options === 'function') cb = options, options = null;

	    return go$writeFile(path, data, options, cb);

	    function go$writeFile(path, data, options, cb) {
	      return fs$writeFile(path, data, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$writeFile, [path, data, options, cb]]);else {
	          if (typeof cb === 'function') cb.apply(this, arguments);
	          retry();
	        }
	      });
	    }
	  }

	  var fs$appendFile = fs.appendFile;
	  if (fs$appendFile) fs.appendFile = appendFile;
	  function appendFile(path, data, options, cb) {
	    if (typeof options === 'function') cb = options, options = null;

	    return go$appendFile(path, data, options, cb);

	    function go$appendFile(path, data, options, cb) {
	      return fs$appendFile(path, data, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$appendFile, [path, data, options, cb]]);else {
	          if (typeof cb === 'function') cb.apply(this, arguments);
	          retry();
	        }
	      });
	    }
	  }

	  var fs$readdir = fs.readdir;
	  fs.readdir = readdir;
	  function readdir(path, cb) {
	    return go$readdir(path, cb);

	    function go$readdir() {
	      return fs$readdir(path, function (err, files) {
	        if (files && files.sort) files.sort(); // Backwards compatibility with graceful-fs.

	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$readdir, [path, cb]]);else {
	          if (typeof cb === 'function') cb.apply(this, arguments);
	          retry();
	        }
	      });
	    }
	  }

	  if (process.version.substr(0, 4) === 'v0.8') {
	    var legStreams = legacy(fs);
	    ReadStream = legStreams.ReadStream;
	    WriteStream = legStreams.WriteStream;
	  }

	  var fs$ReadStream = fs.ReadStream;
	  ReadStream.prototype = Object.create(fs$ReadStream.prototype);
	  ReadStream.prototype.open = ReadStream$open;

	  var fs$WriteStream = fs.WriteStream;
	  WriteStream.prototype = Object.create(fs$WriteStream.prototype);
	  WriteStream.prototype.open = WriteStream$open;

	  fs.ReadStream = ReadStream;
	  fs.WriteStream = WriteStream;

	  function ReadStream(path, options) {
	    if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
	  }

	  function ReadStream$open() {
	    var that = this;
	    open(that.path, that.flags, that.mode, function (err, fd) {
	      if (err) {
	        if (that.autoClose) that.destroy();

	        that.emit('error', err);
	      } else {
	        that.fd = fd;
	        that.emit('open', fd);
	        that.read();
	      }
	    });
	  }

	  function WriteStream(path, options) {
	    if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
	  }

	  function WriteStream$open() {
	    var that = this;
	    open(that.path, that.flags, that.mode, function (err, fd) {
	      if (err) {
	        that.destroy();
	        that.emit('error', err);
	      } else {
	        that.fd = fd;
	        that.emit('open', fd);
	      }
	    });
	  }

	  function createReadStream(path, options) {
	    return new ReadStream(path, options);
	  }

	  function createWriteStream(path, options) {
	    return new WriteStream(path, options);
	  }

	  var fs$open = fs.open;
	  fs.open = open;
	  function open(path, flags, mode, cb) {
	    if (typeof mode === 'function') cb = mode, mode = null;

	    return go$open(path, flags, mode, cb);

	    function go$open(path, flags, mode, cb) {
	      return fs$open(path, flags, mode, function (err, fd) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$open, [path, flags, mode, cb]]);else {
	          if (typeof cb === 'function') cb.apply(this, arguments);
	          retry();
	        }
	      });
	    }
	  }

	  return fs;
	}

	function enqueue(elem) {
	  debug('ENQUEUE', elem[0].name, elem[1]);
	  queue.push(elem);
	}

	function retry() {
	  var elem = queue.shift();
	  if (elem) {
	    debug('RETRY', elem[0].name, elem[1]);
	    elem[0].apply(null, elem[1]);
	  }
	}

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var fs = __webpack_require__(50);
	var constants = __webpack_require__(51);

	var origCwd = process.cwd;
	var cwd = null;
	process.cwd = function () {
	  if (!cwd) cwd = origCwd.call(process);
	  return cwd;
	};
	try {
	  process.cwd();
	} catch (er) {}

	var chdir = process.chdir;
	process.chdir = function (d) {
	  cwd = null;
	  chdir.call(process, d);
	};

	module.exports = patch;

	function patch(fs) {
	  // (re-)implement some things that are known busted or missing.

	  // lchmod, broken prior to 0.6.2
	  // back-port the fix here.
	  if (constants.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
	    patchLchmod(fs);
	  }

	  // lutimes implementation, or no-op
	  if (!fs.lutimes) {
	    patchLutimes(fs);
	  }

	  // https://github.com/isaacs/node-graceful-fs/issues/4
	  // Chown should not fail on einval or eperm if non-root.
	  // It should not fail on enosys ever, as this just indicates
	  // that a fs doesn't support the intended operation.

	  fs.chown = chownFix(fs.chown);
	  fs.fchown = chownFix(fs.fchown);
	  fs.lchown = chownFix(fs.lchown);

	  fs.chmod = chmodFix(fs.chmod);
	  fs.fchmod = chmodFix(fs.fchmod);
	  fs.lchmod = chmodFix(fs.lchmod);

	  fs.chownSync = chownFixSync(fs.chownSync);
	  fs.fchownSync = chownFixSync(fs.fchownSync);
	  fs.lchownSync = chownFixSync(fs.lchownSync);

	  fs.chmodSync = chmodFixSync(fs.chmodSync);
	  fs.fchmodSync = chmodFixSync(fs.fchmodSync);
	  fs.lchmodSync = chmodFixSync(fs.lchmodSync);

	  // if lchmod/lchown do not exist, then make them no-ops
	  if (!fs.lchmod) {
	    fs.lchmod = function (path, mode, cb) {
	      if (cb) process.nextTick(cb);
	    };
	    fs.lchmodSync = function () {};
	  }
	  if (!fs.lchown) {
	    fs.lchown = function (path, uid, gid, cb) {
	      if (cb) process.nextTick(cb);
	    };
	    fs.lchownSync = function () {};
	  }

	  // on Windows, A/V software can lock the directory, causing this
	  // to fail with an EACCES or EPERM if the directory contains newly
	  // created files.  Try again on failure, for up to 1 second.
	  if (process.platform === "win32") {
	    fs.rename = function (fs$rename) {
	      return function (from, to, cb) {
	        var start = Date.now();
	        fs$rename(from, to, function CB(er) {
	          if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 1000) {
	            return fs$rename(from, to, CB);
	          }
	          if (cb) cb(er);
	        });
	      };
	    }(fs.rename);
	  }

	  // if read() returns EAGAIN, then just try it again.
	  fs.read = function (fs$read) {
	    return function (fd, buffer, offset, length, position, callback_) {
	      var _callback;
	      if (callback_ && typeof callback_ === 'function') {
	        var eagCounter = 0;
	        _callback = function callback(er, _, __) {
	          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
	            eagCounter++;
	            return fs$read.call(fs, fd, buffer, offset, length, position, _callback);
	          }
	          callback_.apply(this, arguments);
	        };
	      }
	      return fs$read.call(fs, fd, buffer, offset, length, position, _callback);
	    };
	  }(fs.read);

	  fs.readSync = function (fs$readSync) {
	    return function (fd, buffer, offset, length, position) {
	      var eagCounter = 0;
	      while (true) {
	        try {
	          return fs$readSync.call(fs, fd, buffer, offset, length, position);
	        } catch (er) {
	          if (er.code === 'EAGAIN' && eagCounter < 10) {
	            eagCounter++;
	            continue;
	          }
	          throw er;
	        }
	      }
	    };
	  }(fs.readSync);
	}

	function patchLchmod(fs) {
	  fs.lchmod = function (path, mode, callback) {
	    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function (err, fd) {
	      if (err) {
	        if (callback) callback(err);
	        return;
	      }
	      // prefer to return the chmod error, if one occurs,
	      // but still try to close, and report closing errors if they occur.
	      fs.fchmod(fd, mode, function (err) {
	        fs.close(fd, function (err2) {
	          if (callback) callback(err || err2);
	        });
	      });
	    });
	  };

	  fs.lchmodSync = function (path, mode) {
	    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);

	    // prefer to return the chmod error, if one occurs,
	    // but still try to close, and report closing errors if they occur.
	    var threw = true;
	    var ret;
	    try {
	      ret = fs.fchmodSync(fd, mode);
	      threw = false;
	    } finally {
	      if (threw) {
	        try {
	          fs.closeSync(fd);
	        } catch (er) {}
	      } else {
	        fs.closeSync(fd);
	      }
	    }
	    return ret;
	  };
	}

	function patchLutimes(fs) {
	  if (constants.hasOwnProperty("O_SYMLINK")) {
	    fs.lutimes = function (path, at, mt, cb) {
	      fs.open(path, constants.O_SYMLINK, function (er, fd) {
	        if (er) {
	          if (cb) cb(er);
	          return;
	        }
	        fs.futimes(fd, at, mt, function (er) {
	          fs.close(fd, function (er2) {
	            if (cb) cb(er || er2);
	          });
	        });
	      });
	    };

	    fs.lutimesSync = function (path, at, mt) {
	      var fd = fs.openSync(path, constants.O_SYMLINK);
	      var ret;
	      var threw = true;
	      try {
	        ret = fs.futimesSync(fd, at, mt);
	        threw = false;
	      } finally {
	        if (threw) {
	          try {
	            fs.closeSync(fd);
	          } catch (er) {}
	        } else {
	          fs.closeSync(fd);
	        }
	      }
	      return ret;
	    };
	  } else {
	    fs.lutimes = function (_a, _b, _c, cb) {
	      if (cb) process.nextTick(cb);
	    };
	    fs.lutimesSync = function () {};
	  }
	}

	function chmodFix(orig) {
	  if (!orig) return orig;
	  return function (target, mode, cb) {
	    return orig.call(fs, target, mode, function (er) {
	      if (chownErOk(er)) er = null;
	      if (cb) cb.apply(this, arguments);
	    });
	  };
	}

	function chmodFixSync(orig) {
	  if (!orig) return orig;
	  return function (target, mode) {
	    try {
	      return orig.call(fs, target, mode);
	    } catch (er) {
	      if (!chownErOk(er)) throw er;
	    }
	  };
	}

	function chownFix(orig) {
	  if (!orig) return orig;
	  return function (target, uid, gid, cb) {
	    return orig.call(fs, target, uid, gid, function (er) {
	      if (chownErOk(er)) er = null;
	      if (cb) cb.apply(this, arguments);
	    });
	  };
	}

	function chownFixSync(orig) {
	  if (!orig) return orig;
	  return function (target, uid, gid) {
	    try {
	      return orig.call(fs, target, uid, gid);
	    } catch (er) {
	      if (!chownErOk(er)) throw er;
	    }
	  };
	}

	// ENOSYS means that the fs doesn't support the op. Just ignore
	// that, because it doesn't matter.
	//
	// if there's no getuid, or if getuid() is something other
	// than 0, and the error is EINVAL or EPERM, then just ignore
	// it.
	//
	// This specific case is a silent failure in cp, install, tar,
	// and most other unix tools that manage permissions.
	//
	// When running as root, or if other types of errors are
	// encountered, then it's strict.
	function chownErOk(er) {
	  if (!er) return true;

	  if (er.code === "ENOSYS") return true;

	  var nonroot = !process.getuid || process.getuid() !== 0;
	  if (nonroot) {
	    if (er.code === "EINVAL" || er.code === "EPERM") return true;
	  }

	  return false;
	}

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var fs = __webpack_require__(33);

	module.exports = clone(fs);

	function clone(obj) {
	  if (obj === null || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') return obj;

	  if (obj instanceof Object) var copy = { __proto__: obj.__proto__ };else var copy = Object.create(null);

	  Object.getOwnPropertyNames(obj).forEach(function (key) {
	    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
	  });

	  return copy;
	}

/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = require("constants");

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Stream = __webpack_require__(53).Stream;

	module.exports = legacy;

	function legacy(fs) {
	  return {
	    ReadStream: ReadStream,
	    WriteStream: WriteStream
	  };

	  function ReadStream(path, options) {
	    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

	    Stream.call(this);

	    var self = this;

	    this.path = path;
	    this.fd = null;
	    this.readable = true;
	    this.paused = false;

	    this.flags = 'r';
	    this.mode = 438; /*=0666*/
	    this.bufferSize = 64 * 1024;

	    options = options || {};

	    // Mixin options into this
	    var keys = Object.keys(options);
	    for (var index = 0, length = keys.length; index < length; index++) {
	      var key = keys[index];
	      this[key] = options[key];
	    }

	    if (this.encoding) this.setEncoding(this.encoding);

	    if (this.start !== undefined) {
	      if ('number' !== typeof this.start) {
	        throw TypeError('start must be a Number');
	      }
	      if (this.end === undefined) {
	        this.end = Infinity;
	      } else if ('number' !== typeof this.end) {
	        throw TypeError('end must be a Number');
	      }

	      if (this.start > this.end) {
	        throw new Error('start must be <= end');
	      }

	      this.pos = this.start;
	    }

	    if (this.fd !== null) {
	      process.nextTick(function () {
	        self._read();
	      });
	      return;
	    }

	    fs.open(this.path, this.flags, this.mode, function (err, fd) {
	      if (err) {
	        self.emit('error', err);
	        self.readable = false;
	        return;
	      }

	      self.fd = fd;
	      self.emit('open', fd);
	      self._read();
	    });
	  }

	  function WriteStream(path, options) {
	    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

	    Stream.call(this);

	    this.path = path;
	    this.fd = null;
	    this.writable = true;

	    this.flags = 'w';
	    this.encoding = 'binary';
	    this.mode = 438; /*=0666*/
	    this.bytesWritten = 0;

	    options = options || {};

	    // Mixin options into this
	    var keys = Object.keys(options);
	    for (var index = 0, length = keys.length; index < length; index++) {
	      var key = keys[index];
	      this[key] = options[key];
	    }

	    if (this.start !== undefined) {
	      if ('number' !== typeof this.start) {
	        throw TypeError('start must be a Number');
	      }
	      if (this.start < 0) {
	        throw new Error('start must be >= zero');
	      }

	      this.pos = this.start;
	    }

	    this.busy = false;
	    this._queue = [];

	    if (this.fd === null) {
	      this._open = fs.open;
	      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
	      this.flush();
	    }
	  }
	}

/***/ },
/* 53 */
/***/ function(module, exports) {

	module.exports = require("stream");

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.asyncMap = __webpack_require__(55);
	exports.bindActor = __webpack_require__(56);
	exports.chain = __webpack_require__(57);

/***/ },
/* 55 */
/***/ function(module, exports) {

	"use strict";

	/*
	usage:

	// do something to a list of things
	asyncMap(myListOfStuff, function (thing, cb) { doSomething(thing.foo, cb) }, cb)
	// do more than one thing to each item
	asyncMap(list, fooFn, barFn, cb)

	*/

	module.exports = asyncMap;

	function asyncMap() {
	  var steps = Array.prototype.slice.call(arguments),
	      list = steps.shift() || [],
	      cb_ = steps.pop();
	  if (typeof cb_ !== "function") throw new Error("No callback provided to asyncMap");
	  if (!list) return cb_(null, []);
	  if (!Array.isArray(list)) list = [list];
	  var n = steps.length,
	      data = [] // 2d array
	  ,
	      errState = null,
	      l = list.length,
	      a = l * n;
	  if (!a) return cb_(null, []);
	  function cb(er) {
	    if (er && !errState) errState = er;

	    var argLen = arguments.length;
	    for (var i = 1; i < argLen; i++) {
	      if (arguments[i] !== undefined) {
	        data[i - 1] = (data[i - 1] || []).concat(arguments[i]);
	      }
	    } // see if any new things have been added.
	    if (list.length > l) {
	      var newList = list.slice(l);
	      a += (list.length - l) * n;
	      l = list.length;
	      process.nextTick(function () {
	        newList.forEach(function (ar) {
	          steps.forEach(function (fn) {
	            fn(ar, cb);
	          });
	        });
	      });
	    }

	    if (--a === 0) cb_.apply(null, [errState].concat(data));
	  }
	  // expect the supplied cb function to be called
	  // "n" times for each thing in the array.
	  list.forEach(function (ar) {
	    steps.forEach(function (fn) {
	      fn(ar, cb);
	    });
	  });
	}

/***/ },
/* 56 */
/***/ function(module, exports) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	module.exports = bindActor;
	function bindActor() {
	  var args = Array.prototype.slice.call(arguments) // jswtf.
	  ,
	      obj = null,
	      fn;
	  if (_typeof(args[0]) === "object") {
	    obj = args.shift();
	    fn = args.shift();
	    if (typeof fn === "string") fn = obj[fn];
	  } else fn = args.shift();
	  return function (cb) {
	    fn.apply(obj, args.concat(cb));
	  };
	}

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = chain;
	var bindActor = __webpack_require__(56);
	chain.first = {};chain.last = {};
	function chain(things, cb) {
	  var res = [];(function LOOP(i, len) {
	    if (i >= len) return cb(null, res);
	    if (Array.isArray(things[i])) things[i] = bindActor.apply(null, things[i].map(function (i) {
	      return i === chain.first ? res[0] : i === chain.last ? res[res.length - 1] : i;
	    }));
	    if (!things[i]) return LOOP(i + 1, len);
	    things[i](function (er, data) {
	      if (er) return cb(er, res);
	      if (data !== undefined) res = res.concat(data);
	      LOOP(i + 1, len);
	    });
	  })(0, things.length);
	}

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * @preserve
	 * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
	 *
	 * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
	 * @see http://github.com/homebrewing/brauhaus-diff
	 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
	 * @see http://github.com/garycourt/murmurhash-js
	 * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
	 * @see http://sites.google.com/site/murmurhash/
	 */
	(function () {
	    var cache;

	    // Call this function without `new` to use the cached object (good for
	    // single-threaded environments), or with `new` to create a new object.
	    //
	    // @param {string} key A UTF-16 or ASCII string
	    // @param {number} seed An optional positive integer
	    // @return {object} A MurmurHash3 object for incremental hashing
	    function MurmurHash3(key, seed) {
	        var m = this instanceof MurmurHash3 ? this : cache;
	        m.reset(seed);
	        if (typeof key === 'string' && key.length > 0) {
	            m.hash(key);
	        }

	        if (m !== this) {
	            return m;
	        }
	    };

	    // Incrementally add a string to this hash
	    //
	    // @param {string} key A UTF-16 or ASCII string
	    // @return {object} this
	    MurmurHash3.prototype.hash = function (key) {
	        var h1, k1, i, top, len;

	        len = key.length;
	        this.len += len;

	        k1 = this.k1;
	        i = 0;
	        switch (this.rem) {
	            case 0:
	                k1 ^= len > i ? key.charCodeAt(i++) & 0xffff : 0;
	            case 1:
	                k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) << 8 : 0;
	            case 2:
	                k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) << 16 : 0;
	            case 3:
	                k1 ^= len > i ? (key.charCodeAt(i) & 0xff) << 24 : 0;
	                k1 ^= len > i ? (key.charCodeAt(i++) & 0xff00) >> 8 : 0;
	        }

	        this.rem = len + this.rem & 3; // & 3 is same as % 4
	        len -= this.rem;
	        if (len > 0) {
	            h1 = this.h1;
	            while (1) {
	                k1 = k1 * 0x2d51 + (k1 & 0xffff) * 0xcc9e0000 & 0xffffffff;
	                k1 = k1 << 15 | k1 >>> 17;
	                k1 = k1 * 0x3593 + (k1 & 0xffff) * 0x1b870000 & 0xffffffff;

	                h1 ^= k1;
	                h1 = h1 << 13 | h1 >>> 19;
	                h1 = h1 * 5 + 0xe6546b64 & 0xffffffff;

	                if (i >= len) {
	                    break;
	                }

	                k1 = key.charCodeAt(i++) & 0xffff ^ (key.charCodeAt(i++) & 0xffff) << 8 ^ (key.charCodeAt(i++) & 0xffff) << 16;
	                top = key.charCodeAt(i++);
	                k1 ^= (top & 0xff) << 24 ^ (top & 0xff00) >> 8;
	            }

	            k1 = 0;
	            switch (this.rem) {
	                case 3:
	                    k1 ^= (key.charCodeAt(i + 2) & 0xffff) << 16;
	                case 2:
	                    k1 ^= (key.charCodeAt(i + 1) & 0xffff) << 8;
	                case 1:
	                    k1 ^= key.charCodeAt(i) & 0xffff;
	            }

	            this.h1 = h1;
	        }

	        this.k1 = k1;
	        return this;
	    };

	    // Get the result of this hash
	    //
	    // @return {number} The 32-bit hash
	    MurmurHash3.prototype.result = function () {
	        var k1, h1;

	        k1 = this.k1;
	        h1 = this.h1;

	        if (k1 > 0) {
	            k1 = k1 * 0x2d51 + (k1 & 0xffff) * 0xcc9e0000 & 0xffffffff;
	            k1 = k1 << 15 | k1 >>> 17;
	            k1 = k1 * 0x3593 + (k1 & 0xffff) * 0x1b870000 & 0xffffffff;
	            h1 ^= k1;
	        }

	        h1 ^= this.len;

	        h1 ^= h1 >>> 16;
	        h1 = h1 * 0xca6b + (h1 & 0xffff) * 0x85eb0000 & 0xffffffff;
	        h1 ^= h1 >>> 13;
	        h1 = h1 * 0xae35 + (h1 & 0xffff) * 0xc2b20000 & 0xffffffff;
	        h1 ^= h1 >>> 16;

	        return h1 >>> 0;
	    };

	    // Reset the hash object for reuse
	    //
	    // @param {number} seed An optional positive integer
	    MurmurHash3.prototype.reset = function (seed) {
	        this.h1 = typeof seed === 'number' ? seed : 0;
	        this.rem = this.k1 = this.len = 0;
	        return this;
	    };

	    // A cached object to use. This can be safely used if you're in a single-
	    // threaded environment, otherwise you need to create new hashes to use.
	    cache = new MurmurHash3();

	    if (true) {
	        module.exports = MurmurHash3;
	    } else {
	        this.MurmurHash3 = MurmurHash3;
	    }
	})();

/***/ }
/******/ ]); at SyntaxError: Unexpected token (1719:5)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp$2.parseBindingAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1417:12)
    at Parser.parseBindingAtom (/root/ExpoSE/lib/Tropigate/bin/FunctionSignatures.js:49:30)
    at Parser.pp$1.parseVarId (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1049:20)
    at Parser.pp$1.parseVar (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1032:14)
    at Parser.pp$1.parseVarStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:917:10)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:706:19)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseBlock (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:981:25)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
