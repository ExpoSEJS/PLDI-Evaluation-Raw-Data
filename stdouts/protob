/root/Targets/protob
└─┬ protob@1.2.0 
  ├── bluebird@2.2.2 
  ├─┬ bytebuffer@2.3.2 
  │ └── long@1.2.3 
  ├─┬ glob@3.2.11 
  │ ├── inherits@2.0.3 
  │ └─┬ minimatch@0.3.0 
  │   ├── lru-cache@2.7.3 
  │   └── sigmund@1.0.1 
  ├─┬ optimist@0.6.1 
  │ ├── minimist@0.0.10 
  │ └── wordwrap@0.0.3 
  ├── rimraf@2.2.8 
  └── underscore@1.5.2 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/protob/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 27% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.0564 took 8.5527s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: 'return' outside of function (18:2) on program /**
 * Maintains a registry of all known protocol buffer object definitions.
 * This registry is a global registry that spans versions. Protob should be included at the top level
 */
var cache, REGISTRY,
    goog = require('./compiler/google-protos-defn');

if(typeof window == 'undefined') {
  global.protob = global.protob || {};
  cache = global.protob;
} else {
  window.protob = window.protob || {};
  cache = window.protob;
}

if(cache.registry) {
  module.exports = cache.registry;
  return;
} else {
  var registry = {},
      extensions = {},
      awaitingFinalizers = [];

  /**
   * The registry of all protocol buffer objects that have been compiled
   * @constructor
   */
  function Registry() {
    this.aliases = {};
  }

  /**
   * Resets the registry and clears all related information. Useful for testing.
   * @private
   */
  Registry.prototype.reset = function() {
    awaitingFinalizers = [];
    registry = {};
    extensions = {};
    require('./compiler').Compiler.reset();
    this.compileGoogleDescriptors();
  }

  /**
   * Provides a scope for accessing information from the registry. 
   * This is a convenience and does not need to be used
   * Scopes can be created before anything is registered, and is only evealuated when a lookup is performed
   * @example
   *    myPackage = registry.scope('my.package')
   *    NestedObject = myPackage.lookup('some.NestedObject');
   *
   * @param {string} name - The name of the package to create the scope for. Can be a sub package if coming from another scope
   * @param {Scope} parentScope - The parent scope to create this scope from
   * @constructor
   */
  function Scope(name, parentScope) {
    if(parentScope) {
      this.name = [parentScope.name, name].join('.');
    } else {
      /** @member {string} - the name of the scope */
      this.name = name;
    }
  }

  /**
   * Create a new scope based off this one. This will be a child scope of the current scope
   * @param {string} name - The name of the sub-scope to create
   * @example
   *     scope = myScope.scope('other.package')
   * @public
   */
  Scope.prototype.scope = function(name) { return new Scope(name, this); };

  /**
   * Lookup an object stored in the registry using the current scope as the starting place
   * @param {string} name - The name of the object within this scope
   * @example
   *  scope = registry.scope('my.scope')
   *  scope.lookup('MyObject') // fetch my.scope.MyObject
   * @public
   */
  Scope.prototype.lookup = function(name) { 
    return REGISTRY.lookup([this.name, name].join('.'));
  };

  /**
   * List all keys in the registry under the current scope
   * @public
   */
  Scope.prototype.keys = function() {
    var keys = [],
        self = this,
        name = this.name,
        ln = this.name.length;

    Object.keys(registry).forEach(function(key) {
      if(key.substr(0, ln) == name) keys.push(key.substr(ln, key.length).replace(/^\./, ''));
    });
    return keys;
  };

  /**
   * List all keys in the registry under the current scope, but retain their full scope
   * @public
   */
  Scope.prototype.fullKeys = function() {
    var keys = this.keys(),
        self = this;

    return keys.map(function(k) { return (self.name ? self.name + '.' + k : k); });
  };

  function extractType(mtd) {
    return function() {
      var keys = this.fullKeys(),
          acc = [];
      keys.forEach(function (key) {
         var thing = REGISTRY.lookup(key);
         if (thing[mtd]()) acc.push(thing);
      });
      return acc;
    }
  }

  Registry.prototype.services = extractType('isService');
  Registry.prototype.enums = extractType('isEnum');
  Registry.prototype.messages = extractType('isMessage');
  Registry.prototype.serviceNames = function() { return this.services().map(function(s) { return s.fullName; }); };
  Registry.prototype.enumNames    = function() { return this.enums().map(function(e) { return e.fullName; }); };
  Registry.prototype.messageNames = function() { return this.messages().map(function(m) { return m.fullName; }); };

  Scope.prototype.services = extractType('isService');
  Scope.prototype.enums = extractType('isEnum');
  Scope.prototype.messages = extractType('isMessage');
  Scope.prototype.serviceNames = Registry.prototype.serviceNames;
  Scope.prototype.enumNames = Registry.prototype.enumNames;
  Scope.prototype.messageNames = Registry.prototype.messageNames;

  /**
   * Lookup an object in the registry
   * @example
   *     registry.lookup('my.package.MyObject');
   *
   * @return - an object from the registry if present, or undefined
   * @public
   */
  Registry.prototype.lookup = function(name) {
    if(!awaitingFinalizers.length) this._finalize();
    return registry[name] || registry[this.aliases[name]];
  };

  /**
   * Alias an object in the registry
   * @param {string} aliasName - The alias you'd like to use
   * @param {string} fullName - The full name of the object
   */
  Registry.prototype.alias = function(aliasName, fullName) {
    if(this.aliases.hasOwnProperty(aliasName)) throw new Error("Alias already exists " + aliasName);
    this.aliases[aliasName] = fullName;
  }

  /**
   * Shorthand for the lookup method
   * @see Registry#lookup
   * @public
   */
  Registry.prototype.l = function(name) { return this.lookup(name); };

  /**
   * Shorthand for the scope method
   * @see Registry#scope
   * @public
   */
  Registry.prototype.s = function(name) { return this.scope(name); };

  /**
   * Create a scope for the given name
   * @example
   *     scope = registry.scope('some.name')
   *     MyObject = scope.lookup('MyObject');
   * @public
   */
  Registry.prototype.scope = function(name) { return new Scope(name); }

  /**
   * Registers a set of descriptors into the registry.
   * @param {Array<Object>} descriptors - The objects must conform to google.protobuf.FileDescriptorProto using field numbers as keys
   * @public
   */
  Registry.prototype.register = function(descriptors) {
    var compiler = require('./compiler').Compiler;
    compiler.compileDescriptors(descriptors);
  };

  /**
   * List all keys in the registry
   * @public
   */
  Registry.prototype.keys = function() { return Object.keys(registry); }
  Registry.prototype.fullKeys = Registry.prototype.keys;

  /**
   * Check if a given key is present in the registry
   * @param {string} name - The full path of the protobuf object to check
   * @return boolean - Presence of the key
   * @public
   */
  Registry.prototype.has = function(name) { return registry.hasOwnProperty(name); }

  /**
   * Finalizes the objects in the registry if they are awaiting finalization
   * i.e. if they have just been added.
   * @param {boolean} force - Force the finalization. By default, it will only run if there is anything to run.
   * @private
   */
  Registry.prototype._finalize = function(force) {
    if(!force && !awaitingFinalizers.length) return;
    var finalizers = awaitingFinalizers,
        dp = goog.descriptorProto,
        fd = goog.fieldDescriptorProto;

    finalizers.forEach(function(name) { registry[name].finalize(); });
    awaitingFinalizers = [];
  };

  /**
   * Add an object to be finalized. 
   * This happens when each new object is added to the registry,
   * or when they are extended.
   * @param {string} name - The name of the thing to finalize
   * @private
   */
  Registry.prototype._addFinalize = function(name) {
    awaitingFinalizers = awaitingFinalizers || [];
    if(awaitingFinalizers.indexOf(name) < 0) awaitingFinalizers.push(name);
  }

  /**
   * Add a protocol buffer object to the registry by name
   * @param {string} name - The name of the object for the registry
   * @param {Object} protobufObject - The object to store in the registry
   * @private
   */
  Registry.prototype._addObject = function(name, protobufObject) {
    this._addFinalize(name);
    registry[name] = protobufObject;
  };

  /**
   * Adds an extension to be compiled when the objects are finalized.
   * @param {google.protobuf.FieldDescriptorProto} ext - The field extension to apply
   * @private
   */
  Registry.prototype._addExtension = function(ext) {
    var fd = goog.fieldDescriptorProto,
        extendee = (ext[fd.EXTENDEE]).replace(/^\./, ''),
        key = extendee + (ext[fd.NUMBER]);

    ext[fd.EXTENDEE] = extendee;
    extensions[key] = ext;
  };

  // TODO: remove if not needed
  // Registry.prototype.extensions = function() { return extensions; };

  /**
   * Apply any existing extensions to the objects in the reigstry. Also clear out the extensions so they're not doubly applied
   * @private
   */
  Registry.prototype._applyExtensions = function() {
    var self = this,
        fd = goog.fieldDescriptorProto;

    Object.keys(extensions).forEach(function(key){
      var ext = extensions[key],
          Extendee = registry[ext[fd.EXTENDEE]],
          extendee = Extendee.descriptor,
          fields = extendee[fd.FIELD],
          FieldDescriptor = registry['google.protobuf.FieldDescriptorProto'],
          field;

      if(!fields) fields = extendee[fd.EXTENDEE] = extendee[fd.EXTENDEE] || [];

      field = (fields || []).filter(function(f){ return f[fd.NUMBER] === (ext[fd.NUMBER]); })[0];
      if(!field){
        self._addFinalize(Extendee.fullName);
        if(!ext instanceof FieldDescriptor) ext = new FieldDescriptor(ext);
        fields.push(ext);
      }
    });
    extensions = {};
  };

  /**
   * Check to see if the google descriptors have been compiled
   * @protected
   */
  Registry.prototype.googleDescriptorsCompiled = function() {
    this.googleCompiled = true;
  }

  /**
   * Compile the google descriptors. This must be done as the first step and is done automatically
   * @private
   */
  Registry.prototype.compileGoogleDescriptors = function() {
    if(this.googleCompiled) return;
    this.register(require('./google_descriptors'));

    require('./compiler/encoders').encoders.addFieldEncoders();
    require('./compiler/coorcers').coercers.addFieldCoercers();

    this._finalize();
    this.googleDescriptorsCompiled();
    // These are only the google ones. We need to set their descriptors up
    Object.keys(registry).forEach(function(key) {
      var thing = registry[key];
      thing.fileDescriptor = new (registry['google.protobuf.FileDescriptorProto'])(thing.fileDescriptor);
      if(thing.type.name == 'TYPE_MESSAGE') {
        registry[key].updateDescriptor(new (registry['google.protobuf.DescriptorProto'])(thing.descriptor));
        registry[key].finalize(true);
      } else if(thing.type.name == 'TYPE_ENUM') {
        registry[key].updateDescriptor(new (registry['google.protobuf.EnumDescriptorProto'])(thing.descriptor));
        registry[key].finalize(true);
      } else if(thing.type.name == 'TYPE_SERVICE') {
        registry[key].updateDescriptor(new (registry['google.protobuf.ServiceDescriptorProto'])(thing.descriptor));
        registry[key].finalize(true);
      }
    });

  }

  REGISTRY = cache.registry = new Registry();
  module.exports = REGISTRY;
  REGISTRY.reset();
}

 at SyntaxError: 'return' outside of function (18:2)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$1.parseReturnStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:831:12)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:699:34)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseBlock (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:981:25)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:709:33)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseIfStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:824:28)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:698:30)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- File /root/Targets/protob/node_modules/protob/index.js. Coverage (Term): 24% Coverage (LOC): 40%
*- File /root/Targets/protob/node_modules/protob/lib/protob.js. Coverage (Term): 79% Coverage (LOC): 91%
*- File /root/Targets/protob/node_modules/bytebuffer/ByteBuffer.js. Coverage (Term): 9% Coverage (LOC): 19%
*- File /root/Targets/protob/node_modules/long/index.js. Coverage (Term): 95% Coverage (LOC): 100%
*- File /root/Targets/protob/node_modules/long/dist/Long.js. Coverage (Term): 20% Coverage (LOC): 32%
*- File /root/Targets/protob/node_modules/protob/lib/version.js. Coverage (Term): 94% Coverage (LOC): 100%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
