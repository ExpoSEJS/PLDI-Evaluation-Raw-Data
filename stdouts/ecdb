
> bson@0.2.22 install /root/Targets/ecdb/node_modules/tingodb/node_modules/bson
> (node-gyp rebuild 2> builderror.log) || (exit 0)

make: Entering directory '/root/Targets/ecdb/node_modules/tingodb/node_modules/bson/build'
  CXX(target) Release/obj.target/bson/ext/bson.o
bson.target.mk:92: recipe for target 'Release/obj.target/bson/ext/bson.o' failed
make: Leaving directory '/root/Targets/ecdb/node_modules/tingodb/node_modules/bson/build'
/root/Targets/ecdb
└─┬ ecdb@0.2.11 
  ├─┬ mongodb@2.2.31 
  │ ├── es6-promise@3.2.1 
  │ ├─┬ mongodb-core@2.1.15 
  │ │ ├── bson@1.0.4 
  │ │ └─┬ require_optional@1.0.1 
  │ │   ├── resolve-from@2.0.0 
  │ │   └── semver@5.4.1 
  │ └─┬ readable-stream@2.2.7 
  │   ├── buffer-shims@1.0.0 
  │   ├── core-util-is@1.0.2 
  │   ├── inherits@2.0.3 
  │   ├── isarray@1.0.0 
  │   ├── process-nextick-args@1.0.7 
  │   ├─┬ string_decoder@1.0.3 
  │   │ └── safe-buffer@5.1.1 
  │   └── util-deprecate@1.0.2 
  └─┬ tingodb@0.4.2 
    ├─┬ bson@0.2.22 
    │ └── nan@1.8.4 
    ├── lodash@3.10.1 
    └── safe@0.3.9 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/ecdb/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 1 running / 0 errors / 13% coverage ] ****** [1 done /0 queued / 1 running / 0 errors / 13% coverage ] ****** [2 done /1 queued / 1 running / 1 errors / 15% coverage ] ****** [2 done /0 queued / 2 running / 1 errors / 15% coverage ] ****** [2 done /0 queued / 2 running / 1 errors / 15% coverage ] ****** [3 done /0 queued / 2 running / 2 errors / 15% coverage ] ****** [3 done /0 queued / 2 running / 2 errors / 15% coverage ] ****** [4 done /1 queued / 2 running / 3 errors / 15% coverage ] ****** [4 done /0 queued / 3 running / 3 errors / 15% coverage ] ****** [4 done /0 queued / 3 running / 3 errors / 15% coverage ] ****** [5 done /2 queued / 3 running / 4 errors / 15% coverage ] ****** [5 done /1 queued / 4 running / 4 errors / 15% coverage ] ****** [5 done /0 queued / 5 running / 4 errors / 15% coverage ] ****** [5 done /0 queued / 5 running / 4 errors / 15% coverage ] ****** [6 done /1 queued / 5 running / 5 errors / 15% coverage ] ****** [6 done /0 queued / 6 running / 5 errors / 15% coverage ] ****** [6 done /0 queued / 6 running / 5 errors / 15% coverage ] ****** [7 done /0 queued / 6 running / 6 errors / 15% coverage ] ****** [7 done /0 queued / 6 running / 6 errors / 15% coverage ] ****** [8 done /0 queued / 5 running / 7 errors / 15% coverage ] ****** [9 done /3 queued / 5 running / 8 errors / 15% coverage ] ****** [9 done /2 queued / 6 running / 8 errors / 15% coverage ] ****** [9 done /1 queued / 7 running / 8 errors / 15% coverage ] ****** [9 done /0 queued / 8 running / 8 errors / 15% coverage ] ****** [9 done /0 queued / 8 running / 8 errors / 15% coverage ] ****** [10 done /0 queued / 8 running / 9 errors / 15% coverage ] ****** [10 done /0 queued / 8 running / 9 errors / 15% coverage ] ****** [11 done /0 queued / 7 running / 10 errors / 15% coverage ] ****** [12 done /2 queued / 7 running / 11 errors / 15% coverage ] ****** [12 done /1 queued / 8 running / 11 errors / 15% coverage ] ****** [12 done /0 queued / 9 running / 11 errors / 15% coverage ] ****** [12 done /0 queued / 9 running / 11 errors / 15% coverage ] ****** [13 done /0 queued / 9 running / 12 errors / 15% coverage ] ****** [13 done /0 queued / 9 running / 12 errors / 15% coverage ] ****** [14 done /0 queued / 9 running / 13 errors / 15% coverage ] ****** [14 done /0 queued / 9 running / 13 errors / 15% coverage ] ****** [15 done /0 queued / 8 running / 14 errors / 15% coverage ] ****** [16 done /0 queued / 8 running / 15 errors / 15% coverage ] ****** [16 done /0 queued / 8 running / 15 errors / 15% coverage ] ****** [17 done /2 queued / 8 running / 16 errors / 16% coverage ] ****** [17 done /1 queued / 9 running / 16 errors / 16% coverage ] ****** [17 done /0 queued / 10 running / 16 errors / 16% coverage ] ****** [17 done /0 queued / 10 running / 16 errors / 16% coverage ] ****** [18 done /1 queued / 10 running / 17 errors / 16% coverage ] ****** [18 done /0 queued / 11 running / 17 errors / 16% coverage ] ****** [18 done /0 queued / 11 running / 17 errors / 16% coverage ] ****** [19 done /0 queued / 10 running / 18 errors / 16% coverage ] ****** [20 done /0 queued / 9 running / 19 errors / 16% coverage ] ****** [21 done /1 queued / 9 running / 20 errors / 16% coverage ] ****** [21 done /0 queued / 10 running / 20 errors / 16% coverage ] ****** [21 done /0 queued / 10 running / 20 errors / 16% coverage ] ****** [22 done /0 queued / 9 running / 21 errors / 16% coverage ] ****** [23 done /5 queued / 9 running / 22 errors / 16% coverage ] ****** [23 done /4 queued / 10 running / 22 errors / 16% coverage ] ****** [23 done /3 queued / 11 running / 22 errors / 16% coverage ] ****** [23 done /2 queued / 12 running / 22 errors / 16% coverage ] ****** [23 done /1 queued / 13 running / 22 errors / 16% coverage ] ****** [23 done /0 queued / 14 running / 22 errors / 16% coverage ] ****** [23 done /0 queued / 14 running / 22 errors / 16% coverage ] ****** [24 done /2 queued / 14 running / 23 errors / 16% coverage ] ****** [24 done /1 queued / 15 running / 23 errors / 16% coverage ] ****** [24 done /0 queued / 16 running / 23 errors / 16% coverage ] ****** [24 done /0 queued / 16 running / 23 errors / 16% coverage ] ****** [25 done /0 queued / 16 running / 24 errors / 16% coverage ] ****** [25 done /0 queued / 16 running / 24 errors / 16% coverage ] ****** [26 done /0 queued / 15 running / 25 errors / 16% coverage ] ****** [27 done /2 queued / 15 running / 26 errors / 16% coverage ] ****** [27 done /1 queued / 16 running / 26 errors / 16% coverage ] ****** [27 done /1 queued / 16 running / 26 errors / 16% coverage ] ****** [28 done /2 queued / 16 running / 27 errors / 16% coverage ] ****** [28 done /2 queued / 16 running / 27 errors / 16% coverage ] ****** [29 done /1 queued / 16 running / 28 errors / 16% coverage ] ****** [29 done /1 queued / 16 running / 28 errors / 16% coverage ] ****** [30 done /2 queued / 16 running / 29 errors / 16% coverage ] ****** [30 done /2 queued / 16 running / 29 errors / 16% coverage ] ****** [31 done /2 queued / 16 running / 30 errors / 16% coverage ] ****** [31 done /2 queued / 16 running / 30 errors / 16% coverage ] ****** [32 done /1 queued / 16 running / 31 errors / 16% coverage ] ****** [32 done /1 queued / 16 running / 31 errors / 16% coverage ] ****** [33 done /3 queued / 16 running / 32 errors / 16% coverage ] ****** [33 done /3 queued / 16 running / 32 errors / 16% coverage ] ****** [34 done /5 queued / 16 running / 33 errors / 16% coverage ] ****** [34 done /5 queued / 16 running / 33 errors / 16% coverage ] ****** [35 done /5 queued / 16 running / 34 errors / 16% coverage ] ****** [35 done /5 queued / 16 running / 34 errors / 16% coverage ] ****** [36 done /5 queued / 16 running / 35 errors / 16% coverage ] ****** [36 done /5 queued / 16 running / 35 errors / 16% coverage ] ****** [37 done /4 queued / 16 running / 36 errors / 16% coverage ] ****** [37 done /4 queued / 16 running / 36 errors / 16% coverage ] ****** [38 done /4 queued / 16 running / 37 errors / 16% coverage ] ****** [38 done /4 queued / 16 running / 37 errors / 16% coverage ] ****** [39 done /7 queued / 16 running / 38 errors / 16% coverage ] ****** [39 done /7 queued / 16 running / 38 errors / 16% coverage ] ****** [40 done /11 queued / 16 running / 39 errors / 16% coverage ] ****** [40 done /11 queued / 16 running / 39 errors / 16% coverage ] ****** [41 done /13 queued / 16 running / 40 errors / 16% coverage ] ****** [41 done /13 queued / 16 running / 40 errors / 16% coverage ] ****** [42 done /14 queued / 16 running / 41 errors / 16% coverage ] ****** [42 done /14 queued / 16 running / 41 errors / 16% coverage ] ****** [43 done /16 queued / 16 running / 42 errors / 16% coverage ] ****** [43 done /16 queued / 16 running / 42 errors / 16% coverage ] ****** [44 done /18 queued / 16 running / 43 errors / 16% coverage ] ****** [44 done /18 queued / 16 running / 43 errors / 16% coverage ] ****** [45 done /17 queued / 16 running / 44 errors / 16% coverage ] ****** [45 done /17 queued / 16 running / 44 errors / 16% coverage ] ****** [46 done /18 queued / 16 running / 45 errors / 16% coverage ] ****** [46 done /18 queued / 16 running / 45 errors / 16% coverage ] ****** [47 done /17 queued / 16 running / 46 errors / 16% coverage ] ****** [47 done /17 queued / 16 running / 46 errors / 16% coverage ] ****** [48 done /18 queued / 16 running / 47 errors / 16% coverage ] ****** [48 done /18 queued / 16 running / 47 errors / 16% coverage ] ****** [49 done /20 queued / 16 running / 48 errors / 16% coverage ] ****** [49 done /20 queued / 16 running / 48 errors / 16% coverage ] ****** [50 done /23 queued / 16 running / 49 errors / 16% coverage ] ****** [50 done /23 queued / 16 running / 49 errors / 16% coverage ] ****** [51 done /22 queued / 16 running / 50 errors / 16% coverage ] ****** [51 done /22 queued / 16 running / 50 errors / 16% coverage ] ****** [52 done /21 queued / 16 running / 51 errors / 16% coverage ] ****** [52 done /21 queued / 16 running / 51 errors / 16% coverage ] ****** [53 done /23 queued / 16 running / 52 errors / 16% coverage ] ****** [53 done /23 queued / 16 running / 52 errors / 16% coverage ] ****** [54 done /26 queued / 16 running / 53 errors / 16% coverage ] ****** [54 done /26 queued / 16 running / 53 errors / 16% coverage ] ****** [55 done /26 queued / 16 running / 54 errors / 16% coverage ] ****** [55 done /26 queued / 16 running / 54 errors / 16% coverage ] ****** [56 done /28 queued / 16 running / 55 errors / 16% coverage ] ****** [56 done /28 queued / 16 running / 55 errors / 16% coverage ] ****** [57 done /28 queued / 16 running / 56 errors / 16% coverage ] ****** [57 done /28 queued / 16 running / 56 errors / 16% coverage ] ****** [58 done /27 queued / 16 running / 57 errors / 16% coverage ] ****** [58 done /27 queued / 16 running / 57 errors / 16% coverage ] ****** [59 done /26 queued / 16 running / 58 errors / 16% coverage ] ****** [59 done /26 queued / 16 running / 58 errors / 16% coverage ] ****** [60 done /27 queued / 16 running / 59 errors / 16% coverage ] ****** [60 done /27 queued / 16 running / 59 errors / 16% coverage ] ****** [61 done /28 queued / 16 running / 60 errors / 16% coverage ] ****** [61 done /28 queued / 16 running / 60 errors / 16% coverage ] ****** [62 done /30 queued / 16 running / 61 errors / 16% coverage ] ****** [62 done /30 queued / 16 running / 61 errors / 16% coverage ] ****** [63 done /32 queued / 16 running / 62 errors / 16% coverage ] ****** [63 done /32 queued / 16 running / 62 errors / 16% coverage ] ****** [64 done /33 queued / 16 running / 63 errors / 16% coverage ] ****** [64 done /33 queued / 16 running / 63 errors / 16% coverage ] ****** [65 done /34 queued / 16 running / 64 errors / 16% coverage ] ****** [65 done /34 queued / 16 running / 64 errors / 16% coverage ] ****** [66 done /34 queued / 16 running / 65 errors / 16% coverage ] ****** [66 done /34 queued / 16 running / 65 errors / 16% coverage ] ****** [67 done /35 queued / 16 running / 66 errors / 16% coverage ] ****** [67 done /35 queued / 16 running / 66 errors / 16% coverage ] ****** [68 done /34 queued / 16 running / 67 errors / 16% coverage ] ****** [68 done /34 queued / 16 running / 67 errors / 16% coverage ] ****** [69 done /35 queued / 16 running / 68 errors / 16% coverage ] ****** [69 done /35 queued / 16 running / 68 errors / 16% coverage ] ****** [70 done /37 queued / 16 running / 69 errors / 16% coverage ] ****** [70 done /37 queued / 16 running / 69 errors / 16% coverage ] ****** [71 done /38 queued / 16 running / 70 errors / 16% coverage ] ****** [71 done /38 queued / 16 running / 70 errors / 16% coverage ] ****** [72 done /40 queued / 16 running / 71 errors / 16% coverage ] ****** [72 done /40 queued / 16 running / 71 errors / 16% coverage ] ****** [73 done /41 queued / 16 running / 72 errors / 16% coverage ] ****** [73 done /41 queued / 16 running / 72 errors / 16% coverage ] ****** [74 done /43 queued / 16 running / 73 errors / 16% coverage ] ****** [74 done /43 queued / 16 running / 73 errors / 16% coverage ] ****** [75 done /44 queued / 16 running / 74 errors / 16% coverage ] ****** [75 done /44 queued / 16 running / 74 errors / 16% coverage ] ****** [76 done /47 queued / 16 running / 75 errors / 16% coverage ] ****** [76 done /47 queued / 16 running / 75 errors / 16% coverage ] ****** [77 done /48 queued / 16 running / 76 errors / 16% coverage ] ****** [77 done /48 queued / 16 running / 76 errors / 16% coverage ] ****** [78 done /49 queued / 16 running / 77 errors / 16% coverage ] ****** [78 done /49 queued / 16 running / 77 errors / 16% coverage ] ****** [79 done /48 queued / 16 running / 78 errors / 16% coverage ] ****** [79 done /48 queued / 16 running / 78 errors / 16% coverage ] ****** [80 done /47 queued / 16 running / 79 errors / 16% coverage ] ****** [80 done /47 queued / 16 running / 79 errors / 16% coverage ] ****** [81 done /50 queued / 16 running / 80 errors / 16% coverage ] ****** [81 done /50 queued / 16 running / 80 errors / 16% coverage ] ****** [82 done /49 queued / 16 running / 81 errors / 16% coverage ] ****** [82 done /49 queued / 16 running / 81 errors / 16% coverage ] ****** [83 done /48 queued / 16 running / 82 errors / 16% coverage ] ****** [83 done /48 queued / 16 running / 82 errors / 16% coverage ] ****** [84 done /48 queued / 16 running / 83 errors / 16% coverage ] ****** [84 done /48 queued / 16 running / 83 errors / 16% coverage ] ****** [85 done /50 queued / 16 running / 84 errors / 16% coverage ] ****** [85 done /50 queued / 16 running / 84 errors / 16% coverage ] ****** [86 done /51 queued / 16 running / 85 errors / 16% coverage ] ****** [86 done /51 queued / 16 running / 85 errors / 16% coverage ] ****** [87 done /50 queued / 16 running / 86 errors / 16% coverage ] ****** [87 done /50 queued / 16 running / 86 errors / 16% coverage ] ****** [88 done /51 queued / 16 running / 87 errors / 16% coverage ] ****** [88 done /51 queued / 16 running / 87 errors / 16% coverage ] ****** [89 done /50 queued / 16 running / 88 errors / 16% coverage ] ****** [89 done /50 queued / 16 running / 88 errors / 16% coverage ] ****** [90 done /52 queued / 16 running / 89 errors / 16% coverage ] ****** [90 done /52 queued / 16 running / 89 errors / 16% coverage ] ****** [91 done /53 queued / 16 running / 90 errors / 16% coverage ] ****** [91 done /53 queued / 16 running / 90 errors / 16% coverage ] ****** [92 done /55 queued / 16 running / 91 errors / 16% coverage ] ****** [92 done /55 queued / 16 running / 91 errors / 16% coverage ] ****** [93 done /56 queued / 16 running / 92 errors / 16% coverage ] ****** [93 done /56 queued / 16 running / 92 errors / 16% coverage ] ****** [94 done /56 queued / 16 running / 93 errors / 16% coverage ] ****** [94 done /56 queued / 16 running / 93 errors / 16% coverage ] ****** [95 done /58 queued / 16 running / 94 errors / 16% coverage ] ****** [95 done /58 queued / 16 running / 94 errors / 16% coverage ] ****** [96 done /62 queued / 16 running / 95 errors / 16% coverage ] ****** [96 done /62 queued / 16 running / 95 errors / 16% coverage ] ****** [97 done /64 queued / 16 running / 96 errors / 16% coverage ] ****** [97 done /64 queued / 16 running / 96 errors / 16% coverage ] ****** [98 done /65 queued / 16 running / 97 errors / 16% coverage ] ****** [98 done /65 queued / 16 running / 97 errors / 16% coverage ] ****** [99 done /64 queued / 16 running / 98 errors / 16% coverage ] ****** [99 done /64 queued / 16 running / 98 errors / 16% coverage ] ****** [100 done /66 queued / 16 running / 99 errors / 16% coverage ] ****** [100 done /66 queued / 16 running / 99 errors / 16% coverage ] ****** [101 done /68 queued / 16 running / 100 errors / 16% coverage ] ****** [101 done /68 queued / 16 running / 100 errors / 16% coverage ] ****** [102 done /72 queued / 16 running / 101 errors / 16% coverage ] ****** [102 done /72 queued / 16 running / 101 errors / 16% coverage ] ****** [103 done /73 queued / 16 running / 102 errors / 16% coverage ] ****** [103 done /73 queued / 16 running / 102 errors / 16% coverage ] ****** [104 done /75 queued / 16 running / 103 errors / 16% coverage ] ****** [104 done /75 queued / 16 running / 103 errors / 16% coverage ] ****** [105 done /77 queued / 16 running / 104 errors / 16% coverage ] ****** [105 done /77 queued / 16 running / 104 errors / 16% coverage ] ****** [106 done /77 queued / 16 running / 105 errors / 16% coverage ] ****** [106 done /77 queued / 16 running / 105 errors / 16% coverage ] ****** [107 done /77 queued / 16 running / 106 errors / 16% coverage ] ****** [107 done /77 queued / 16 running / 106 errors / 16% coverage ] ****** [108 done /79 queued / 16 running / 107 errors / 16% coverage ] ****** [108 done /79 queued / 16 running / 107 errors / 16% coverage ] ****** [109 done /82 queued / 16 running / 108 errors / 16% coverage ] ****** [109 done /82 queued / 16 running / 108 errors / 16% coverage ] ****** [110 done /82 queued / 16 running / 109 errors / 16% coverage ] ****** [110 done /82 queued / 16 running / 109 errors / 16% coverage ] ****** [111 done /83 queued / 16 running / 110 errors / 16% coverage ] ****** [111 done /83 queued / 16 running / 110 errors / 16% coverage ] ****** [112 done /83 queued / 16 running / 111 errors / 16% coverage ] ****** [112 done /83 queued / 16 running / 111 errors / 16% coverage ] ****** [113 done /83 queued / 16 running / 112 errors / 16% coverage ] ****** [113 done /83 queued / 16 running / 112 errors / 16% coverage ] ****** [114 done /85 queued / 16 running / 113 errors / 16% coverage ] ****** [114 done /85 queued / 16 running / 113 errors / 16% coverage ] ****** [115 done /86 queued / 16 running / 114 errors / 16% coverage ] ****** [115 done /86 queued / 16 running / 114 errors / 16% coverage ] ****** [116 done /86 queued / 16 running / 115 errors / 16% coverage ] ****** [116 done /86 queued / 16 running / 115 errors / 16% coverage ] ****** [117 done /87 queued / 16 running / 116 errors / 16% coverage ] ****** [117 done /87 queued / 16 running / 116 errors / 16% coverage ] ****** [118 done /89 queued / 16 running / 117 errors / 16% coverage ] ****** [118 done /89 queued / 16 running / 117 errors / 16% coverage ] ****** [119 done /88 queued / 16 running / 118 errors / 16% coverage ] ****** [119 done /88 queued / 16 running / 118 errors / 16% coverage ] ****** [120 done /89 queued / 16 running / 119 errors / 16% coverage ] ****** [120 done /89 queued / 16 running / 119 errors / 16% coverage ] ****** [121 done /92 queued / 16 running / 120 errors / 16% coverage ] ****** [121 done /92 queued / 16 running / 120 errors / 16% coverage ] ****** [122 done /93 queued / 16 running / 121 errors / 16% coverage ] ****** [122 done /93 queued / 16 running / 121 errors / 16% coverage ] ****** [123 done /94 queued / 16 running / 122 errors / 16% coverage ] ****** [123 done /94 queued / 16 running / 122 errors / 16% coverage ] ****** [124 done /95 queued / 16 running / 123 errors / 16% coverage ] ****** [124 done /95 queued / 16 running / 123 errors / 16% coverage ] ****** [125 done /96 queued / 16 running / 124 errors / 16% coverage ] ****** [125 done /96 queued / 16 running / 124 errors / 16% coverage ] ****** [126 done /97 queued / 16 running / 125 errors / 16% coverage ] ****** [126 done /97 queued / 16 running / 125 errors / 16% coverage ] ****** [127 done /98 queued / 16 running / 126 errors / 16% coverage ] ****** [127 done /98 queued / 16 running / 126 errors / 16% coverage ] ****** [128 done /98 queued / 16 running / 127 errors / 16% coverage ] ****** [128 done /98 queued / 16 running / 127 errors / 16% coverage ] ****** [129 done /100 queued / 16 running / 128 errors / 16% coverage ] ****** [129 done /100 queued / 16 running / 128 errors / 16% coverage ] ****** [130 done /99 queued / 16 running / 129 errors / 16% coverage ] ****** [130 done /99 queued / 16 running / 129 errors / 16% coverage ] ****** [131 done /98 queued / 16 running / 130 errors / 16% coverage ] ****** [131 done /98 queued / 16 running / 130 errors / 16% coverage ] ****** [132 done /100 queued / 16 running / 131 errors / 16% coverage ] ****** [132 done /100 queued / 16 running / 131 errors / 16% coverage ] ****** [133 done /100 queued / 16 running / 132 errors / 16% coverage ] ****** [133 done /100 queued / 16 running / 132 errors / 16% coverage ] ****** [134 done /99 queued / 16 running / 133 errors / 16% coverage ] ****** [134 done /99 queued / 16 running / 133 errors / 16% coverage ] ****** [135 done /98 queued / 16 running / 134 errors / 16% coverage ] ****** [135 done /98 queued / 16 running / 134 errors / 16% coverage ] ****** [136 done /100 queued / 16 running / 135 errors / 16% coverage ] ****** [136 done /100 queued / 16 running / 135 errors / 16% coverage ] ****** [137 done /102 queued / 16 running / 136 errors / 16% coverage ] ****** [137 done /102 queued / 16 running / 136 errors / 16% coverage ] ****** [138 done /102 queued / 16 running / 137 errors / 16% coverage ] ****** [138 done /102 queued / 16 running / 137 errors / 16% coverage ] ****** [139 done /103 queued / 16 running / 138 errors / 16% coverage ] ****** [139 done /103 queued / 16 running / 138 errors / 16% coverage ] ****** [140 done /102 queued / 16 running / 139 errors / 16% coverage ] ****** [140 done /102 queued / 16 running / 139 errors / 16% coverage ] ****** [141 done /103 queued / 16 running / 140 errors / 16% coverage ] ****** [141 done /103 queued / 16 running / 140 errors / 16% coverage ] ****** [142 done /102 queued / 16 running / 141 errors / 16% coverage ] ****** [142 done /102 queued / 16 running / 141 errors / 16% coverage ] ****** [143 done /102 queued / 16 running / 142 errors / 16% coverage ] ****** [143 done /102 queued / 16 running / 142 errors / 16% coverage ] ****** [144 done /101 queued / 16 running / 143 errors / 16% coverage ] ****** [144 done /101 queued / 16 running / 143 errors / 16% coverage ] ****** [145 done /102 queued / 16 running / 144 errors / 16% coverage ] ****** [145 done /102 queued / 16 running / 144 errors / 16% coverage ] ****** [146 done /104 queued / 16 running / 145 errors / 16% coverage ] ****** [146 done /104 queued / 16 running / 145 errors / 16% coverage ] ****** [147 done /106 queued / 16 running / 146 errors / 16% coverage ] ****** [147 done /106 queued / 16 running / 146 errors / 16% coverage ] ****** [148 done /105 queued / 16 running / 147 errors / 16% coverage ] ****** [148 done /105 queued / 16 running / 147 errors / 16% coverage ] ****** [149 done /107 queued / 16 running / 148 errors / 16% coverage ] ****** [149 done /107 queued / 16 running / 148 errors / 16% coverage ] ****** [150 done /106 queued / 16 running / 149 errors / 16% coverage ] ****** [150 done /106 queued / 16 running / 149 errors / 16% coverage ] ****** [151 done /108 queued / 16 running / 150 errors / 16% coverage ] ****** [151 done /108 queued / 16 running / 150 errors / 16% coverage ] ****** [152 done /110 queued / 16 running / 151 errors / 16% coverage ] ****** [152 done /110 queued / 16 running / 151 errors / 16% coverage ] ****** [153 done /112 queued / 16 running / 152 errors / 16% coverage ] ****** [153 done /112 queued / 16 running / 152 errors / 16% coverage ] ****** [154 done /116 queued / 16 running / 153 errors / 16% coverage ] ****** [154 done /116 queued / 16 running / 153 errors / 16% coverage ] ****** [155 done /116 queued / 16 running / 154 errors / 16% coverage ] ****** [155 done /116 queued / 16 running / 154 errors / 16% coverage ] ****** [156 done /119 queued / 16 running / 155 errors / 16% coverage ] ****** [156 done /119 queued / 16 running / 155 errors / 16% coverage ] ****** [157 done /119 queued / 16 running / 156 errors / 16% coverage ] ****** [157 done /119 queued / 16 running / 156 errors / 16% coverage ] ****** [158 done /118 queued / 16 running / 157 errors / 16% coverage ] ****** [158 done /118 queued / 16 running / 157 errors / 16% coverage ] ****** [159 done /119 queued / 16 running / 158 errors / 16% coverage ] ****** [159 done /119 queued / 16 running / 158 errors / 16% coverage ] ****** [160 done /122 queued / 16 running / 159 errors / 16% coverage ] ****** [160 done /122 queued / 16 running / 159 errors / 16% coverage ] ****** [161 done /121 queued / 16 running / 160 errors / 16% coverage ] ****** [161 done /121 queued / 16 running / 160 errors / 16% coverage ] ****** [162 done /123 queued / 16 running / 161 errors / 16% coverage ] ****** [162 done /123 queued / 16 running / 161 errors / 16% coverage ] ****** [163 done /124 queued / 16 running / 162 errors / 16% coverage ] ****** [163 done /124 queued / 16 running / 162 errors / 16% coverage ] ****** [164 done /125 queued / 16 running / 163 errors / 16% coverage ] ****** [164 done /125 queued / 16 running / 163 errors / 16% coverage ] ****** [165 done /126 queued / 16 running / 164 errors / 16% coverage ] ****** [165 done /126 queued / 16 running / 164 errors / 16% coverage ] ****** [166 done /125 queued / 16 running / 165 errors / 16% coverage ] ****** [166 done /125 queued / 16 running / 165 errors / 16% coverage ] ****** [167 done /125 queued / 16 running / 166 errors / 16% coverage ] ****** [167 done /125 queued / 16 running / 166 errors / 16% coverage ] ****** [168 done /125 queued / 16 running / 167 errors / 16% coverage ] ****** [168 done /125 queued / 16 running / 167 errors / 16% coverage ] ****** [169 done /126 queued / 16 running / 168 errors / 16% coverage ] ****** [169 done /126 queued / 16 running / 168 errors / 16% coverage ] ****** [170 done /126 queued / 16 running / 169 errors / 16% coverage ] ****** [170 done /126 queued / 16 running / 169 errors / 16% coverage ] ****** [171 done /128 queued / 16 running / 170 errors / 16% coverage ] ****** [171 done /128 queued / 16 running / 170 errors / 16% coverage ] ****** [172 done /131 queued / 16 running / 171 errors / 16% coverage ] ****** [172 done /131 queued / 16 running / 171 errors / 16% coverage ] ****** [173 done /130 queued / 16 running / 172 errors / 16% coverage ] ****** [173 done /130 queued / 16 running / 172 errors / 16% coverage ] ****** [174 done /129 queued / 16 running / 173 errors / 16% coverage ] ****** [174 done /129 queued / 16 running / 173 errors / 16% coverage ] ****** [175 done /128 queued / 16 running / 174 errors / 16% coverage ] ****** [175 done /128 queued / 16 running / 174 errors / 16% coverage ] ****** [176 done /129 queued / 16 running / 175 errors / 16% coverage ] ****** [176 done /129 queued / 16 running / 175 errors / 16% coverage ] ****** [177 done /133 queued / 16 running / 176 errors / 16% coverage ] ****** [177 done /133 queued / 16 running / 176 errors / 16% coverage ] ****** [178 done /133 queued / 16 running / 177 errors / 16% coverage ] ****** [178 done /133 queued / 16 running / 177 errors / 16% coverage ] ****** [179 done /133 queued / 16 running / 178 errors / 16% coverage ] ****** [179 done /133 queued / 16 running / 178 errors / 16% coverage ] ****** [180 done /132 queued / 16 running / 179 errors / 16% coverage ] ****** [180 done /132 queued / 16 running / 179 errors / 16% coverage ] ****** [181 done /133 queued / 16 running / 180 errors / 16% coverage ] ****** [181 done /133 queued / 16 running / 180 errors / 16% coverage ] ****** [182 done /135 queued / 16 running / 181 errors / 16% coverage ] ****** [182 done /135 queued / 16 running / 181 errors / 16% coverage ] ****** [183 done /137 queued / 16 running / 182 errors / 16% coverage ] ****** [183 done /137 queued / 16 running / 182 errors / 16% coverage ] ****** [184 done /139 queued / 16 running / 183 errors / 16% coverage ] ****** [184 done /139 queued / 16 running / 183 errors / 16% coverage ] ****** [185 done /139 queued / 16 running / 184 errors / 16% coverage ] ****** [185 done /139 queued / 16 running / 184 errors / 16% coverage ] ****** [186 done /139 queued / 16 running / 185 errors / 16% coverage ] ****** [186 done /139 queued / 16 running / 185 errors / 16% coverage ] ****** [187 done /139 queued / 16 running / 186 errors / 16% coverage ] ****** [187 done /139 queued / 16 running / 186 errors / 16% coverage ] ****** [188 done /140 queued / 16 running / 187 errors / 16% coverage ] ****** [188 done /140 queued / 16 running / 187 errors / 16% coverage ] ****** [189 done /139 queued / 16 running / 188 errors / 16% coverage ] ****** [189 done /139 queued / 16 running / 188 errors / 16% coverage ] ****** [190 done /141 queued / 16 running / 189 errors / 16% coverage ] ****** [190 done /141 queued / 16 running / 189 errors / 16% coverage ] ****** [191 done /140 queued / 16 running / 190 errors / 16% coverage ] ****** [191 done /140 queued / 16 running / 190 errors / 16% coverage ] ****** [192 done /141 queued / 16 running / 191 errors / 16% coverage ] ****** [192 done /141 queued / 16 running / 191 errors / 16% coverage ] ****** [193 done /140 queued / 16 running / 192 errors / 16% coverage ] ****** [193 done /140 queued / 16 running / 192 errors / 16% coverage ] ****** [194 done /139 queued / 16 running / 193 errors / 16% coverage ] ****** [194 done /139 queued / 16 running / 193 errors / 16% coverage ] ****** [195 done /140 queued / 16 running / 194 errors / 16% coverage ] ****** [195 done /140 queued / 16 running / 194 errors / 16% coverage ] ****** [196 done /141 queued / 16 running / 195 errors / 16% coverage ] ****** [196 done /141 queued / 16 running / 195 errors / 16% coverage ] ****** [197 done /141 queued / 16 running / 196 errors / 16% coverage ] ****** [197 done /141 queued / 16 running / 196 errors / 16% coverage ] ****** [198 done /141 queued / 16 running / 197 errors / 16% coverage ] ****** [198 done /141 queued / 16 running / 197 errors / 16% coverage ] ****** [199 done /143 queued / 16 running / 198 errors / 16% coverage ] ****** [199 done /143 queued / 16 running / 198 errors / 16% coverage ] ****** [200 done /142 queued / 16 running / 199 errors / 16% coverage ] ****** [200 done /142 queued / 16 running / 199 errors / 16% coverage ] ****** [201 done /144 queued / 16 running / 200 errors / 16% coverage ] ****** [201 done /144 queued / 16 running / 200 errors / 16% coverage ] ****** [202 done /145 queued / 16 running / 201 errors / 16% coverage ] ****** [202 done /145 queued / 16 running / 201 errors / 16% coverage ] ****** [203 done /147 queued / 16 running / 202 errors / 16% coverage ] ****** [203 done /147 queued / 16 running / 202 errors / 16% coverage ] ****** [204 done /148 queued / 16 running / 203 errors / 16% coverage ] ****** [204 done /148 queued / 16 running / 203 errors / 16% coverage ] ****** [205 done /150 queued / 16 running / 204 errors / 16% coverage ] ****** [205 done /150 queued / 16 running / 204 errors / 16% coverage ] ****** [206 done /149 queued / 16 running / 205 errors / 16% coverage ] ****** [206 done /149 queued / 16 running / 205 errors / 16% coverage ] ****** [207 done /152 queued / 16 running / 206 errors / 16% coverage ] ****** [207 done /152 queued / 16 running / 206 errors / 16% coverage ] ****** [208 done /151 queued / 16 running / 207 errors / 16% coverage ] ****** [208 done /151 queued / 16 running / 207 errors / 16% coverage ] ****** [209 done /150 queued / 16 running / 208 errors / 16% coverage ] ****** [209 done /150 queued / 16 running / 208 errors / 16% coverage ] ****** [210 done /153 queued / 16 running / 209 errors / 16% coverage ] ****** [210 done /153 queued / 16 running / 209 errors / 16% coverage ] ****** [211 done /153 queued / 16 running / 210 errors / 16% coverage ] ****** [211 done /153 queued / 16 running / 210 errors / 16% coverage ] ****** [212 done /152 queued / 16 running / 211 errors / 16% coverage ] ****** [212 done /152 queued / 16 running / 211 errors / 16% coverage ] ****** [213 done /151 queued / 16 running / 212 errors / 16% coverage ] ****** [213 done /151 queued / 16 running / 212 errors / 16% coverage ] ****** [214 done /152 queued / 16 running / 213 errors / 16% coverage ] ****** [214 done /152 queued / 16 running / 213 errors / 16% coverage ] ****** [215 done /154 queued / 16 running / 214 errors / 16% coverage ] ****** [215 done /154 queued / 16 running / 214 errors / 16% coverage ] ****** [216 done /154 queued / 16 running / 215 errors / 16% coverage ] ****** [216 done /154 queued / 16 running / 215 errors / 16% coverage ] ****** [217 done /153 queued / 16 running / 216 errors / 16% coverage ] ****** [217 done /153 queued / 16 running / 216 errors / 16% coverage ] ****** [218 done /152 queued / 16 running / 217 errors / 16% coverage ] ****** [218 done /152 queued / 16 running / 217 errors / 16% coverage ] ****** [219 done /154 queued / 16 running / 218 errors / 16% coverage ] ****** [219 done /154 queued / 16 running / 218 errors / 16% coverage ] ****** [220 done /154 queued / 16 running / 219 errors / 16% coverage ] ****** [220 done /154 queued / 16 running / 219 errors / 16% coverage ] ****** [221 done /158 queued / 16 running / 220 errors / 16% coverage ] ****** [221 done /158 queued / 16 running / 220 errors / 16% coverage ] ****** [222 done /157 queued / 16 running / 221 errors / 16% coverage ] ****** [222 done /157 queued / 16 running / 221 errors / 16% coverage ] ****** [223 done /158 queued / 16 running / 222 errors / 16% coverage ] ****** [223 done /158 queued / 16 running / 222 errors / 16% coverage ] ****** [224 done /160 queued / 16 running / 223 errors / 16% coverage ] ****** [224 done /160 queued / 16 running / 223 errors / 16% coverage ] ****** [225 done /162 queued / 16 running / 224 errors / 16% coverage ] ****** [225 done /162 queued / 16 running / 224 errors / 16% coverage ] ****** [226 done /162 queued / 16 running / 225 errors / 16% coverage ] ****** [226 done /162 queued / 16 running / 225 errors / 16% coverage ] ****** [227 done /161 queued / 16 running / 226 errors / 16% coverage ] ****** [227 done /161 queued / 16 running / 226 errors / 16% coverage ] ****** [228 done /162 queued / 16 running / 227 errors / 16% coverage ] ****** [228 done /162 queued / 16 running / 227 errors / 16% coverage ] ****** [229 done /161 queued / 16 running / 228 errors / 16% coverage ] ****** [229 done /161 queued / 16 running / 228 errors / 16% coverage ] ****** [230 done /162 queued / 16 running / 229 errors / 16% coverage ] ****** [230 done /162 queued / 16 running / 229 errors / 16% coverage ] ****** [231 done /164 queued / 16 running / 230 errors / 16% coverage ] ****** [231 done /164 queued / 16 running / 230 errors / 16% coverage ] ****** [232 done /166 queued / 16 running / 231 errors / 16% coverage ] ****** [232 done /166 queued / 16 running / 231 errors / 16% coverage ] ****** [233 done /165 queued / 16 running / 232 errors / 16% coverage ] ****** [233 done /165 queued / 16 running / 232 errors / 16% coverage ] ****** [234 done /164 queued / 16 running / 233 errors / 16% coverage ] ****** [234 done /164 queued / 16 running / 233 errors / 16% coverage ] ****** [235 done /164 queued / 16 running / 234 errors / 16% coverage ] ****** [235 done /164 queued / 16 running / 234 errors / 16% coverage ] ****** [236 done /163 queued / 16 running / 235 errors / 16% coverage ] ****** [236 done /163 queued / 16 running / 235 errors / 16% coverage ] ****** [237 done /164 queued / 16 running / 236 errors / 16% coverage ] ****** [237 done /164 queued / 16 running / 236 errors / 16% coverage ] ****** [238 done /163 queued / 16 running / 237 errors / 16% coverage ] ****** [238 done /163 queued / 16 running / 237 errors / 16% coverage ] ****** [239 done /166 queued / 16 running / 238 errors / 16% coverage ] ****** [239 done /166 queued / 16 running / 238 errors / 16% coverage ] ****** [240 done /165 queued / 16 running / 239 errors / 16% coverage ] ****** [240 done /165 queued / 16 running / 239 errors / 16% coverage ] ****** [241 done /166 queued / 16 running / 240 errors / 16% coverage ] ****** [241 done /166 queued / 16 running / 240 errors / 16% coverage ] ****** [242 done /166 queued / 16 running / 241 errors / 16% coverage ] ****** [242 done /166 queued / 16 running / 241 errors / 16% coverage ] ****** [243 done /167 queued / 16 running / 242 errors / 16% coverage ] ****** [243 done /167 queued / 16 running / 242 errors / 16% coverage ] ****** [244 done /169 queued / 16 running / 243 errors / 16% coverage ] ****** [244 done /169 queued / 16 running / 243 errors / 16% coverage ] ****** [245 done /172 queued / 16 running / 244 errors / 16% coverage ] ****** [245 done /172 queued / 16 running / 244 errors / 16% coverage ] ****** [246 done /171 queued / 16 running / 245 errors / 16% coverage ] ****** [246 done /171 queued / 16 running / 245 errors / 16% coverage ] ****** [247 done /172 queued / 16 running / 246 errors / 16% coverage ] ****** [247 done /172 queued / 16 running / 246 errors / 16% coverage ] ****** [248 done /175 queued / 16 running / 247 errors / 16% coverage ] ****** [248 done /175 queued / 16 running / 247 errors / 16% coverage ] ****** [249 done /177 queued / 16 running / 248 errors / 16% coverage ] ****** [249 done /177 queued / 16 running / 248 errors / 16% coverage ] ****** [250 done /177 queued / 16 running / 249 errors / 16% coverage ] ****** [250 done /177 queued / 16 running / 249 errors / 16% coverage ] ****** [251 done /179 queued / 16 running / 250 errors / 16% coverage ] ****** [251 done /179 queued / 16 running / 250 errors / 16% coverage ] ****** [252 done /181 queued / 16 running / 251 errors / 16% coverage ] ****** [252 done /181 queued / 16 running / 251 errors / 16% coverage ] ****** [253 done /180 queued / 16 running / 252 errors / 16% coverage ] ****** [253 done /180 queued / 16 running / 252 errors / 16% coverage ] ****** [254 done /181 queued / 16 running / 253 errors / 16% coverage ] ****** [254 done /181 queued / 16 running / 253 errors / 16% coverage ] ****** [255 done /181 queued / 16 running / 254 errors / 16% coverage ] ****** [255 done /181 queued / 16 running / 254 errors / 16% coverage ] ****** [256 done /180 queued / 16 running / 255 errors / 16% coverage ] ****** [256 done /180 queued / 16 running / 255 errors / 16% coverage ] ****** [257 done /180 queued / 16 running / 256 errors / 16% coverage ] ****** [257 done /180 queued / 16 running / 256 errors / 16% coverage ] ****** [258 done /182 queued / 16 running / 257 errors / 16% coverage ] ****** [258 done /182 queued / 16 running / 257 errors / 16% coverage ] ****** [259 done /183 queued / 16 running / 258 errors / 16% coverage ] ****** [259 done /183 queued / 16 running / 258 errors / 16% coverage ] ****** [260 done /182 queued / 16 running / 259 errors / 16% coverage ] ****** [260 done /182 queued / 16 running / 259 errors / 16% coverage ] ****** [261 done /183 queued / 16 running / 260 errors / 16% coverage ] ****** [261 done /183 queued / 16 running / 260 errors / 16% coverage ] ****** [262 done /185 queued / 16 running / 261 errors / 16% coverage ] ****** [262 done /185 queued / 16 running / 261 errors / 16% coverage ] ****** [263 done /187 queued / 16 running / 262 errors / 16% coverage ] ****** [263 done /187 queued / 16 running / 262 errors / 16% coverage ] ****** [264 done /186 queued / 16 running / 263 errors / 16% coverage ] ****** [264 done /186 queued / 16 running / 263 errors / 16% coverage ] ****** [265 done /186 queued / 16 running / 264 errors / 16% coverage ] ****** [265 done /186 queued / 16 running / 264 errors / 16% coverage ] ****** [266 done /185 queued / 16 running / 265 errors / 16% coverage ] ****** [266 done /185 queued / 16 running / 265 errors / 16% coverage ] ****** [267 done /184 queued / 16 running / 266 errors / 16% coverage ] ****** [267 done /184 queued / 16 running / 266 errors / 16% coverage ] ****** [268 done /185 queued / 16 running / 267 errors / 16% coverage ] ****** [268 done /185 queued / 16 running / 267 errors / 16% coverage ] ****** [269 done /186 queued / 16 running / 268 errors / 16% coverage ] ****** [269 done /186 queued / 16 running / 268 errors / 16% coverage ] ****** [270 done /189 queued / 16 running / 269 errors / 16% coverage ] ****** [270 done /189 queued / 16 running / 269 errors / 16% coverage ] ****** [271 done /191 queued / 16 running / 270 errors / 16% coverage ] ****** [271 done /191 queued / 16 running / 270 errors / 16% coverage ] ****** [272 done /190 queued / 16 running / 271 errors / 16% coverage ] ****** [272 done /190 queued / 16 running / 271 errors / 16% coverage ] ****** [273 done /192 queued / 16 running / 272 errors / 16% coverage ] ****** [273 done /192 queued / 16 running / 272 errors / 16% coverage ] ****** [274 done /194 queued / 16 running / 273 errors / 16% coverage ] ****** [274 done /194 queued / 16 running / 273 errors / 16% coverage ] ****** [275 done /199 queued / 16 running / 274 errors / 16% coverage ] ****** [275 done /199 queued / 16 running / 274 errors / 16% coverage ] ****** [276 done /201 queued / 16 running / 275 errors / 16% coverage ] ****** [276 done /201 queued / 16 running / 275 errors / 16% coverage ] ****** [277 done /201 queued / 16 running / 276 errors / 16% coverage ] ****** [277 done /201 queued / 16 running / 276 errors / 16% coverage ] ****** [278 done /202 queued / 16 running / 277 errors / 16% coverage ] ****** [278 done /202 queued / 16 running / 277 errors / 16% coverage ] ****** [279 done /201 queued / 16 running / 278 errors / 16% coverage ] ****** [279 done /201 queued / 16 running / 278 errors / 16% coverage ] ****** [280 done /201 queued / 16 running / 279 errors / 16% coverage ] ****** [280 done /201 queued / 16 running / 279 errors / 16% coverage ] ****** [281 done /201 queued / 16 running / 280 errors / 16% coverage ] ****** [281 done /201 queued / 16 running / 280 errors / 16% coverage ] ****** [282 done /206 queued / 16 running / 281 errors / 16% coverage ] ****** [282 done /206 queued / 16 running / 281 errors / 16% coverage ] ****** [283 done /205 queued / 16 running / 282 errors / 16% coverage ] ****** [283 done /205 queued / 16 running / 282 errors / 16% coverage ] ****** [284 done /205 queued / 16 running / 283 errors / 16% coverage ] ****** [284 done /205 queued / 16 running / 283 errors / 16% coverage ] ****** [285 done /207 queued / 16 running / 284 errors / 16% coverage ] ****** [285 done /207 queued / 16 running / 284 errors / 16% coverage ] ****** [286 done /206 queued / 16 running / 285 errors / 16% coverage ] ****** [286 done /206 queued / 16 running / 285 errors / 16% coverage ] ****** [287 done /207 queued / 16 running / 286 errors / 16% coverage ] ****** [287 done /207 queued / 16 running / 286 errors / 16% coverage ] ****** [288 done /208 queued / 16 running / 287 errors / 16% coverage ] ****** [288 done /208 queued / 16 running / 287 errors / 16% coverage ] ****** [289 done /209 queued / 16 running / 288 errors / 16% coverage ] ****** [289 done /209 queued / 16 running / 288 errors / 16% coverage ] ****** [290 done /210 queued / 16 running / 289 errors / 16% coverage ] ****** [290 done /210 queued / 16 running / 289 errors / 16% coverage ] ****** [291 done /211 queued / 16 running / 290 errors / 16% coverage ] ****** [291 done /211 queued / 16 running / 290 errors / 16% coverage ] ****** [292 done /212 queued / 16 running / 291 errors / 16% coverage ] ****** [292 done /212 queued / 16 running / 291 errors / 16% coverage ] ****** [293 done /213 queued / 16 running / 292 errors / 16% coverage ] ****** [293 done /213 queued / 16 running / 292 errors / 16% coverage ] ****** [294 done /217 queued / 16 running / 293 errors / 16% coverage ] ****** [294 done /217 queued / 16 running / 293 errors / 16% coverage ] ****** [295 done /217 queued / 16 running / 294 errors / 16% coverage ] ****** [295 done /217 queued / 16 running / 294 errors / 16% coverage ] ****** [296 done /219 queued / 16 running / 295 errors / 16% coverage ] ****** [296 done /219 queued / 16 running / 295 errors / 16% coverage ] ****** [297 done /219 queued / 16 running / 296 errors / 16% coverage ] ****** [297 done /219 queued / 16 running / 296 errors / 16% coverage ] ****** [298 done /221 queued / 16 running / 297 errors / 16% coverage ] ****** [298 done /221 queued / 16 running / 297 errors / 16% coverage ] ****** [299 done /222 queued / 16 running / 298 errors / 16% coverage ] ****** [299 done /222 queued / 16 running / 298 errors / 16% coverage ] ****** [300 done /224 queued / 16 running / 299 errors / 16% coverage ] ****** [300 done /224 queued / 16 running / 299 errors / 16% coverage ] ****** [301 done /224 queued / 16 running / 300 errors / 16% coverage ] ****** [301 done /224 queued / 16 running / 300 errors / 16% coverage ] ****** [302 done /225 queued / 16 running / 301 errors / 16% coverage ] ****** [302 done /225 queued / 16 running / 301 errors / 16% coverage ] ****** [303 done /226 queued / 16 running / 302 errors / 16% coverage ] ****** [303 done /226 queued / 16 running / 302 errors / 16% coverage ] ****** [304 done /225 queued / 16 running / 303 errors / 16% coverage ] ****** [304 done /225 queued / 16 running / 303 errors / 16% coverage ] ****** [305 done /226 queued / 16 running / 304 errors / 16% coverage ] ****** [305 done /226 queued / 16 running / 304 errors / 16% coverage ] ****** [306 done /227 queued / 16 running / 305 errors / 16% coverage ] ****** [306 done /227 queued / 16 running / 305 errors / 16% coverage ] ****** [307 done /229 queued / 16 running / 306 errors / 16% coverage ] ****** [307 done /229 queued / 16 running / 306 errors / 16% coverage ] ****** [308 done /230 queued / 16 running / 307 errors / 16% coverage ] ****** [308 done /230 queued / 16 running / 307 errors / 16% coverage ] ****** [309 done /231 queued / 16 running / 308 errors / 16% coverage ] ****** [309 done /231 queued / 16 running / 308 errors / 16% coverage ] ****** [310 done /233 queued / 16 running / 309 errors / 16% coverage ] ****** [310 done /233 queued / 16 running / 309 errors / 16% coverage ] ****** [311 done /235 queued / 16 running / 310 errors / 16% coverage ] ****** [311 done /235 queued / 16 running / 310 errors / 16% coverage ] ****** [312 done /238 queued / 16 running / 311 errors / 16% coverage ] ****** [312 done /238 queued / 16 running / 311 errors / 16% coverage ] ****** [313 done /238 queued / 16 running / 312 errors / 16% coverage ] ****** [313 done /238 queued / 16 running / 312 errors / 16% coverage ] ****** [314 done /237 queued / 16 running / 313 errors / 16% coverage ] ****** [314 done /237 queued / 16 running / 313 errors / 16% coverage ] ****** [315 done /238 queued / 16 running / 314 errors / 16% coverage ] ****** [315 done /238 queued / 16 running / 314 errors / 16% coverage ] ****** [316 done /237 queued / 16 running / 315 errors / 16% coverage ] ****** [316 done /237 queued / 16 running / 315 errors / 16% coverage ] ****** [317 done /238 queued / 16 running / 316 errors / 16% coverage ] ****** [317 done /238 queued / 16 running / 316 errors / 16% coverage ] ****** [318 done /243 queued / 16 running / 317 errors / 16% coverage ] ****** [318 done /243 queued / 16 running / 317 errors / 16% coverage ] ****** [319 done /246 queued / 16 running / 318 errors / 16% coverage ] ****** [319 done /246 queued / 16 running / 318 errors / 16% coverage ] ****** [320 done /245 queued / 16 running / 319 errors / 16% coverage ] ****** [320 done /245 queued / 16 running / 319 errors / 16% coverage ] ****** [321 done /244 queued / 16 running / 320 errors / 16% coverage ] ****** [321 done /244 queued / 16 running / 320 errors / 16% coverage ] ****** [322 done /245 queued / 16 running / 321 errors / 16% coverage ] ****** [322 done /245 queued / 16 running / 321 errors / 16% coverage ] ****** [323 done /248 queued / 16 running / 322 errors / 16% coverage ] ****** [323 done /248 queued / 16 running / 322 errors / 16% coverage ] ****** [324 done /247 queued / 16 running / 323 errors / 16% coverage ] ****** [324 done /247 queued / 16 running / 323 errors / 16% coverage ] ****** [325 done /248 queued / 16 running / 324 errors / 16% coverage ] ****** [325 done /248 queued / 16 running / 324 errors / 16% coverage ] ****** [326 done /247 queued / 16 running / 325 errors / 16% coverage ] ****** [326 done /247 queued / 16 running / 325 errors / 16% coverage ] ****** [327 done /248 queued / 16 running / 326 errors / 16% coverage ] ****** [327 done /248 queued / 16 running / 326 errors / 16% coverage ] ****** [328 done /248 queued / 16 running / 327 errors / 16% coverage ] ****** [328 done /248 queued / 16 running / 327 errors / 16% coverage ] ****** [329 done /248 queued / 16 running / 328 errors / 16% coverage ] ****** [329 done /248 queued / 16 running / 328 errors / 16% coverage ] ****** [330 done /250 queued / 16 running / 329 errors / 16% coverage ] ****** [330 done /250 queued / 16 running / 329 errors / 16% coverage ] ****** [331 done /251 queued / 16 running / 330 errors / 16% coverage ] ****** [331 done /251 queued / 16 running / 330 errors / 16% coverage ] ****** [332 done /251 queued / 16 running / 331 errors / 16% coverage ] ****** [332 done /251 queued / 16 running / 331 errors / 16% coverage ] ****** [333 done /252 queued / 16 running / 332 errors / 16% coverage ] ****** [333 done /252 queued / 16 running / 332 errors / 16% coverage ] ****** [334 done /253 queued / 16 running / 333 errors / 16% coverage ] ****** [334 done /253 queued / 16 running / 333 errors / 16% coverage ] ****** [335 done /254 queued / 16 running / 334 errors / 16% coverage ] ****** [335 done /254 queued / 16 running / 334 errors / 16% coverage ] ****** [336 done /255 queued / 16 running / 335 errors / 16% coverage ] ****** [336 done /255 queued / 16 running / 335 errors / 16% coverage ] ****** [337 done /256 queued / 16 running / 336 errors / 16% coverage ] ****** [337 done /256 queued / 16 running / 336 errors / 16% coverage ] ****** [338 done /256 queued / 16 running / 337 errors / 16% coverage ] ****** [338 done /256 queued / 16 running / 337 errors / 16% coverage ] ****** [339 done /255 queued / 16 running / 338 errors / 16% coverage ] ****** [339 done /255 queued / 16 running / 338 errors / 16% coverage ] ****** [340 done /255 queued / 16 running / 339 errors / 16% coverage ] ****** [340 done /255 queued / 16 running / 339 errors / 16% coverage ] ****** [341 done /255 queued / 16 running / 340 errors / 16% coverage ] ****** [341 done /255 queued / 16 running / 340 errors / 16% coverage ] ****** [342 done /254 queued / 16 running / 341 errors / 16% coverage ] ****** [342 done /254 queued / 16 running / 341 errors / 16% coverage ] ****** [343 done /256 queued / 16 running / 342 errors / 16% coverage ] ****** [343 done /256 queued / 16 running / 342 errors / 16% coverage ] ****** [344 done /255 queued / 16 running / 343 errors / 16% coverage ] ****** [344 done /255 queued / 16 running / 343 errors / 16% coverage ] ****** [345 done /259 queued / 16 running / 344 errors / 16% coverage ] ****** [345 done /259 queued / 16 running / 344 errors / 16% coverage ] ****** [346 done /261 queued / 16 running / 345 errors / 16% coverage ] ****** [346 done /261 queued / 16 running / 345 errors / 16% coverage ] ****** [347 done /264 queued / 16 running / 346 errors / 16% coverage ] ****** [347 done /264 queued / 16 running / 346 errors / 16% coverage ] ****** [348 done /265 queued / 16 running / 347 errors / 16% coverage ] ****** [348 done /265 queued / 16 running / 347 errors / 16% coverage ] ****** [349 done /267 queued / 16 running / 348 errors / 16% coverage ] ****** [349 done /267 queued / 16 running / 348 errors / 16% coverage ] ****** [350 done /270 queued / 16 running / 349 errors / 16% coverage ] ****** [350 done /270 queued / 16 running / 349 errors / 16% coverage ] ****** [351 done /269 queued / 16 running / 350 errors / 16% coverage ] ****** [351 done /269 queued / 16 running / 350 errors / 16% coverage ] ****** [352 done /271 queued / 16 running / 351 errors / 16% coverage ] ****** [352 done /271 queued / 16 running / 351 errors / 16% coverage ] ****** [353 done /274 queued / 16 running / 352 errors / 16% coverage ] ****** [353 done /274 queued / 16 running / 352 errors / 16% coverage ] ****** [354 done /276 queued / 16 running / 353 errors / 16% coverage ] ****** [354 done /276 queued / 16 running / 353 errors / 16% coverage ] ****** [355 done /278 queued / 16 running / 354 errors / 16% coverage ] ****** [355 done /278 queued / 16 running / 354 errors / 16% coverage ] ****** [356 done /280 queued / 16 running / 355 errors / 16% coverage ] ****** [356 done /280 queued / 16 running / 355 errors / 16% coverage ] ****** [357 done /280 queued / 16 running / 356 errors / 16% coverage ] ****** [357 done /280 queued / 16 running / 356 errors / 16% coverage ] ****** [358 done /281 queued / 16 running / 357 errors / 16% coverage ] ****** [358 done /281 queued / 16 running / 357 errors / 16% coverage ] ****** [359 done /283 queued / 16 running / 358 errors / 16% coverage ] ****** [359 done /283 queued / 16 running / 358 errors / 16% coverage ] ****** [360 done /284 queued / 16 running / 359 errors / 16% coverage ] ****** [360 done /284 queued / 16 running / 359 errors / 16% coverage ] ****** [361 done /284 queued / 16 running / 360 errors / 16% coverage ] ****** [361 done /284 queued / 16 running / 360 errors / 16% coverage ] ****** [362 done /286 queued / 16 running / 361 errors / 16% coverage ] ****** [362 done /286 queued / 16 running / 361 errors / 16% coverage ] ****** [363 done /287 queued / 16 running / 362 errors / 16% coverage ] ****** [363 done /287 queued / 16 running / 362 errors / 16% coverage ] ****** [364 done /291 queued / 16 running / 363 errors / 16% coverage ] ****** [364 done /291 queued / 16 running / 363 errors / 16% coverage ] ****** [365 done /290 queued / 16 running / 364 errors / 16% coverage ] ****** [365 done /290 queued / 16 running / 364 errors / 16% coverage ] ****** [366 done /291 queued / 16 running / 365 errors / 16% coverage ] ****** [366 done /291 queued / 16 running / 365 errors / 16% coverage ] ****** [367 done /294 queued / 16 running / 366 errors / 16% coverage ] ****** [367 done /294 queued / 16 running / 366 errors / 16% coverage ] ****** [368 done /295 queued / 16 running / 367 errors / 16% coverage ] ****** [368 done /295 queued / 16 running / 367 errors / 16% coverage ] ****** [369 done /295 queued / 16 running / 368 errors / 16% coverage ] ****** [369 done /295 queued / 16 running / 368 errors / 16% coverage ] ****** [370 done /294 queued / 16 running / 369 errors / 16% coverage ] ****** [370 done /294 queued / 16 running / 369 errors / 16% coverage ] ****** [371 done /294 queued / 16 running / 370 errors / 16% coverage ] ****** [371 done /294 queued / 16 running / 370 errors / 16% coverage ] ****** [372 done /297 queued / 16 running / 371 errors / 16% coverage ] ****** [372 done /297 queued / 16 running / 371 errors / 16% coverage ] ****** [373 done /296 queued / 16 running / 372 errors / 16% coverage ] ****** [373 done /296 queued / 16 running / 372 errors / 16% coverage ] ****** [374 done /296 queued / 16 running / 373 errors / 16% coverage ] ****** [374 done /296 queued / 16 running / 373 errors / 16% coverage ] ****** [375 done /297 queued / 16 running / 374 errors / 16% coverage ] ****** [375 done /297 queued / 16 running / 374 errors / 16% coverage ] ****** [376 done /297 queued / 16 running / 375 errors / 16% coverage ] ****** [376 done /297 queued / 16 running / 375 errors / 16% coverage ] ****** [377 done /297 queued / 16 running / 376 errors / 16% coverage ] ****** [377 done /297 queued / 16 running / 376 errors / 16% coverage ] ****** [378 done /302 queued / 16 running / 377 errors / 16% coverage ] ****** [378 done /302 queued / 16 running / 377 errors / 16% coverage ] ****** [379 done /302 queued / 16 running / 378 errors / 16% coverage ] ****** [379 done /302 queued / 16 running / 378 errors / 16% coverage ] ****** [380 done /305 queued / 16 running / 379 errors / 16% coverage ] ****** [380 done /305 queued / 16 running / 379 errors / 16% coverage ] ****** [381 done /306 queued / 16 running / 380 errors / 16% coverage ] ****** [381 done /306 queued / 16 running / 380 errors / 16% coverage ] ****** [382 done /308 queued / 16 running / 381 errors / 16% coverage ] ****** [382 done /308 queued / 16 running / 381 errors / 16% coverage ] ****** [383 done /310 queued / 16 running / 382 errors / 16% coverage ] ****** [383 done /310 queued / 16 running / 382 errors / 16% coverage ] ****** [384 done /310 queued / 16 running / 383 errors / 16% coverage ] ****** [384 done /310 queued / 16 running / 383 errors / 16% coverage ] ****** [385 done /311 queued / 16 running / 384 errors / 16% coverage ] ****** [385 done /311 queued / 16 running / 384 errors / 16% coverage ] ****** [386 done /313 queued / 16 running / 385 errors / 16% coverage ] ****** [386 done /313 queued / 16 running / 385 errors / 16% coverage ] ****** [387 done /312 queued / 16 running / 386 errors / 16% coverage ] ****** [387 done /312 queued / 16 running / 386 errors / 16% coverage ] ****** [388 done /314 queued / 16 running / 387 errors / 16% coverage ] ****** [388 done /314 queued / 16 running / 387 errors / 16% coverage ] ****** [389 done /316 queued / 16 running / 388 errors / 16% coverage ] ****** [389 done /316 queued / 16 running / 388 errors / 16% coverage ] ****** [390 done /318 queued / 16 running / 389 errors / 16% coverage ] ****** [390 done /318 queued / 16 running / 389 errors / 16% coverage ] ****** [391 done /317 queued / 16 running / 390 errors / 16% coverage ] ****** [391 done /317 queued / 16 running / 390 errors / 16% coverage ] ****** [392 done /317 queued / 16 running / 391 errors / 16% coverage ] ****** [392 done /317 queued / 16 running / 391 errors / 16% coverage ] ****** [393 done /316 queued / 16 running / 392 errors / 16% coverage ] ****** [393 done /316 queued / 16 running / 392 errors / 16% coverage ] ****** [394 done /315 queued / 16 running / 393 errors / 16% coverage ] ****** [394 done /315 queued / 16 running / 393 errors / 16% coverage ] ****** [395 done /316 queued / 16 running / 394 errors / 16% coverage ] ****** [395 done /316 queued / 16 running / 394 errors / 16% coverage ] ****** [396 done /315 queued / 16 running / 395 errors / 16% coverage ] ****** [396 done /315 queued / 16 running / 395 errors / 16% coverage ] ****** [397 done /317 queued / 16 running / 396 errors / 16% coverage ] ****** [397 done /317 queued / 16 running / 396 errors / 16% coverage ] ****** [398 done /316 queued / 16 running / 397 errors / 16% coverage ] ****** [398 done /316 queued / 16 running / 397 errors / 16% coverage ] ****** [399 done /319 queued / 16 running / 398 errors / 16% coverage ] ****** [399 done /319 queued / 16 running / 398 errors / 16% coverage ] ****** [400 done /321 queued / 16 running / 399 errors / 16% coverage ] ****** [400 done /321 queued / 16 running / 399 errors / 16% coverage ] ****** [401 done /320 queued / 16 running / 400 errors / 16% coverage ] ****** [401 done /320 queued / 16 running / 400 errors / 16% coverage ] ****** [402 done /321 queued / 16 running / 401 errors / 16% coverage ] ****** [402 done /321 queued / 16 running / 401 errors / 16% coverage ] ****** [403 done /320 queued / 16 running / 402 errors / 16% coverage ] ****** [403 done /320 queued / 16 running / 402 errors / 16% coverage ] ****** [404 done /322 queued / 16 running / 403 errors / 16% coverage ] ****** [404 done /322 queued / 16 running / 403 errors / 16% coverage ] ****** [405 done /321 queued / 16 running / 404 errors / 16% coverage ] ****** [405 done /321 queued / 16 running / 404 errors / 16% coverage ] ****** [406 done /323 queued / 16 running / 405 errors / 16% coverage ] ****** [406 done /323 queued / 16 running / 405 errors / 16% coverage ] ****** [407 done /327 queued / 16 running / 406 errors / 16% coverage ] ****** [407 done /327 queued / 16 running / 406 errors / 16% coverage ] ****** [408 done /328 queued / 16 running / 407 errors / 16% coverage ] ****** [408 done /328 queued / 16 running / 407 errors / 16% coverage ] ****** [409 done /329 queued / 16 running / 408 errors / 16% coverage ] ****** [409 done /329 queued / 16 running / 408 errors / 16% coverage ] ****** [410 done /331 queued / 16 running / 409 errors / 16% coverage ] ****** [410 done /331 queued / 16 running / 409 errors / 16% coverage ] ****** [411 done /334 queued / 16 running / 410 errors / 16% coverage ] ****** [411 done /334 queued / 16 running / 410 errors / 16% coverage ] ****** [412 done /337 queued / 16 running / 411 errors / 16% coverage ] ****** [412 done /337 queued / 16 running / 411 errors / 16% coverage ] ****** [413 done /339 queued / 16 running / 412 errors / 16% coverage ] ****** [413 done /339 queued / 16 running / 412 errors / 16% coverage ] ****** [414 done /340 queued / 16 running / 413 errors / 16% coverage ] ****** [414 done /340 queued / 16 running / 413 errors / 16% coverage ] ****** [415 done /344 queued / 16 running / 414 errors / 16% coverage ] ****** [415 done /344 queued / 16 running / 414 errors / 16% coverage ] ****** [416 done /347 queued / 16 running / 415 errors / 16% coverage ] ****** [416 done /347 queued / 16 running / 415 errors / 16% coverage ] ****** [417 done /346 queued / 16 running / 416 errors / 16% coverage ] ****** [417 done /346 queued / 16 running / 416 errors / 16% coverage ] ****** [418 done /345 queued / 16 running / 417 errors / 16% coverage ] ****** [418 done /345 queued / 16 running / 417 errors / 16% coverage ] ****** [419 done /347 queued / 16 running / 418 errors / 16% coverage ] ****** [419 done /347 queued / 16 running / 418 errors / 16% coverage ] ****** [420 done /348 queued / 16 running / 419 errors / 16% coverage ] ****** [420 done /348 queued / 16 running / 419 errors / 16% coverage ] ****** [421 done /348 queued / 16 running / 420 errors / 16% coverage ] ****** [421 done /348 queued / 16 running / 420 errors / 16% coverage ] ****** [422 done /352 queued / 16 running / 421 errors / 16% coverage ] ****** [422 done /352 queued / 16 running / 421 errors / 16% coverage ] ****** [423 done /351 queued / 16 running / 422 errors / 16% coverage ] ****** [423 done /351 queued / 16 running / 422 errors / 16% coverage ] ****** [424 done /351 queued / 16 running / 423 errors / 16% coverage ] ****** [424 done /351 queued / 16 running / 423 errors / 16% coverage ] ****** [425 done /351 queued / 16 running / 424 errors / 16% coverage ] ****** [425 done /351 queued / 16 running / 424 errors / 16% coverage ] ****** [426 done /351 queued / 16 running / 425 errors / 16% coverage ] ****** [426 done /351 queued / 16 running / 425 errors / 16% coverage ] ****** [427 done /350 queued / 16 running / 426 errors / 16% coverage ] ****** [427 done /350 queued / 16 running / 426 errors / 16% coverage ] ****** [428 done /350 queued / 16 running / 427 errors / 16% coverage ] ****** [428 done /350 queued / 16 running / 427 errors / 16% coverage ] ****** [429 done /349 queued / 16 running / 428 errors / 16% coverage ] ****** [429 done /349 queued / 16 running / 428 errors / 16% coverage ] ****** [430 done /351 queued / 16 running / 429 errors / 16% coverage ] ****** [430 done /351 queued / 16 running / 429 errors / 16% coverage ] ****** [431 done /351 queued / 16 running / 430 errors / 16% coverage ] ****** [431 done /351 queued / 16 running / 430 errors / 16% coverage ] ****** [432 done /353 queued / 16 running / 431 errors / 16% coverage ] ****** [432 done /353 queued / 16 running / 431 errors / 16% coverage ] ****** [433 done /354 queued / 16 running / 432 errors / 16% coverage ] ****** [433 done /354 queued / 16 running / 432 errors / 16% coverage ] ****** [434 done /354 queued / 16 running / 433 errors / 16% coverage ] ****** [434 done /354 queued / 16 running / 433 errors / 16% coverage ] ****** [435 done /356 queued / 16 running / 434 errors / 16% coverage ] ****** [435 done /356 queued / 16 running / 434 errors / 16% coverage ] ****** [436 done /357 queued / 16 running / 435 errors / 16% coverage ] ****** [436 done /357 queued / 16 running / 435 errors / 16% coverage ] ****** [437 done /357 queued / 16 running / 436 errors / 16% coverage ] ****** [437 done /357 queued / 16 running / 436 errors / 16% coverage ] ****** [438 done /356 queued / 16 running / 437 errors / 16% coverage ] ****** [438 done /356 queued / 16 running / 437 errors / 16% coverage ] ****** [439 done /358 queued / 16 running / 438 errors / 16% coverage ] ****** [439 done /358 queued / 16 running / 438 errors / 16% coverage ] ****** [440 done /359 queued / 16 running / 439 errors / 16% coverage ] ****** [440 done /359 queued / 16 running / 439 errors / 16% coverage ] ****** [441 done /360 queued / 16 running / 440 errors / 16% coverage ] ****** [441 done /360 queued / 16 running / 440 errors / 16% coverage ] ****** [442 done /362 queued / 16 running / 441 errors / 16% coverage ] ****** [442 done /362 queued / 16 running / 441 errors / 16% coverage ] ****** [443 done /361 queued / 16 running / 442 errors / 16% coverage ] ****** [443 done /361 queued / 16 running / 442 errors / 16% coverage ] ****** [444 done /360 queued / 16 running / 443 errors / 16% coverage ] ****** [444 done /360 queued / 16 running / 443 errors / 16% coverage ] ****** [445 done /359 queued / 16 running / 444 errors / 16% coverage ] ****** [445 done /359 queued / 16 running / 444 errors / 16% coverage ] ****** [446 done /359 queued / 16 running / 445 errors / 16% coverage ] ****** [446 done /359 queued / 16 running / 445 errors / 16% coverage ] ****** [447 done /362 queued / 16 running / 446 errors / 16% coverage ] ****** [447 done /362 queued / 16 running / 446 errors / 16% coverage ] ****** [448 done /361 queued / 16 running / 447 errors / 16% coverage ] ****** [448 done /361 queued / 16 running / 447 errors / 16% coverage ] ****** [449 done /364 queued / 16 running / 448 errors / 16% coverage ] ****** [449 done /364 queued / 16 running / 448 errors / 16% coverage ] ****** [450 done /368 queued / 16 running / 449 errors / 16% coverage ] ****** [450 done /368 queued / 16 running / 449 errors / 16% coverage ] ****** [451 done /367 queued / 16 running / 450 errors / 16% coverage ] ****** [451 done /367 queued / 16 running / 450 errors / 16% coverage ] ****** [452 done /369 queued / 16 running / 451 errors / 16% coverage ] ****** [452 done /369 queued / 16 running / 451 errors / 16% coverage ] ****** [453 done /368 queued / 16 running / 452 errors / 16% coverage ] ****** [453 done /368 queued / 16 running / 452 errors / 16% coverage ] ****** [454 done /370 queued / 16 running / 453 errors / 16% coverage ] ****** [454 done /370 queued / 16 running / 453 errors / 16% coverage ] ****** [455 done /371 queued / 16 running / 454 errors / 16% coverage ] ****** [455 done /371 queued / 16 running / 454 errors / 16% coverage ] ****** [456 done /372 queued / 16 running / 455 errors / 16% coverage ] ****** [456 done /372 queued / 16 running / 455 errors / 16% coverage ] ****** [457 done /371 queued / 16 running / 456 errors / 16% coverage ] ****** [457 done /371 queued / 16 running / 456 errors / 16% coverage ] ****** [458 done /371 queued / 16 running / 457 errors / 16% coverage ] ****** [458 done /371 queued / 16 running / 457 errors / 16% coverage ] ****** [459 done /373 queued / 16 running / 458 errors / 16% coverage ] ****** [459 done /373 queued / 16 running / 458 errors / 16% coverage ] ****** [460 done /372 queued / 16 running / 459 errors / 16% coverage ] ****** [460 done /372 queued / 16 running / 459 errors / 16% coverage ] ****** [461 done /372 queued / 16 running / 460 errors / 16% coverage ] ****** [461 done /372 queued / 16 running / 460 errors / 16% coverage ] ****** [462 done /374 queued / 16 running / 461 errors / 16% coverage ] ****** [462 done /374 queued / 16 running / 461 errors / 16% coverage ] ****** [463 done /376 queued / 16 running / 462 errors / 16% coverage ] ****** [463 done /376 queued / 16 running / 462 errors / 16% coverage ] ****** [464 done /379 queued / 16 running / 463 errors / 16% coverage ] ****** [464 done /379 queued / 16 running / 463 errors / 16% coverage ] ****** [465 done /378 queued / 16 running / 464 errors / 16% coverage ] ****** [465 done /378 queued / 16 running / 464 errors / 16% coverage ] ****** [466 done /380 queued / 16 running / 465 errors / 16% coverage ] ****** [466 done /380 queued / 16 running / 465 errors / 16% coverage ] ****** [467 done /380 queued / 16 running / 466 errors / 16% coverage ] ****** [467 done /380 queued / 16 running / 466 errors / 16% coverage ] ****** [468 done /381 queued / 16 running / 467 errors / 16% coverage ] ****** [468 done /381 queued / 16 running / 467 errors / 16% coverage ] ****** [469 done /380 queued / 16 running / 468 errors / 16% coverage ] ****** [469 done /380 queued / 16 running / 468 errors / 16% coverage ] ****** [470 done /379 queued / 16 running / 469 errors / 16% coverage ] ****** [470 done /379 queued / 16 running / 469 errors / 16% coverage ] ****** [471 done /380 queued / 16 running / 470 errors / 16% coverage ] ****** [471 done /380 queued / 16 running / 470 errors / 16% coverage ] ****** [472 done /379 queued / 16 running / 471 errors / 16% coverage ] ****** [472 done /379 queued / 16 running / 471 errors / 16% coverage ] ****** [473 done /378 queued / 16 running / 472 errors / 16% coverage ] ****** [473 done /378 queued / 16 running / 472 errors / 16% coverage ] ****** [474 done /378 queued / 16 running / 473 errors / 16% coverage ] ****** [474 done /378 queued / 16 running / 473 errors / 16% coverage ] ****** [475 done /378 queued / 16 running / 474 errors / 16% coverage ] ****** [475 done /378 queued / 16 running / 474 errors / 16% coverage ] ****** [476 done /382 queued / 16 running / 475 errors / 16% coverage ] ****** [476 done /382 queued / 16 running / 475 errors / 16% coverage ] ****** [477 done /384 queued / 16 running / 476 errors / 16% coverage ] ****** [477 done /384 queued / 16 running / 476 errors / 16% coverage ] ****** [478 done /383 queued / 16 running / 477 errors / 16% coverage ] ****** [478 done /383 queued / 16 running / 477 errors / 16% coverage ] ****** [479 done /383 queued / 16 running / 478 errors / 16% coverage ] ****** [479 done /383 queued / 16 running / 478 errors / 16% coverage ] ****** [480 done /383 queued / 16 running / 479 errors / 16% coverage ] ****** [480 done /383 queued / 16 running / 479 errors / 16% coverage ] ****** [481 done /388 queued / 16 running / 480 errors / 16% coverage ] ****** [481 done /388 queued / 16 running / 480 errors / 16% coverage ] ****** [482 done /389 queued / 16 running / 481 errors / 16% coverage ] ****** [482 done /389 queued / 16 running / 481 errors / 16% coverage ] ****** [483 done /388 queued / 16 running / 482 errors / 16% coverage ] ****** [483 done /388 queued / 16 running / 482 errors / 16% coverage ] ****** [484 done /387 queued / 16 running / 483 errors / 16% coverage ] ****** [484 done /387 queued / 16 running / 483 errors / 16% coverage ] ****** [485 done /386 queued / 16 running / 484 errors / 16% coverage ] ****** [485 done /386 queued / 16 running / 484 errors / 16% coverage ] ****** [486 done /386 queued / 16 running / 485 errors / 16% coverage ] ****** [486 done /386 queued / 16 running / 485 errors / 16% coverage ] ****** [487 done /389 queued / 16 running / 486 errors / 16% coverage ] ****** [487 done /389 queued / 16 running / 486 errors / 16% coverage ] ****** [488 done /388 queued / 16 running / 487 errors / 16% coverage ] ****** [488 done /388 queued / 16 running / 487 errors / 16% coverage ] ****** [489 done /393 queued / 16 running / 488 errors / 16% coverage ] ****** [489 done /393 queued / 16 running / 488 errors / 16% coverage ] ****** [490 done /394 queued / 16 running / 489 errors / 16% coverage ] ****** [490 done /394 queued / 16 running / 489 errors / 16% coverage ] ****** [491 done /395 queued / 16 running / 490 errors / 16% coverage ] ****** [491 done /395 queued / 16 running / 490 errors / 16% coverage ] ****** [492 done /397 queued / 16 running / 491 errors / 16% coverage ] ****** [492 done /397 queued / 16 running / 491 errors / 16% coverage ] ****** [493 done /399 queued / 16 running / 492 errors / 16% coverage ] ****** [493 done /399 queued / 16 running / 492 errors / 16% coverage ] ****** [494 done /399 queued / 16 running / 493 errors / 16% coverage ] ****** [494 done /399 queued / 16 running / 493 errors / 16% coverage ] ****** [495 done /400 queued / 16 running / 494 errors / 16% coverage ] ****** [495 done /400 queued / 16 running / 494 errors / 16% coverage ] ****** [496 done /401 queued / 16 running / 495 errors / 16% coverage ] ****** [496 done /401 queued / 16 running / 495 errors / 16% coverage ] ****** [497 done /400 queued / 16 running / 496 errors / 16% coverage ] ****** [497 done /400 queued / 16 running / 496 errors / 16% coverage ] ****** [498 done /399 queued / 16 running / 497 errors / 16% coverage ] ****** [498 done /399 queued / 16 running / 497 errors / 16% coverage ] ****** [499 done /398 queued / 16 running / 498 errors / 16% coverage ] ****** [499 done /398 queued / 16 running / 498 errors / 16% coverage ] ****** [500 done /399 queued / 16 running / 499 errors / 16% coverage ] ****** [500 done /399 queued / 16 running / 499 errors / 16% coverage ] ****** [501 done /399 queued / 16 running / 500 errors / 16% coverage ] ****** [501 done /399 queued / 16 running / 500 errors / 16% coverage ] ****** [502 done /400 queued / 16 running / 501 errors / 16% coverage ] ****** [502 done /400 queued / 16 running / 501 errors / 16% coverage ] ****** [503 done /399 queued / 16 running / 502 errors / 16% coverage ] ****** [503 done /399 queued / 16 running / 502 errors / 16% coverage ] ****** [504 done /400 queued / 16 running / 503 errors / 16% coverage ] ****** [504 done /400 queued / 16 running / 503 errors / 16% coverage ] ****** [505 done /401 queued / 16 running / 504 errors / 16% coverage ] ****** [505 done /401 queued / 16 running / 504 errors / 16% coverage ] ****** [506 done /403 queued / 16 running / 505 errors / 16% coverage ] ****** [506 done /403 queued / 16 running / 505 errors / 16% coverage ] ****** [507 done /405 queued / 16 running / 506 errors / 16% coverage ] ****** [507 done /405 queued / 16 running / 506 errors / 16% coverage ] ****** [508 done /406 queued / 16 running / 507 errors / 16% coverage ] ****** [508 done /406 queued / 16 running / 507 errors / 16% coverage ] ****** [509 done /405 queued / 16 running / 508 errors / 16% coverage ] ****** [509 done /405 queued / 16 running / 508 errors / 16% coverage ] ****** [510 done /405 queued / 16 running / 509 errors / 16% coverage ] ****** [510 done /405 queued / 16 running / 509 errors / 16% coverage ] ****** [511 done /404 queued / 16 running / 510 errors / 16% coverage ] ****** [511 done /404 queued / 16 running / 510 errors / 16% coverage ] ****** [512 done /404 queued / 16 running / 511 errors / 16% coverage ] ****** [512 done /404 queued / 16 running / 511 errors / 16% coverage ] ****** [513 done /406 queued / 16 running / 512 errors / 16% coverage ] ****** [513 done /406 queued / 16 running / 512 errors / 16% coverage ] ****** [514 done /405 queued / 16 running / 513 errors / 16% coverage ] ****** [514 done /405 queued / 16 running / 513 errors / 16% coverage ] ****** [515 done /404 queued / 16 running / 514 errors / 16% coverage ] ****** [515 done /404 queued / 16 running / 514 errors / 16% coverage ] ****** [516 done /403 queued / 16 running / 515 errors / 16% coverage ] ****** [516 done /403 queued / 16 running / 515 errors / 16% coverage ] ****** [517 done /405 queued / 16 running / 516 errors / 16% coverage ] ****** [517 done /405 queued / 16 running / 516 errors / 16% coverage ] ****** [518 done /404 queued / 16 running / 517 errors / 16% coverage ] ****** [518 done /404 queued / 16 running / 517 errors / 16% coverage ] ****** [519 done /405 queued / 16 running / 518 errors / 16% coverage ] ****** [519 done /405 queued / 16 running / 518 errors / 16% coverage ] ****** [520 done /407 queued / 16 running / 519 errors / 16% coverage ] ****** [520 done /407 queued / 16 running / 519 errors / 16% coverage ] ****** [521 done /409 queued / 16 running / 520 errors / 16% coverage ] ****** [521 done /409 queued / 16 running / 520 errors / 16% coverage ] ****** [522 done /410 queued / 16 running / 521 errors / 16% coverage ] ****** [522 done /410 queued / 16 running / 521 errors / 16% coverage ] ****** [523 done /411 queued / 16 running / 522 errors / 16% coverage ] ****** [523 done /411 queued / 16 running / 522 errors / 16% coverage ] ****** [524 done /414 queued / 16 running / 523 errors / 16% coverage ] ****** [524 done /414 queued / 16 running / 523 errors / 16% coverage ] ****** [525 done /416 queued / 16 running / 524 errors / 16% coverage ] ****** [525 done /416 queued / 16 running / 524 errors / 16% coverage ] ****** [526 done /416 queued / 16 running / 525 errors / 16% coverage ] ****** [526 done /416 queued / 16 running / 525 errors / 16% coverage ] ****** [527 done /417 queued / 16 running / 526 errors / 16% coverage ] ****** [527 done /417 queued / 16 running / 526 errors / 16% coverage ] ****** [528 done /417 queued / 16 running / 527 errors / 16% coverage ] ****** [528 done /417 queued / 16 running / 527 errors / 16% coverage ] ****** [529 done /417 queued / 16 running / 528 errors / 16% coverage ] ****** [529 done /417 queued / 16 running / 528 errors / 16% coverage ] ****** [530 done /419 queued / 16 running / 529 errors / 16% coverage ] ****** [530 done /419 queued / 16 running / 529 errors / 16% coverage ] ****** [531 done /418 queued / 16 running / 530 errors / 16% coverage ] ****** [531 done /418 queued / 16 running / 530 errors / 16% coverage ] ****** [532 done /419 queued / 16 running / 531 errors / 16% coverage ] ****** [532 done /419 queued / 16 running / 531 errors / 16% coverage ] ****** [533 done /423 queued / 16 running / 532 errors / 16% coverage ] ****** [533 done /423 queued / 16 running / 532 errors / 16% coverage ] ****** [534 done /422 queued / 16 running / 533 errors / 16% coverage ] ****** [534 done /422 queued / 16 running / 533 errors / 16% coverage ] ****** [535 done /424 queued / 16 running / 534 errors / 16% coverage ] ****** [535 done /424 queued / 16 running / 534 errors / 16% coverage ] ****** [536 done /423 queued / 16 running / 535 errors / 16% coverage ] ****** [536 done /423 queued / 16 running / 535 errors / 16% coverage ] ****** [537 done /422 queued / 16 running / 536 errors / 16% coverage ] ****** [537 done /422 queued / 16 running / 536 errors / 16% coverage ] ****** [538 done /421 queued / 16 running / 537 errors / 16% coverage ] ****** [538 done /421 queued / 16 running / 537 errors / 16% coverage ] ****** [539 done /420 queued / 16 running / 538 errors / 16% coverage ] ****** [539 done /420 queued / 16 running / 538 errors / 16% coverage ] ****** [540 done /422 queued / 16 running / 539 errors / 16% coverage ] ****** [540 done /422 queued / 16 running / 539 errors / 16% coverage ] ****** [541 done /421 queued / 16 running / 540 errors / 16% coverage ] ****** [541 done /421 queued / 16 running / 540 errors / 16% coverage ] ****** [542 done /420 queued / 16 running / 541 errors / 16% coverage ] ****** [542 done /420 queued / 16 running / 541 errors / 16% coverage ] ****** [543 done /421 queued / 16 running / 542 errors / 16% coverage ] ****** [543 done /421 queued / 16 running / 542 errors / 16% coverage ] ****** [544 done /423 queued / 16 running / 543 errors / 16% coverage ] ****** [544 done /423 queued / 16 running / 543 errors / 16% coverage ] ****** [545 done /423 queued / 16 running / 544 errors / 16% coverage ] ****** [545 done /423 queued / 16 running / 544 errors / 16% coverage ] ****** [546 done /423 queued / 16 running / 545 errors / 16% coverage ] ****** [546 done /423 queued / 16 running / 545 errors / 16% coverage ] ****** [547 done /427 queued / 16 running / 546 errors / 16% coverage ] ****** [547 done /427 queued / 16 running / 546 errors / 16% coverage ] ****** [548 done /431 queued / 16 running / 547 errors / 16% coverage ] ****** [548 done /431 queued / 16 running / 547 errors / 16% coverage ] ****** [549 done /430 queued / 16 running / 548 errors / 16% coverage ] ****** [549 done /430 queued / 16 running / 548 errors / 16% coverage ] ****** [550 done /431 queued / 16 running / 549 errors / 16% coverage ] ****** [550 done /431 queued / 16 running / 549 errors / 16% coverage ] ****** [551 done /434 queued / 16 running / 550 errors / 16% coverage ] ****** [551 done /434 queued / 16 running / 550 errors / 16% coverage ] ****** [552 done /433 queued / 16 running / 551 errors / 16% coverage ] ****** [552 done /433 queued / 16 running / 551 errors / 16% coverage ] ****** [553 done /434 queued / 16 running / 552 errors / 16% coverage ] ****** [553 done /434 queued / 16 running / 552 errors / 16% coverage ] ****** [554 done /435 queued / 16 running / 553 errors / 16% coverage ] ****** [554 done /435 queued / 16 running / 553 errors / 16% coverage ] ****** [555 done /436 queued / 16 running / 554 errors / 16% coverage ] ****** [555 done /436 queued / 16 running / 554 errors / 16% coverage ] ****** [556 done /436 queued / 16 running / 555 errors / 16% coverage ] ****** [556 done /436 queued / 16 running / 555 errors / 16% coverage ] ****** [557 done /440 queued / 16 running / 556 errors / 16% coverage ] ****** [557 done /440 queued / 16 running / 556 errors / 16% coverage ] ****** [558 done /441 queued / 16 running / 557 errors / 16% coverage ] ****** [558 done /441 queued / 16 running / 557 errors / 16% coverage ] ****** [559 done /443 queued / 16 running / 558 errors / 16% coverage ] ****** [559 done /443 queued / 16 running / 558 errors / 16% coverage ] ****** [560 done /442 queued / 16 running / 559 errors / 16% coverage ] ****** [560 done /442 queued / 16 running / 559 errors / 16% coverage ] ****** [561 done /442 queued / 16 running / 560 errors / 16% coverage ] ****** [561 done /442 queued / 16 running / 560 errors / 16% coverage ] ****** [562 done /443 queued / 16 running / 561 errors / 16% coverage ] ****** [562 done /443 queued / 16 running / 561 errors / 16% coverage ] ****** [563 done /445 queued / 16 running / 562 errors / 16% coverage ] ****** [563 done /445 queued / 16 running / 562 errors / 16% coverage ] ****** [564 done /445 queued / 16 running / 563 errors / 16% coverage ] ****** [564 done /445 queued / 16 running / 563 errors / 16% coverage ] ****** [565 done /447 queued / 16 running / 564 errors / 16% coverage ] ****** [565 done /447 queued / 16 running / 564 errors / 16% coverage ] ****** [566 done /449 queued / 16 running / 565 errors / 16% coverage ] ****** [566 done /449 queued / 16 running / 565 errors / 16% coverage ] ****** [567 done /449 queued / 16 running / 566 errors / 16% coverage ] ****** [567 done /449 queued / 16 running / 566 errors / 16% coverage ] ****** [568 done /449 queued / 16 running / 567 errors / 16% coverage ] ****** [568 done /449 queued / 16 running / 567 errors / 16% coverage ] ****** [569 done /452 queued / 16 running / 568 errors / 16% coverage ] ****** [569 done /452 queued / 16 running / 568 errors / 16% coverage ] ****** [570 done /454 queued / 16 running / 569 errors / 16% coverage ] ****** [570 done /454 queued / 16 running / 569 errors / 16% coverage ] ****** [571 done /455 queued / 16 running / 570 errors / 16% coverage ] ****** [571 done /455 queued / 16 running / 570 errors / 16% coverage ] ****** [572 done /456 queued / 16 running / 571 errors / 16% coverage ] ****** [572 done /456 queued / 16 running / 571 errors / 16% coverage ] ****** [573 done /457 queued / 16 running / 572 errors / 16% coverage ] ****** [573 done /457 queued / 16 running / 572 errors / 16% coverage ] ****** [574 done /458 queued / 16 running / 573 errors / 16% coverage ] ****** [574 done /458 queued / 16 running / 573 errors / 16% coverage ] ****** [575 done /457 queued / 16 running / 574 errors / 16% coverage ] ****** [575 done /457 queued / 16 running / 574 errors / 16% coverage ] ****** [576 done /458 queued / 16 running / 575 errors / 16% coverage ] ****** [576 done /458 queued / 16 running / 575 errors / 16% coverage ] ****** [577 done /459 queued / 16 running / 576 errors / 16% coverage ] ****** [577 done /459 queued / 16 running / 576 errors / 16% coverage ] ****** [578 done /459 queued / 16 running / 577 errors / 16% coverage ] ****** [578 done /459 queued / 16 running / 577 errors / 16% coverage ] ****** [579 done /459 queued / 16 running / 578 errors / 16% coverage ] ****** [579 done /459 queued / 16 running / 578 errors / 16% coverage ] ****** [580 done /458 queued / 16 running / 579 errors / 16% coverage ] ****** [580 done /458 queued / 16 running / 579 errors / 16% coverage ] ****** [581 done /457 queued / 16 running / 580 errors / 16% coverage ] ****** [581 done /457 queued / 16 running / 580 errors / 16% coverage ] ****** [582 done /457 queued / 16 running / 581 errors / 16% coverage ] ****** [582 done /457 queued / 16 running / 581 errors / 16% coverage ] ****** [583 done /459 queued / 16 running / 582 errors / 16% coverage ] ****** [583 done /459 queued / 16 running / 582 errors / 16% coverage ] ****** [584 done /459 queued / 16 running / 583 errors / 16% coverage ] ****** [584 done /459 queued / 16 running / 583 errors / 16% coverage ] ****** [585 done /461 queued / 16 running / 584 errors / 16% coverage ] ****** [585 done /461 queued / 16 running / 584 errors / 16% coverage ] ****** [586 done /464 queued / 16 running / 585 errors / 16% coverage ] ****** [586 done /464 queued / 16 running / 585 errors / 16% coverage ] ****** [587 done /466 queued / 16 running / 586 errors / 16% coverage ] ****** [587 done /466 queued / 16 running / 586 errors / 16% coverage ] ****** [588 done /465 queued / 16 running / 587 errors / 16% coverage ] ****** [588 done /465 queued / 16 running / 587 errors / 16% coverage ] ****** [589 done /466 queued / 16 running / 588 errors / 16% coverage ] ****** [589 done /466 queued / 16 running / 588 errors / 16% coverage ] ****** [590 done /468 queued / 16 running / 589 errors / 16% coverage ] ****** [590 done /468 queued / 16 running / 589 errors / 16% coverage ] ****** [591 done /469 queued / 16 running / 590 errors / 16% coverage ] ****** [591 done /469 queued / 16 running / 590 errors / 16% coverage ] ****** [592 done /471 queued / 16 running / 591 errors / 16% coverage ] ****** [592 done /471 queued / 16 running / 591 errors / 16% coverage ] ****** [593 done /470 queued / 16 running / 592 errors / 16% coverage ] ****** [593 done /470 queued / 16 running / 592 errors / 16% coverage ] ****** [594 done /475 queued / 16 running / 593 errors / 16% coverage ] ****** [594 done /475 queued / 16 running / 593 errors / 16% coverage ] ****** [595 done /476 queued / 16 running / 594 errors / 16% coverage ] ****** [595 done /476 queued / 16 running / 594 errors / 16% coverage ] ****** [596 done /478 queued / 16 running / 595 errors / 16% coverage ] ****** [596 done /478 queued / 16 running / 595 errors / 16% coverage ] ****** [597 done /477 queued / 16 running / 596 errors / 16% coverage ] ****** [597 done /477 queued / 16 running / 596 errors / 16% coverage ] ****** [598 done /479 queued / 16 running / 597 errors / 16% coverage ] ****** [598 done /479 queued / 16 running / 597 errors / 16% coverage ] ****** [599 done /483 queued / 16 running / 598 errors / 16% coverage ] ****** [599 done /483 queued / 16 running / 598 errors / 16% coverage ] ****** [600 done /484 queued / 16 running / 599 errors / 16% coverage ] ****** [600 done /484 queued / 16 running / 599 errors / 16% coverage ] ****** [601 done /483 queued / 16 running / 600 errors / 16% coverage ] ****** [601 done /483 queued / 16 running / 600 errors / 16% coverage ] ****** [602 done /484 queued / 16 running / 601 errors / 16% coverage ] ****** [602 done /484 queued / 16 running / 601 errors / 16% coverage ] ****** [603 done /486 queued / 16 running / 602 errors / 16% coverage ] ****** [603 done /486 queued / 16 running / 602 errors / 16% coverage ] ****** [604 done /489 queued / 16 running / 603 errors / 16% coverage ] ****** [604 done /489 queued / 16 running / 603 errors / 16% coverage ] ****** [605 done /488 queued / 16 running / 604 errors / 16% coverage ] ****** [605 done /488 queued / 16 running / 604 errors / 16% coverage ] ****** [606 done /493 queued / 16 running / 605 errors / 16% coverage ] ****** [606 done /493 queued / 16 running / 605 errors / 16% coverage ] ****** [607 done /495 queued / 16 running / 606 errors / 16% coverage ] ****** [607 done /495 queued / 16 running / 606 errors / 16% coverage ] ****** [608 done /496 queued / 16 running / 607 errors / 16% coverage ] ****** [608 done /496 queued / 16 running / 607 errors / 16% coverage ] ****** [609 done /497 queued / 16 running / 608 errors / 16% coverage ] ****** [609 done /497 queued / 16 running / 608 errors / 16% coverage ] ****** [610 done /498 queued / 16 running / 609 errors / 16% coverage ] ****** [610 done /498 queued / 16 running / 609 errors / 16% coverage ] ****** [611 done /500 queued / 16 running / 610 errors / 16% coverage ] ****** [611 done /500 queued / 16 running / 610 errors / 16% coverage ] ****** [612 done /501 queued / 16 running / 611 errors / 16% coverage ] ****** [612 done /501 queued / 16 running / 611 errors / 16% coverage ] ****** [613 done /502 queued / 16 running / 612 errors / 16% coverage ] ****** [613 done /502 queued / 16 running / 612 errors / 16% coverage ] ****** [614 done /506 queued / 16 running / 613 errors / 16% coverage ] ****** [614 done /506 queued / 16 running / 613 errors / 16% coverage ] ****** [615 done /507 queued / 16 running / 614 errors / 16% coverage ] ****** [615 done /507 queued / 16 running / 614 errors / 16% coverage ] ****** [616 done /508 queued / 16 running / 615 errors / 16% coverage ] ****** [616 done /508 queued / 16 running / 615 errors / 16% coverage ] ****** [617 done /509 queued / 16 running / 616 errors / 16% coverage ] ****** [617 done /509 queued / 16 running / 616 errors / 16% coverage ] ****** [618 done /511 queued / 16 running / 617 errors / 16% coverage ] ****** [618 done /511 queued / 16 running / 617 errors / 16% coverage ] ****** [619 done /515 queued / 16 running / 618 errors / 16% coverage ] ****** [619 done /515 queued / 16 running / 618 errors / 16% coverage ] ****** [620 done /516 queued / 16 running / 619 errors / 16% coverage ] ****** [620 done /516 queued / 16 running / 619 errors / 16% coverage ] ****** [621 done /517 queued / 16 running / 620 errors / 16% coverage ] ****** [621 done /517 queued / 16 running / 620 errors / 16% coverage ] ****** [622 done /518 queued / 16 running / 621 errors / 16% coverage ] ****** [622 done /518 queued / 16 running / 621 errors / 16% coverage ] ****** [623 done /519 queued / 16 running / 622 errors / 16% coverage ] ****** [623 done /519 queued / 16 running / 622 errors / 16% coverage ] ****** [624 done /521 queued / 16 running / 623 errors / 16% coverage ] ****** [624 done /521 queued / 16 running / 623 errors / 16% coverage ] ****** [625 done /523 queued / 16 running / 624 errors / 16% coverage ] ****** [625 done /523 queued / 16 running / 624 errors / 16% coverage ] ****** [626 done /525 queued / 16 running / 625 errors / 16% coverage ] ****** [626 done /525 queued / 16 running / 625 errors / 16% coverage ] ****** [627 done /524 queued / 16 running / 626 errors / 16% coverage ] ****** [627 done /524 queued / 16 running / 626 errors / 16% coverage ] ****** [628 done /526 queued / 16 running / 627 errors / 16% coverage ] ****** [628 done /526 queued / 16 running / 627 errors / 16% coverage ] ****** [629 done /527 queued / 16 running / 628 errors / 16% coverage ] ****** [629 done /527 queued / 16 running / 628 errors / 16% coverage ] ****** [630 done /529 queued / 16 running / 629 errors / 16% coverage ] ****** [630 done /529 queued / 16 running / 629 errors / 16% coverage ] ****** [631 done /532 queued / 16 running / 630 errors / 16% coverage ] ****** [631 done /532 queued / 16 running / 630 errors / 16% coverage ] ****** [632 done /534 queued / 16 running / 631 errors / 16% coverage ] ****** [632 done /534 queued / 16 running / 631 errors / 16% coverage ] ****** [633 done /536 queued / 16 running / 632 errors / 16% coverage ] ****** [633 done /536 queued / 16 running / 632 errors / 16% coverage ] ****** [634 done /539 queued / 16 running / 633 errors / 16% coverage ] ****** [634 done /539 queued / 16 running / 633 errors / 16% coverage ] ****** [635 done /538 queued / 16 running / 634 errors / 16% coverage ] ****** [635 done /538 queued / 16 running / 634 errors / 16% coverage ] ****** [636 done /539 queued / 16 running / 635 errors / 16% coverage ] ****** [636 done /539 queued / 16 running / 635 errors / 16% coverage ] ****** [637 done /540 queued / 16 running / 636 errors / 16% coverage ] ****** [637 done /540 queued / 16 running / 636 errors / 16% coverage ] ****** [638 done /542 queued / 16 running / 637 errors / 16% coverage ] ****** [638 done /542 queued / 16 running / 637 errors / 16% coverage ] ****** [639 done /541 queued / 16 running / 638 errors / 16% coverage ] ****** [639 done /541 queued / 16 running / 638 errors / 16% coverage ] ****** [640 done /542 queued / 16 running / 639 errors / 16% coverage ] ****** [640 done /542 queued / 16 running / 639 errors / 16% coverage ] ****** [641 done /543 queued / 16 running / 640 errors / 16% coverage ] ****** [641 done /543 queued / 16 running / 640 errors / 16% coverage ] ****** [642 done /543 queued / 16 running / 641 errors / 16% coverage ] ****** [642 done /543 queued / 16 running / 641 errors / 16% coverage ] ****** [643 done /547 queued / 16 running / 642 errors / 16% coverage ] ****** [643 done /547 queued / 16 running / 642 errors / 16% coverage ] ****** [644 done /549 queued / 16 running / 643 errors / 16% coverage ] ****** [644 done /549 queued / 16 running / 643 errors / 16% coverage ] ****** [645 done /549 queued / 16 running / 644 errors / 16% coverage ] ****** [645 done /549 queued / 16 running / 644 errors / 16% coverage ] ****** [646 done /549 queued / 16 running / 645 errors / 16% coverage ] ****** [646 done /549 queued / 16 running / 645 errors / 16% coverage ] ****** [647 done /548 queued / 16 running / 646 errors / 16% coverage ] ****** [647 done /548 queued / 16 running / 646 errors / 16% coverage ] ****** [648 done /547 queued / 16 running / 647 errors / 16% coverage ] ****** [648 done /547 queued / 16 running / 647 errors / 16% coverage ] ****** [649 done /548 queued / 16 running / 648 errors / 16% coverage ] ****** [649 done /548 queued / 16 running / 648 errors / 16% coverage ] ****** [650 done /549 queued / 16 running / 649 errors / 16% coverage ] ****** [650 done /549 queued / 16 running / 649 errors / 16% coverage ] ****** [651 done /551 queued / 16 running / 650 errors / 16% coverage ] ****** [651 done /551 queued / 16 running / 650 errors / 16% coverage ] ****** [652 done /551 queued / 16 running / 651 errors / 16% coverage ] ****** [652 done /551 queued / 16 running / 651 errors / 16% coverage ] ****** [653 done /553 queued / 16 running / 652 errors / 16% coverage ] ****** [653 done /553 queued / 16 running / 652 errors / 16% coverage ] ****** [654 done /555 queued / 16 running / 653 errors / 16% coverage ] ****** [654 done /555 queued / 16 running / 653 errors / 16% coverage ] ****** [655 done /556 queued / 16 running / 654 errors / 16% coverage ] ****** [655 done /556 queued / 16 running / 654 errors / 16% coverage ] ****** [656 done /559 queued / 16 running / 655 errors / 16% coverage ] ****** [656 done /559 queued / 16 running / 655 errors / 16% coverage ] ****** [657 done /561 queued / 16 running / 656 errors / 16% coverage ] ****** [657 done /561 queued / 16 running / 656 errors / 16% coverage ] ****** [658 done /563 queued / 16 running / 657 errors / 16% coverage ] ****** [658 done /563 queued / 16 running / 657 errors / 16% coverage ] ****** [659 done /566 queued / 16 running / 658 errors / 16% coverage ] ****** [659 done /566 queued / 16 running / 658 errors / 16% coverage ] ****** [660 done /566 queued / 16 running / 659 errors / 16% coverage ] ****** [660 done /566 queued / 16 running / 659 errors / 16% coverage ] ****** [661 done /565 queued / 16 running / 660 errors / 16% coverage ] ****** [661 done /565 queued / 16 running / 660 errors / 16% coverage ] ****** [662 done /564 queued / 16 running / 661 errors / 16% coverage ] ****** [662 done /564 queued / 16 running / 661 errors / 16% coverage ] ****** [663 done /565 queued / 16 running / 662 errors / 16% coverage ] ****** [663 done /565 queued / 16 running / 662 errors / 16% coverage ] ****** [664 done /567 queued / 16 running / 663 errors / 16% coverage ] ****** [664 done /567 queued / 16 running / 663 errors / 16% coverage ] ****** [665 done /567 queued / 16 running / 664 errors / 16% coverage ] ****** [665 done /567 queued / 16 running / 664 errors / 16% coverage ] ****** [666 done /566 queued / 16 running / 665 errors / 16% coverage ] ****** [666 done /566 queued / 16 running / 665 errors / 16% coverage ] ****** [667 done /565 queued / 16 running / 666 errors / 16% coverage ] ****** [667 done /565 queued / 16 running / 666 errors / 16% coverage ] ****** [668 done /567 queued / 16 running / 667 errors / 16% coverage ] ****** [668 done /567 queued / 16 running / 667 errors / 16% coverage ] ****** [669 done /567 queued / 16 running / 668 errors / 16% coverage ] ****** [669 done /567 queued / 16 running / 668 errors / 16% coverage ] ****** [670 done /568 queued / 16 running / 669 errors / 16% coverage ] ****** [670 done /568 queued / 16 running / 669 errors / 16% coverage ] ****** [671 done /570 queued / 16 running / 670 errors / 16% coverage ] ****** [671 done /570 queued / 16 running / 670 errors / 16% coverage ] ****** [672 done /573 queued / 16 running / 671 errors / 16% coverage ] ****** [672 done /573 queued / 16 running / 671 errors / 16% coverage ] ****** [673 done /576 queued / 16 running / 672 errors / 16% coverage ] ****** [673 done /576 queued / 16 running / 672 errors / 16% coverage ] ****** [674 done /577 queued / 16 running / 673 errors / 16% coverage ] ****** [674 done /577 queued / 16 running / 673 errors / 16% coverage ] ****** [675 done /579 queued / 16 running / 674 errors / 16% coverage ] ****** [675 done /579 queued / 16 running / 674 errors / 16% coverage ] ****** [676 done /581 queued / 16 running / 675 errors / 16% coverage ] ****** [676 done /581 queued / 16 running / 675 errors / 16% coverage ] ****** [677 done /582 queued / 16 running / 676 errors / 16% coverage ] ****** [677 done /582 queued / 16 running / 676 errors / 16% coverage ] ****** [678 done /582 queued / 16 running / 677 errors / 16% coverage ] ****** [678 done /582 queued / 16 running / 677 errors / 16% coverage ] ****** [679 done /581 queued / 16 running / 678 errors / 16% coverage ] ****** [679 done /581 queued / 16 running / 678 errors / 16% coverage ] ****** [680 done /583 queued / 16 running / 679 errors / 16% coverage ] ****** [680 done /583 queued / 16 running / 679 errors / 16% coverage ] ****** [681 done /582 queued / 16 running / 680 errors / 16% coverage ] ****** [681 done /582 queued / 16 running / 680 errors / 16% coverage ] ****** [682 done /581 queued / 16 running / 681 errors / 16% coverage ] ****** [682 done /581 queued / 16 running / 681 errors / 16% coverage ] ****** [683 done /584 queued / 16 running / 682 errors / 16% coverage ] ****** [683 done /584 queued / 16 running / 682 errors / 16% coverage ] ****** [684 done /586 queued / 16 running / 683 errors / 16% coverage ] ****** [684 done /586 queued / 16 running / 683 errors / 16% coverage ] ****** [685 done /587 queued / 16 running / 684 errors / 16% coverage ] ****** [685 done /587 queued / 16 running / 684 errors / 16% coverage ] ****** [686 done /588 queued / 16 running / 685 errors / 16% coverage ] ****** [686 done /588 queued / 16 running / 685 errors / 16% coverage ] ****** [687 done /588 queued / 16 running / 686 errors / 16% coverage ] ****** [687 done /588 queued / 16 running / 686 errors / 16% coverage ] ****** [688 done /587 queued / 16 running / 687 errors / 16% coverage ] ****** [688 done /587 queued / 16 running / 687 errors / 16% coverage ] ****** [689 done /588 queued / 16 running / 688 errors / 16% coverage ] ****** [689 done /588 queued / 16 running / 688 errors / 16% coverage ] ****** [690 done /588 queued / 16 running / 689 errors / 16% coverage ] ****** [690 done /588 queued / 16 running / 689 errors / 16% coverage ] ****** [691 done /591 queued / 16 running / 690 errors / 16% coverage ] ****** [691 done /591 queued / 16 running / 690 errors / 16% coverage ] ****** [692 done /592 queued / 16 running / 691 errors / 16% coverage ] ****** [692 done /592 queued / 16 running / 691 errors / 16% coverage ] ****** [693 done /595 queued / 16 running / 692 errors / 16% coverage ] ****** [693 done /595 queued / 16 running / 692 errors / 16% coverage ] ****** [694 done /595 queued / 16 running / 693 errors / 16% coverage ] ****** [694 done /595 queued / 16 running / 693 errors / 16% coverage ] ****** [695 done /597 queued / 16 running / 694 errors / 16% coverage ] ****** [695 done /597 queued / 16 running / 694 errors / 16% coverage ] ****** [696 done /598 queued / 16 running / 695 errors / 16% coverage ] ****** [696 done /598 queued / 16 running / 695 errors / 16% coverage ] ****** [697 done /597 queued / 16 running / 696 errors / 16% coverage ] ****** [697 done /597 queued / 16 running / 696 errors / 16% coverage ] ****** [698 done /600 queued / 16 running / 697 errors / 16% coverage ] ****** [698 done /600 queued / 16 running / 697 errors / 16% coverage ] ****** [699 done /599 queued / 16 running / 698 errors / 16% coverage ] ****** [699 done /599 queued / 16 running / 698 errors / 16% coverage ] ****** [700 done /601 queued / 16 running / 699 errors / 16% coverage ] ****** [700 done /601 queued / 16 running / 699 errors / 16% coverage ] ****** [701 done /603 queued / 16 running / 700 errors / 16% coverage ] ****** [701 done /603 queued / 16 running / 700 errors / 16% coverage ] ****** [702 done /602 queued / 16 running / 701 errors / 16% coverage ] ****** [702 done /602 queued / 16 running / 701 errors / 16% coverage ] ****** [703 done /602 queued / 16 running / 702 errors / 16% coverage ] ****** [703 done /602 queued / 16 running / 702 errors / 16% coverage ] ****** [704 done /604 queued / 16 running / 703 errors / 16% coverage ] ****** [704 done /604 queued / 16 running / 703 errors / 16% coverage ] ****** [705 done /604 queued / 16 running / 704 errors / 16% coverage ] ****** [705 done /604 queued / 16 running / 704 errors / 16% coverage ] ****** [706 done /604 queued / 16 running / 705 errors / 16% coverage ] ****** [706 done /604 queued / 16 running / 705 errors / 16% coverage ] ****** [707 done /607 queued / 16 running / 706 errors / 16% coverage ] ****** [707 done /607 queued / 16 running / 706 errors / 16% coverage ] ****** [708 done /609 queued / 16 running / 707 errors / 16% coverage ] ****** [708 done /609 queued / 16 running / 707 errors / 16% coverage ] ****** [709 done /608 queued / 16 running / 708 errors / 16% coverage ] ****** [709 done /608 queued / 16 running / 708 errors / 16% coverage ] ****** [710 done /608 queued / 16 running / 709 errors / 16% coverage ] ****** [710 done /608 queued / 16 running / 709 errors / 16% coverage ] ****** [711 done /607 queued / 16 running / 710 errors / 16% coverage ] ****** [711 done /607 queued / 16 running / 710 errors / 16% coverage ] ****** [712 done /607 queued / 16 running / 711 errors / 16% coverage ] ****** [712 done /607 queued / 16 running / 711 errors / 16% coverage ] ****** [713 done /608 queued / 16 running / 712 errors / 16% coverage ] ****** [713 done /608 queued / 16 running / 712 errors / 16% coverage ] ****** [714 done /610 queued / 16 running / 713 errors / 16% coverage ] ****** [714 done /610 queued / 16 running / 713 errors / 16% coverage ] ****** [715 done /609 queued / 16 running / 714 errors / 16% coverage ] ****** [715 done /609 queued / 16 running / 714 errors / 16% coverage ] ****** [716 done /611 queued / 16 running / 715 errors / 16% coverage ] ****** [716 done /611 queued / 16 running / 715 errors / 16% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log","toString","apply","bound ","create"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0,"Switcher":false,"Target_Switch_Base":0} start 0.0425 took 14.3709s
*-- Test Case {"Switcher":true,"Target_Switch_Base":0,"_bound":1,"ExpansionArg_type":0,"ExpansionArg_type_2":0} start 14.5056 took 13.759s
*-- Errors occured in test {"Switcher":true,"Target_Switch_Base":0,"_bound":1,"ExpansionArg_type":0,"ExpansionArg_type_2":0}
* Error: Tropigate failed because SyntaxError: 'with' in strict mode (1134:4) on program var safe = require('safe');
var _ = require('lodash');
var crypto = require('crypto');
var fs = require('fs');
var path = require('path');
var tcursor = require('./tcursor');
var wqueue = require('./wqueue');
var tindex = require('./tindex');
var tcache = require("./tcache");
var Code = require('./tcode').Code;
var tutils = require('./utils');
var Updater = require('./updater');

function tcoll(tdb) {
	var self = this;
	this._tdb = null;
	this._name = null;
	this._store = {};
	this._fd = null;
	this._fsize = null;
	this._id = 1;
	this._wq = new wqueue();
	this._tq = null;
	this._idx = {};
	this._cache = null;
	this._mc = {};
	this._check1 = Math.random()*100+1;
	// native mongo db compatibility attrs
	this.collectionName = null;
	if (tdb._stype=="mem") {
		this.init = this.initM;
		this._put = this._putM;
		this._get = this._getM;
	} else {
		this.init = this.initFS;
		this._put = this._putFS;
		this._get = this._getFS;
	}
}

module.exports = tcoll;

tcoll.prototype.initM = function (tdb, name, options, create, cb) {
	var self= this;
	this._tdb = tdb;
	tdb._mstore = tdb._mstore || {};
	this.collectionName = this._name = name;
	if (options.strict) {
		var exists = tdb._mstore[name];
		if (exists && create) return cb(new Error("Collection " + self._name + " already exists. Currently in safe mode."));
		else if (!exists && !create) return cb(new Error("Collection " + self._name + " does not exist. Currently in safe mode."));
	}
	tdb._mstore[name] = this._mstore = tdb._mstore[name] || [];
	for (var k=0; k< this._mstore.length; k++) {
		var o = this._mstore[k];
		if (o) {
			self._store[simplifyKey(o._id)]={pos:k+1};
		}
	}
	this._tq = new wqueue(100, function (cb) {
		// update indexes
		safe.forEachSeries(_.values(self._store), function (rec, cb) {
			self._get(rec.pos, false, safe.sure(cb, function (obj) {
				var id = simplifyKey(obj._id);
				_.forEach(self._idx,function(v, k) {
					v.set(obj, id);
				});
				cb();
			}));
		}, cb);
	});
	self.ensureIndex({_id: 1}, {name: '_id_', unique: true}, cb);
};

tcoll.prototype.initFS = function (tdb, name, options, create, cb) {
	var self= this;
	this._tdb = tdb;
	this._cache = new tcache(tdb, tdb._gopts.cacheSize);
	this._cmaxobj = tdb._gopts.cacheMaxObjSize || 1024;
	this.collectionName = this._name = name;
	this._filename = path.join(this._tdb._path, this._name);
	if (options.strict) {
		var exists = fs.existsSync(self._filename);
		if (exists && create) return cb(new Error("Collection " + self._name + " already exists. Currently in safe mode."));
		else if (!exists && !create) return cb(new Error("Collection " + self._name + " does not exist. Currently in safe mode."));
	}
	var pos = 0;
	var deleted = 0;
	var found = 0;
	this._tq = new wqueue(100, function (cb) {
		(function (cb) {
			fs.open(self._filename, "a+", safe.sure(cb, function (fd) {
			self._fd = fd;
			var b1 = new Buffer(45);
			safe.whilst(function () { return self._fsize===null; }, function(cb) {
				(function (cb) {
					fs.read(fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {
						if (bytes===0) {
							self._fsize = pos;
							return cb();
						}
						var h1 = JSON.parse(data.toString());
						h1.o = parseInt(h1.o,10);
						h1.k = parseInt(h1.k,10);
						var b2 = new Buffer(h1.k);
						fs.read(fd,b2,0,h1.k,pos+45+1, safe.sure(cb, function (bytes, data) {
							var k = JSON.parse(data.toString());
							self._id = k._uid;
							if (k._a=='del') {
								delete self._store[k._id];
								deleted++;
							} else {
								if (self._store[k._id]) deleted++;
								self._store[k._id] = { pos: pos, sum: k._s };
							}
							pos+=45+3+h1.o+h1.k;
							found++;
							cb();
						}));
					}));
				})(function (err) {
					if (err)
						cb(new Error(self._name+": Error during load - "+err.toString()));
					else
						cb();
				});
			}, cb);
			}));
		})(function (err) {
			if (!found && err)
				return cb(err); // nothing read and error, just rise it
			safe.run(function (cb) {
				var size = _.size(self._store);
				// autocompact on certain ratio or err
				if (deleted > size || err) {
					self._compact(function (errCompact) {
						if (errCompact && err)
							cb(errCompact);
						else {
							if (errCompact) console.log(err);
							cb();
						}
					});
				} else cb();
			}, function () {
				self._refreshIndexes(cb);
			});
		});
	});
	self.ensureIndex({_id: 1}, {name: '_id_', unique: true}, cb);
};

tcoll.prototype.compactCollection = function (cb) {
	var self = this;
	self._tq.add(function (cb) {
		self._compact(safe.sure(cb, function () {
			self._cache.clear();
			self._refreshIndexes(cb);
		}));
	}, true, cb);
};

tcoll.prototype._refreshIndexes = function (cb) {
	var self = this;
	_.forEach(self._idx,function(v, k) {
		v.clear();
	});
	safe.forEachSeries(_.values(self._store), function (rec, cb) {
		self._get(rec.pos, false, safe.sure(cb, function (obj) {
			var id = simplifyKey(obj._id);
			_.forEach(self._idx,function(v, k) {
				v.set(obj, id);
			});
			cb();
		}));
	}, cb);
};

tcoll.prototype._compact = function (cb) {
	var self = this;
	var filename = self._filename + '.compact';
	fs.open(filename, 'w+', safe.sure(cb, function (fd) {
		var b1 = new Buffer(45);
		function get(pos, cb) {
			fs.read(self._fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {
				var h1 = JSON.parse(data.toString());
				h1.o = parseInt(h1.o, 10);
				h1.k = parseInt(h1.k, 10);
				var b2 = new Buffer(h1.k + h1.o + 3);
				fs.read(self._fd, b2, 0, b2.length, pos + 45, safe.sure(cb, function (bytes, data) {
					cb(null, Buffer.concat([ b1, b2 ]));
				}));
			}));
		}
		var wpos = 0;
		var store = {};
		safe.forEachSeries(_.keys(self._store), function (k, cb) {
			var rec = self._store[k];
			get(rec.pos, safe.sure(cb, function (data) {
				fs.write(fd, data, 0, data.length, wpos, safe.sure(cb, function (written) {
					if (written != data.length) return cb(new Error('Insufficient disk space'));
					store[k] = { pos: wpos, sum: rec.sum };
					wpos += data.length;
					cb();
				}));
			}));
		}, function (err) {
			if (err) {
				fs.close(fd, function () {
					fs.unlink(filename, function () {
						cb(err);
					});
				});
				return;
			}
			if (!!process.platform.match(/^win/)) {
				// WINDOWS: unsafe because if something fail while renaming file it will not
				// restore automatically
				fs.close(self._fd, safe.sure(cb,function() {
					fs.close(fd, safe.sure(cb,function() {
						fs.unlink(self._filename, safe.sure(cb,function () {
							fs.rename(filename, self._filename, safe.sure(cb, function () {
								fs.open(self._filename, 'a+', safe.sure(cb, function (fd) {
									self._fd = fd;
									self._fsize = wpos;
									self._store = store;
									cb();
								}));
							}));
						}));
					}));
				}));
		    } else {
				// safe way
				fs.rename(filename, self._filename, safe.sure(cb, function () {
					fs.close(self._fd);
					self._fd = fd;
					self._fsize = wpos;
					self._store = store;
					cb();
				}));
			}
		});
	}));
};

tcoll.prototype.drop = function (cb) {
	this._tdb.dropCollection(this._name,cb);
};

tcoll.prototype.rename = function (nname, opts, cb) {
	var self = this;
	if (_.isFunction(opts)) {
		cb = opts;
		opts = {};
	}
	var err = self._tdb._nameCheck(nname);
	if (err)
		return safe.back(cb,err);
	if (self._tdb._stype=="mem") {
		delete self._tdb._cols[self._name];
		self._tdb._cols[nname] = self;
		delete self._tdb._mstore[self._name];
		self._tdb._mstore[nname] = self._mstore;
		safe.back(cb,null);
	} else {
		self._tq.add(function (cb) {
			fs.rename(path.join(self._tdb._path,self._name),path.join(self._tdb._path,nname),safe.sure(cb, function () {
				delete self._tdb._cols[self._name];
				self._tdb._cols[nname] = self;
				self.collectionName = self._name = nname;
				cb();
			}));
		},true,cb);
	}
};

tcoll.prototype._stop = function (cb) {
	var self = this;
	self._tq.add(function (cb) {
		// this will prevent any tasks processed on this instance
		self._tq._stoped = true;
		if (self._fd) {
			fs.close(self._fd,safe.sure(cb, function () {
				cb(null,true);
			}));
		} else
			cb(null,false);
	},true,cb);
};

tcoll.prototype.createIndex = tcoll.prototype.ensureIndex = function (obj, options, cb) {
	var self = this;
	if (_.isFunction(options)) {
		cb = options;
		options = {};
	}
	cb = cb || function () {};
	options = options || {};

	var c = new tcursor(this,{},{},{});
	c.sort(obj);
	if (c._err)
		return safe.back(cb,c._err);
	var key = c._sort;

	if (key===null)
		return safe.back(cb,new Error("No fields are specified"));

	var index = self._idx[key];
	if (index)
		return safe.back(cb,null, index.name);

	// force array support when global option is set
	if (_.isUndefined(options._tiarr) && self._tdb._gopts.searchInArray)
		options._tiarr = true;

	var name = options.name || _.map(key, function (v) { return v[0] + '_' + v[1]; }).join('_');
	index = new tindex(key, self, options, name);

	if (self._tq._tc==-1) {
		// if no operation is pending just register index
		self._idx[key] = index;
		safe.back(cb, null, index.name);
	}
	else {
		// overwise register index operation
		this._tq.add(function (cb) {
			var range = _.values(self._store);
			safe.forEachSeries(range, function (rec, cb) {
				self._get(rec.pos, false, safe.sure(cb, function (obj) {
					index.set(obj,simplifyKey(obj._id));
					cb();
				}));
			}, safe.sure(cb, function () {
				self._idx[key] = index;
				cb();
			}));
		}, true, function (err) {
			if (err) cb(err);
			else cb(null, index.name);
		});
	}
};

tcoll.prototype.indexExists = function (idx, cb) {
	if (!_.isArray(idx))
		idx = [idx];
	var i = _.intersection(idx,_(this._idx).values().map('name').value());
	cb(null,i.length == idx.length);
};

tcoll.prototype.indexes = function (cb) {
	var self = this;
	this._tq.add(function (cb) {
		cb(null, _.values(self._idx));
	},false,cb);
};

tcoll.prototype._getM = function (pos, unsafe, cb) {
	safe.back(cb,null,unsafe?this._mstore[pos-1]:this._tdb._cloneDeep(this._mstore[pos-1]));
};

tcoll.prototype._getFS = function (pos, unsafe, cb) {
	var self = this;
	var cached = self._cache.get(pos,unsafe);
	if (cached)
		return safe.back(cb,null,cached);
	var b1 = new Buffer(45);
	fs.read(self._fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {
		var h1 = JSON.parse(data.toString());
		h1.o = parseInt(h1.o,10);
		h1.k = parseInt(h1.k,10);
		var b2 = new Buffer(h1.o);
		fs.read(self._fd,b2,0,h1.o,pos+45+2+h1.k, safe.trap_sure(cb, function (bytes, data) {
			var obj = self._unwrapTypes(JSON.parse(data.toString()));
			if (bytes <= self._cmaxobj)
				self._cache.set(pos, obj);
			cb(null,obj);
		}))
	}))
}

tcoll.prototype.insert = function (docs, opts, cb ) {
	var self = this;
	if (_.isFunction(opts) && cb == null) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	if (opts.w>0 && !_.isFunction(cb))
		throw new Error("Callback is required for safe update");
	cb = cb || function () {};
	if (!_.isArray(docs))
		docs = [docs];
	this._tq.add(function (cb) {
		safe.forEachSeries(docs, function (doc, cb) {
			if (_.isUndefined(doc._id)) {
				doc._id = new self._tdb.ObjectID();
			}
			self._put(doc, false, cb);
		}, safe.sure(cb, function () {
			cb(null, docs);
		}))
	}, true, cb)
}

tcoll.prototype._wrapTypes = function(obj) {
	var self = this;
	_.each(obj, function (v,k) {
		if (_.isDate(v))
			obj[k] = {$wrap:"$date",v:v.valueOf(),h:v}
		else if (v instanceof self._tdb.ObjectID)
			obj[k] = {$wrap:"$oid",v:v.toJSON()}
		else if (v instanceof self._tdb.Binary)
			obj[k] = {$wrap: "$bin", v: v.toJSON()};
		else if (_.isObject(v))
			self._wrapTypes(v)

	})
	return obj;
}

tcoll.prototype._ensureIds = function(obj) {
	var self = this;
	_.each(obj, function (v,k) {
		if (k.length >0) {
			if (k[0]=='$')
				throw new Error("key "+k+" must not start with '$'");;
			if (k.indexOf('.')!=-1)
				throw new Error("key "+k+" must not contain '.'");
		}
		if (_.isObject(v)) {
			if (v instanceof self._tdb.ObjectID) {
				if (v.id<0) {
					v._persist(++self._id)
				}
			}
			else
				self._ensureIds(v)
		}
	})
	return obj;
}


tcoll.prototype._unwrapTypes = function(obj) {
	var self = this;
	_.each(obj, function (v,k) {
		if (_.isObject(v)) {
			switch (v.$wrap) {
				case "$date": obj[k] = new Date(v.v); break;
				case "$oid":
					var oid = new self._tdb.ObjectID(v.v);
					obj[k]=oid;
				break;
				case "$bin":
					var bin = new self._tdb.Binary(new Buffer(v.v, 'base64'));
					obj[k] = bin;
				break;
				default: self._unwrapTypes(v);
			}
		}
	})
	return obj;
}

tcoll.prototype._putM = function (item_, remove, cb) {
	var item = this._tdb._cloneDeep(item_);
	var self = this;
	self._wq.add(function (cb) {
		try {
			item = self._ensureIds(item);
		} catch (err) {
			err.errmsg = err.toString();
			return cb(err)
		}
		if (_.isUndefined(item._id))
			return cb(new Error("Invalid object key (_id)"));

		var key = {_id:simplifyKey(item._id)};

		// check index update
		if (item && !remove) {
			try {
				_.forEach(self._idx,function(v,k) {
					v.set(item,key._id,true);
				})
			} catch (err) {
				err.errmsg = err.toString();
				return cb(err)
			}
		}

		if (remove) {
			self._mstore[self._store[key._id].pos-1]=null;
			delete self._store[key._id];
		}
		else {
			if (self._store[key._id]) {
				self._mstore[self._store[key._id].pos-1] = item;
			} else {
				self._mstore.push(item);
				self._store[key._id] = {pos: self._mstore.length};
			}
		}

		// update index
		_.forEach(self._idx,function(v,k) {
			if (!remove)
				v.set(item,key._id);
			else
				v.del(item,key._id);
		})
		cb(null);
	}, true, cb);
}


tcoll.prototype._putFS = function (item, remove, cb) {
	var self = this;
	self._wq.add(function (cb) {
		try {
			item = self._ensureIds(item);
		} catch (err) {
			err.errmsg = err.toString();
			return cb(err)
		}
		if (_.isUndefined(item._id))
			return cb(new Error("Invalid object key (_id)"));
		item = self._wrapTypes(item);
		var sobj = new Buffer(remove?"":JSON.stringify(item));
		item = self._unwrapTypes(item);
		var key = {_id:simplifyKey(item._id),_uid:self._id,_dt:(new Date()).valueOf()};
		if (remove) key._a = "del";
		else {
			var hash = crypto.createHash('md5');
			hash.update(sobj, 'utf8');
			key._s = hash.digest('hex');
		}
		var skey = new Buffer(JSON.stringify(key));
		var zeros = "0000000000";
		var lobj = sobj.length.toString();
		var lkey = skey.length.toString();
		lobj = zeros.substr(0,zeros.length - lobj.length)+lobj;
		lkey = zeros.substr(0,zeros.length - lkey.length)+lkey;
		var h1={k:lkey,o:lobj,v:"001"};
		var buf = new Buffer(JSON.stringify(h1)+"\n"+skey+"\n"+sobj+"\n");

		// check index update
		if (item && !remove) {
			try {
				_.forEach(self._idx,function(v,k) {
					v.set(item,key._id,true);
				})
			} catch (err) {
				err.errmsg = err.toString();
				return cb(err)
			}
		}

		safe.run(function (cb) {
			var rec = self._store[key._id];
			if (rec && rec.sum == key._s) return safe.back(cb);
			fs.write(self._fd, buf, 0, buf.length, self._fsize, safe.sure(cb, function (written) {
				if (remove)
					delete self._store[key._id];
				else
					self._store[key._id] = { pos: self._fsize, sum: key._s };

				if (remove || sobj.length > self._cmaxobj)
					self._cache.unset(self._fsize)
				else
					self._cache.set(self._fsize,item);
				self._fsize+=written;
				// randomly check for non exclusive file usage
				// which is growth of file that we are nor aware
				// randomly to avoid overhead
				if (self._check1==0) {
					this._check1 = Math.random()*100+1;
					fs.fstat(self._fd, safe.sure(cb, function (stat) {
						if (self._fsize!=stat.size)
							cb(new Error("File size mismatch. Are you use db/collection exclusively?"))
						else
							cb()
					}))
				} else {
					self._check1--;
					cb();
				}
			}));
		},
		function () {
			// update index
			_.forEach(self._idx,function(v,k) {
				if (!remove)
					v.set(item,key._id);
				else
					v.del(item,key._id);
			})
			cb(null);
		});
	}, true, cb);
}

tcoll.prototype.count = function (query, options, cb) {
	var self = this;
	if (arguments.length == 1) {
		cb = arguments[0];
        options = null;
		query = null;
	}
	if (arguments.length == 2) {
        query = arguments[0];
		cb = arguments[1];
        options = null;
	}
	if (query==null || _.size(query)==0) {
		this._tq.add(function (cb) {
			cb(null, _.size(self._store));
		},false,cb);
	} else
		self.find(query, options).count(cb);
}

tcoll.prototype.stats = function (cb) {
	var self = this;
	this._tq.add(function (cb) {
		cb(null, {count:_.size(self._store)});
	},false,cb);
}


var findOpts = ['limit','sort','fields','skip','hint','timeout','batchSize','safe','w'];

tcoll.prototype.findOne = function () {
	var findArgs = Array.prototype.slice.call(arguments,0,arguments.length-1);
	var cb = arguments[arguments.length-1];
	this.find.apply(this,findArgs).limit(1).nextObject(cb);
}

tcoll.prototype.find = function () {
	var cb = null, query = {}, opts = {}, fields = null, skip = null, limit = null, sort = null;
	var argc = arguments.length;
	if (argc>0) {
		// guess callback, it is always latest
		cb = arguments[argc-1];
		if (!_.isFunction(cb))
			cb=null
		else
			argc--;
		if (argc>0) {
			// query should always exist
			query = arguments[0]
			if (argc>1) {
				if (argc==2) {
					var val = arguments[1];
					// worst case we get either options either fiels
					if (_.intersection(_.keys(val),findOpts).length!=0)
						opts = val
					else
						fields = val;
				} else {
					fields = arguments[1];
					if (argc == 3)
						opts = arguments[2]
					else {
						skip = arguments[2];
						limit = arguments[3]
					}
				}
			}
		}
	}

	opts = opts || {};
	skip = skip || opts.skip || null;
	limit = limit || opts.limit || null;
	fields = fields || opts.fields || null;
	sort = sort || opts.sort || null;


	var c = new tcursor(this,query, fields, opts);

	if (skip) c.skip(skip);
	if (limit) c.limit(limit);
	if (sort) c.sort(sort);
	if (cb)
		cb(null, c)
	else
		return c;
}


function simplifyKey(key) {
	var k = key;
	if (key.toJSON)
		k = key.toJSON();
	if (_.isNumber(k)||_.isString(k))
		return k;
	return k.toString();
}

tcoll.prototype.update = function (query, doc, opts, cb) {
	var self = this;
	if (_.isFunction(opts) && cb == null) {
		cb = opts;
	}
	opts = opts || {};
	if (opts.w>0 && !_.isFunction(cb))
		throw new Error("Callback is required for safe update");
	cb = cb || function () {}
	if (!_.isObject(query))
		throw new Error("selector must be a valid JavaScript object");
	if (!_.isObject(doc))
		throw new Error("document must be a valid JavaScript object");

	var multi = opts.multi || false;
    var updater = new Updater(doc, self._tdb);
	var $doc = updater.hasAtomic()?null:doc;
	this._tq.add(function (cb) {
		self.__find(query, null, 0, multi ? null : 1, null, opts.hint, {}, safe.sure(cb, function (res) {
			if (res.length==0) {
				if (opts.upsert) {
					$doc = $doc || query;
					$doc = self._tdb._cloneDeep($doc);
					updater.update($doc,true);
					if (_.isUndefined($doc._id))
						$doc._id = new self._tdb.ObjectID();
					self._put($doc, false, safe.sure(cb, function () {
						cb(null, 1,{updatedExisting:false,upserted:$doc._id,n:1})
					}))
				} else
					cb(null,0);
			} else {
				safe.forEachSeries(res, function (pos, cb) {
					self._get(pos, false, safe.sure(cb, function (obj) {
						// remove current version of doc from indexes
						_.forEach(self._idx,function(v,k) {
							v.del(obj,simplifyKey(obj._id));
						})
						var udoc = $doc;
						if (!$doc) {
							udoc = obj;
							updater.update(udoc);
						}
						udoc._id = obj._id;
						// put will add it back to indexes
						self._put(udoc, false, cb);
					}))
				}, safe.sure(cb,function () {
					cb(null, res.length, {updatedExisting:true,n:res.length});
				}))
			}
		}))
	},true,cb);
}

tcoll.prototype.findAndModify = function (query, sort, doc, opts, cb) {
	var self = this;
	if (_.isFunction(opts) && cb == null) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	doc = doc || {};

	var updater = new Updater(doc, self._tdb);
	var $doc = updater.hasAtomic()?null:doc;

	var c = new tcursor(this,{}, opts.fields || {},{});
	c.sort(sort);
	if (c._err)
		return safe.back(cb,c._err);

	this._tq.add(function (cb) {
		self.__find(query, null, 0, 1, c._sort, opts.hint, {}, safe.sure(cb, function (res) {
			if (res.length==0) {
				if (opts.upsert) {
					$doc = $doc || query;
					$doc = self._tdb._cloneDeep($doc);
					updater.update($doc,true);
					if (_.isUndefined($doc._id))
						$doc._id = new self._tdb.ObjectID();
					self._put($doc, false, safe.sure(cb, function () {
						cb(null,opts.new?c._projectFields($doc):{})
					}))
				} else
					cb();
			} else {
				self._get(res[0], false, safe.sure(cb, function (obj) {
					var robj = (opts.new && !opts.remove) ? obj : self._tdb._cloneDeep(obj);
					// remove current version of doc from indexes
					_.forEach(self._idx,function(v,k) {
						v.del(obj,simplifyKey(obj._id));
					})
					var udoc = $doc;
					if (!$doc) {
						udoc = obj;
						updater.update(udoc);
					}
					udoc._id = obj._id;
					// put will add it back to indexes
					self._put(udoc, opts.remove?true:false, safe.sure(cb,function () {
						cb(null,c._projectFields(robj))
					}))
				}))
			}
		}))
	},true,cb);
}

tcoll.prototype.save = function (doc, opts, cb) {
	var self = this;
	cb = _.isFunction(doc)?doc:_.isFunction(opts)?opts:cb;
	cb = cb || function () {};
	doc = doc || {};
	opts = opts || {};
	this._tq.add(function (cb) {
		var res = doc;
		(function(cb) {
			if (_.isUndefined(doc._id)) {
				doc._id = new self._tdb.ObjectID();
				cb()
			} else {
				var id = simplifyKey(doc._id);
				var pos = self._store[id];
				// check if document with this id already exist
				if (pos) {
					// if so we need to fetch it to update index
					self._get(pos.pos, false, safe.sure(cb, function (oldDoc) {
						// remove current version of doc from indexes
						_.forEach(self._idx,function(v,k) {
							v.del(oldDoc,id);
						})
						res = 1;
						cb();
					}))
				} else cb();
			}
		})(safe.sure(cb, function () {
			self._put(doc, false, safe.sure(cb, function () {
				cb(null,res); // when update return 1 when new save return obj
			}))
		}))
	},true,cb);
}

tcoll.prototype.remove = function (query, opts, cb) {
	var self = this;
	if (_.isFunction(query)) {
		cb = query;
		query = opts = {};
	} else if (_.isFunction(opts)) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	if (opts.w>0 && !_.isFunction(cb))
		throw new Error("Callback is required");
	cb = cb || function () {};
	var single = opts.single || false;
	this._tq.add(function (cb) {
		self.__find(query, null, 0, single ? 1 : null, null, opts.hint, {}, safe.sure(cb, function (res) {
			safe.forEachSeries(res, function (pos, cb) {
				self._get(pos, false, safe.sure(cb, function (obj) {
					self._put(obj,true,cb);
				}))
			}, safe.sure(cb, function () {
				cb(null,res.length);
			}))
		}))
	},true,cb);
}

tcoll.prototype.findAndRemove = function (query,sort,opts,cb) {
	var self = this;

	if (_.isFunction(sort) && cb == null && opts==null) {
		cb = sort;
		sort = {}
		opts = {};
	} else if (_.isFunction(opts) && cb == null) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	sort = sort || {};

	var c = new tcursor(this,{},{},{});

	// Fix for mongoouse/tungus they pass sort as undefined
	c.sort(sort);

	if (c._err)
		return safe.back(cb,c._err);

	this._tq.add(function (cb) {
		self.__find(query, null, 0, 1, c._sort, opts.hint, {}, safe.sure(cb, function (res) {
			if (res.length==0)
				return cb();
			self._get(res[0], false, safe.sure(cb, function (obj) {
				self._put(obj,true,safe.sure(cb, function () {
					cb(null,obj);
				}))
			}))
		}))
	},true,cb);
}

tcoll.prototype._bestSortIndex = function (sort) {
	// no sort
	if (!sort) return null;
	// exact match
	if (this._idx[sort]) return this._idx[sort];
	// find potential sort indexes
	var pi = [];
	_.forEach(this._idx,function (idx) {
		var fields = idx.fields();
		var match = _.takeWhile(fields, function (kv, i) {
			return i < sort.length ? kv[0] == sort[i][0] : false;
		});
		if (match.length == sort.length) {
			var score = fields.length;
			_.forEach(sort,function (kv, i) {
				if (kv[1] != fields[i][1]) score += 1;
			});
			pi.push({ value: idx, score: score });
		}
	});
	if (pi.length === 0) return null;
	// select best index
	pi = pi.sort(function (l, r) { return l.score < r.score; });
	return pi[0].value;
};

function reduceIndexSet(pi) {
	var hit;
	do {
		hit = false;
		// compare each potential index with each other
		_.forEach(pi,function (v1, i1) {
			_.forEach(pi,function (v2, i2) {
				if (i1 == i2) return;
				// compare the set of possible keys for both indexes
				if (_.union(v1.k, v2.k).length == v1.k.length) {
					// key for v2 is a subset of key for v1, check equality
					if (v1.k.length == v2.k.length && v1.i.depth() > v2.i.depth()) {
						// keys are equal, but the depth of v2 is lower;
						// v2 is preferable, strike out v1
						pi.splice(i1, 1);
					} else {
						// in other two cases v1 is preferable, strike out v2
						pi.splice(i2, 1);
					}
					hit = true;
					return false;
				}
			});
			if (hit) return false;
		});
	} while (hit);
};

tcoll.prototype.__find = function (query, fields, skip, limit, sort, hint, arFields, cb) {
	var self = this;
	var range = [];
	// find sort index
	var si = this._bestSortIndex(sort);
	// for non empty query check indexes that we can use
	var qt = self._tdb.Finder.matcher(query);
	var pi = [];
	if (_.size(qt)>0) {
		_.forEach(self._idx,function (i) {
			var f = _.pluck(i.fields(), 0);
			var e = _.takeWhile(f, function (k) {
				return qt._ex(k) == 1 && (!hint || hint[k]);
			});
			if (e.length > 0) pi.push({ i: i, k: e, e: f.length > e.length });
		});
	}

	// if possible indexes found split the query and process
	// indexes separately
	if (!_.isEmpty(pi)) {
		// choose the most appropriate indexes
		reduceIndexSet(pi);
		// split query
		var io = {};
		_.forEach(pi,function (v) {
			_.forEach(v.k,function (k) {
				if (!io[k]) io[k] = qt.split(k);
			});
		});
		// process indexes
		var p = [];
		_.forEach(pi,function (st) {
			// this action applies to all indexes
			var r = io[st.k[0]]._index(st.i);
			// process subfields of compound index
			_.forEach(st.k.slice(1),function (k) {
				var v = io[k];
				r = _.flatten(_.map(r, function (si) { return v._index(si); }));
			});
			// expand subindexes to plain ids
			if (st.e) r = _.flatten(_.map(r, function (si) { return si.all(); }));
			// store result of index search
			p.push(r);
		});
		if (p.length == 1) {
			p = p[0];
			// optimization for the case when search and sorting indexes are the same
			if (si && pi[0].i === si) {
				var sif = si.fields();
				if (_.every(sort, function (v, i) { return sif[i][1] == v[1]; })) {
					// sort order exactly matches index order,
					// so the result is already sorted
					sort = null;
				} else if (_.every(sort, function (v, i) { return sif[i][1] == -v[1]; })) {
					// sort order is exactly opposite to index order,
					// so the result is sorted, but in reverse direction
					p.reverse();
					sort = null;
				}
			}
		} else {
			// TODO: use sort index as intersect base to speedup sorting
			p = tutils.intersectIndexes(p);
		}
		// nowe we have ids, need to convert them to positions
		_.forEach(p,function (_id) {
			range.push(self._store[_id].pos)
		})
	} else {
		if (si) {
			_.each(si.all(_.pluck(sort, 1)), function (_id) {
				range.push(self._store[_id].pos)
			})
			//if (order==-1)
			//	range.reverse();
			sort = null;
		} else
			range = _.values(self._store).map(function (rec) { return rec.pos; });
	}

	if (sort && si) {
		var ps = {};
		_.each(range,function (pos) {
			ps[pos] = true;
		});
		range = [];
		_.each(si.all(_.pluck(sort, 1)),function (_id) {
			var pos = self._store[_id].pos;
			if (_.has(ps,pos)) range.push(pos);
		});
		//if (order == -1)
		//	range.reverse();
		sort = null;
	}

	// no sort, no query then return right away
	if (sort==null && (_.size(qt)==0 || qt._args.length==0)) {
		if (skip!=0 || limit!=null) {
			var c = Math.min(range.length-skip,limit?limit:range.length-skip);
			range = range.splice(skip,c)
		}
		return safe.back(cb,null,range);
	}

	var matcher = null;
	// check if we can use simple match or array match function
	var arrayMatch = false;
	if (self._tdb._gopts.searchInArray)
		arrayMatch = true;
	else {
		var fields = qt.fields();
		_.each(fields, function (v,k) {
			if (arFields[k])
				arrayMatch = true;
		})
	}

	eval("matcher = function (obj) { return "+ (arrayMatch?qt.native3():qt.native()) + " }");

	// create sort index
	if (sort) {
		si = new tindex(sort,self);
	}

	// now simple non-index search
	var res = [];
	var found = 0;
	safe.forEachSeries(range, function (pos, cb) {
		if (sort==null && limit && res.length>=limit)
			return safe.back(cb);
		self._get(pos, true, safe.sure(cb, function (obj) {
			if (matcher(obj)) {
				if (sort!=null || found>=skip) {
					if (sort==null)
						res.push(pos);
					else
						si.set(obj,pos);
				}
				found++;
			}
			cb()
		}))
	}, safe.sure(cb, function () {
		if (sort) {
			res = si.all();
			//if (order==-1) {
			//	res.reverse();
			//}
			if (skip!=0 || limit!=null) {
				var c = Math.min(res.length-skip,limit?limit:res.length-skip);
				res = res.splice(skip,c)
			}
		}
		cb(null, res);
	}))
}

tcoll.prototype._find = function (query, fields, skip, limit, sort_, hint, arFields, cb) {
	var self = this;
	this._tq.add(function (cb) {
		self.__find(query, fields, skip, limit, sort_, hint, arFields, cb);
	}, false, cb);
}

function code2fn(obj) {
	if (_.isObject(obj)) {
		_.each(obj,function (value, key) {
			if (value instanceof Code) {
				with (value.scope) {
					obj[key] = eval('(' + value.code + ')');
				}
			}
			else code2fn(value);
		});
	}
}

tcoll.prototype.mapReduce = function (map, reduce, opts, cb) {
	var self = this;
	if (_.isFunction(opts)) {
		cb = opts;
		opts = {};
	}

	if (!opts.out) return safe.back(cb, new Error('the out option parameter must be defined'));
	if (!opts.out.inline && !opts.out.replace) {
		return safe.back(cb, new Error('the only supported out options are inline and replace'));
	}

	code2fn(opts.scope);

	var m = {};

	function emit(k, v) {
		var values = m[k];
		if (!values) m[k] = [ v ];
		else {
			values.push(v);
			if (values.length > 1000) values = [ reduce(k, values) ];
		}
	}

	with (opts.scope || {}) {
		try {
			if (map instanceof Code) {
				with (map.scope) {
					map = eval('(' + map.code + ')');
				}
			} else map = eval('(' + map + ')');
			if (reduce instanceof Code) {
				with (reduce.scope) {
					reduce = eval('(' + reduce.code + ')');
				}
			} else reduce = eval('(' + reduce + ')');
			if (finalize instanceof Code) {
				with (finalize.scope) {
					finalize = eval('(' + finalize.code + ')');
				}
			} else var finalize = eval('(' + opts.finalize + ')');
		} catch (e) {
			return safe.back(cb,e);
		}
	}

	self.find(opts.query, null, { limit: opts.limit, sort: opts.sort }, safe.sure(cb, function (c) {
		var doc;
		safe.doUntil(
			function (cb) {
				c.nextObject(safe.trap_sure(cb, function (_doc) {
					doc = _doc;
					if (doc) map.call(doc);
					return cb();
				}));
			},
			function () {
				return doc === null;
			},
			safe.trap_sure(cb, function () {
				_.each(m,function (v, k) {
					v = v.length > 1 ? reduce(k, v) : v[0];
					if (finalize) v = finalize(k, v);
					m[k] = v;
				});

				var stats = {};
				if (opts.out.inline) return process.nextTick(function () {
					cb(null, _.values(m), stats); // execute outside of trap
				});

				// write results to collection
				safe.waterfall([
					function (cb) {
						self._tdb.collection(opts.out.replace, { strict: 1 }, function (err, col) {
							if (err) return cb(null, null);
							col.drop(cb);
						});
					},
					function (arg, cb) {
						self._tdb.collection(opts.out.replace, {}, cb);
					},
					function (col, cb) {
						var docs = [];
						_.each(m,function (value, key) {
							var doc = {
								_id: key,
								value: value
							};
							docs.push(doc);
						});
						col.insert(docs, safe.sure(cb, function () {
							if (opts.verbose) cb(null, col, stats);
							else cb(null, col);
						}));
					}
				], cb);
			}
		)); // doUntil
	}));
};

tcoll.prototype.group = function (keys, condition, initial, reduce, finalize, command, options, callback) {
	var self = this;

	var args = Array.prototype.slice.call(arguments, 3);
	callback = args.pop();
	reduce = args.length ? args.shift() : null;
	finalize = args.length ? args.shift() : null;
	command = args.length ? args.shift() : null;
	options = args.length ? args.shift() : {};

	if (!_.isFunction(finalize)) {
		command = finalize;
		finalize = null;
	}

	code2fn(options.scope);

	with (options.scope || {}) {
		try {
			if (_.isFunction(keys)) keys = eval('(' + keys + ')');
			else if (keys instanceof Code) {
				with (keys.scope) {
					keys = eval('(' + keys.code + ')');
				}
			}
			if (reduce instanceof Code) {
				with (reduce.scope) {
					reduce = eval('(' + reduce.code + ')');
				}
			} else reduce = eval('(' + reduce + ')');
			if (finalize instanceof Code) {
				with (finalize.scope) {
					finalize = eval('(' + finalize.code + ')');
				}
			} else finalize = eval('(' + finalize + ')');
		} catch (e) {
			return callback(e);
		}
	}

	var m = {};
	self.find(condition, safe.sure(callback, function (c) {
		var doc;
		safe.doUntil(
			function (cb) {
				c.nextObject(safe.sure(cb, function (_doc) {
					doc = _doc;
					if (!doc) return cb();
					var keys2 = keys;
					if (_.isFunction(keys)) keys2 = keys(doc);
					if (!_.isArray(keys2)) {
						var keys3 = [];
						_.each(keys2,function (v, k) {
							if (v) keys3.push(k);
						});
						keys2 = keys3;
					}
					var key = {};
					_.each(keys2,function (k) {
						key[k] = doc[k];
					});
					var skey = JSON.stringify(key);
					var obj = m[skey];
					if (!obj) obj = m[skey] = _.extend({}, key, initial);
					try {
						reduce(doc, obj);
					} catch (e) {
						return cb(e);
					}
					cb();
				}));
			},
			function () {
				return doc === null;
			},
			safe.sure(callback, function () {
				var result = _.values(m);
				if (finalize) {
					_.each(result,function (value) {
						finalize(value);
					});
				}
				callback(null, result);
			})
		);
	}));
};
 at SyntaxError: 'with' in strict mode (1134:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$1.parseWithStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:932:27)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:708:32)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseBlock (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:981:25)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:709:33)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseIfStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:824:28)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:698:30)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"Target_Switch_Base":0,"_bound":1}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":0,"ExpansionArg_type_2":1,"_bound":3} start 28.4906 took 19.1908s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":0,"ExpansionArg_type_2":1,"_bound":3}
* Error: Tropigate failed because SyntaxError: 'with' in strict mode (1134:4) on program var safe = require('safe');
var _ = require('lodash');
var crypto = require('crypto');
var fs = require('fs');
var path = require('path');
var tcursor = require('./tcursor');
var wqueue = require('./wqueue');
var tindex = require('./tindex');
var tcache = require("./tcache");
var Code = require('./tcode').Code;
var tutils = require('./utils');
var Updater = require('./updater');

function tcoll(tdb) {
	var self = this;
	this._tdb = null;
	this._name = null;
	this._store = {};
	this._fd = null;
	this._fsize = null;
	this._id = 1;
	this._wq = new wqueue();
	this._tq = null;
	this._idx = {};
	this._cache = null;
	this._mc = {};
	this._check1 = Math.random()*100+1;
	// native mongo db compatibility attrs
	this.collectionName = null;
	if (tdb._stype=="mem") {
		this.init = this.initM;
		this._put = this._putM;
		this._get = this._getM;
	} else {
		this.init = this.initFS;
		this._put = this._putFS;
		this._get = this._getFS;
	}
}

module.exports = tcoll;

tcoll.prototype.initM = function (tdb, name, options, create, cb) {
	var self= this;
	this._tdb = tdb;
	tdb._mstore = tdb._mstore || {};
	this.collectionName = this._name = name;
	if (options.strict) {
		var exists = tdb._mstore[name];
		if (exists && create) return cb(new Error("Collection " + self._name + " already exists. Currently in safe mode."));
		else if (!exists && !create) return cb(new Error("Collection " + self._name + " does not exist. Currently in safe mode."));
	}
	tdb._mstore[name] = this._mstore = tdb._mstore[name] || [];
	for (var k=0; k< this._mstore.length; k++) {
		var o = this._mstore[k];
		if (o) {
			self._store[simplifyKey(o._id)]={pos:k+1};
		}
	}
	this._tq = new wqueue(100, function (cb) {
		// update indexes
		safe.forEachSeries(_.values(self._store), function (rec, cb) {
			self._get(rec.pos, false, safe.sure(cb, function (obj) {
				var id = simplifyKey(obj._id);
				_.forEach(self._idx,function(v, k) {
					v.set(obj, id);
				});
				cb();
			}));
		}, cb);
	});
	self.ensureIndex({_id: 1}, {name: '_id_', unique: true}, cb);
};

tcoll.prototype.initFS = function (tdb, name, options, create, cb) {
	var self= this;
	this._tdb = tdb;
	this._cache = new tcache(tdb, tdb._gopts.cacheSize);
	this._cmaxobj = tdb._gopts.cacheMaxObjSize || 1024;
	this.collectionName = this._name = name;
	this._filename = path.join(this._tdb._path, this._name);
	if (options.strict) {
		var exists = fs.existsSync(self._filename);
		if (exists && create) return cb(new Error("Collection " + self._name + " already exists. Currently in safe mode."));
		else if (!exists && !create) return cb(new Error("Collection " + self._name + " does not exist. Currently in safe mode."));
	}
	var pos = 0;
	var deleted = 0;
	var found = 0;
	this._tq = new wqueue(100, function (cb) {
		(function (cb) {
			fs.open(self._filename, "a+", safe.sure(cb, function (fd) {
			self._fd = fd;
			var b1 = new Buffer(45);
			safe.whilst(function () { return self._fsize===null; }, function(cb) {
				(function (cb) {
					fs.read(fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {
						if (bytes===0) {
							self._fsize = pos;
							return cb();
						}
						var h1 = JSON.parse(data.toString());
						h1.o = parseInt(h1.o,10);
						h1.k = parseInt(h1.k,10);
						var b2 = new Buffer(h1.k);
						fs.read(fd,b2,0,h1.k,pos+45+1, safe.sure(cb, function (bytes, data) {
							var k = JSON.parse(data.toString());
							self._id = k._uid;
							if (k._a=='del') {
								delete self._store[k._id];
								deleted++;
							} else {
								if (self._store[k._id]) deleted++;
								self._store[k._id] = { pos: pos, sum: k._s };
							}
							pos+=45+3+h1.o+h1.k;
							found++;
							cb();
						}));
					}));
				})(function (err) {
					if (err)
						cb(new Error(self._name+": Error during load - "+err.toString()));
					else
						cb();
				});
			}, cb);
			}));
		})(function (err) {
			if (!found && err)
				return cb(err); // nothing read and error, just rise it
			safe.run(function (cb) {
				var size = _.size(self._store);
				// autocompact on certain ratio or err
				if (deleted > size || err) {
					self._compact(function (errCompact) {
						if (errCompact && err)
							cb(errCompact);
						else {
							if (errCompact) console.log(err);
							cb();
						}
					});
				} else cb();
			}, function () {
				self._refreshIndexes(cb);
			});
		});
	});
	self.ensureIndex({_id: 1}, {name: '_id_', unique: true}, cb);
};

tcoll.prototype.compactCollection = function (cb) {
	var self = this;
	self._tq.add(function (cb) {
		self._compact(safe.sure(cb, function () {
			self._cache.clear();
			self._refreshIndexes(cb);
		}));
	}, true, cb);
};

tcoll.prototype._refreshIndexes = function (cb) {
	var self = this;
	_.forEach(self._idx,function(v, k) {
		v.clear();
	});
	safe.forEachSeries(_.values(self._store), function (rec, cb) {
		self._get(rec.pos, false, safe.sure(cb, function (obj) {
			var id = simplifyKey(obj._id);
			_.forEach(self._idx,function(v, k) {
				v.set(obj, id);
			});
			cb();
		}));
	}, cb);
};

tcoll.prototype._compact = function (cb) {
	var self = this;
	var filename = self._filename + '.compact';
	fs.open(filename, 'w+', safe.sure(cb, function (fd) {
		var b1 = new Buffer(45);
		function get(pos, cb) {
			fs.read(self._fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {
				var h1 = JSON.parse(data.toString());
				h1.o = parseInt(h1.o, 10);
				h1.k = parseInt(h1.k, 10);
				var b2 = new Buffer(h1.k + h1.o + 3);
				fs.read(self._fd, b2, 0, b2.length, pos + 45, safe.sure(cb, function (bytes, data) {
					cb(null, Buffer.concat([ b1, b2 ]));
				}));
			}));
		}
		var wpos = 0;
		var store = {};
		safe.forEachSeries(_.keys(self._store), function (k, cb) {
			var rec = self._store[k];
			get(rec.pos, safe.sure(cb, function (data) {
				fs.write(fd, data, 0, data.length, wpos, safe.sure(cb, function (written) {
					if (written != data.length) return cb(new Error('Insufficient disk space'));
					store[k] = { pos: wpos, sum: rec.sum };
					wpos += data.length;
					cb();
				}));
			}));
		}, function (err) {
			if (err) {
				fs.close(fd, function () {
					fs.unlink(filename, function () {
						cb(err);
					});
				});
				return;
			}
			if (!!process.platform.match(/^win/)) {
				// WINDOWS: unsafe because if something fail while renaming file it will not
				// restore automatically
				fs.close(self._fd, safe.sure(cb,function() {
					fs.close(fd, safe.sure(cb,function() {
						fs.unlink(self._filename, safe.sure(cb,function () {
							fs.rename(filename, self._filename, safe.sure(cb, function () {
								fs.open(self._filename, 'a+', safe.sure(cb, function (fd) {
									self._fd = fd;
									self._fsize = wpos;
									self._store = store;
									cb();
								}));
							}));
						}));
					}));
				}));
		    } else {
				// safe way
				fs.rename(filename, self._filename, safe.sure(cb, function () {
					fs.close(self._fd);
					self._fd = fd;
					self._fsize = wpos;
					self._store = store;
					cb();
				}));
			}
		});
	}));
};

tcoll.prototype.drop = function (cb) {
	this._tdb.dropCollection(this._name,cb);
};

tcoll.prototype.rename = function (nname, opts, cb) {
	var self = this;
	if (_.isFunction(opts)) {
		cb = opts;
		opts = {};
	}
	var err = self._tdb._nameCheck(nname);
	if (err)
		return safe.back(cb,err);
	if (self._tdb._stype=="mem") {
		delete self._tdb._cols[self._name];
		self._tdb._cols[nname] = self;
		delete self._tdb._mstore[self._name];
		self._tdb._mstore[nname] = self._mstore;
		safe.back(cb,null);
	} else {
		self._tq.add(function (cb) {
			fs.rename(path.join(self._tdb._path,self._name),path.join(self._tdb._path,nname),safe.sure(cb, function () {
				delete self._tdb._cols[self._name];
				self._tdb._cols[nname] = self;
				self.collectionName = self._name = nname;
				cb();
			}));
		},true,cb);
	}
};

tcoll.prototype._stop = function (cb) {
	var self = this;
	self._tq.add(function (cb) {
		// this will prevent any tasks processed on this instance
		self._tq._stoped = true;
		if (self._fd) {
			fs.close(self._fd,safe.sure(cb, function () {
				cb(null,true);
			}));
		} else
			cb(null,false);
	},true,cb);
};

tcoll.prototype.createIndex = tcoll.prototype.ensureIndex = function (obj, options, cb) {
	var self = this;
	if (_.isFunction(options)) {
		cb = options;
		options = {};
	}
	cb = cb || function () {};
	options = options || {};

	var c = new tcursor(this,{},{},{});
	c.sort(obj);
	if (c._err)
		return safe.back(cb,c._err);
	var key = c._sort;

	if (key===null)
		return safe.back(cb,new Error("No fields are specified"));

	var index = self._idx[key];
	if (index)
		return safe.back(cb,null, index.name);

	// force array support when global option is set
	if (_.isUndefined(options._tiarr) && self._tdb._gopts.searchInArray)
		options._tiarr = true;

	var name = options.name || _.map(key, function (v) { return v[0] + '_' + v[1]; }).join('_');
	index = new tindex(key, self, options, name);

	if (self._tq._tc==-1) {
		// if no operation is pending just register index
		self._idx[key] = index;
		safe.back(cb, null, index.name);
	}
	else {
		// overwise register index operation
		this._tq.add(function (cb) {
			var range = _.values(self._store);
			safe.forEachSeries(range, function (rec, cb) {
				self._get(rec.pos, false, safe.sure(cb, function (obj) {
					index.set(obj,simplifyKey(obj._id));
					cb();
				}));
			}, safe.sure(cb, function () {
				self._idx[key] = index;
				cb();
			}));
		}, true, function (err) {
			if (err) cb(err);
			else cb(null, index.name);
		});
	}
};

tcoll.prototype.indexExists = function (idx, cb) {
	if (!_.isArray(idx))
		idx = [idx];
	var i = _.intersection(idx,_(this._idx).values().map('name').value());
	cb(null,i.length == idx.length);
};

tcoll.prototype.indexes = function (cb) {
	var self = this;
	this._tq.add(function (cb) {
		cb(null, _.values(self._idx));
	},false,cb);
};

tcoll.prototype._getM = function (pos, unsafe, cb) {
	safe.back(cb,null,unsafe?this._mstore[pos-1]:this._tdb._cloneDeep(this._mstore[pos-1]));
};

tcoll.prototype._getFS = function (pos, unsafe, cb) {
	var self = this;
	var cached = self._cache.get(pos,unsafe);
	if (cached)
		return safe.back(cb,null,cached);
	var b1 = new Buffer(45);
	fs.read(self._fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {
		var h1 = JSON.parse(data.toString());
		h1.o = parseInt(h1.o,10);
		h1.k = parseInt(h1.k,10);
		var b2 = new Buffer(h1.o);
		fs.read(self._fd,b2,0,h1.o,pos+45+2+h1.k, safe.trap_sure(cb, function (bytes, data) {
			var obj = self._unwrapTypes(JSON.parse(data.toString()));
			if (bytes <= self._cmaxobj)
				self._cache.set(pos, obj);
			cb(null,obj);
		}))
	}))
}

tcoll.prototype.insert = function (docs, opts, cb ) {
	var self = this;
	if (_.isFunction(opts) && cb == null) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	if (opts.w>0 && !_.isFunction(cb))
		throw new Error("Callback is required for safe update");
	cb = cb || function () {};
	if (!_.isArray(docs))
		docs = [docs];
	this._tq.add(function (cb) {
		safe.forEachSeries(docs, function (doc, cb) {
			if (_.isUndefined(doc._id)) {
				doc._id = new self._tdb.ObjectID();
			}
			self._put(doc, false, cb);
		}, safe.sure(cb, function () {
			cb(null, docs);
		}))
	}, true, cb)
}

tcoll.prototype._wrapTypes = function(obj) {
	var self = this;
	_.each(obj, function (v,k) {
		if (_.isDate(v))
			obj[k] = {$wrap:"$date",v:v.valueOf(),h:v}
		else if (v instanceof self._tdb.ObjectID)
			obj[k] = {$wrap:"$oid",v:v.toJSON()}
		else if (v instanceof self._tdb.Binary)
			obj[k] = {$wrap: "$bin", v: v.toJSON()};
		else if (_.isObject(v))
			self._wrapTypes(v)

	})
	return obj;
}

tcoll.prototype._ensureIds = function(obj) {
	var self = this;
	_.each(obj, function (v,k) {
		if (k.length >0) {
			if (k[0]=='$')
				throw new Error("key "+k+" must not start with '$'");;
			if (k.indexOf('.')!=-1)
				throw new Error("key "+k+" must not contain '.'");
		}
		if (_.isObject(v)) {
			if (v instanceof self._tdb.ObjectID) {
				if (v.id<0) {
					v._persist(++self._id)
				}
			}
			else
				self._ensureIds(v)
		}
	})
	return obj;
}


tcoll.prototype._unwrapTypes = function(obj) {
	var self = this;
	_.each(obj, function (v,k) {
		if (_.isObject(v)) {
			switch (v.$wrap) {
				case "$date": obj[k] = new Date(v.v); break;
				case "$oid":
					var oid = new self._tdb.ObjectID(v.v);
					obj[k]=oid;
				break;
				case "$bin":
					var bin = new self._tdb.Binary(new Buffer(v.v, 'base64'));
					obj[k] = bin;
				break;
				default: self._unwrapTypes(v);
			}
		}
	})
	return obj;
}

tcoll.prototype._putM = function (item_, remove, cb) {
	var item = this._tdb._cloneDeep(item_);
	var self = this;
	self._wq.add(function (cb) {
		try {
			item = self._ensureIds(item);
		} catch (err) {
			err.errmsg = err.toString();
			return cb(err)
		}
		if (_.isUndefined(item._id))
			return cb(new Error("Invalid object key (_id)"));

		var key = {_id:simplifyKey(item._id)};

		// check index update
		if (item && !remove) {
			try {
				_.forEach(self._idx,function(v,k) {
					v.set(item,key._id,true);
				})
			} catch (err) {
				err.errmsg = err.toString();
				return cb(err)
			}
		}

		if (remove) {
			self._mstore[self._store[key._id].pos-1]=null;
			delete self._store[key._id];
		}
		else {
			if (self._store[key._id]) {
				self._mstore[self._store[key._id].pos-1] = item;
			} else {
				self._mstore.push(item);
				self._store[key._id] = {pos: self._mstore.length};
			}
		}

		// update index
		_.forEach(self._idx,function(v,k) {
			if (!remove)
				v.set(item,key._id);
			else
				v.del(item,key._id);
		})
		cb(null);
	}, true, cb);
}


tcoll.prototype._putFS = function (item, remove, cb) {
	var self = this;
	self._wq.add(function (cb) {
		try {
			item = self._ensureIds(item);
		} catch (err) {
			err.errmsg = err.toString();
			return cb(err)
		}
		if (_.isUndefined(item._id))
			return cb(new Error("Invalid object key (_id)"));
		item = self._wrapTypes(item);
		var sobj = new Buffer(remove?"":JSON.stringify(item));
		item = self._unwrapTypes(item);
		var key = {_id:simplifyKey(item._id),_uid:self._id,_dt:(new Date()).valueOf()};
		if (remove) key._a = "del";
		else {
			var hash = crypto.createHash('md5');
			hash.update(sobj, 'utf8');
			key._s = hash.digest('hex');
		}
		var skey = new Buffer(JSON.stringify(key));
		var zeros = "0000000000";
		var lobj = sobj.length.toString();
		var lkey = skey.length.toString();
		lobj = zeros.substr(0,zeros.length - lobj.length)+lobj;
		lkey = zeros.substr(0,zeros.length - lkey.length)+lkey;
		var h1={k:lkey,o:lobj,v:"001"};
		var buf = new Buffer(JSON.stringify(h1)+"\n"+skey+"\n"+sobj+"\n");

		// check index update
		if (item && !remove) {
			try {
				_.forEach(self._idx,function(v,k) {
					v.set(item,key._id,true);
				})
			} catch (err) {
				err.errmsg = err.toString();
				return cb(err)
			}
		}

		safe.run(function (cb) {
			var rec = self._store[key._id];
			if (rec && rec.sum == key._s) return safe.back(cb);
			fs.write(self._fd, buf, 0, buf.length, self._fsize, safe.sure(cb, function (written) {
				if (remove)
					delete self._store[key._id];
				else
					self._store[key._id] = { pos: self._fsize, sum: key._s };

				if (remove || sobj.length > self._cmaxobj)
					self._cache.unset(self._fsize)
				else
					self._cache.set(self._fsize,item);
				self._fsize+=written;
				// randomly check for non exclusive file usage
				// which is growth of file that we are nor aware
				// randomly to avoid overhead
				if (self._check1==0) {
					this._check1 = Math.random()*100+1;
					fs.fstat(self._fd, safe.sure(cb, function (stat) {
						if (self._fsize!=stat.size)
							cb(new Error("File size mismatch. Are you use db/collection exclusively?"))
						else
							cb()
					}))
				} else {
					self._check1--;
					cb();
				}
			}));
		},
		function () {
			// update index
			_.forEach(self._idx,function(v,k) {
				if (!remove)
					v.set(item,key._id);
				else
					v.del(item,key._id);
			})
			cb(null);
		});
	}, true, cb);
}

tcoll.prototype.count = function (query, options, cb) {
	var self = this;
	if (arguments.length == 1) {
		cb = arguments[0];
        options = null;
		query = null;
	}
	if (arguments.length == 2) {
        query = arguments[0];
		cb = arguments[1];
        options = null;
	}
	if (query==null || _.size(query)==0) {
		this._tq.add(function (cb) {
			cb(null, _.size(self._store));
		},false,cb);
	} else
		self.find(query, options).count(cb);
}

tcoll.prototype.stats = function (cb) {
	var self = this;
	this._tq.add(function (cb) {
		cb(null, {count:_.size(self._store)});
	},false,cb);
}


var findOpts = ['limit','sort','fields','skip','hint','timeout','batchSize','safe','w'];

tcoll.prototype.findOne = function () {
	var findArgs = Array.prototype.slice.call(arguments,0,arguments.length-1);
	var cb = arguments[arguments.length-1];
	this.find.apply(this,findArgs).limit(1).nextObject(cb);
}

tcoll.prototype.find = function () {
	var cb = null, query = {}, opts = {}, fields = null, skip = null, limit = null, sort = null;
	var argc = arguments.length;
	if (argc>0) {
		// guess callback, it is always latest
		cb = arguments[argc-1];
		if (!_.isFunction(cb))
			cb=null
		else
			argc--;
		if (argc>0) {
			// query should always exist
			query = arguments[0]
			if (argc>1) {
				if (argc==2) {
					var val = arguments[1];
					// worst case we get either options either fiels
					if (_.intersection(_.keys(val),findOpts).length!=0)
						opts = val
					else
						fields = val;
				} else {
					fields = arguments[1];
					if (argc == 3)
						opts = arguments[2]
					else {
						skip = arguments[2];
						limit = arguments[3]
					}
				}
			}
		}
	}

	opts = opts || {};
	skip = skip || opts.skip || null;
	limit = limit || opts.limit || null;
	fields = fields || opts.fields || null;
	sort = sort || opts.sort || null;


	var c = new tcursor(this,query, fields, opts);

	if (skip) c.skip(skip);
	if (limit) c.limit(limit);
	if (sort) c.sort(sort);
	if (cb)
		cb(null, c)
	else
		return c;
}


function simplifyKey(key) {
	var k = key;
	if (key.toJSON)
		k = key.toJSON();
	if (_.isNumber(k)||_.isString(k))
		return k;
	return k.toString();
}

tcoll.prototype.update = function (query, doc, opts, cb) {
	var self = this;
	if (_.isFunction(opts) && cb == null) {
		cb = opts;
	}
	opts = opts || {};
	if (opts.w>0 && !_.isFunction(cb))
		throw new Error("Callback is required for safe update");
	cb = cb || function () {}
	if (!_.isObject(query))
		throw new Error("selector must be a valid JavaScript object");
	if (!_.isObject(doc))
		throw new Error("document must be a valid JavaScript object");

	var multi = opts.multi || false;
    var updater = new Updater(doc, self._tdb);
	var $doc = updater.hasAtomic()?null:doc;
	this._tq.add(function (cb) {
		self.__find(query, null, 0, multi ? null : 1, null, opts.hint, {}, safe.sure(cb, function (res) {
			if (res.length==0) {
				if (opts.upsert) {
					$doc = $doc || query;
					$doc = self._tdb._cloneDeep($doc);
					updater.update($doc,true);
					if (_.isUndefined($doc._id))
						$doc._id = new self._tdb.ObjectID();
					self._put($doc, false, safe.sure(cb, function () {
						cb(null, 1,{updatedExisting:false,upserted:$doc._id,n:1})
					}))
				} else
					cb(null,0);
			} else {
				safe.forEachSeries(res, function (pos, cb) {
					self._get(pos, false, safe.sure(cb, function (obj) {
						// remove current version of doc from indexes
						_.forEach(self._idx,function(v,k) {
							v.del(obj,simplifyKey(obj._id));
						})
						var udoc = $doc;
						if (!$doc) {
							udoc = obj;
							updater.update(udoc);
						}
						udoc._id = obj._id;
						// put will add it back to indexes
						self._put(udoc, false, cb);
					}))
				}, safe.sure(cb,function () {
					cb(null, res.length, {updatedExisting:true,n:res.length});
				}))
			}
		}))
	},true,cb);
}

tcoll.prototype.findAndModify = function (query, sort, doc, opts, cb) {
	var self = this;
	if (_.isFunction(opts) && cb == null) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	doc = doc || {};

	var updater = new Updater(doc, self._tdb);
	var $doc = updater.hasAtomic()?null:doc;

	var c = new tcursor(this,{}, opts.fields || {},{});
	c.sort(sort);
	if (c._err)
		return safe.back(cb,c._err);

	this._tq.add(function (cb) {
		self.__find(query, null, 0, 1, c._sort, opts.hint, {}, safe.sure(cb, function (res) {
			if (res.length==0) {
				if (opts.upsert) {
					$doc = $doc || query;
					$doc = self._tdb._cloneDeep($doc);
					updater.update($doc,true);
					if (_.isUndefined($doc._id))
						$doc._id = new self._tdb.ObjectID();
					self._put($doc, false, safe.sure(cb, function () {
						cb(null,opts.new?c._projectFields($doc):{})
					}))
				} else
					cb();
			} else {
				self._get(res[0], false, safe.sure(cb, function (obj) {
					var robj = (opts.new && !opts.remove) ? obj : self._tdb._cloneDeep(obj);
					// remove current version of doc from indexes
					_.forEach(self._idx,function(v,k) {
						v.del(obj,simplifyKey(obj._id));
					})
					var udoc = $doc;
					if (!$doc) {
						udoc = obj;
						updater.update(udoc);
					}
					udoc._id = obj._id;
					// put will add it back to indexes
					self._put(udoc, opts.remove?true:false, safe.sure(cb,function () {
						cb(null,c._projectFields(robj))
					}))
				}))
			}
		}))
	},true,cb);
}

tcoll.prototype.save = function (doc, opts, cb) {
	var self = this;
	cb = _.isFunction(doc)?doc:_.isFunction(opts)?opts:cb;
	cb = cb || function () {};
	doc = doc || {};
	opts = opts || {};
	this._tq.add(function (cb) {
		var res = doc;
		(function(cb) {
			if (_.isUndefined(doc._id)) {
				doc._id = new self._tdb.ObjectID();
				cb()
			} else {
				var id = simplifyKey(doc._id);
				var pos = self._store[id];
				// check if document with this id already exist
				if (pos) {
					// if so we need to fetch it to update index
					self._get(pos.pos, false, safe.sure(cb, function (oldDoc) {
						// remove current version of doc from indexes
						_.forEach(self._idx,function(v,k) {
							v.del(oldDoc,id);
						})
						res = 1;
						cb();
					}))
				} else cb();
			}
		})(safe.sure(cb, function () {
			self._put(doc, false, safe.sure(cb, function () {
				cb(null,res); // when update return 1 when new save return obj
			}))
		}))
	},true,cb);
}

tcoll.prototype.remove = function (query, opts, cb) {
	var self = this;
	if (_.isFunction(query)) {
		cb = query;
		query = opts = {};
	} else if (_.isFunction(opts)) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	if (opts.w>0 && !_.isFunction(cb))
		throw new Error("Callback is required");
	cb = cb || function () {};
	var single = opts.single || false;
	this._tq.add(function (cb) {
		self.__find(query, null, 0, single ? 1 : null, null, opts.hint, {}, safe.sure(cb, function (res) {
			safe.forEachSeries(res, function (pos, cb) {
				self._get(pos, false, safe.sure(cb, function (obj) {
					self._put(obj,true,cb);
				}))
			}, safe.sure(cb, function () {
				cb(null,res.length);
			}))
		}))
	},true,cb);
}

tcoll.prototype.findAndRemove = function (query,sort,opts,cb) {
	var self = this;

	if (_.isFunction(sort) && cb == null && opts==null) {
		cb = sort;
		sort = {}
		opts = {};
	} else if (_.isFunction(opts) && cb == null) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	sort = sort || {};

	var c = new tcursor(this,{},{},{});

	// Fix for mongoouse/tungus they pass sort as undefined
	c.sort(sort);

	if (c._err)
		return safe.back(cb,c._err);

	this._tq.add(function (cb) {
		self.__find(query, null, 0, 1, c._sort, opts.hint, {}, safe.sure(cb, function (res) {
			if (res.length==0)
				return cb();
			self._get(res[0], false, safe.sure(cb, function (obj) {
				self._put(obj,true,safe.sure(cb, function () {
					cb(null,obj);
				}))
			}))
		}))
	},true,cb);
}

tcoll.prototype._bestSortIndex = function (sort) {
	// no sort
	if (!sort) return null;
	// exact match
	if (this._idx[sort]) return this._idx[sort];
	// find potential sort indexes
	var pi = [];
	_.forEach(this._idx,function (idx) {
		var fields = idx.fields();
		var match = _.takeWhile(fields, function (kv, i) {
			return i < sort.length ? kv[0] == sort[i][0] : false;
		});
		if (match.length == sort.length) {
			var score = fields.length;
			_.forEach(sort,function (kv, i) {
				if (kv[1] != fields[i][1]) score += 1;
			});
			pi.push({ value: idx, score: score });
		}
	});
	if (pi.length === 0) return null;
	// select best index
	pi = pi.sort(function (l, r) { return l.score < r.score; });
	return pi[0].value;
};

function reduceIndexSet(pi) {
	var hit;
	do {
		hit = false;
		// compare each potential index with each other
		_.forEach(pi,function (v1, i1) {
			_.forEach(pi,function (v2, i2) {
				if (i1 == i2) return;
				// compare the set of possible keys for both indexes
				if (_.union(v1.k, v2.k).length == v1.k.length) {
					// key for v2 is a subset of key for v1, check equality
					if (v1.k.length == v2.k.length && v1.i.depth() > v2.i.depth()) {
						// keys are equal, but the depth of v2 is lower;
						// v2 is preferable, strike out v1
						pi.splice(i1, 1);
					} else {
						// in other two cases v1 is preferable, strike out v2
						pi.splice(i2, 1);
					}
					hit = true;
					return false;
				}
			});
			if (hit) return false;
		});
	} while (hit);
};

tcoll.prototype.__find = function (query, fields, skip, limit, sort, hint, arFields, cb) {
	var self = this;
	var range = [];
	// find sort index
	var si = this._bestSortIndex(sort);
	// for non empty query check indexes that we can use
	var qt = self._tdb.Finder.matcher(query);
	var pi = [];
	if (_.size(qt)>0) {
		_.forEach(self._idx,function (i) {
			var f = _.pluck(i.fields(), 0);
			var e = _.takeWhile(f, function (k) {
				return qt._ex(k) == 1 && (!hint || hint[k]);
			});
			if (e.length > 0) pi.push({ i: i, k: e, e: f.length > e.length });
		});
	}

	// if possible indexes found split the query and process
	// indexes separately
	if (!_.isEmpty(pi)) {
		// choose the most appropriate indexes
		reduceIndexSet(pi);
		// split query
		var io = {};
		_.forEach(pi,function (v) {
			_.forEach(v.k,function (k) {
				if (!io[k]) io[k] = qt.split(k);
			});
		});
		// process indexes
		var p = [];
		_.forEach(pi,function (st) {
			// this action applies to all indexes
			var r = io[st.k[0]]._index(st.i);
			// process subfields of compound index
			_.forEach(st.k.slice(1),function (k) {
				var v = io[k];
				r = _.flatten(_.map(r, function (si) { return v._index(si); }));
			});
			// expand subindexes to plain ids
			if (st.e) r = _.flatten(_.map(r, function (si) { return si.all(); }));
			// store result of index search
			p.push(r);
		});
		if (p.length == 1) {
			p = p[0];
			// optimization for the case when search and sorting indexes are the same
			if (si && pi[0].i === si) {
				var sif = si.fields();
				if (_.every(sort, function (v, i) { return sif[i][1] == v[1]; })) {
					// sort order exactly matches index order,
					// so the result is already sorted
					sort = null;
				} else if (_.every(sort, function (v, i) { return sif[i][1] == -v[1]; })) {
					// sort order is exactly opposite to index order,
					// so the result is sorted, but in reverse direction
					p.reverse();
					sort = null;
				}
			}
		} else {
			// TODO: use sort index as intersect base to speedup sorting
			p = tutils.intersectIndexes(p);
		}
		// nowe we have ids, need to convert them to positions
		_.forEach(p,function (_id) {
			range.push(self._store[_id].pos)
		})
	} else {
		if (si) {
			_.each(si.all(_.pluck(sort, 1)), function (_id) {
				range.push(self._store[_id].pos)
			})
			//if (order==-1)
			//	range.reverse();
			sort = null;
		} else
			range = _.values(self._store).map(function (rec) { return rec.pos; });
	}

	if (sort && si) {
		var ps = {};
		_.each(range,function (pos) {
			ps[pos] = true;
		});
		range = [];
		_.each(si.all(_.pluck(sort, 1)),function (_id) {
			var pos = self._store[_id].pos;
			if (_.has(ps,pos)) range.push(pos);
		});
		//if (order == -1)
		//	range.reverse();
		sort = null;
	}

	// no sort, no query then return right away
	if (sort==null && (_.size(qt)==0 || qt._args.length==0)) {
		if (skip!=0 || limit!=null) {
			var c = Math.min(range.length-skip,limit?limit:range.length-skip);
			range = range.splice(skip,c)
		}
		return safe.back(cb,null,range);
	}

	var matcher = null;
	// check if we can use simple match or array match function
	var arrayMatch = false;
	if (self._tdb._gopts.searchInArray)
		arrayMatch = true;
	else {
		var fields = qt.fields();
		_.each(fields, function (v,k) {
			if (arFields[k])
				arrayMatch = true;
		})
	}

	eval("matcher = function (obj) { return "+ (arrayMatch?qt.native3():qt.native()) + " }");

	// create sort index
	if (sort) {
		si = new tindex(sort,self);
	}

	// now simple non-index search
	var res = [];
	var found = 0;
	safe.forEachSeries(range, function (pos, cb) {
		if (sort==null && limit && res.length>=limit)
			return safe.back(cb);
		self._get(pos, true, safe.sure(cb, function (obj) {
			if (matcher(obj)) {
				if (sort!=null || found>=skip) {
					if (sort==null)
						res.push(pos);
					else
						si.set(obj,pos);
				}
				found++;
			}
			cb()
		}))
	}, safe.sure(cb, function () {
		if (sort) {
			res = si.all();
			//if (order==-1) {
			//	res.reverse();
			//}
			if (skip!=0 || limit!=null) {
				var c = Math.min(res.length-skip,limit?limit:res.length-skip);
				res = res.splice(skip,c)
			}
		}
		cb(null, res);
	}))
}

tcoll.prototype._find = function (query, fields, skip, limit, sort_, hint, arFields, cb) {
	var self = this;
	this._tq.add(function (cb) {
		self.__find(query, fields, skip, limit, sort_, hint, arFields, cb);
	}, false, cb);
}

function code2fn(obj) {
	if (_.isObject(obj)) {
		_.each(obj,function (value, key) {
			if (value instanceof Code) {
				with (value.scope) {
					obj[key] = eval('(' + value.code + ')');
				}
			}
			else code2fn(value);
		});
	}
}

tcoll.prototype.mapReduce = function (map, reduce, opts, cb) {
	var self = this;
	if (_.isFunction(opts)) {
		cb = opts;
		opts = {};
	}

	if (!opts.out) return safe.back(cb, new Error('the out option parameter must be defined'));
	if (!opts.out.inline && !opts.out.replace) {
		return safe.back(cb, new Error('the only supported out options are inline and replace'));
	}

	code2fn(opts.scope);

	var m = {};

	function emit(k, v) {
		var values = m[k];
		if (!values) m[k] = [ v ];
		else {
			values.push(v);
			if (values.length > 1000) values = [ reduce(k, values) ];
		}
	}

	with (opts.scope || {}) {
		try {
			if (map instanceof Code) {
				with (map.scope) {
					map = eval('(' + map.code + ')');
				}
			} else map = eval('(' + map + ')');
			if (reduce instanceof Code) {
				with (reduce.scope) {
					reduce = eval('(' + reduce.code + ')');
				}
			} else reduce = eval('(' + reduce + ')');
			if (finalize instanceof Code) {
				with (finalize.scope) {
					finalize = eval('(' + finalize.code + ')');
				}
			} else var finalize = eval('(' + opts.finalize + ')');
		} catch (e) {
			return safe.back(cb,e);
		}
	}

	self.find(opts.query, null, { limit: opts.limit, sort: opts.sort }, safe.sure(cb, function (c) {
		var doc;
		safe.doUntil(
			function (cb) {
				c.nextObject(safe.trap_sure(cb, function (_doc) {
					doc = _doc;
					if (doc) map.call(doc);
					return cb();
				}));
			},
			function () {
				return doc === null;
			},
			safe.trap_sure(cb, function () {
				_.each(m,function (v, k) {
					v = v.length > 1 ? reduce(k, v) : v[0];
					if (finalize) v = finalize(k, v);
					m[k] = v;
				});

				var stats = {};
				if (opts.out.inline) return process.nextTick(function () {
					cb(null, _.values(m), stats); // execute outside of trap
				});

				// write results to collection
				safe.waterfall([
					function (cb) {
						self._tdb.collection(opts.out.replace, { strict: 1 }, function (err, col) {
							if (err) return cb(null, null);
							col.drop(cb);
						});
					},
					function (arg, cb) {
						self._tdb.collection(opts.out.replace, {}, cb);
					},
					function (col, cb) {
						var docs = [];
						_.each(m,function (value, key) {
							var doc = {
								_id: key,
								value: value
							};
							docs.push(doc);
						});
						col.insert(docs, safe.sure(cb, function () {
							if (opts.verbose) cb(null, col, stats);
							else cb(null, col);
						}));
					}
				], cb);
			}
		)); // doUntil
	}));
};

tcoll.prototype.group = function (keys, condition, initial, reduce, finalize, command, options, callback) {
	var self = this;

	var args = Array.prototype.slice.call(arguments, 3);
	callback = args.pop();
	reduce = args.length ? args.shift() : null;
	finalize = args.length ? args.shift() : null;
	command = args.length ? args.shift() : null;
	options = args.length ? args.shift() : {};

	if (!_.isFunction(finalize)) {
		command = finalize;
		finalize = null;
	}

	code2fn(options.scope);

	with (options.scope || {}) {
		try {
			if (_.isFunction(keys)) keys = eval('(' + keys + ')');
			else if (keys instanceof Code) {
				with (keys.scope) {
					keys = eval('(' + keys.code + ')');
				}
			}
			if (reduce instanceof Code) {
				with (reduce.scope) {
					reduce = eval('(' + reduce.code + ')');
				}
			} else reduce = eval('(' + reduce + ')');
			if (finalize instanceof Code) {
				with (finalize.scope) {
					finalize = eval('(' + finalize.code + ')');
				}
			} else finalize = eval('(' + finalize + ')');
		} catch (e) {
			return callback(e);
		}
	}

	var m = {};
	self.find(condition, safe.sure(callback, function (c) {
		var doc;
		safe.doUntil(
			function (cb) {
				c.nextObject(safe.sure(cb, function (_doc) {
					doc = _doc;
					if (!doc) return cb();
					var keys2 = keys;
					if (_.isFunction(keys)) keys2 = keys(doc);
					if (!_.isArray(keys2)) {
						var keys3 = [];
						_.each(keys2,function (v, k) {
							if (v) keys3.push(k);
						});
						keys2 = keys3;
					}
					var key = {};
					_.each(keys2,function (k) {
						key[k] = doc[k];
					});
					var skey = JSON.stringify(key);
					var obj = m[skey];
					if (!obj) obj = m[skey] = _.extend({}, key, initial);
					try {
						reduce(doc, obj);
					} catch (e) {
						return cb(e);
					}
					cb();
				}));
			},
			function () {
				return doc === null;
			},
			safe.sure(callback, function () {
				var result = _.values(m);
				if (finalize) {
					_.each(result,function (value) {
						finalize(value);
					});
				}
				callback(null, result);
			})
		);
	}));
};
 at SyntaxError: 'with' in strict mode (1134:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$1.parseWithStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:932:27)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:708:32)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseBlock (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:981:25)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:709:33)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseIfStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:824:28)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:698:30)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":0,"ExpansionArg_type_2":1,"_bound":3}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":1,"ExpansionArg_type_2":0,"_bound":2} start 28.5346 took 19.267s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":1,"ExpansionArg_type_2":0,"_bound":2}
* Error: Tropigate failed because SyntaxError: 'with' in strict mode (1134:4) on program var safe = require('safe');
var _ = require('lodash');
var crypto = require('crypto');
var fs = require('fs');
var path = require('path');
var tcursor = require('./tcursor');
var wqueue = require('./wqueue');
var tindex = require('./tindex');
var tcache = require("./tcache");
var Code = require('./tcode').Code;
var tutils = require('./utils');
var Updater = require('./updater');

function tcoll(tdb) {
	var self = this;
	this._tdb = null;
	this._name = null;
	this._store = {};
	this._fd = null;
	this._fsize = null;
	this._id = 1;
	this._wq = new wqueue();
	this._tq = null;
	this._idx = {};
	this._cache = null;
	this._mc = {};
	this._check1 = Math.random()*100+1;
	// native mongo db compatibility attrs
	this.collectionName = null;
	if (tdb._stype=="mem") {
		this.init = this.initM;
		this._put = this._putM;
		this._get = this._getM;
	} else {
		this.init = this.initFS;
		this._put = this._putFS;
		this._get = this._getFS;
	}
}

module.exports = tcoll;

tcoll.prototype.initM = function (tdb, name, options, create, cb) {
	var self= this;
	this._tdb = tdb;
	tdb._mstore = tdb._mstore || {};
	this.collectionName = this._name = name;
	if (options.strict) {
		var exists = tdb._mstore[name];
		if (exists && create) return cb(new Error("Collection " + self._name + " already exists. Currently in safe mode."));
		else if (!exists && !create) return cb(new Error("Collection " + self._name + " does not exist. Currently in safe mode."));
	}
	tdb._mstore[name] = this._mstore = tdb._mstore[name] || [];
	for (var k=0; k< this._mstore.length; k++) {
		var o = this._mstore[k];
		if (o) {
			self._store[simplifyKey(o._id)]={pos:k+1};
		}
	}
	this._tq = new wqueue(100, function (cb) {
		// update indexes
		safe.forEachSeries(_.values(self._store), function (rec, cb) {
			self._get(rec.pos, false, safe.sure(cb, function (obj) {
				var id = simplifyKey(obj._id);
				_.forEach(self._idx,function(v, k) {
					v.set(obj, id);
				});
				cb();
			}));
		}, cb);
	});
	self.ensureIndex({_id: 1}, {name: '_id_', unique: true}, cb);
};

tcoll.prototype.initFS = function (tdb, name, options, create, cb) {
	var self= this;
	this._tdb = tdb;
	this._cache = new tcache(tdb, tdb._gopts.cacheSize);
	this._cmaxobj = tdb._gopts.cacheMaxObjSize || 1024;
	this.collectionName = this._name = name;
	this._filename = path.join(this._tdb._path, this._name);
	if (options.strict) {
		var exists = fs.existsSync(self._filename);
		if (exists && create) return cb(new Error("Collection " + self._name + " already exists. Currently in safe mode."));
		else if (!exists && !create) return cb(new Error("Collection " + self._name + " does not exist. Currently in safe mode."));
	}
	var pos = 0;
	var deleted = 0;
	var found = 0;
	this._tq = new wqueue(100, function (cb) {
		(function (cb) {
			fs.open(self._filename, "a+", safe.sure(cb, function (fd) {
			self._fd = fd;
			var b1 = new Buffer(45);
			safe.whilst(function () { return self._fsize===null; }, function(cb) {
				(function (cb) {
					fs.read(fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {
						if (bytes===0) {
							self._fsize = pos;
							return cb();
						}
						var h1 = JSON.parse(data.toString());
						h1.o = parseInt(h1.o,10);
						h1.k = parseInt(h1.k,10);
						var b2 = new Buffer(h1.k);
						fs.read(fd,b2,0,h1.k,pos+45+1, safe.sure(cb, function (bytes, data) {
							var k = JSON.parse(data.toString());
							self._id = k._uid;
							if (k._a=='del') {
								delete self._store[k._id];
								deleted++;
							} else {
								if (self._store[k._id]) deleted++;
								self._store[k._id] = { pos: pos, sum: k._s };
							}
							pos+=45+3+h1.o+h1.k;
							found++;
							cb();
						}));
					}));
				})(function (err) {
					if (err)
						cb(new Error(self._name+": Error during load - "+err.toString()));
					else
						cb();
				});
			}, cb);
			}));
		})(function (err) {
			if (!found && err)
				return cb(err); // nothing read and error, just rise it
			safe.run(function (cb) {
				var size = _.size(self._store);
				// autocompact on certain ratio or err
				if (deleted > size || err) {
					self._compact(function (errCompact) {
						if (errCompact && err)
							cb(errCompact);
						else {
							if (errCompact) console.log(err);
							cb();
						}
					});
				} else cb();
			}, function () {
				self._refreshIndexes(cb);
			});
		});
	});
	self.ensureIndex({_id: 1}, {name: '_id_', unique: true}, cb);
};

tcoll.prototype.compactCollection = function (cb) {
	var self = this;
	self._tq.add(function (cb) {
		self._compact(safe.sure(cb, function () {
			self._cache.clear();
			self._refreshIndexes(cb);
		}));
	}, true, cb);
};

tcoll.prototype._refreshIndexes = function (cb) {
	var self = this;
	_.forEach(self._idx,function(v, k) {
		v.clear();
	});
	safe.forEachSeries(_.values(self._store), function (rec, cb) {
		self._get(rec.pos, false, safe.sure(cb, function (obj) {
			var id = simplifyKey(obj._id);
			_.forEach(self._idx,function(v, k) {
				v.set(obj, id);
			});
			cb();
		}));
	}, cb);
};

tcoll.prototype._compact = function (cb) {
	var self = this;
	var filename = self._filename + '.compact';
	fs.open(filename, 'w+', safe.sure(cb, function (fd) {
		var b1 = new Buffer(45);
		function get(pos, cb) {
			fs.read(self._fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {
				var h1 = JSON.parse(data.toString());
				h1.o = parseInt(h1.o, 10);
				h1.k = parseInt(h1.k, 10);
				var b2 = new Buffer(h1.k + h1.o + 3);
				fs.read(self._fd, b2, 0, b2.length, pos + 45, safe.sure(cb, function (bytes, data) {
					cb(null, Buffer.concat([ b1, b2 ]));
				}));
			}));
		}
		var wpos = 0;
		var store = {};
		safe.forEachSeries(_.keys(self._store), function (k, cb) {
			var rec = self._store[k];
			get(rec.pos, safe.sure(cb, function (data) {
				fs.write(fd, data, 0, data.length, wpos, safe.sure(cb, function (written) {
					if (written != data.length) return cb(new Error('Insufficient disk space'));
					store[k] = { pos: wpos, sum: rec.sum };
					wpos += data.length;
					cb();
				}));
			}));
		}, function (err) {
			if (err) {
				fs.close(fd, function () {
					fs.unlink(filename, function () {
						cb(err);
					});
				});
				return;
			}
			if (!!process.platform.match(/^win/)) {
				// WINDOWS: unsafe because if something fail while renaming file it will not
				// restore automatically
				fs.close(self._fd, safe.sure(cb,function() {
					fs.close(fd, safe.sure(cb,function() {
						fs.unlink(self._filename, safe.sure(cb,function () {
							fs.rename(filename, self._filename, safe.sure(cb, function () {
								fs.open(self._filename, 'a+', safe.sure(cb, function (fd) {
									self._fd = fd;
									self._fsize = wpos;
									self._store = store;
									cb();
								}));
							}));
						}));
					}));
				}));
		    } else {
				// safe way
				fs.rename(filename, self._filename, safe.sure(cb, function () {
					fs.close(self._fd);
					self._fd = fd;
					self._fsize = wpos;
					self._store = store;
					cb();
				}));
			}
		});
	}));
};

tcoll.prototype.drop = function (cb) {
	this._tdb.dropCollection(this._name,cb);
};

tcoll.prototype.rename = function (nname, opts, cb) {
	var self = this;
	if (_.isFunction(opts)) {
		cb = opts;
		opts = {};
	}
	var err = self._tdb._nameCheck(nname);
	if (err)
		return safe.back(cb,err);
	if (self._tdb._stype=="mem") {
		delete self._tdb._cols[self._name];
		self._tdb._cols[nname] = self;
		delete self._tdb._mstore[self._name];
		self._tdb._mstore[nname] = self._mstore;
		safe.back(cb,null);
	} else {
		self._tq.add(function (cb) {
			fs.rename(path.join(self._tdb._path,self._name),path.join(self._tdb._path,nname),safe.sure(cb, function () {
				delete self._tdb._cols[self._name];
				self._tdb._cols[nname] = self;
				self.collectionName = self._name = nname;
				cb();
			}));
		},true,cb);
	}
};

tcoll.prototype._stop = function (cb) {
	var self = this;
	self._tq.add(function (cb) {
		// this will prevent any tasks processed on this instance
		self._tq._stoped = true;
		if (self._fd) {
			fs.close(self._fd,safe.sure(cb, function () {
				cb(null,true);
			}));
		} else
			cb(null,false);
	},true,cb);
};

tcoll.prototype.createIndex = tcoll.prototype.ensureIndex = function (obj, options, cb) {
	var self = this;
	if (_.isFunction(options)) {
		cb = options;
		options = {};
	}
	cb = cb || function () {};
	options = options || {};

	var c = new tcursor(this,{},{},{});
	c.sort(obj);
	if (c._err)
		return safe.back(cb,c._err);
	var key = c._sort;

	if (key===null)
		return safe.back(cb,new Error("No fields are specified"));

	var index = self._idx[key];
	if (index)
		return safe.back(cb,null, index.name);

	// force array support when global option is set
	if (_.isUndefined(options._tiarr) && self._tdb._gopts.searchInArray)
		options._tiarr = true;

	var name = options.name || _.map(key, function (v) { return v[0] + '_' + v[1]; }).join('_');
	index = new tindex(key, self, options, name);

	if (self._tq._tc==-1) {
		// if no operation is pending just register index
		self._idx[key] = index;
		safe.back(cb, null, index.name);
	}
	else {
		// overwise register index operation
		this._tq.add(function (cb) {
			var range = _.values(self._store);
			safe.forEachSeries(range, function (rec, cb) {
				self._get(rec.pos, false, safe.sure(cb, function (obj) {
					index.set(obj,simplifyKey(obj._id));
					cb();
				}));
			}, safe.sure(cb, function () {
				self._idx[key] = index;
				cb();
			}));
		}, true, function (err) {
			if (err) cb(err);
			else cb(null, index.name);
		});
	}
};

tcoll.prototype.indexExists = function (idx, cb) {
	if (!_.isArray(idx))
		idx = [idx];
	var i = _.intersection(idx,_(this._idx).values().map('name').value());
	cb(null,i.length == idx.length);
};

tcoll.prototype.indexes = function (cb) {
	var self = this;
	this._tq.add(function (cb) {
		cb(null, _.values(self._idx));
	},false,cb);
};

tcoll.prototype._getM = function (pos, unsafe, cb) {
	safe.back(cb,null,unsafe?this._mstore[pos-1]:this._tdb._cloneDeep(this._mstore[pos-1]));
};

tcoll.prototype._getFS = function (pos, unsafe, cb) {
	var self = this;
	var cached = self._cache.get(pos,unsafe);
	if (cached)
		return safe.back(cb,null,cached);
	var b1 = new Buffer(45);
	fs.read(self._fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {
		var h1 = JSON.parse(data.toString());
		h1.o = parseInt(h1.o,10);
		h1.k = parseInt(h1.k,10);
		var b2 = new Buffer(h1.o);
		fs.read(self._fd,b2,0,h1.o,pos+45+2+h1.k, safe.trap_sure(cb, function (bytes, data) {
			var obj = self._unwrapTypes(JSON.parse(data.toString()));
			if (bytes <= self._cmaxobj)
				self._cache.set(pos, obj);
			cb(null,obj);
		}))
	}))
}

tcoll.prototype.insert = function (docs, opts, cb ) {
	var self = this;
	if (_.isFunction(opts) && cb == null) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	if (opts.w>0 && !_.isFunction(cb))
		throw new Error("Callback is required for safe update");
	cb = cb || function () {};
	if (!_.isArray(docs))
		docs = [docs];
	this._tq.add(function (cb) {
		safe.forEachSeries(docs, function (doc, cb) {
			if (_.isUndefined(doc._id)) {
				doc._id = new self._tdb.ObjectID();
			}
			self._put(doc, false, cb);
		}, safe.sure(cb, function () {
			cb(null, docs);
		}))
	}, true, cb)
}

tcoll.prototype._wrapTypes = function(obj) {
	var self = this;
	_.each(obj, function (v,k) {
		if (_.isDate(v))
			obj[k] = {$wrap:"$date",v:v.valueOf(),h:v}
		else if (v instanceof self._tdb.ObjectID)
			obj[k] = {$wrap:"$oid",v:v.toJSON()}
		else if (v instanceof self._tdb.Binary)
			obj[k] = {$wrap: "$bin", v: v.toJSON()};
		else if (_.isObject(v))
			self._wrapTypes(v)

	})
	return obj;
}

tcoll.prototype._ensureIds = function(obj) {
	var self = this;
	_.each(obj, function (v,k) {
		if (k.length >0) {
			if (k[0]=='$')
				throw new Error("key "+k+" must not start with '$'");;
			if (k.indexOf('.')!=-1)
				throw new Error("key "+k+" must not contain '.'");
		}
		if (_.isObject(v)) {
			if (v instanceof self._tdb.ObjectID) {
				if (v.id<0) {
					v._persist(++self._id)
				}
			}
			else
				self._ensureIds(v)
		}
	})
	return obj;
}


tcoll.prototype._unwrapTypes = function(obj) {
	var self = this;
	_.each(obj, function (v,k) {
		if (_.isObject(v)) {
			switch (v.$wrap) {
				case "$date": obj[k] = new Date(v.v); break;
				case "$oid":
					var oid = new self._tdb.ObjectID(v.v);
					obj[k]=oid;
				break;
				case "$bin":
					var bin = new self._tdb.Binary(new Buffer(v.v, 'base64'));
					obj[k] = bin;
				break;
				default: self._unwrapTypes(v);
			}
		}
	})
	return obj;
}

tcoll.prototype._putM = function (item_, remove, cb) {
	var item = this._tdb._cloneDeep(item_);
	var self = this;
	self._wq.add(function (cb) {
		try {
			item = self._ensureIds(item);
		} catch (err) {
			err.errmsg = err.toString();
			return cb(err)
		}
		if (_.isUndefined(item._id))
			return cb(new Error("Invalid object key (_id)"));

		var key = {_id:simplifyKey(item._id)};

		// check index update
		if (item && !remove) {
			try {
				_.forEach(self._idx,function(v,k) {
					v.set(item,key._id,true);
				})
			} catch (err) {
				err.errmsg = err.toString();
				return cb(err)
			}
		}

		if (remove) {
			self._mstore[self._store[key._id].pos-1]=null;
			delete self._store[key._id];
		}
		else {
			if (self._store[key._id]) {
				self._mstore[self._store[key._id].pos-1] = item;
			} else {
				self._mstore.push(item);
				self._store[key._id] = {pos: self._mstore.length};
			}
		}

		// update index
		_.forEach(self._idx,function(v,k) {
			if (!remove)
				v.set(item,key._id);
			else
				v.del(item,key._id);
		})
		cb(null);
	}, true, cb);
}


tcoll.prototype._putFS = function (item, remove, cb) {
	var self = this;
	self._wq.add(function (cb) {
		try {
			item = self._ensureIds(item);
		} catch (err) {
			err.errmsg = err.toString();
			return cb(err)
		}
		if (_.isUndefined(item._id))
			return cb(new Error("Invalid object key (_id)"));
		item = self._wrapTypes(item);
		var sobj = new Buffer(remove?"":JSON.stringify(item));
		item = self._unwrapTypes(item);
		var key = {_id:simplifyKey(item._id),_uid:self._id,_dt:(new Date()).valueOf()};
		if (remove) key._a = "del";
		else {
			var hash = crypto.createHash('md5');
			hash.update(sobj, 'utf8');
			key._s = hash.digest('hex');
		}
		var skey = new Buffer(JSON.stringify(key));
		var zeros = "0000000000";
		var lobj = sobj.length.toString();
		var lkey = skey.length.toString();
		lobj = zeros.substr(0,zeros.length - lobj.length)+lobj;
		lkey = zeros.substr(0,zeros.length - lkey.length)+lkey;
		var h1={k:lkey,o:lobj,v:"001"};
		var buf = new Buffer(JSON.stringify(h1)+"\n"+skey+"\n"+sobj+"\n");

		// check index update
		if (item && !remove) {
			try {
				_.forEach(self._idx,function(v,k) {
					v.set(item,key._id,true);
				})
			} catch (err) {
				err.errmsg = err.toString();
				return cb(err)
			}
		}

		safe.run(function (cb) {
			var rec = self._store[key._id];
			if (rec && rec.sum == key._s) return safe.back(cb);
			fs.write(self._fd, buf, 0, buf.length, self._fsize, safe.sure(cb, function (written) {
				if (remove)
					delete self._store[key._id];
				else
					self._store[key._id] = { pos: self._fsize, sum: key._s };

				if (remove || sobj.length > self._cmaxobj)
					self._cache.unset(self._fsize)
				else
					self._cache.set(self._fsize,item);
				self._fsize+=written;
				// randomly check for non exclusive file usage
				// which is growth of file that we are nor aware
				// randomly to avoid overhead
				if (self._check1==0) {
					this._check1 = Math.random()*100+1;
					fs.fstat(self._fd, safe.sure(cb, function (stat) {
						if (self._fsize!=stat.size)
							cb(new Error("File size mismatch. Are you use db/collection exclusively?"))
						else
							cb()
					}))
				} else {
					self._check1--;
					cb();
				}
			}));
		},
		function () {
			// update index
			_.forEach(self._idx,function(v,k) {
				if (!remove)
					v.set(item,key._id);
				else
					v.del(item,key._id);
			})
			cb(null);
		});
	}, true, cb);
}

tcoll.prototype.count = function (query, options, cb) {
	var self = this;
	if (arguments.length == 1) {
		cb = arguments[0];
        options = null;
		query = null;
	}
	if (arguments.length == 2) {
        query = arguments[0];
		cb = arguments[1];
        options = null;
	}
	if (query==null || _.size(query)==0) {
		this._tq.add(function (cb) {
			cb(null, _.size(self._store));
		},false,cb);
	} else
		self.find(query, options).count(cb);
}

tcoll.prototype.stats = function (cb) {
	var self = this;
	this._tq.add(function (cb) {
		cb(null, {count:_.size(self._store)});
	},false,cb);
}


var findOpts = ['limit','sort','fields','skip','hint','timeout','batchSize','safe','w'];

tcoll.prototype.findOne = function () {
	var findArgs = Array.prototype.slice.call(arguments,0,arguments.length-1);
	var cb = arguments[arguments.length-1];
	this.find.apply(this,findArgs).limit(1).nextObject(cb);
}

tcoll.prototype.find = function () {
	var cb = null, query = {}, opts = {}, fields = null, skip = null, limit = null, sort = null;
	var argc = arguments.length;
	if (argc>0) {
		// guess callback, it is always latest
		cb = arguments[argc-1];
		if (!_.isFunction(cb))
			cb=null
		else
			argc--;
		if (argc>0) {
			// query should always exist
			query = arguments[0]
			if (argc>1) {
				if (argc==2) {
					var val = arguments[1];
					// worst case we get either options either fiels
					if (_.intersection(_.keys(val),findOpts).length!=0)
						opts = val
					else
						fields = val;
				} else {
					fields = arguments[1];
					if (argc == 3)
						opts = arguments[2]
					else {
						skip = arguments[2];
						limit = arguments[3]
					}
				}
			}
		}
	}

	opts = opts || {};
	skip = skip || opts.skip || null;
	limit = limit || opts.limit || null;
	fields = fields || opts.fields || null;
	sort = sort || opts.sort || null;


	var c = new tcursor(this,query, fields, opts);

	if (skip) c.skip(skip);
	if (limit) c.limit(limit);
	if (sort) c.sort(sort);
	if (cb)
		cb(null, c)
	else
		return c;
}


function simplifyKey(key) {
	var k = key;
	if (key.toJSON)
		k = key.toJSON();
	if (_.isNumber(k)||_.isString(k))
		return k;
	return k.toString();
}

tcoll.prototype.update = function (query, doc, opts, cb) {
	var self = this;
	if (_.isFunction(opts) && cb == null) {
		cb = opts;
	}
	opts = opts || {};
	if (opts.w>0 && !_.isFunction(cb))
		throw new Error("Callback is required for safe update");
	cb = cb || function () {}
	if (!_.isObject(query))
		throw new Error("selector must be a valid JavaScript object");
	if (!_.isObject(doc))
		throw new Error("document must be a valid JavaScript object");

	var multi = opts.multi || false;
    var updater = new Updater(doc, self._tdb);
	var $doc = updater.hasAtomic()?null:doc;
	this._tq.add(function (cb) {
		self.__find(query, null, 0, multi ? null : 1, null, opts.hint, {}, safe.sure(cb, function (res) {
			if (res.length==0) {
				if (opts.upsert) {
					$doc = $doc || query;
					$doc = self._tdb._cloneDeep($doc);
					updater.update($doc,true);
					if (_.isUndefined($doc._id))
						$doc._id = new self._tdb.ObjectID();
					self._put($doc, false, safe.sure(cb, function () {
						cb(null, 1,{updatedExisting:false,upserted:$doc._id,n:1})
					}))
				} else
					cb(null,0);
			} else {
				safe.forEachSeries(res, function (pos, cb) {
					self._get(pos, false, safe.sure(cb, function (obj) {
						// remove current version of doc from indexes
						_.forEach(self._idx,function(v,k) {
							v.del(obj,simplifyKey(obj._id));
						})
						var udoc = $doc;
						if (!$doc) {
							udoc = obj;
							updater.update(udoc);
						}
						udoc._id = obj._id;
						// put will add it back to indexes
						self._put(udoc, false, cb);
					}))
				}, safe.sure(cb,function () {
					cb(null, res.length, {updatedExisting:true,n:res.length});
				}))
			}
		}))
	},true,cb);
}

tcoll.prototype.findAndModify = function (query, sort, doc, opts, cb) {
	var self = this;
	if (_.isFunction(opts) && cb == null) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	doc = doc || {};

	var updater = new Updater(doc, self._tdb);
	var $doc = updater.hasAtomic()?null:doc;

	var c = new tcursor(this,{}, opts.fields || {},{});
	c.sort(sort);
	if (c._err)
		return safe.back(cb,c._err);

	this._tq.add(function (cb) {
		self.__find(query, null, 0, 1, c._sort, opts.hint, {}, safe.sure(cb, function (res) {
			if (res.length==0) {
				if (opts.upsert) {
					$doc = $doc || query;
					$doc = self._tdb._cloneDeep($doc);
					updater.update($doc,true);
					if (_.isUndefined($doc._id))
						$doc._id = new self._tdb.ObjectID();
					self._put($doc, false, safe.sure(cb, function () {
						cb(null,opts.new?c._projectFields($doc):{})
					}))
				} else
					cb();
			} else {
				self._get(res[0], false, safe.sure(cb, function (obj) {
					var robj = (opts.new && !opts.remove) ? obj : self._tdb._cloneDeep(obj);
					// remove current version of doc from indexes
					_.forEach(self._idx,function(v,k) {
						v.del(obj,simplifyKey(obj._id));
					})
					var udoc = $doc;
					if (!$doc) {
						udoc = obj;
						updater.update(udoc);
					}
					udoc._id = obj._id;
					// put will add it back to indexes
					self._put(udoc, opts.remove?true:false, safe.sure(cb,function () {
						cb(null,c._projectFields(robj))
					}))
				}))
			}
		}))
	},true,cb);
}

tcoll.prototype.save = function (doc, opts, cb) {
	var self = this;
	cb = _.isFunction(doc)?doc:_.isFunction(opts)?opts:cb;
	cb = cb || function () {};
	doc = doc || {};
	opts = opts || {};
	this._tq.add(function (cb) {
		var res = doc;
		(function(cb) {
			if (_.isUndefined(doc._id)) {
				doc._id = new self._tdb.ObjectID();
				cb()
			} else {
				var id = simplifyKey(doc._id);
				var pos = self._store[id];
				// check if document with this id already exist
				if (pos) {
					// if so we need to fetch it to update index
					self._get(pos.pos, false, safe.sure(cb, function (oldDoc) {
						// remove current version of doc from indexes
						_.forEach(self._idx,function(v,k) {
							v.del(oldDoc,id);
						})
						res = 1;
						cb();
					}))
				} else cb();
			}
		})(safe.sure(cb, function () {
			self._put(doc, false, safe.sure(cb, function () {
				cb(null,res); // when update return 1 when new save return obj
			}))
		}))
	},true,cb);
}

tcoll.prototype.remove = function (query, opts, cb) {
	var self = this;
	if (_.isFunction(query)) {
		cb = query;
		query = opts = {};
	} else if (_.isFunction(opts)) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	if (opts.w>0 && !_.isFunction(cb))
		throw new Error("Callback is required");
	cb = cb || function () {};
	var single = opts.single || false;
	this._tq.add(function (cb) {
		self.__find(query, null, 0, single ? 1 : null, null, opts.hint, {}, safe.sure(cb, function (res) {
			safe.forEachSeries(res, function (pos, cb) {
				self._get(pos, false, safe.sure(cb, function (obj) {
					self._put(obj,true,cb);
				}))
			}, safe.sure(cb, function () {
				cb(null,res.length);
			}))
		}))
	},true,cb);
}

tcoll.prototype.findAndRemove = function (query,sort,opts,cb) {
	var self = this;

	if (_.isFunction(sort) && cb == null && opts==null) {
		cb = sort;
		sort = {}
		opts = {};
	} else if (_.isFunction(opts) && cb == null) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	sort = sort || {};

	var c = new tcursor(this,{},{},{});

	// Fix for mongoouse/tungus they pass sort as undefined
	c.sort(sort);

	if (c._err)
		return safe.back(cb,c._err);

	this._tq.add(function (cb) {
		self.__find(query, null, 0, 1, c._sort, opts.hint, {}, safe.sure(cb, function (res) {
			if (res.length==0)
				return cb();
			self._get(res[0], false, safe.sure(cb, function (obj) {
				self._put(obj,true,safe.sure(cb, function () {
					cb(null,obj);
				}))
			}))
		}))
	},true,cb);
}

tcoll.prototype._bestSortIndex = function (sort) {
	// no sort
	if (!sort) return null;
	// exact match
	if (this._idx[sort]) return this._idx[sort];
	// find potential sort indexes
	var pi = [];
	_.forEach(this._idx,function (idx) {
		var fields = idx.fields();
		var match = _.takeWhile(fields, function (kv, i) {
			return i < sort.length ? kv[0] == sort[i][0] : false;
		});
		if (match.length == sort.length) {
			var score = fields.length;
			_.forEach(sort,function (kv, i) {
				if (kv[1] != fields[i][1]) score += 1;
			});
			pi.push({ value: idx, score: score });
		}
	});
	if (pi.length === 0) return null;
	// select best index
	pi = pi.sort(function (l, r) { return l.score < r.score; });
	return pi[0].value;
};

function reduceIndexSet(pi) {
	var hit;
	do {
		hit = false;
		// compare each potential index with each other
		_.forEach(pi,function (v1, i1) {
			_.forEach(pi,function (v2, i2) {
				if (i1 == i2) return;
				// compare the set of possible keys for both indexes
				if (_.union(v1.k, v2.k).length == v1.k.length) {
					// key for v2 is a subset of key for v1, check equality
					if (v1.k.length == v2.k.length && v1.i.depth() > v2.i.depth()) {
						// keys are equal, but the depth of v2 is lower;
						// v2 is preferable, strike out v1
						pi.splice(i1, 1);
					} else {
						// in other two cases v1 is preferable, strike out v2
						pi.splice(i2, 1);
					}
					hit = true;
					return false;
				}
			});
			if (hit) return false;
		});
	} while (hit);
};

tcoll.prototype.__find = function (query, fields, skip, limit, sort, hint, arFields, cb) {
	var self = this;
	var range = [];
	// find sort index
	var si = this._bestSortIndex(sort);
	// for non empty query check indexes that we can use
	var qt = self._tdb.Finder.matcher(query);
	var pi = [];
	if (_.size(qt)>0) {
		_.forEach(self._idx,function (i) {
			var f = _.pluck(i.fields(), 0);
			var e = _.takeWhile(f, function (k) {
				return qt._ex(k) == 1 && (!hint || hint[k]);
			});
			if (e.length > 0) pi.push({ i: i, k: e, e: f.length > e.length });
		});
	}

	// if possible indexes found split the query and process
	// indexes separately
	if (!_.isEmpty(pi)) {
		// choose the most appropriate indexes
		reduceIndexSet(pi);
		// split query
		var io = {};
		_.forEach(pi,function (v) {
			_.forEach(v.k,function (k) {
				if (!io[k]) io[k] = qt.split(k);
			});
		});
		// process indexes
		var p = [];
		_.forEach(pi,function (st) {
			// this action applies to all indexes
			var r = io[st.k[0]]._index(st.i);
			// process subfields of compound index
			_.forEach(st.k.slice(1),function (k) {
				var v = io[k];
				r = _.flatten(_.map(r, function (si) { return v._index(si); }));
			});
			// expand subindexes to plain ids
			if (st.e) r = _.flatten(_.map(r, function (si) { return si.all(); }));
			// store result of index search
			p.push(r);
		});
		if (p.length == 1) {
			p = p[0];
			// optimization for the case when search and sorting indexes are the same
			if (si && pi[0].i === si) {
				var sif = si.fields();
				if (_.every(sort, function (v, i) { return sif[i][1] == v[1]; })) {
					// sort order exactly matches index order,
					// so the result is already sorted
					sort = null;
				} else if (_.every(sort, function (v, i) { return sif[i][1] == -v[1]; })) {
					// sort order is exactly opposite to index order,
					// so the result is sorted, but in reverse direction
					p.reverse();
					sort = null;
				}
			}
		} else {
			// TODO: use sort index as intersect base to speedup sorting
			p = tutils.intersectIndexes(p);
		}
		// nowe we have ids, need to convert them to positions
		_.forEach(p,function (_id) {
			range.push(self._store[_id].pos)
		})
	} else {
		if (si) {
			_.each(si.all(_.pluck(sort, 1)), function (_id) {
				range.push(self._store[_id].pos)
			})
			//if (order==-1)
			//	range.reverse();
			sort = null;
		} else
			range = _.values(self._store).map(function (rec) { return rec.pos; });
	}

	if (sort && si) {
		var ps = {};
		_.each(range,function (pos) {
			ps[pos] = true;
		});
		range = [];
		_.each(si.all(_.pluck(sort, 1)),function (_id) {
			var pos = self._store[_id].pos;
			if (_.has(ps,pos)) range.push(pos);
		});
		//if (order == -1)
		//	range.reverse();
		sort = null;
	}

	// no sort, no query then return right away
	if (sort==null && (_.size(qt)==0 || qt._args.length==0)) {
		if (skip!=0 || limit!=null) {
			var c = Math.min(range.length-skip,limit?limit:range.length-skip);
			range = range.splice(skip,c)
		}
		return safe.back(cb,null,range);
	}

	var matcher = null;
	// check if we can use simple match or array match function
	var arrayMatch = false;
	if (self._tdb._gopts.searchInArray)
		arrayMatch = true;
	else {
		var fields = qt.fields();
		_.each(fields, function (v,k) {
			if (arFields[k])
				arrayMatch = true;
		})
	}

	eval("matcher = function (obj) { return "+ (arrayMatch?qt.native3():qt.native()) + " }");

	// create sort index
	if (sort) {
		si = new tindex(sort,self);
	}

	// now simple non-index search
	var res = [];
	var found = 0;
	safe.forEachSeries(range, function (pos, cb) {
		if (sort==null && limit && res.length>=limit)
			return safe.back(cb);
		self._get(pos, true, safe.sure(cb, function (obj) {
			if (matcher(obj)) {
				if (sort!=null || found>=skip) {
					if (sort==null)
						res.push(pos);
					else
						si.set(obj,pos);
				}
				found++;
			}
			cb()
		}))
	}, safe.sure(cb, function () {
		if (sort) {
			res = si.all();
			//if (order==-1) {
			//	res.reverse();
			//}
			if (skip!=0 || limit!=null) {
				var c = Math.min(res.length-skip,limit?limit:res.length-skip);
				res = res.splice(skip,c)
			}
		}
		cb(null, res);
	}))
}

tcoll.prototype._find = function (query, fields, skip, limit, sort_, hint, arFields, cb) {
	var self = this;
	this._tq.add(function (cb) {
		self.__find(query, fields, skip, limit, sort_, hint, arFields, cb);
	}, false, cb);
}

function code2fn(obj) {
	if (_.isObject(obj)) {
		_.each(obj,function (value, key) {
			if (value instanceof Code) {
				with (value.scope) {
					obj[key] = eval('(' + value.code + ')');
				}
			}
			else code2fn(value);
		});
	}
}

tcoll.prototype.mapReduce = function (map, reduce, opts, cb) {
	var self = this;
	if (_.isFunction(opts)) {
		cb = opts;
		opts = {};
	}

	if (!opts.out) return safe.back(cb, new Error('the out option parameter must be defined'));
	if (!opts.out.inline && !opts.out.replace) {
		return safe.back(cb, new Error('the only supported out options are inline and replace'));
	}

	code2fn(opts.scope);

	var m = {};

	function emit(k, v) {
		var values = m[k];
		if (!values) m[k] = [ v ];
		else {
			values.push(v);
			if (values.length > 1000) values = [ reduce(k, values) ];
		}
	}

	with (opts.scope || {}) {
		try {
			if (map instanceof Code) {
				with (map.scope) {
					map = eval('(' + map.code + ')');
				}
			} else map = eval('(' + map + ')');
			if (reduce instanceof Code) {
				with (reduce.scope) {
					reduce = eval('(' + reduce.code + ')');
				}
			} else reduce = eval('(' + reduce + ')');
			if (finalize instanceof Code) {
				with (finalize.scope) {
					finalize = eval('(' + finalize.code + ')');
				}
			} else var finalize = eval('(' + opts.finalize + ')');
		} catch (e) {
			return safe.back(cb,e);
		}
	}

	self.find(opts.query, null, { limit: opts.limit, sort: opts.sort }, safe.sure(cb, function (c) {
		var doc;
		safe.doUntil(
			function (cb) {
				c.nextObject(safe.trap_sure(cb, function (_doc) {
					doc = _doc;
					if (doc) map.call(doc);
					return cb();
				}));
			},
			function () {
				return doc === null;
			},
			safe.trap_sure(cb, function () {
				_.each(m,function (v, k) {
					v = v.length > 1 ? reduce(k, v) : v[0];
					if (finalize) v = finalize(k, v);
					m[k] = v;
				});

				var stats = {};
				if (opts.out.inline) return process.nextTick(function () {
					cb(null, _.values(m), stats); // execute outside of trap
				});

				// write results to collection
				safe.waterfall([
					function (cb) {
						self._tdb.collection(opts.out.replace, { strict: 1 }, function (err, col) {
							if (err) return cb(null, null);
							col.drop(cb);
						});
					},
					function (arg, cb) {
						self._tdb.collection(opts.out.replace, {}, cb);
					},
					function (col, cb) {
						var docs = [];
						_.each(m,function (value, key) {
							var doc = {
								_id: key,
								value: value
							};
							docs.push(doc);
						});
						col.insert(docs, safe.sure(cb, function () {
							if (opts.verbose) cb(null, col, stats);
							else cb(null, col);
						}));
					}
				], cb);
			}
		)); // doUntil
	}));
};

tcoll.prototype.group = function (keys, condition, initial, reduce, finalize, command, options, callback) {
	var self = this;

	var args = Array.prototype.slice.call(arguments, 3);
	callback = args.pop();
	reduce = args.length ? args.shift() : null;
	finalize = args.length ? args.shift() : null;
	command = args.length ? args.shift() : null;
	options = args.length ? args.shift() : {};

	if (!_.isFunction(finalize)) {
		command = finalize;
		finalize = null;
	}

	code2fn(options.scope);

	with (options.scope || {}) {
		try {
			if (_.isFunction(keys)) keys = eval('(' + keys + ')');
			else if (keys instanceof Code) {
				with (keys.scope) {
					keys = eval('(' + keys.code + ')');
				}
			}
			if (reduce instanceof Code) {
				with (reduce.scope) {
					reduce = eval('(' + reduce.code + ')');
				}
			} else reduce = eval('(' + reduce + ')');
			if (finalize instanceof Code) {
				with (finalize.scope) {
					finalize = eval('(' + finalize.code + ')');
				}
			} else finalize = eval('(' + finalize + ')');
		} catch (e) {
			return callback(e);
		}
	}

	var m = {};
	self.find(condition, safe.sure(callback, function (c) {
		var doc;
		safe.doUntil(
			function (cb) {
				c.nextObject(safe.sure(cb, function (_doc) {
					doc = _doc;
					if (!doc) return cb();
					var keys2 = keys;
					if (_.isFunction(keys)) keys2 = keys(doc);
					if (!_.isArray(keys2)) {
						var keys3 = [];
						_.each(keys2,function (v, k) {
							if (v) keys3.push(k);
						});
						keys2 = keys3;
					}
					var key = {};
					_.each(keys2,function (k) {
						key[k] = doc[k];
					});
					var skey = JSON.stringify(key);
					var obj = m[skey];
					if (!obj) obj = m[skey] = _.extend({}, key, initial);
					try {
						reduce(doc, obj);
					} catch (e) {
						return cb(e);
					}
					cb();
				}));
			},
			function () {
				return doc === null;
			},
			safe.sure(callback, function () {
				var result = _.values(m);
				if (finalize) {
					_.each(result,function (value) {
						finalize(value);
					});
				}
				callback(null, result);
			})
		);
	}));
};
 at SyntaxError: 'with' in strict mode (1134:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$1.parseWithStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:932:27)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:708:32)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseBlock (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:981:25)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:709:33)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseIfStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:824:28)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:698:30)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":1,"ExpansionArg_type_2":0,"_bound":2}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":2,"ExpansionArg_type_2":0,"_bound":3,"ExpansionArg_int":0} start 47.9518 took 14.1985s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":2,"ExpansionArg_type_2":0,"_bound":3,"ExpansionArg_int":0}
* Error: Tropigate failed because SyntaxError: 'with' in strict mode (1134:4) on program var safe = require('safe');
var _ = require('lodash');
var crypto = require('crypto');
var fs = require('fs');
var path = require('path');
var tcursor = require('./tcursor');
var wqueue = require('./wqueue');
var tindex = require('./tindex');
var tcache = require("./tcache");
var Code = require('./tcode').Code;
var tutils = require('./utils');
var Updater = require('./updater');

function tcoll(tdb) {
	var self = this;
	this._tdb = null;
	this._name = null;
	this._store = {};
	this._fd = null;
	this._fsize = null;
	this._id = 1;
	this._wq = new wqueue();
	this._tq = null;
	this._idx = {};
	this._cache = null;
	this._mc = {};
	this._check1 = Math.random()*100+1;
	// native mongo db compatibility attrs
	this.collectionName = null;
	if (tdb._stype=="mem") {
		this.init = this.initM;
		this._put = this._putM;
		this._get = this._getM;
	} else {
		this.init = this.initFS;
		this._put = this._putFS;
		this._get = this._getFS;
	}
}

module.exports = tcoll;

tcoll.prototype.initM = function (tdb, name, options, create, cb) {
	var self= this;
	this._tdb = tdb;
	tdb._mstore = tdb._mstore || {};
	this.collectionName = this._name = name;
	if (options.strict) {
		var exists = tdb._mstore[name];
		if (exists && create) return cb(new Error("Collection " + self._name + " already exists. Currently in safe mode."));
		else if (!exists && !create) return cb(new Error("Collection " + self._name + " does not exist. Currently in safe mode."));
	}
	tdb._mstore[name] = this._mstore = tdb._mstore[name] || [];
	for (var k=0; k< this._mstore.length; k++) {
		var o = this._mstore[k];
		if (o) {
			self._store[simplifyKey(o._id)]={pos:k+1};
		}
	}
	this._tq = new wqueue(100, function (cb) {
		// update indexes
		safe.forEachSeries(_.values(self._store), function (rec, cb) {
			self._get(rec.pos, false, safe.sure(cb, function (obj) {
				var id = simplifyKey(obj._id);
				_.forEach(self._idx,function(v, k) {
					v.set(obj, id);
				});
				cb();
			}));
		}, cb);
	});
	self.ensureIndex({_id: 1}, {name: '_id_', unique: true}, cb);
};

tcoll.prototype.initFS = function (tdb, name, options, create, cb) {
	var self= this;
	this._tdb = tdb;
	this._cache = new tcache(tdb, tdb._gopts.cacheSize);
	this._cmaxobj = tdb._gopts.cacheMaxObjSize || 1024;
	this.collectionName = this._name = name;
	this._filename = path.join(this._tdb._path, this._name);
	if (options.strict) {
		var exists = fs.existsSync(self._filename);
		if (exists && create) return cb(new Error("Collection " + self._name + " already exists. Currently in safe mode."));
		else if (!exists && !create) return cb(new Error("Collection " + self._name + " does not exist. Currently in safe mode."));
	}
	var pos = 0;
	var deleted = 0;
	var found = 0;
	this._tq = new wqueue(100, function (cb) {
		(function (cb) {
			fs.open(self._filename, "a+", safe.sure(cb, function (fd) {
			self._fd = fd;
			var b1 = new Buffer(45);
			safe.whilst(function () { return self._fsize===null; }, function(cb) {
				(function (cb) {
					fs.read(fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {
						if (bytes===0) {
							self._fsize = pos;
							return cb();
						}
						var h1 = JSON.parse(data.toString());
						h1.o = parseInt(h1.o,10);
						h1.k = parseInt(h1.k,10);
						var b2 = new Buffer(h1.k);
						fs.read(fd,b2,0,h1.k,pos+45+1, safe.sure(cb, function (bytes, data) {
							var k = JSON.parse(data.toString());
							self._id = k._uid;
							if (k._a=='del') {
								delete self._store[k._id];
								deleted++;
							} else {
								if (self._store[k._id]) deleted++;
								self._store[k._id] = { pos: pos, sum: k._s };
							}
							pos+=45+3+h1.o+h1.k;
							found++;
							cb();
						}));
					}));
				})(function (err) {
					if (err)
						cb(new Error(self._name+": Error during load - "+err.toString()));
					else
						cb();
				});
			}, cb);
			}));
		})(function (err) {
			if (!found && err)
				return cb(err); // nothing read and error, just rise it
			safe.run(function (cb) {
				var size = _.size(self._store);
				// autocompact on certain ratio or err
				if (deleted > size || err) {
					self._compact(function (errCompact) {
						if (errCompact && err)
							cb(errCompact);
						else {
							if (errCompact) console.log(err);
							cb();
						}
					});
				} else cb();
			}, function () {
				self._refreshIndexes(cb);
			});
		});
	});
	self.ensureIndex({_id: 1}, {name: '_id_', unique: true}, cb);
};

tcoll.prototype.compactCollection = function (cb) {
	var self = this;
	self._tq.add(function (cb) {
		self._compact(safe.sure(cb, function () {
			self._cache.clear();
			self._refreshIndexes(cb);
		}));
	}, true, cb);
};

tcoll.prototype._refreshIndexes = function (cb) {
	var self = this;
	_.forEach(self._idx,function(v, k) {
		v.clear();
	});
	safe.forEachSeries(_.values(self._store), function (rec, cb) {
		self._get(rec.pos, false, safe.sure(cb, function (obj) {
			var id = simplifyKey(obj._id);
			_.forEach(self._idx,function(v, k) {
				v.set(obj, id);
			});
			cb();
		}));
	}, cb);
};

tcoll.prototype._compact = function (cb) {
	var self = this;
	var filename = self._filename + '.compact';
	fs.open(filename, 'w+', safe.sure(cb, function (fd) {
		var b1 = new Buffer(45);
		function get(pos, cb) {
			fs.read(self._fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {
				var h1 = JSON.parse(data.toString());
				h1.o = parseInt(h1.o, 10);
				h1.k = parseInt(h1.k, 10);
				var b2 = new Buffer(h1.k + h1.o + 3);
				fs.read(self._fd, b2, 0, b2.length, pos + 45, safe.sure(cb, function (bytes, data) {
					cb(null, Buffer.concat([ b1, b2 ]));
				}));
			}));
		}
		var wpos = 0;
		var store = {};
		safe.forEachSeries(_.keys(self._store), function (k, cb) {
			var rec = self._store[k];
			get(rec.pos, safe.sure(cb, function (data) {
				fs.write(fd, data, 0, data.length, wpos, safe.sure(cb, function (written) {
					if (written != data.length) return cb(new Error('Insufficient disk space'));
					store[k] = { pos: wpos, sum: rec.sum };
					wpos += data.length;
					cb();
				}));
			}));
		}, function (err) {
			if (err) {
				fs.close(fd, function () {
					fs.unlink(filename, function () {
						cb(err);
					});
				});
				return;
			}
			if (!!process.platform.match(/^win/)) {
				// WINDOWS: unsafe because if something fail while renaming file it will not
				// restore automatically
				fs.close(self._fd, safe.sure(cb,function() {
					fs.close(fd, safe.sure(cb,function() {
						fs.unlink(self._filename, safe.sure(cb,function () {
							fs.rename(filename, self._filename, safe.sure(cb, function () {
								fs.open(self._filename, 'a+', safe.sure(cb, function (fd) {
									self._fd = fd;
									self._fsize = wpos;
									self._store = store;
									cb();
								}));
							}));
						}));
					}));
				}));
		    } else {
				// safe way
				fs.rename(filename, self._filename, safe.sure(cb, function () {
					fs.close(self._fd);
					self._fd = fd;
					self._fsize = wpos;
					self._store = store;
					cb();
				}));
			}
		});
	}));
};

tcoll.prototype.drop = function (cb) {
	this._tdb.dropCollection(this._name,cb);
};

tcoll.prototype.rename = function (nname, opts, cb) {
	var self = this;
	if (_.isFunction(opts)) {
		cb = opts;
		opts = {};
	}
	var err = self._tdb._nameCheck(nname);
	if (err)
		return safe.back(cb,err);
	if (self._tdb._stype=="mem") {
		delete self._tdb._cols[self._name];
		self._tdb._cols[nname] = self;
		delete self._tdb._mstore[self._name];
		self._tdb._mstore[nname] = self._mstore;
		safe.back(cb,null);
	} else {
		self._tq.add(function (cb) {
			fs.rename(path.join(self._tdb._path,self._name),path.join(self._tdb._path,nname),safe.sure(cb, function () {
				delete self._tdb._cols[self._name];
				self._tdb._cols[nname] = self;
				self.collectionName = self._name = nname;
				cb();
			}));
		},true,cb);
	}
};

tcoll.prototype._stop = function (cb) {
	var self = this;
	self._tq.add(function (cb) {
		// this will prevent any tasks processed on this instance
		self._tq._stoped = true;
		if (self._fd) {
			fs.close(self._fd,safe.sure(cb, function () {
				cb(null,true);
			}));
		} else
			cb(null,false);
	},true,cb);
};

tcoll.prototype.createIndex = tcoll.prototype.ensureIndex = function (obj, options, cb) {
	var self = this;
	if (_.isFunction(options)) {
		cb = options;
		options = {};
	}
	cb = cb || function () {};
	options = options || {};

	var c = new tcursor(this,{},{},{});
	c.sort(obj);
	if (c._err)
		return safe.back(cb,c._err);
	var key = c._sort;

	if (key===null)
		return safe.back(cb,new Error("No fields are specified"));

	var index = self._idx[key];
	if (index)
		return safe.back(cb,null, index.name);

	// force array support when global option is set
	if (_.isUndefined(options._tiarr) && self._tdb._gopts.searchInArray)
		options._tiarr = true;

	var name = options.name || _.map(key, function (v) { return v[0] + '_' + v[1]; }).join('_');
	index = new tindex(key, self, options, name);

	if (self._tq._tc==-1) {
		// if no operation is pending just register index
		self._idx[key] = index;
		safe.back(cb, null, index.name);
	}
	else {
		// overwise register index operation
		this._tq.add(function (cb) {
			var range = _.values(self._store);
			safe.forEachSeries(range, function (rec, cb) {
				self._get(rec.pos, false, safe.sure(cb, function (obj) {
					index.set(obj,simplifyKey(obj._id));
					cb();
				}));
			}, safe.sure(cb, function () {
				self._idx[key] = index;
				cb();
			}));
		}, true, function (err) {
			if (err) cb(err);
			else cb(null, index.name);
		});
	}
};

tcoll.prototype.indexExists = function (idx, cb) {
	if (!_.isArray(idx))
		idx = [idx];
	var i = _.intersection(idx,_(this._idx).values().map('name').value());
	cb(null,i.length == idx.length);
};

tcoll.prototype.indexes = function (cb) {
	var self = this;
	this._tq.add(function (cb) {
		cb(null, _.values(self._idx));
	},false,cb);
};

tcoll.prototype._getM = function (pos, unsafe, cb) {
	safe.back(cb,null,unsafe?this._mstore[pos-1]:this._tdb._cloneDeep(this._mstore[pos-1]));
};

tcoll.prototype._getFS = function (pos, unsafe, cb) {
	var self = this;
	var cached = self._cache.get(pos,unsafe);
	if (cached)
		return safe.back(cb,null,cached);
	var b1 = new Buffer(45);
	fs.read(self._fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {
		var h1 = JSON.parse(data.toString());
		h1.o = parseInt(h1.o,10);
		h1.k = parseInt(h1.k,10);
		var b2 = new Buffer(h1.o);
		fs.read(self._fd,b2,0,h1.o,pos+45+2+h1.k, safe.trap_sure(cb, function (bytes, data) {
			var obj = self._unwrapTypes(JSON.parse(data.toString()));
			if (bytes <= self._cmaxobj)
				self._cache.set(pos, obj);
			cb(null,obj);
		}))
	}))
}

tcoll.prototype.insert = function (docs, opts, cb ) {
	var self = this;
	if (_.isFunction(opts) && cb == null) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	if (opts.w>0 && !_.isFunction(cb))
		throw new Error("Callback is required for safe update");
	cb = cb || function () {};
	if (!_.isArray(docs))
		docs = [docs];
	this._tq.add(function (cb) {
		safe.forEachSeries(docs, function (doc, cb) {
			if (_.isUndefined(doc._id)) {
				doc._id = new self._tdb.ObjectID();
			}
			self._put(doc, false, cb);
		}, safe.sure(cb, function () {
			cb(null, docs);
		}))
	}, true, cb)
}

tcoll.prototype._wrapTypes = function(obj) {
	var self = this;
	_.each(obj, function (v,k) {
		if (_.isDate(v))
			obj[k] = {$wrap:"$date",v:v.valueOf(),h:v}
		else if (v instanceof self._tdb.ObjectID)
			obj[k] = {$wrap:"$oid",v:v.toJSON()}
		else if (v instanceof self._tdb.Binary)
			obj[k] = {$wrap: "$bin", v: v.toJSON()};
		else if (_.isObject(v))
			self._wrapTypes(v)

	})
	return obj;
}

tcoll.prototype._ensureIds = function(obj) {
	var self = this;
	_.each(obj, function (v,k) {
		if (k.length >0) {
			if (k[0]=='$')
				throw new Error("key "+k+" must not start with '$'");;
			if (k.indexOf('.')!=-1)
				throw new Error("key "+k+" must not contain '.'");
		}
		if (_.isObject(v)) {
			if (v instanceof self._tdb.ObjectID) {
				if (v.id<0) {
					v._persist(++self._id)
				}
			}
			else
				self._ensureIds(v)
		}
	})
	return obj;
}


tcoll.prototype._unwrapTypes = function(obj) {
	var self = this;
	_.each(obj, function (v,k) {
		if (_.isObject(v)) {
			switch (v.$wrap) {
				case "$date": obj[k] = new Date(v.v); break;
				case "$oid":
					var oid = new self._tdb.ObjectID(v.v);
					obj[k]=oid;
				break;
				case "$bin":
					var bin = new self._tdb.Binary(new Buffer(v.v, 'base64'));
					obj[k] = bin;
				break;
				default: self._unwrapTypes(v);
			}
		}
	})
	return obj;
}

tcoll.prototype._putM = function (item_, remove, cb) {
	var item = this._tdb._cloneDeep(item_);
	var self = this;
	self._wq.add(function (cb) {
		try {
			item = self._ensureIds(item);
		} catch (err) {
			err.errmsg = err.toString();
			return cb(err)
		}
		if (_.isUndefined(item._id))
			return cb(new Error("Invalid object key (_id)"));

		var key = {_id:simplifyKey(item._id)};

		// check index update
		if (item && !remove) {
			try {
				_.forEach(self._idx,function(v,k) {
					v.set(item,key._id,true);
				})
			} catch (err) {
				err.errmsg = err.toString();
				return cb(err)
			}
		}

		if (remove) {
			self._mstore[self._store[key._id].pos-1]=null;
			delete self._store[key._id];
		}
		else {
			if (self._store[key._id]) {
				self._mstore[self._store[key._id].pos-1] = item;
			} else {
				self._mstore.push(item);
				self._store[key._id] = {pos: self._mstore.length};
			}
		}

		// update index
		_.forEach(self._idx,function(v,k) {
			if (!remove)
				v.set(item,key._id);
			else
				v.del(item,key._id);
		})
		cb(null);
	}, true, cb);
}


tcoll.prototype._putFS = function (item, remove, cb) {
	var self = this;
	self._wq.add(function (cb) {
		try {
			item = self._ensureIds(item);
		} catch (err) {
			err.errmsg = err.toString();
			return cb(err)
		}
		if (_.isUndefined(item._id))
			return cb(new Error("Invalid object key (_id)"));
		item = self._wrapTypes(item);
		var sobj = new Buffer(remove?"":JSON.stringify(item));
		item = self._unwrapTypes(item);
		var key = {_id:simplifyKey(item._id),_uid:self._id,_dt:(new Date()).valueOf()};
		if (remove) key._a = "del";
		else {
			var hash = crypto.createHash('md5');
			hash.update(sobj, 'utf8');
			key._s = hash.digest('hex');
		}
		var skey = new Buffer(JSON.stringify(key));
		var zeros = "0000000000";
		var lobj = sobj.length.toString();
		var lkey = skey.length.toString();
		lobj = zeros.substr(0,zeros.length - lobj.length)+lobj;
		lkey = zeros.substr(0,zeros.length - lkey.length)+lkey;
		var h1={k:lkey,o:lobj,v:"001"};
		var buf = new Buffer(JSON.stringify(h1)+"\n"+skey+"\n"+sobj+"\n");

		// check index update
		if (item && !remove) {
			try {
				_.forEach(self._idx,function(v,k) {
					v.set(item,key._id,true);
				})
			} catch (err) {
				err.errmsg = err.toString();
				return cb(err)
			}
		}

		safe.run(function (cb) {
			var rec = self._store[key._id];
			if (rec && rec.sum == key._s) return safe.back(cb);
			fs.write(self._fd, buf, 0, buf.length, self._fsize, safe.sure(cb, function (written) {
				if (remove)
					delete self._store[key._id];
				else
					self._store[key._id] = { pos: self._fsize, sum: key._s };

				if (remove || sobj.length > self._cmaxobj)
					self._cache.unset(self._fsize)
				else
					self._cache.set(self._fsize,item);
				self._fsize+=written;
				// randomly check for non exclusive file usage
				// which is growth of file that we are nor aware
				// randomly to avoid overhead
				if (self._check1==0) {
					this._check1 = Math.random()*100+1;
					fs.fstat(self._fd, safe.sure(cb, function (stat) {
						if (self._fsize!=stat.size)
							cb(new Error("File size mismatch. Are you use db/collection exclusively?"))
						else
							cb()
					}))
				} else {
					self._check1--;
					cb();
				}
			}));
		},
		function () {
			// update index
			_.forEach(self._idx,function(v,k) {
				if (!remove)
					v.set(item,key._id);
				else
					v.del(item,key._id);
			})
			cb(null);
		});
	}, true, cb);
}

tcoll.prototype.count = function (query, options, cb) {
	var self = this;
	if (arguments.length == 1) {
		cb = arguments[0];
        options = null;
		query = null;
	}
	if (arguments.length == 2) {
        query = arguments[0];
		cb = arguments[1];
        options = null;
	}
	if (query==null || _.size(query)==0) {
		this._tq.add(function (cb) {
			cb(null, _.size(self._store));
		},false,cb);
	} else
		self.find(query, options).count(cb);
}

tcoll.prototype.stats = function (cb) {
	var self = this;
	this._tq.add(function (cb) {
		cb(null, {count:_.size(self._store)});
	},false,cb);
}


var findOpts = ['limit','sort','fields','skip','hint','timeout','batchSize','safe','w'];

tcoll.prototype.findOne = function () {
	var findArgs = Array.prototype.slice.call(arguments,0,arguments.length-1);
	var cb = arguments[arguments.length-1];
	this.find.apply(this,findArgs).limit(1).nextObject(cb);
}

tcoll.prototype.find = function () {
	var cb = null, query = {}, opts = {}, fields = null, skip = null, limit = null, sort = null;
	var argc = arguments.length;
	if (argc>0) {
		// guess callback, it is always latest
		cb = arguments[argc-1];
		if (!_.isFunction(cb))
			cb=null
		else
			argc--;
		if (argc>0) {
			// query should always exist
			query = arguments[0]
			if (argc>1) {
				if (argc==2) {
					var val = arguments[1];
					// worst case we get either options either fiels
					if (_.intersection(_.keys(val),findOpts).length!=0)
						opts = val
					else
						fields = val;
				} else {
					fields = arguments[1];
					if (argc == 3)
						opts = arguments[2]
					else {
						skip = arguments[2];
						limit = arguments[3]
					}
				}
			}
		}
	}

	opts = opts || {};
	skip = skip || opts.skip || null;
	limit = limit || opts.limit || null;
	fields = fields || opts.fields || null;
	sort = sort || opts.sort || null;


	var c = new tcursor(this,query, fields, opts);

	if (skip) c.skip(skip);
	if (limit) c.limit(limit);
	if (sort) c.sort(sort);
	if (cb)
		cb(null, c)
	else
		return c;
}


function simplifyKey(key) {
	var k = key;
	if (key.toJSON)
		k = key.toJSON();
	if (_.isNumber(k)||_.isString(k))
		return k;
	return k.toString();
}

tcoll.prototype.update = function (query, doc, opts, cb) {
	var self = this;
	if (_.isFunction(opts) && cb == null) {
		cb = opts;
	}
	opts = opts || {};
	if (opts.w>0 && !_.isFunction(cb))
		throw new Error("Callback is required for safe update");
	cb = cb || function () {}
	if (!_.isObject(query))
		throw new Error("selector must be a valid JavaScript object");
	if (!_.isObject(doc))
		throw new Error("document must be a valid JavaScript object");

	var multi = opts.multi || false;
    var updater = new Updater(doc, self._tdb);
	var $doc = updater.hasAtomic()?null:doc;
	this._tq.add(function (cb) {
		self.__find(query, null, 0, multi ? null : 1, null, opts.hint, {}, safe.sure(cb, function (res) {
			if (res.length==0) {
				if (opts.upsert) {
					$doc = $doc || query;
					$doc = self._tdb._cloneDeep($doc);
					updater.update($doc,true);
					if (_.isUndefined($doc._id))
						$doc._id = new self._tdb.ObjectID();
					self._put($doc, false, safe.sure(cb, function () {
						cb(null, 1,{updatedExisting:false,upserted:$doc._id,n:1})
					}))
				} else
					cb(null,0);
			} else {
				safe.forEachSeries(res, function (pos, cb) {
					self._get(pos, false, safe.sure(cb, function (obj) {
						// remove current version of doc from indexes
						_.forEach(self._idx,function(v,k) {
							v.del(obj,simplifyKey(obj._id));
						})
						var udoc = $doc;
						if (!$doc) {
							udoc = obj;
							updater.update(udoc);
						}
						udoc._id = obj._id;
						// put will add it back to indexes
						self._put(udoc, false, cb);
					}))
				}, safe.sure(cb,function () {
					cb(null, res.length, {updatedExisting:true,n:res.length});
				}))
			}
		}))
	},true,cb);
}

tcoll.prototype.findAndModify = function (query, sort, doc, opts, cb) {
	var self = this;
	if (_.isFunction(opts) && cb == null) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	doc = doc || {};

	var updater = new Updater(doc, self._tdb);
	var $doc = updater.hasAtomic()?null:doc;

	var c = new tcursor(this,{}, opts.fields || {},{});
	c.sort(sort);
	if (c._err)
		return safe.back(cb,c._err);

	this._tq.add(function (cb) {
		self.__find(query, null, 0, 1, c._sort, opts.hint, {}, safe.sure(cb, function (res) {
			if (res.length==0) {
				if (opts.upsert) {
					$doc = $doc || query;
					$doc = self._tdb._cloneDeep($doc);
					updater.update($doc,true);
					if (_.isUndefined($doc._id))
						$doc._id = new self._tdb.ObjectID();
					self._put($doc, false, safe.sure(cb, function () {
						cb(null,opts.new?c._projectFields($doc):{})
					}))
				} else
					cb();
			} else {
				self._get(res[0], false, safe.sure(cb, function (obj) {
					var robj = (opts.new && !opts.remove) ? obj : self._tdb._cloneDeep(obj);
					// remove current version of doc from indexes
					_.forEach(self._idx,function(v,k) {
						v.del(obj,simplifyKey(obj._id));
					})
					var udoc = $doc;
					if (!$doc) {
						udoc = obj;
						updater.update(udoc);
					}
					udoc._id = obj._id;
					// put will add it back to indexes
					self._put(udoc, opts.remove?true:false, safe.sure(cb,function () {
						cb(null,c._projectFields(robj))
					}))
				}))
			}
		}))
	},true,cb);
}

tcoll.prototype.save = function (doc, opts, cb) {
	var self = this;
	cb = _.isFunction(doc)?doc:_.isFunction(opts)?opts:cb;
	cb = cb || function () {};
	doc = doc || {};
	opts = opts || {};
	this._tq.add(function (cb) {
		var res = doc;
		(function(cb) {
			if (_.isUndefined(doc._id)) {
				doc._id = new self._tdb.ObjectID();
				cb()
			} else {
				var id = simplifyKey(doc._id);
				var pos = self._store[id];
				// check if document with this id already exist
				if (pos) {
					// if so we need to fetch it to update index
					self._get(pos.pos, false, safe.sure(cb, function (oldDoc) {
						// remove current version of doc from indexes
						_.forEach(self._idx,function(v,k) {
							v.del(oldDoc,id);
						})
						res = 1;
						cb();
					}))
				} else cb();
			}
		})(safe.sure(cb, function () {
			self._put(doc, false, safe.sure(cb, function () {
				cb(null,res); // when update return 1 when new save return obj
			}))
		}))
	},true,cb);
}

tcoll.prototype.remove = function (query, opts, cb) {
	var self = this;
	if (_.isFunction(query)) {
		cb = query;
		query = opts = {};
	} else if (_.isFunction(opts)) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	if (opts.w>0 && !_.isFunction(cb))
		throw new Error("Callback is required");
	cb = cb || function () {};
	var single = opts.single || false;
	this._tq.add(function (cb) {
		self.__find(query, null, 0, single ? 1 : null, null, opts.hint, {}, safe.sure(cb, function (res) {
			safe.forEachSeries(res, function (pos, cb) {
				self._get(pos, false, safe.sure(cb, function (obj) {
					self._put(obj,true,cb);
				}))
			}, safe.sure(cb, function () {
				cb(null,res.length);
			}))
		}))
	},true,cb);
}

tcoll.prototype.findAndRemove = function (query,sort,opts,cb) {
	var self = this;

	if (_.isFunction(sort) && cb == null && opts==null) {
		cb = sort;
		sort = {}
		opts = {};
	} else if (_.isFunction(opts) && cb == null) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	sort = sort || {};

	var c = new tcursor(this,{},{},{});

	// Fix for mongoouse/tungus they pass sort as undefined
	c.sort(sort);

	if (c._err)
		return safe.back(cb,c._err);

	this._tq.add(function (cb) {
		self.__find(query, null, 0, 1, c._sort, opts.hint, {}, safe.sure(cb, function (res) {
			if (res.length==0)
				return cb();
			self._get(res[0], false, safe.sure(cb, function (obj) {
				self._put(obj,true,safe.sure(cb, function () {
					cb(null,obj);
				}))
			}))
		}))
	},true,cb);
}

tcoll.prototype._bestSortIndex = function (sort) {
	// no sort
	if (!sort) return null;
	// exact match
	if (this._idx[sort]) return this._idx[sort];
	// find potential sort indexes
	var pi = [];
	_.forEach(this._idx,function (idx) {
		var fields = idx.fields();
		var match = _.takeWhile(fields, function (kv, i) {
			return i < sort.length ? kv[0] == sort[i][0] : false;
		});
		if (match.length == sort.length) {
			var score = fields.length;
			_.forEach(sort,function (kv, i) {
				if (kv[1] != fields[i][1]) score += 1;
			});
			pi.push({ value: idx, score: score });
		}
	});
	if (pi.length === 0) return null;
	// select best index
	pi = pi.sort(function (l, r) { return l.score < r.score; });
	return pi[0].value;
};

function reduceIndexSet(pi) {
	var hit;
	do {
		hit = false;
		// compare each potential index with each other
		_.forEach(pi,function (v1, i1) {
			_.forEach(pi,function (v2, i2) {
				if (i1 == i2) return;
				// compare the set of possible keys for both indexes
				if (_.union(v1.k, v2.k).length == v1.k.length) {
					// key for v2 is a subset of key for v1, check equality
					if (v1.k.length == v2.k.length && v1.i.depth() > v2.i.depth()) {
						// keys are equal, but the depth of v2 is lower;
						// v2 is preferable, strike out v1
						pi.splice(i1, 1);
					} else {
						// in other two cases v1 is preferable, strike out v2
						pi.splice(i2, 1);
					}
					hit = true;
					return false;
				}
			});
			if (hit) return false;
		});
	} while (hit);
};

tcoll.prototype.__find = function (query, fields, skip, limit, sort, hint, arFields, cb) {
	var self = this;
	var range = [];
	// find sort index
	var si = this._bestSortIndex(sort);
	// for non empty query check indexes that we can use
	var qt = self._tdb.Finder.matcher(query);
	var pi = [];
	if (_.size(qt)>0) {
		_.forEach(self._idx,function (i) {
			var f = _.pluck(i.fields(), 0);
			var e = _.takeWhile(f, function (k) {
				return qt._ex(k) == 1 && (!hint || hint[k]);
			});
			if (e.length > 0) pi.push({ i: i, k: e, e: f.length > e.length });
		});
	}

	// if possible indexes found split the query and process
	// indexes separately
	if (!_.isEmpty(pi)) {
		// choose the most appropriate indexes
		reduceIndexSet(pi);
		// split query
		var io = {};
		_.forEach(pi,function (v) {
			_.forEach(v.k,function (k) {
				if (!io[k]) io[k] = qt.split(k);
			});
		});
		// process indexes
		var p = [];
		_.forEach(pi,function (st) {
			// this action applies to all indexes
			var r = io[st.k[0]]._index(st.i);
			// process subfields of compound index
			_.forEach(st.k.slice(1),function (k) {
				var v = io[k];
				r = _.flatten(_.map(r, function (si) { return v._index(si); }));
			});
			// expand subindexes to plain ids
			if (st.e) r = _.flatten(_.map(r, function (si) { return si.all(); }));
			// store result of index search
			p.push(r);
		});
		if (p.length == 1) {
			p = p[0];
			// optimization for the case when search and sorting indexes are the same
			if (si && pi[0].i === si) {
				var sif = si.fields();
				if (_.every(sort, function (v, i) { return sif[i][1] == v[1]; })) {
					// sort order exactly matches index order,
					// so the result is already sorted
					sort = null;
				} else if (_.every(sort, function (v, i) { return sif[i][1] == -v[1]; })) {
					// sort order is exactly opposite to index order,
					// so the result is sorted, but in reverse direction
					p.reverse();
					sort = null;
				}
			}
		} else {
			// TODO: use sort index as intersect base to speedup sorting
			p = tutils.intersectIndexes(p);
		}
		// nowe we have ids, need to convert them to positions
		_.forEach(p,function (_id) {
			range.push(self._store[_id].pos)
		})
	} else {
		if (si) {
			_.each(si.all(_.pluck(sort, 1)), function (_id) {
				range.push(self._store[_id].pos)
			})
			//if (order==-1)
			//	range.reverse();
			sort = null;
		} else
			range = _.values(self._store).map(function (rec) { return rec.pos; });
	}

	if (sort && si) {
		var ps = {};
		_.each(range,function (pos) {
			ps[pos] = true;
		});
		range = [];
		_.each(si.all(_.pluck(sort, 1)),function (_id) {
			var pos = self._store[_id].pos;
			if (_.has(ps,pos)) range.push(pos);
		});
		//if (order == -1)
		//	range.reverse();
		sort = null;
	}

	// no sort, no query then return right away
	if (sort==null && (_.size(qt)==0 || qt._args.length==0)) {
		if (skip!=0 || limit!=null) {
			var c = Math.min(range.length-skip,limit?limit:range.length-skip);
			range = range.splice(skip,c)
		}
		return safe.back(cb,null,range);
	}

	var matcher = null;
	// check if we can use simple match or array match function
	var arrayMatch = false;
	if (self._tdb._gopts.searchInArray)
		arrayMatch = true;
	else {
		var fields = qt.fields();
		_.each(fields, function (v,k) {
			if (arFields[k])
				arrayMatch = true;
		})
	}

	eval("matcher = function (obj) { return "+ (arrayMatch?qt.native3():qt.native()) + " }");

	// create sort index
	if (sort) {
		si = new tindex(sort,self);
	}

	// now simple non-index search
	var res = [];
	var found = 0;
	safe.forEachSeries(range, function (pos, cb) {
		if (sort==null && limit && res.length>=limit)
			return safe.back(cb);
		self._get(pos, true, safe.sure(cb, function (obj) {
			if (matcher(obj)) {
				if (sort!=null || found>=skip) {
					if (sort==null)
						res.push(pos);
					else
						si.set(obj,pos);
				}
				found++;
			}
			cb()
		}))
	}, safe.sure(cb, function () {
		if (sort) {
			res = si.all();
			//if (order==-1) {
			//	res.reverse();
			//}
			if (skip!=0 || limit!=null) {
				var c = Math.min(res.length-skip,limit?limit:res.length-skip);
				res = res.splice(skip,c)
			}
		}
		cb(null, res);
	}))
}

tcoll.prototype._find = function (query, fields, skip, limit, sort_, hint, arFields, cb) {
	var self = this;
	this._tq.add(function (cb) {
		self.__find(query, fields, skip, limit, sort_, hint, arFields, cb);
	}, false, cb);
}

function code2fn(obj) {
	if (_.isObject(obj)) {
		_.each(obj,function (value, key) {
			if (value instanceof Code) {
				with (value.scope) {
					obj[key] = eval('(' + value.code + ')');
				}
			}
			else code2fn(value);
		});
	}
}

tcoll.prototype.mapReduce = function (map, reduce, opts, cb) {
	var self = this;
	if (_.isFunction(opts)) {
		cb = opts;
		opts = {};
	}

	if (!opts.out) return safe.back(cb, new Error('the out option parameter must be defined'));
	if (!opts.out.inline && !opts.out.replace) {
		return safe.back(cb, new Error('the only supported out options are inline and replace'));
	}

	code2fn(opts.scope);

	var m = {};

	function emit(k, v) {
		var values = m[k];
		if (!values) m[k] = [ v ];
		else {
			values.push(v);
			if (values.length > 1000) values = [ reduce(k, values) ];
		}
	}

	with (opts.scope || {}) {
		try {
			if (map instanceof Code) {
				with (map.scope) {
					map = eval('(' + map.code + ')');
				}
			} else map = eval('(' + map + ')');
			if (reduce instanceof Code) {
				with (reduce.scope) {
					reduce = eval('(' + reduce.code + ')');
				}
			} else reduce = eval('(' + reduce + ')');
			if (finalize instanceof Code) {
				with (finalize.scope) {
					finalize = eval('(' + finalize.code + ')');
				}
			} else var finalize = eval('(' + opts.finalize + ')');
		} catch (e) {
			return safe.back(cb,e);
		}
	}

	self.find(opts.query, null, { limit: opts.limit, sort: opts.sort }, safe.sure(cb, function (c) {
		var doc;
		safe.doUntil(
			function (cb) {
				c.nextObject(safe.trap_sure(cb, function (_doc) {
					doc = _doc;
					if (doc) map.call(doc);
					return cb();
				}));
			},
			function () {
				return doc === null;
			},
			safe.trap_sure(cb, function () {
				_.each(m,function (v, k) {
					v = v.length > 1 ? reduce(k, v) : v[0];
					if (finalize) v = finalize(k, v);
					m[k] = v;
				});

				var stats = {};
				if (opts.out.inline) return process.nextTick(function () {
					cb(null, _.values(m), stats); // execute outside of trap
				});

				// write results to collection
				safe.waterfall([
					function (cb) {
						self._tdb.collection(opts.out.replace, { strict: 1 }, function (err, col) {
							if (err) return cb(null, null);
							col.drop(cb);
						});
					},
					function (arg, cb) {
						self._tdb.collection(opts.out.replace, {}, cb);
					},
					function (col, cb) {
						var docs = [];
						_.each(m,function (value, key) {
							var doc = {
								_id: key,
								value: value
							};
							docs.push(doc);
						});
						col.insert(docs, safe.sure(cb, function () {
							if (opts.verbose) cb(null, col, stats);
							else cb(null, col);
						}));
					}
				], cb);
			}
		)); // doUntil
	}));
};

tcoll.prototype.group = function (keys, condition, initial, reduce, finalize, command, options, callback) {
	var self = this;

	var args = Array.prototype.slice.call(arguments, 3);
	callback = args.pop();
	reduce = args.length ? args.shift() : null;
	finalize = args.length ? args.shift() : null;
	command = args.length ? args.shift() : null;
	options = args.length ? args.shift() : {};

	if (!_.isFunction(finalize)) {
		command = finalize;
		finalize = null;
	}

	code2fn(options.scope);

	with (options.scope || {}) {
		try {
			if (_.isFunction(keys)) keys = eval('(' + keys + ')');
			else if (keys instanceof Code) {
				with (keys.scope) {
					keys = eval('(' + keys.code + ')');
				}
			}
			if (reduce instanceof Code) {
				with (reduce.scope) {
					reduce = eval('(' + reduce.code + ')');
				}
			} else reduce = eval('(' + reduce + ')');
			if (finalize instanceof Code) {
				with (finalize.scope) {
					finalize = eval('(' + finalize.code + ')');
				}
			} else finalize = eval('(' + finalize + ')');
		} catch (e) {
			return callback(e);
		}
	}

	var m = {};
	self.find(condition, safe.sure(callback, function (c) {
		var doc;
		safe.doUntil(
			function (cb) {
				c.nextObject(safe.sure(cb, function (_doc) {
					doc = _doc;
					if (!doc) return cb();
					var keys2 = keys;
					if (_.isFunction(keys)) keys2 = keys(doc);
					if (!_.isArray(keys2)) {
						var keys3 = [];
						_.each(keys2,function (v, k) {
							if (v) keys3.push(k);
						});
						keys2 = keys3;
					}
					var key = {};
					_.each(keys2,function (k) {
						key[k] = doc[k];
					});
					var skey = JSON.stringify(key);
					var obj = m[skey];
					if (!obj) obj = m[skey] = _.extend({}, key, initial);
					try {
						reduce(doc, obj);
					} catch (e) {
						return cb(e);
					}
					cb();
				}));
			},
			function () {
				return doc === null;
			},
			safe.sure(callback, function () {
				var result = _.values(m);
				if (finalize) {
					_.each(result,function (value) {
						finalize(value);
					});
				}
				callback(null, result);
			})
		);
	}));
};
 at SyntaxError: 'with' in strict mode (1134:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$1.parseWithStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:932:27)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:708:32)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseBlock (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:981:25)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:709:33)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseIfStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:824:28)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:698:30)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":2,"ExpansionArg_type_2":0,"_bound":3}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":1,"ExpansionArg_type_2":2,"_bound":4,"ExpansionArg_int":0} start 47.8644 took 16.048s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":1,"ExpansionArg_type_2":2,"_bound":4,"ExpansionArg_int":0}
* Error: Tropigate failed because SyntaxError: 'with' in strict mode (1134:4) on program var safe = require('safe');
var _ = require('lodash');
var crypto = require('crypto');
var fs = require('fs');
var path = require('path');
var tcursor = require('./tcursor');
var wqueue = require('./wqueue');
var tindex = require('./tindex');
var tcache = require("./tcache");
var Code = require('./tcode').Code;
var tutils = require('./utils');
var Updater = require('./updater');

function tcoll(tdb) {
	var self = this;
	this._tdb = null;
	this._name = null;
	this._store = {};
	this._fd = null;
	this._fsize = null;
	this._id = 1;
	this._wq = new wqueue();
	this._tq = null;
	this._idx = {};
	this._cache = null;
	this._mc = {};
	this._check1 = Math.random()*100+1;
	// native mongo db compatibility attrs
	this.collectionName = null;
	if (tdb._stype=="mem") {
		this.init = this.initM;
		this._put = this._putM;
		this._get = this._getM;
	} else {
		this.init = this.initFS;
		this._put = this._putFS;
		this._get = this._getFS;
	}
}

module.exports = tcoll;

tcoll.prototype.initM = function (tdb, name, options, create, cb) {
	var self= this;
	this._tdb = tdb;
	tdb._mstore = tdb._mstore || {};
	this.collectionName = this._name = name;
	if (options.strict) {
		var exists = tdb._mstore[name];
		if (exists && create) return cb(new Error("Collection " + self._name + " already exists. Currently in safe mode."));
		else if (!exists && !create) return cb(new Error("Collection " + self._name + " does not exist. Currently in safe mode."));
	}
	tdb._mstore[name] = this._mstore = tdb._mstore[name] || [];
	for (var k=0; k< this._mstore.length; k++) {
		var o = this._mstore[k];
		if (o) {
			self._store[simplifyKey(o._id)]={pos:k+1};
		}
	}
	this._tq = new wqueue(100, function (cb) {
		// update indexes
		safe.forEachSeries(_.values(self._store), function (rec, cb) {
			self._get(rec.pos, false, safe.sure(cb, function (obj) {
				var id = simplifyKey(obj._id);
				_.forEach(self._idx,function(v, k) {
					v.set(obj, id);
				});
				cb();
			}));
		}, cb);
	});
	self.ensureIndex({_id: 1}, {name: '_id_', unique: true}, cb);
};

tcoll.prototype.initFS = function (tdb, name, options, create, cb) {
	var self= this;
	this._tdb = tdb;
	this._cache = new tcache(tdb, tdb._gopts.cacheSize);
	this._cmaxobj = tdb._gopts.cacheMaxObjSize || 1024;
	this.collectionName = this._name = name;
	this._filename = path.join(this._tdb._path, this._name);
	if (options.strict) {
		var exists = fs.existsSync(self._filename);
		if (exists && create) return cb(new Error("Collection " + self._name + " already exists. Currently in safe mode."));
		else if (!exists && !create) return cb(new Error("Collection " + self._name + " does not exist. Currently in safe mode."));
	}
	var pos = 0;
	var deleted = 0;
	var found = 0;
	this._tq = new wqueue(100, function (cb) {
		(function (cb) {
			fs.open(self._filename, "a+", safe.sure(cb, function (fd) {
			self._fd = fd;
			var b1 = new Buffer(45);
			safe.whilst(function () { return self._fsize===null; }, function(cb) {
				(function (cb) {
					fs.read(fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {
						if (bytes===0) {
							self._fsize = pos;
							return cb();
						}
						var h1 = JSON.parse(data.toString());
						h1.o = parseInt(h1.o,10);
						h1.k = parseInt(h1.k,10);
						var b2 = new Buffer(h1.k);
						fs.read(fd,b2,0,h1.k,pos+45+1, safe.sure(cb, function (bytes, data) {
							var k = JSON.parse(data.toString());
							self._id = k._uid;
							if (k._a=='del') {
								delete self._store[k._id];
								deleted++;
							} else {
								if (self._store[k._id]) deleted++;
								self._store[k._id] = { pos: pos, sum: k._s };
							}
							pos+=45+3+h1.o+h1.k;
							found++;
							cb();
						}));
					}));
				})(function (err) {
					if (err)
						cb(new Error(self._name+": Error during load - "+err.toString()));
					else
						cb();
				});
			}, cb);
			}));
		})(function (err) {
			if (!found && err)
				return cb(err); // nothing read and error, just rise it
			safe.run(function (cb) {
				var size = _.size(self._store);
				// autocompact on certain ratio or err
				if (deleted > size || err) {
					self._compact(function (errCompact) {
						if (errCompact && err)
							cb(errCompact);
						else {
							if (errCompact) console.log(err);
							cb();
						}
					});
				} else cb();
			}, function () {
				self._refreshIndexes(cb);
			});
		});
	});
	self.ensureIndex({_id: 1}, {name: '_id_', unique: true}, cb);
};

tcoll.prototype.compactCollection = function (cb) {
	var self = this;
	self._tq.add(function (cb) {
		self._compact(safe.sure(cb, function () {
			self._cache.clear();
			self._refreshIndexes(cb);
		}));
	}, true, cb);
};

tcoll.prototype._refreshIndexes = function (cb) {
	var self = this;
	_.forEach(self._idx,function(v, k) {
		v.clear();
	});
	safe.forEachSeries(_.values(self._store), function (rec, cb) {
		self._get(rec.pos, false, safe.sure(cb, function (obj) {
			var id = simplifyKey(obj._id);
			_.forEach(self._idx,function(v, k) {
				v.set(obj, id);
			});
			cb();
		}));
	}, cb);
};

tcoll.prototype._compact = function (cb) {
	var self = this;
	var filename = self._filename + '.compact';
	fs.open(filename, 'w+', safe.sure(cb, function (fd) {
		var b1 = new Buffer(45);
		function get(pos, cb) {
			fs.read(self._fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {
				var h1 = JSON.parse(data.toString());
				h1.o = parseInt(h1.o, 10);
				h1.k = parseInt(h1.k, 10);
				var b2 = new Buffer(h1.k + h1.o + 3);
				fs.read(self._fd, b2, 0, b2.length, pos + 45, safe.sure(cb, function (bytes, data) {
					cb(null, Buffer.concat([ b1, b2 ]));
				}));
			}));
		}
		var wpos = 0;
		var store = {};
		safe.forEachSeries(_.keys(self._store), function (k, cb) {
			var rec = self._store[k];
			get(rec.pos, safe.sure(cb, function (data) {
				fs.write(fd, data, 0, data.length, wpos, safe.sure(cb, function (written) {
					if (written != data.length) return cb(new Error('Insufficient disk space'));
					store[k] = { pos: wpos, sum: rec.sum };
					wpos += data.length;
					cb();
				}));
			}));
		}, function (err) {
			if (err) {
				fs.close(fd, function () {
					fs.unlink(filename, function () {
						cb(err);
					});
				});
				return;
			}
			if (!!process.platform.match(/^win/)) {
				// WINDOWS: unsafe because if something fail while renaming file it will not
				// restore automatically
				fs.close(self._fd, safe.sure(cb,function() {
					fs.close(fd, safe.sure(cb,function() {
						fs.unlink(self._filename, safe.sure(cb,function () {
							fs.rename(filename, self._filename, safe.sure(cb, function () {
								fs.open(self._filename, 'a+', safe.sure(cb, function (fd) {
									self._fd = fd;
									self._fsize = wpos;
									self._store = store;
									cb();
								}));
							}));
						}));
					}));
				}));
		    } else {
				// safe way
				fs.rename(filename, self._filename, safe.sure(cb, function () {
					fs.close(self._fd);
					self._fd = fd;
					self._fsize = wpos;
					self._store = store;
					cb();
				}));
			}
		});
	}));
};

tcoll.prototype.drop = function (cb) {
	this._tdb.dropCollection(this._name,cb);
};

tcoll.prototype.rename = function (nname, opts, cb) {
	var self = this;
	if (_.isFunction(opts)) {
		cb = opts;
		opts = {};
	}
	var err = self._tdb._nameCheck(nname);
	if (err)
		return safe.back(cb,err);
	if (self._tdb._stype=="mem") {
		delete self._tdb._cols[self._name];
		self._tdb._cols[nname] = self;
		delete self._tdb._mstore[self._name];
		self._tdb._mstore[nname] = self._mstore;
		safe.back(cb,null);
	} else {
		self._tq.add(function (cb) {
			fs.rename(path.join(self._tdb._path,self._name),path.join(self._tdb._path,nname),safe.sure(cb, function () {
				delete self._tdb._cols[self._name];
				self._tdb._cols[nname] = self;
				self.collectionName = self._name = nname;
				cb();
			}));
		},true,cb);
	}
};

tcoll.prototype._stop = function (cb) {
	var self = this;
	self._tq.add(function (cb) {
		// this will prevent any tasks processed on this instance
		self._tq._stoped = true;
		if (self._fd) {
			fs.close(self._fd,safe.sure(cb, function () {
				cb(null,true);
			}));
		} else
			cb(null,false);
	},true,cb);
};

tcoll.prototype.createIndex = tcoll.prototype.ensureIndex = function (obj, options, cb) {
	var self = this;
	if (_.isFunction(options)) {
		cb = options;
		options = {};
	}
	cb = cb || function () {};
	options = options || {};

	var c = new tcursor(this,{},{},{});
	c.sort(obj);
	if (c._err)
		return safe.back(cb,c._err);
	var key = c._sort;

	if (key===null)
		return safe.back(cb,new Error("No fields are specified"));

	var index = self._idx[key];
	if (index)
		return safe.back(cb,null, index.name);

	// force array support when global option is set
	if (_.isUndefined(options._tiarr) && self._tdb._gopts.searchInArray)
		options._tiarr = true;

	var name = options.name || _.map(key, function (v) { return v[0] + '_' + v[1]; }).join('_');
	index = new tindex(key, self, options, name);

	if (self._tq._tc==-1) {
		// if no operation is pending just register index
		self._idx[key] = index;
		safe.back(cb, null, index.name);
	}
	else {
		// overwise register index operation
		this._tq.add(function (cb) {
			var range = _.values(self._store);
			safe.forEachSeries(range, function (rec, cb) {
				self._get(rec.pos, false, safe.sure(cb, function (obj) {
					index.set(obj,simplifyKey(obj._id));
					cb();
				}));
			}, safe.sure(cb, function () {
				self._idx[key] = index;
				cb();
			}));
		}, true, function (err) {
			if (err) cb(err);
			else cb(null, index.name);
		});
	}
};

tcoll.prototype.indexExists = function (idx, cb) {
	if (!_.isArray(idx))
		idx = [idx];
	var i = _.intersection(idx,_(this._idx).values().map('name').value());
	cb(null,i.length == idx.length);
};

tcoll.prototype.indexes = function (cb) {
	var self = this;
	this._tq.add(function (cb) {
		cb(null, _.values(self._idx));
	},false,cb);
};

tcoll.prototype._getM = function (pos, unsafe, cb) {
	safe.back(cb,null,unsafe?this._mstore[pos-1]:this._tdb._cloneDeep(this._mstore[pos-1]));
};

tcoll.prototype._getFS = function (pos, unsafe, cb) {
	var self = this;
	var cached = self._cache.get(pos,unsafe);
	if (cached)
		return safe.back(cb,null,cached);
	var b1 = new Buffer(45);
	fs.read(self._fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {
		var h1 = JSON.parse(data.toString());
		h1.o = parseInt(h1.o,10);
		h1.k = parseInt(h1.k,10);
		var b2 = new Buffer(h1.o);
		fs.read(self._fd,b2,0,h1.o,pos+45+2+h1.k, safe.trap_sure(cb, function (bytes, data) {
			var obj = self._unwrapTypes(JSON.parse(data.toString()));
			if (bytes <= self._cmaxobj)
				self._cache.set(pos, obj);
			cb(null,obj);
		}))
	}))
}

tcoll.prototype.insert = function (docs, opts, cb ) {
	var self = this;
	if (_.isFunction(opts) && cb == null) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	if (opts.w>0 && !_.isFunction(cb))
		throw new Error("Callback is required for safe update");
	cb = cb || function () {};
	if (!_.isArray(docs))
		docs = [docs];
	this._tq.add(function (cb) {
		safe.forEachSeries(docs, function (doc, cb) {
			if (_.isUndefined(doc._id)) {
				doc._id = new self._tdb.ObjectID();
			}
			self._put(doc, false, cb);
		}, safe.sure(cb, function () {
			cb(null, docs);
		}))
	}, true, cb)
}

tcoll.prototype._wrapTypes = function(obj) {
	var self = this;
	_.each(obj, function (v,k) {
		if (_.isDate(v))
			obj[k] = {$wrap:"$date",v:v.valueOf(),h:v}
		else if (v instanceof self._tdb.ObjectID)
			obj[k] = {$wrap:"$oid",v:v.toJSON()}
		else if (v instanceof self._tdb.Binary)
			obj[k] = {$wrap: "$bin", v: v.toJSON()};
		else if (_.isObject(v))
			self._wrapTypes(v)

	})
	return obj;
}

tcoll.prototype._ensureIds = function(obj) {
	var self = this;
	_.each(obj, function (v,k) {
		if (k.length >0) {
			if (k[0]=='$')
				throw new Error("key "+k+" must not start with '$'");;
			if (k.indexOf('.')!=-1)
				throw new Error("key "+k+" must not contain '.'");
		}
		if (_.isObject(v)) {
			if (v instanceof self._tdb.ObjectID) {
				if (v.id<0) {
					v._persist(++self._id)
				}
			}
			else
				self._ensureIds(v)
		}
	})
	return obj;
}


tcoll.prototype._unwrapTypes = function(obj) {
	var self = this;
	_.each(obj, function (v,k) {
		if (_.isObject(v)) {
			switch (v.$wrap) {
				case "$date": obj[k] = new Date(v.v); break;
				case "$oid":
					var oid = new self._tdb.ObjectID(v.v);
					obj[k]=oid;
				break;
				case "$bin":
					var bin = new self._tdb.Binary(new Buffer(v.v, 'base64'));
					obj[k] = bin;
				break;
				default: self._unwrapTypes(v);
			}
		}
	})
	return obj;
}

tcoll.prototype._putM = function (item_, remove, cb) {
	var item = this._tdb._cloneDeep(item_);
	var self = this;
	self._wq.add(function (cb) {
		try {
			item = self._ensureIds(item);
		} catch (err) {
			err.errmsg = err.toString();
			return cb(err)
		}
		if (_.isUndefined(item._id))
			return cb(new Error("Invalid object key (_id)"));

		var key = {_id:simplifyKey(item._id)};

		// check index update
		if (item && !remove) {
			try {
				_.forEach(self._idx,function(v,k) {
					v.set(item,key._id,true);
				})
			} catch (err) {
				err.errmsg = err.toString();
				return cb(err)
			}
		}

		if (remove) {
			self._mstore[self._store[key._id].pos-1]=null;
			delete self._store[key._id];
		}
		else {
			if (self._store[key._id]) {
				self._mstore[self._store[key._id].pos-1] = item;
			} else {
				self._mstore.push(item);
				self._store[key._id] = {pos: self._mstore.length};
			}
		}

		// update index
		_.forEach(self._idx,function(v,k) {
			if (!remove)
				v.set(item,key._id);
			else
				v.del(item,key._id);
		})
		cb(null);
	}, true, cb);
}


tcoll.prototype._putFS = function (item, remove, cb) {
	var self = this;
	self._wq.add(function (cb) {
		try {
			item = self._ensureIds(item);
		} catch (err) {
			err.errmsg = err.toString();
			return cb(err)
		}
		if (_.isUndefined(item._id))
			return cb(new Error("Invalid object key (_id)"));
		item = self._wrapTypes(item);
		var sobj = new Buffer(remove?"":JSON.stringify(item));
		item = self._unwrapTypes(item);
		var key = {_id:simplifyKey(item._id),_uid:self._id,_dt:(new Date()).valueOf()};
		if (remove) key._a = "del";
		else {
			var hash = crypto.createHash('md5');
			hash.update(sobj, 'utf8');
			key._s = hash.digest('hex');
		}
		var skey = new Buffer(JSON.stringify(key));
		var zeros = "0000000000";
		var lobj = sobj.length.toString();
		var lkey = skey.length.toString();
		lobj = zeros.substr(0,zeros.length - lobj.length)+lobj;
		lkey = zeros.substr(0,zeros.length - lkey.length)+lkey;
		var h1={k:lkey,o:lobj,v:"001"};
		var buf = new Buffer(JSON.stringify(h1)+"\n"+skey+"\n"+sobj+"\n");

		// check index update
		if (item && !remove) {
			try {
				_.forEach(self._idx,function(v,k) {
					v.set(item,key._id,true);
				})
			} catch (err) {
				err.errmsg = err.toString();
				return cb(err)
			}
		}

		safe.run(function (cb) {
			var rec = self._store[key._id];
			if (rec && rec.sum == key._s) return safe.back(cb);
			fs.write(self._fd, buf, 0, buf.length, self._fsize, safe.sure(cb, function (written) {
				if (remove)
					delete self._store[key._id];
				else
					self._store[key._id] = { pos: self._fsize, sum: key._s };

				if (remove || sobj.length > self._cmaxobj)
					self._cache.unset(self._fsize)
				else
					self._cache.set(self._fsize,item);
				self._fsize+=written;
				// randomly check for non exclusive file usage
				// which is growth of file that we are nor aware
				// randomly to avoid overhead
				if (self._check1==0) {
					this._check1 = Math.random()*100+1;
					fs.fstat(self._fd, safe.sure(cb, function (stat) {
						if (self._fsize!=stat.size)
							cb(new Error("File size mismatch. Are you use db/collection exclusively?"))
						else
							cb()
					}))
				} else {
					self._check1--;
					cb();
				}
			}));
		},
		function () {
			// update index
			_.forEach(self._idx,function(v,k) {
				if (!remove)
					v.set(item,key._id);
				else
					v.del(item,key._id);
			})
			cb(null);
		});
	}, true, cb);
}

tcoll.prototype.count = function (query, options, cb) {
	var self = this;
	if (arguments.length == 1) {
		cb = arguments[0];
        options = null;
		query = null;
	}
	if (arguments.length == 2) {
        query = arguments[0];
		cb = arguments[1];
        options = null;
	}
	if (query==null || _.size(query)==0) {
		this._tq.add(function (cb) {
			cb(null, _.size(self._store));
		},false,cb);
	} else
		self.find(query, options).count(cb);
}

tcoll.prototype.stats = function (cb) {
	var self = this;
	this._tq.add(function (cb) {
		cb(null, {count:_.size(self._store)});
	},false,cb);
}


var findOpts = ['limit','sort','fields','skip','hint','timeout','batchSize','safe','w'];

tcoll.prototype.findOne = function () {
	var findArgs = Array.prototype.slice.call(arguments,0,arguments.length-1);
	var cb = arguments[arguments.length-1];
	this.find.apply(this,findArgs).limit(1).nextObject(cb);
}

tcoll.prototype.find = function () {
	var cb = null, query = {}, opts = {}, fields = null, skip = null, limit = null, sort = null;
	var argc = arguments.length;
	if (argc>0) {
		// guess callback, it is always latest
		cb = arguments[argc-1];
		if (!_.isFunction(cb))
			cb=null
		else
			argc--;
		if (argc>0) {
			// query should always exist
			query = arguments[0]
			if (argc>1) {
				if (argc==2) {
					var val = arguments[1];
					// worst case we get either options either fiels
					if (_.intersection(_.keys(val),findOpts).length!=0)
						opts = val
					else
						fields = val;
				} else {
					fields = arguments[1];
					if (argc == 3)
						opts = arguments[2]
					else {
						skip = arguments[2];
						limit = arguments[3]
					}
				}
			}
		}
	}

	opts = opts || {};
	skip = skip || opts.skip || null;
	limit = limit || opts.limit || null;
	fields = fields || opts.fields || null;
	sort = sort || opts.sort || null;


	var c = new tcursor(this,query, fields, opts);

	if (skip) c.skip(skip);
	if (limit) c.limit(limit);
	if (sort) c.sort(sort);
	if (cb)
		cb(null, c)
	else
		return c;
}


function simplifyKey(key) {
	var k = key;
	if (key.toJSON)
		k = key.toJSON();
	if (_.isNumber(k)||_.isString(k))
		return k;
	return k.toString();
}

tcoll.prototype.update = function (query, doc, opts, cb) {
	var self = this;
	if (_.isFunction(opts) && cb == null) {
		cb = opts;
	}
	opts = opts || {};
	if (opts.w>0 && !_.isFunction(cb))
		throw new Error("Callback is required for safe update");
	cb = cb || function () {}
	if (!_.isObject(query))
		throw new Error("selector must be a valid JavaScript object");
	if (!_.isObject(doc))
		throw new Error("document must be a valid JavaScript object");

	var multi = opts.multi || false;
    var updater = new Updater(doc, self._tdb);
	var $doc = updater.hasAtomic()?null:doc;
	this._tq.add(function (cb) {
		self.__find(query, null, 0, multi ? null : 1, null, opts.hint, {}, safe.sure(cb, function (res) {
			if (res.length==0) {
				if (opts.upsert) {
					$doc = $doc || query;
					$doc = self._tdb._cloneDeep($doc);
					updater.update($doc,true);
					if (_.isUndefined($doc._id))
						$doc._id = new self._tdb.ObjectID();
					self._put($doc, false, safe.sure(cb, function () {
						cb(null, 1,{updatedExisting:false,upserted:$doc._id,n:1})
					}))
				} else
					cb(null,0);
			} else {
				safe.forEachSeries(res, function (pos, cb) {
					self._get(pos, false, safe.sure(cb, function (obj) {
						// remove current version of doc from indexes
						_.forEach(self._idx,function(v,k) {
							v.del(obj,simplifyKey(obj._id));
						})
						var udoc = $doc;
						if (!$doc) {
							udoc = obj;
							updater.update(udoc);
						}
						udoc._id = obj._id;
						// put will add it back to indexes
						self._put(udoc, false, cb);
					}))
				}, safe.sure(cb,function () {
					cb(null, res.length, {updatedExisting:true,n:res.length});
				}))
			}
		}))
	},true,cb);
}

tcoll.prototype.findAndModify = function (query, sort, doc, opts, cb) {
	var self = this;
	if (_.isFunction(opts) && cb == null) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	doc = doc || {};

	var updater = new Updater(doc, self._tdb);
	var $doc = updater.hasAtomic()?null:doc;

	var c = new tcursor(this,{}, opts.fields || {},{});
	c.sort(sort);
	if (c._err)
		return safe.back(cb,c._err);

	this._tq.add(function (cb) {
		self.__find(query, null, 0, 1, c._sort, opts.hint, {}, safe.sure(cb, function (res) {
			if (res.length==0) {
				if (opts.upsert) {
					$doc = $doc || query;
					$doc = self._tdb._cloneDeep($doc);
					updater.update($doc,true);
					if (_.isUndefined($doc._id))
						$doc._id = new self._tdb.ObjectID();
					self._put($doc, false, safe.sure(cb, function () {
						cb(null,opts.new?c._projectFields($doc):{})
					}))
				} else
					cb();
			} else {
				self._get(res[0], false, safe.sure(cb, function (obj) {
					var robj = (opts.new && !opts.remove) ? obj : self._tdb._cloneDeep(obj);
					// remove current version of doc from indexes
					_.forEach(self._idx,function(v,k) {
						v.del(obj,simplifyKey(obj._id));
					})
					var udoc = $doc;
					if (!$doc) {
						udoc = obj;
						updater.update(udoc);
					}
					udoc._id = obj._id;
					// put will add it back to indexes
					self._put(udoc, opts.remove?true:false, safe.sure(cb,function () {
						cb(null,c._projectFields(robj))
					}))
				}))
			}
		}))
	},true,cb);
}

tcoll.prototype.save = function (doc, opts, cb) {
	var self = this;
	cb = _.isFunction(doc)?doc:_.isFunction(opts)?opts:cb;
	cb = cb || function () {};
	doc = doc || {};
	opts = opts || {};
	this._tq.add(function (cb) {
		var res = doc;
		(function(cb) {
			if (_.isUndefined(doc._id)) {
				doc._id = new self._tdb.ObjectID();
				cb()
			} else {
				var id = simplifyKey(doc._id);
				var pos = self._store[id];
				// check if document with this id already exist
				if (pos) {
					// if so we need to fetch it to update index
					self._get(pos.pos, false, safe.sure(cb, function (oldDoc) {
						// remove current version of doc from indexes
						_.forEach(self._idx,function(v,k) {
							v.del(oldDoc,id);
						})
						res = 1;
						cb();
					}))
				} else cb();
			}
		})(safe.sure(cb, function () {
			self._put(doc, false, safe.sure(cb, function () {
				cb(null,res); // when update return 1 when new save return obj
			}))
		}))
	},true,cb);
}

tcoll.prototype.remove = function (query, opts, cb) {
	var self = this;
	if (_.isFunction(query)) {
		cb = query;
		query = opts = {};
	} else if (_.isFunction(opts)) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	if (opts.w>0 && !_.isFunction(cb))
		throw new Error("Callback is required");
	cb = cb || function () {};
	var single = opts.single || false;
	this._tq.add(function (cb) {
		self.__find(query, null, 0, single ? 1 : null, null, opts.hint, {}, safe.sure(cb, function (res) {
			safe.forEachSeries(res, function (pos, cb) {
				self._get(pos, false, safe.sure(cb, function (obj) {
					self._put(obj,true,cb);
				}))
			}, safe.sure(cb, function () {
				cb(null,res.length);
			}))
		}))
	},true,cb);
}

tcoll.prototype.findAndRemove = function (query,sort,opts,cb) {
	var self = this;

	if (_.isFunction(sort) && cb == null && opts==null) {
		cb = sort;
		sort = {}
		opts = {};
	} else if (_.isFunction(opts) && cb == null) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	sort = sort || {};

	var c = new tcursor(this,{},{},{});

	// Fix for mongoouse/tungus they pass sort as undefined
	c.sort(sort);

	if (c._err)
		return safe.back(cb,c._err);

	this._tq.add(function (cb) {
		self.__find(query, null, 0, 1, c._sort, opts.hint, {}, safe.sure(cb, function (res) {
			if (res.length==0)
				return cb();
			self._get(res[0], false, safe.sure(cb, function (obj) {
				self._put(obj,true,safe.sure(cb, function () {
					cb(null,obj);
				}))
			}))
		}))
	},true,cb);
}

tcoll.prototype._bestSortIndex = function (sort) {
	// no sort
	if (!sort) return null;
	// exact match
	if (this._idx[sort]) return this._idx[sort];
	// find potential sort indexes
	var pi = [];
	_.forEach(this._idx,function (idx) {
		var fields = idx.fields();
		var match = _.takeWhile(fields, function (kv, i) {
			return i < sort.length ? kv[0] == sort[i][0] : false;
		});
		if (match.length == sort.length) {
			var score = fields.length;
			_.forEach(sort,function (kv, i) {
				if (kv[1] != fields[i][1]) score += 1;
			});
			pi.push({ value: idx, score: score });
		}
	});
	if (pi.length === 0) return null;
	// select best index
	pi = pi.sort(function (l, r) { return l.score < r.score; });
	return pi[0].value;
};

function reduceIndexSet(pi) {
	var hit;
	do {
		hit = false;
		// compare each potential index with each other
		_.forEach(pi,function (v1, i1) {
			_.forEach(pi,function (v2, i2) {
				if (i1 == i2) return;
				// compare the set of possible keys for both indexes
				if (_.union(v1.k, v2.k).length == v1.k.length) {
					// key for v2 is a subset of key for v1, check equality
					if (v1.k.length == v2.k.length && v1.i.depth() > v2.i.depth()) {
						// keys are equal, but the depth of v2 is lower;
						// v2 is preferable, strike out v1
						pi.splice(i1, 1);
					} else {
						// in other two cases v1 is preferable, strike out v2
						pi.splice(i2, 1);
					}
					hit = true;
					return false;
				}
			});
			if (hit) return false;
		});
	} while (hit);
};

tcoll.prototype.__find = function (query, fields, skip, limit, sort, hint, arFields, cb) {
	var self = this;
	var range = [];
	// find sort index
	var si = this._bestSortIndex(sort);
	// for non empty query check indexes that we can use
	var qt = self._tdb.Finder.matcher(query);
	var pi = [];
	if (_.size(qt)>0) {
		_.forEach(self._idx,function (i) {
			var f = _.pluck(i.fields(), 0);
			var e = _.takeWhile(f, function (k) {
				return qt._ex(k) == 1 && (!hint || hint[k]);
			});
			if (e.length > 0) pi.push({ i: i, k: e, e: f.length > e.length });
		});
	}

	// if possible indexes found split the query and process
	// indexes separately
	if (!_.isEmpty(pi)) {
		// choose the most appropriate indexes
		reduceIndexSet(pi);
		// split query
		var io = {};
		_.forEach(pi,function (v) {
			_.forEach(v.k,function (k) {
				if (!io[k]) io[k] = qt.split(k);
			});
		});
		// process indexes
		var p = [];
		_.forEach(pi,function (st) {
			// this action applies to all indexes
			var r = io[st.k[0]]._index(st.i);
			// process subfields of compound index
			_.forEach(st.k.slice(1),function (k) {
				var v = io[k];
				r = _.flatten(_.map(r, function (si) { return v._index(si); }));
			});
			// expand subindexes to plain ids
			if (st.e) r = _.flatten(_.map(r, function (si) { return si.all(); }));
			// store result of index search
			p.push(r);
		});
		if (p.length == 1) {
			p = p[0];
			// optimization for the case when search and sorting indexes are the same
			if (si && pi[0].i === si) {
				var sif = si.fields();
				if (_.every(sort, function (v, i) { return sif[i][1] == v[1]; })) {
					// sort order exactly matches index order,
					// so the result is already sorted
					sort = null;
				} else if (_.every(sort, function (v, i) { return sif[i][1] == -v[1]; })) {
					// sort order is exactly opposite to index order,
					// so the result is sorted, but in reverse direction
					p.reverse();
					sort = null;
				}
			}
		} else {
			// TODO: use sort index as intersect base to speedup sorting
			p = tutils.intersectIndexes(p);
		}
		// nowe we have ids, need to convert them to positions
		_.forEach(p,function (_id) {
			range.push(self._store[_id].pos)
		})
	} else {
		if (si) {
			_.each(si.all(_.pluck(sort, 1)), function (_id) {
				range.push(self._store[_id].pos)
			})
			//if (order==-1)
			//	range.reverse();
			sort = null;
		} else
			range = _.values(self._store).map(function (rec) { return rec.pos; });
	}

	if (sort && si) {
		var ps = {};
		_.each(range,function (pos) {
			ps[pos] = true;
		});
		range = [];
		_.each(si.all(_.pluck(sort, 1)),function (_id) {
			var pos = self._store[_id].pos;
			if (_.has(ps,pos)) range.push(pos);
		});
		//if (order == -1)
		//	range.reverse();
		sort = null;
	}

	// no sort, no query then return right away
	if (sort==null && (_.size(qt)==0 || qt._args.length==0)) {
		if (skip!=0 || limit!=null) {
			var c = Math.min(range.length-skip,limit?limit:range.length-skip);
			range = range.splice(skip,c)
		}
		return safe.back(cb,null,range);
	}

	var matcher = null;
	// check if we can use simple match or array match function
	var arrayMatch = false;
	if (self._tdb._gopts.searchInArray)
		arrayMatch = true;
	else {
		var fields = qt.fields();
		_.each(fields, function (v,k) {
			if (arFields[k])
				arrayMatch = true;
		})
	}

	eval("matcher = function (obj) { return "+ (arrayMatch?qt.native3():qt.native()) + " }");

	// create sort index
	if (sort) {
		si = new tindex(sort,self);
	}

	// now simple non-index search
	var res = [];
	var found = 0;
	safe.forEachSeries(range, function (pos, cb) {
		if (sort==null && limit && res.length>=limit)
			return safe.back(cb);
		self._get(pos, true, safe.sure(cb, function (obj) {
			if (matcher(obj)) {
				if (sort!=null || found>=skip) {
					if (sort==null)
						res.push(pos);
					else
						si.set(obj,pos);
				}
				found++;
			}
			cb()
		}))
	}, safe.sure(cb, function () {
		if (sort) {
			res = si.all();
			//if (order==-1) {
			//	res.reverse();
			//}
			if (skip!=0 || limit!=null) {
				var c = Math.min(res.length-skip,limit?limit:res.length-skip);
				res = res.splice(skip,c)
			}
		}
		cb(null, res);
	}))
}

tcoll.prototype._find = function (query, fields, skip, limit, sort_, hint, arFields, cb) {
	var self = this;
	this._tq.add(function (cb) {
		self.__find(query, fields, skip, limit, sort_, hint, arFields, cb);
	}, false, cb);
}

function code2fn(obj) {
	if (_.isObject(obj)) {
		_.each(obj,function (value, key) {
			if (value instanceof Code) {
				with (value.scope) {
					obj[key] = eval('(' + value.code + ')');
				}
			}
			else code2fn(value);
		});
	}
}

tcoll.prototype.mapReduce = function (map, reduce, opts, cb) {
	var self = this;
	if (_.isFunction(opts)) {
		cb = opts;
		opts = {};
	}

	if (!opts.out) return safe.back(cb, new Error('the out option parameter must be defined'));
	if (!opts.out.inline && !opts.out.replace) {
		return safe.back(cb, new Error('the only supported out options are inline and replace'));
	}

	code2fn(opts.scope);

	var m = {};

	function emit(k, v) {
		var values = m[k];
		if (!values) m[k] = [ v ];
		else {
			values.push(v);
			if (values.length > 1000) values = [ reduce(k, values) ];
		}
	}

	with (opts.scope || {}) {
		try {
			if (map instanceof Code) {
				with (map.scope) {
					map = eval('(' + map.code + ')');
				}
			} else map = eval('(' + map + ')');
			if (reduce instanceof Code) {
				with (reduce.scope) {
					reduce = eval('(' + reduce.code + ')');
				}
			} else reduce = eval('(' + reduce + ')');
			if (finalize instanceof Code) {
				with (finalize.scope) {
					finalize = eval('(' + finalize.code + ')');
				}
			} else var finalize = eval('(' + opts.finalize + ')');
		} catch (e) {
			return safe.back(cb,e);
		}
	}

	self.find(opts.query, null, { limit: opts.limit, sort: opts.sort }, safe.sure(cb, function (c) {
		var doc;
		safe.doUntil(
			function (cb) {
				c.nextObject(safe.trap_sure(cb, function (_doc) {
					doc = _doc;
					if (doc) map.call(doc);
					return cb();
				}));
			},
			function () {
				return doc === null;
			},
			safe.trap_sure(cb, function () {
				_.each(m,function (v, k) {
					v = v.length > 1 ? reduce(k, v) : v[0];
					if (finalize) v = finalize(k, v);
					m[k] = v;
				});

				var stats = {};
				if (opts.out.inline) return process.nextTick(function () {
					cb(null, _.values(m), stats); // execute outside of trap
				});

				// write results to collection
				safe.waterfall([
					function (cb) {
						self._tdb.collection(opts.out.replace, { strict: 1 }, function (err, col) {
							if (err) return cb(null, null);
							col.drop(cb);
						});
					},
					function (arg, cb) {
						self._tdb.collection(opts.out.replace, {}, cb);
					},
					function (col, cb) {
						var docs = [];
						_.each(m,function (value, key) {
							var doc = {
								_id: key,
								value: value
							};
							docs.push(doc);
						});
						col.insert(docs, safe.sure(cb, function () {
							if (opts.verbose) cb(null, col, stats);
							else cb(null, col);
						}));
					}
				], cb);
			}
		)); // doUntil
	}));
};

tcoll.prototype.group = function (keys, condition, initial, reduce, finalize, command, options, callback) {
	var self = this;

	var args = Array.prototype.slice.call(arguments, 3);
	callback = args.pop();
	reduce = args.length ? args.shift() : null;
	finalize = args.length ? args.shift() : null;
	command = args.length ? args.shift() : null;
	options = args.length ? args.shift() : {};

	if (!_.isFunction(finalize)) {
		command = finalize;
		finalize = null;
	}

	code2fn(options.scope);

	with (options.scope || {}) {
		try {
			if (_.isFunction(keys)) keys = eval('(' + keys + ')');
			else if (keys instanceof Code) {
				with (keys.scope) {
					keys = eval('(' + keys.code + ')');
				}
			}
			if (reduce instanceof Code) {
				with (reduce.scope) {
					reduce = eval('(' + reduce.code + ')');
				}
			} else reduce = eval('(' + reduce + ')');
			if (finalize instanceof Code) {
				with (finalize.scope) {
					finalize = eval('(' + finalize.code + ')');
				}
			} else finalize = eval('(' + finalize + ')');
		} catch (e) {
			return callback(e);
		}
	}

	var m = {};
	self.find(condition, safe.sure(callback, function (c) {
		var doc;
		safe.doUntil(
			function (cb) {
				c.nextObject(safe.sure(cb, function (_doc) {
					doc = _doc;
					if (!doc) return cb();
					var keys2 = keys;
					if (_.isFunction(keys)) keys2 = keys(doc);
					if (!_.isArray(keys2)) {
						var keys3 = [];
						_.each(keys2,function (v, k) {
							if (v) keys3.push(k);
						});
						keys2 = keys3;
					}
					var key = {};
					_.each(keys2,function (k) {
						key[k] = doc[k];
					});
					var skey = JSON.stringify(key);
					var obj = m[skey];
					if (!obj) obj = m[skey] = _.extend({}, key, initial);
					try {
						reduce(doc, obj);
					} catch (e) {
						return cb(e);
					}
					cb();
				}));
			},
			function () {
				return doc === null;
			},
			safe.sure(callback, function () {
				var result = _.values(m);
				if (finalize) {
					_.each(result,function (value) {
						finalize(value);
					});
				}
				callback(null, result);
			})
		);
	}));
};
 at SyntaxError: 'with' in strict mode (1134:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$1.parseWithStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:932:27)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:708:32)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseBlock (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:981:25)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:709:33)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseIfStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:824:28)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:698:30)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"Switcher":true,"ExpansionArg_type":1,"ExpansionArg_type_2":2,"_bound":4}'
*-- Test Case {"Switcher":true,"ExpansionArg_type":0,"ExpansionArg_type_2":2,"_bound":4,"ExpansionArg_int":0} start 47.7462 took 16.8277s
*-- Errors occured in test {"Switcher":true,"ExpansionArg_type":0,"ExpansionArg_type_2":2,"_bound":4,"ExpansionArg_int":0}
* Error: Tropigate failed because SyntaxError: 'with' in strict mode (1134:4) on program var safe = require('safe');
var _ = require('lodash');
var crypto = require('crypto');
var fs = require('fs');
var path = require('path');
var tcursor = require('./tcursor');
var wqueue = require('./wqueue');
var tindex = require('./tindex');
var tcache = require("./tcache");
var Code = require('./tcode').Code;
var tutils = require('./utils');
var Updater = require('./updater');

function tcoll(tdb) {
	var self = this;
	this._tdb = null;
	this._name = null;
	this._store = {};
	this._fd = null;
	this._fsize = null;
	this._id = 1;
	this._wq = new wqueue();
	this._tq = null;
	this._idx = {};
	this._cache = null;
	this._mc = {};
	this._check1 = Math.random()*100+1;
	// native mongo db compatibility attrs
	this.collectionName = null;
	if (tdb._stype=="mem") {
		this.init = this.initM;
		this._put = this._putM;
		this._get = this._getM;
	} else {
		this.init = this.initFS;
		this._put = this._putFS;
		this._get = this._getFS;
	}
}

module.exports = tcoll;

tcoll.prototype.initM = function (tdb, name, options, create, cb) {
	var self= this;
	this._tdb = tdb;
	tdb._mstore = tdb._mstore || {};
	this.collectionName = this._name = name;
	if (options.strict) {
		var exists = tdb._mstore[name];
		if (exists && create) return cb(new Error("Collection " + self._name + " already exists. Currently in safe mode."));
		else if (!exists && !create) return cb(new Error("Collection " + self._name + " does not exist. Currently in safe mode."));
	}
	tdb._mstore[name] = this._mstore = tdb._mstore[name] || [];
	for (var k=0; k< this._mstore.length; k++) {
		var o = this._mstore[k];
		if (o) {
			self._store[simplifyKey(o._id)]={pos:k+1};
		}
	}
	this._tq = new wqueue(100, function (cb) {
		// update indexes
		safe.forEachSeries(_.values(self._store), function (rec, cb) {
			self._get(rec.pos, false, safe.sure(cb, function (obj) {
				var id = simplifyKey(obj._id);
				_.forEach(self._idx,function(v, k) {
					v.set(obj, id);
				});
				cb();
			}));
		}, cb);
	});
	self.ensureIndex({_id: 1}, {name: '_id_', unique: true}, cb);
};

tcoll.prototype.initFS = function (tdb, name, options, create, cb) {
	var self= this;
	this._tdb = tdb;
	this._cache = new tcache(tdb, tdb._gopts.cacheSize);
	this._cmaxobj = tdb._gopts.cacheMaxObjSize || 1024;
	this.collectionName = this._name = name;
	this._filename = path.join(this._tdb._path, this._name);
	if (options.strict) {
		var exists = fs.existsSync(self._filename);
		if (exists && create) return cb(new Error("Collection " + self._name + " already exists. Currently in safe mode."));
		else if (!exists && !create) return cb(new Error("Collection " + self._name + " does not exist. Currently in safe mode."));
	}
	var pos = 0;
	var deleted = 0;
	var found = 0;
	this._tq = new wqueue(100, function (cb) {
		(function (cb) {
			fs.open(self._filename, "a+", safe.sure(cb, function (fd) {
			self._fd = fd;
			var b1 = new Buffer(45);
			safe.whilst(function () { return self._fsize===null; }, function(cb) {
				(function (cb) {
					fs.read(fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {
						if (bytes===0) {
							self._fsize = pos;
							return cb();
						}
						var h1 = JSON.parse(data.toString());
						h1.o = parseInt(h1.o,10);
						h1.k = parseInt(h1.k,10);
						var b2 = new Buffer(h1.k);
						fs.read(fd,b2,0,h1.k,pos+45+1, safe.sure(cb, function (bytes, data) {
							var k = JSON.parse(data.toString());
							self._id = k._uid;
							if (k._a=='del') {
								delete self._store[k._id];
								deleted++;
							} else {
								if (self._store[k._id]) deleted++;
								self._store[k._id] = { pos: pos, sum: k._s };
							}
							pos+=45+3+h1.o+h1.k;
							found++;
							cb();
						}));
					}));
				})(function (err) {
					if (err)
						cb(new Error(self._name+": Error during load - "+err.toString()));
					else
						cb();
				});
			}, cb);
			}));
		})(function (err) {
			if (!found && err)
				return cb(err); // nothing read and error, just rise it
			safe.run(function (cb) {
				var size = _.size(self._store);
				// autocompact on certain ratio or err
				if (deleted > size || err) {
					self._compact(function (errCompact) {
						if (errCompact && err)
							cb(errCompact);
						else {
							if (errCompact) console.log(err);
							cb();
						}
					});
				} else cb();
			}, function () {
				self._refreshIndexes(cb);
			});
		});
	});
	self.ensureIndex({_id: 1}, {name: '_id_', unique: true}, cb);
};

tcoll.prototype.compactCollection = function (cb) {
	var self = this;
	self._tq.add(function (cb) {
		self._compact(safe.sure(cb, function () {
			self._cache.clear();
			self._refreshIndexes(cb);
		}));
	}, true, cb);
};

tcoll.prototype._refreshIndexes = function (cb) {
	var self = this;
	_.forEach(self._idx,function(v, k) {
		v.clear();
	});
	safe.forEachSeries(_.values(self._store), function (rec, cb) {
		self._get(rec.pos, false, safe.sure(cb, function (obj) {
			var id = simplifyKey(obj._id);
			_.forEach(self._idx,function(v, k) {
				v.set(obj, id);
			});
			cb();
		}));
	}, cb);
};

tcoll.prototype._compact = function (cb) {
	var self = this;
	var filename = self._filename + '.compact';
	fs.open(filename, 'w+', safe.sure(cb, function (fd) {
		var b1 = new Buffer(45);
		function get(pos, cb) {
			fs.read(self._fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {
				var h1 = JSON.parse(data.toString());
				h1.o = parseInt(h1.o, 10);
				h1.k = parseInt(h1.k, 10);
				var b2 = new Buffer(h1.k + h1.o + 3);
				fs.read(self._fd, b2, 0, b2.length, pos + 45, safe.sure(cb, function (bytes, data) {
					cb(null, Buffer.concat([ b1, b2 ]));
				}));
			}));
		}
		var wpos = 0;
		var store = {};
		safe.forEachSeries(_.keys(self._store), function (k, cb) {
			var rec = self._store[k];
			get(rec.pos, safe.sure(cb, function (data) {
				fs.write(fd, data, 0, data.length, wpos, safe.sure(cb, function (written) {
					if (written != data.length) return cb(new Error('Insufficient disk space'));
					store[k] = { pos: wpos, sum: rec.sum };
					wpos += data.length;
					cb();
				}));
			}));
		}, function (err) {
			if (err) {
				fs.close(fd, function () {
					fs.unlink(filename, function () {
						cb(err);
					});
				});
				return;
			}
			if (!!process.platform.match(/^win/)) {
				// WINDOWS: unsafe because if something fail while renaming file it will not
				// restore automatically
				fs.close(self._fd, safe.sure(cb,function() {
					fs.close(fd, safe.sure(cb,function() {
						fs.unlink(self._filename, safe.sure(cb,function () {
							fs.rename(filename, self._filename, safe.sure(cb, function () {
								fs.open(self._filename, 'a+', safe.sure(cb, function (fd) {
									self._fd = fd;
									self._fsize = wpos;
									self._store = store;
									cb();
								}));
							}));
						}));
					}));
				}));
		    } else {
				// safe way
				fs.rename(filename, self._filename, safe.sure(cb, function () {
					fs.close(self._fd);
					self._fd = fd;
					self._fsize = wpos;
					self._store = store;
					cb();
				}));
			}
		});
	}));
};

tcoll.prototype.drop = function (cb) {
	this._tdb.dropCollection(this._name,cb);
};

tcoll.prototype.rename = function (nname, opts, cb) {
	var self = this;
	if (_.isFunction(opts)) {
		cb = opts;
		opts = {};
	}
	var err = self._tdb._nameCheck(nname);
	if (err)
		return safe.back(cb,err);
	if (self._tdb._stype=="mem") {
		delete self._tdb._cols[self._name];
		self._tdb._cols[nname] = self;
		delete self._tdb._mstore[self._name];
		self._tdb._mstore[nname] = self._mstore;
		safe.back(cb,null);
	} else {
		self._tq.add(function (cb) {
			fs.rename(path.join(self._tdb._path,self._name),path.join(self._tdb._path,nname),safe.sure(cb, function () {
				delete self._tdb._cols[self._name];
				self._tdb._cols[nname] = self;
				self.collectionName = self._name = nname;
				cb();
			}));
		},true,cb);
	}
};

tcoll.prototype._stop = function (cb) {
	var self = this;
	self._tq.add(function (cb) {
		// this will prevent any tasks processed on this instance
		self._tq._stoped = true;
		if (self._fd) {
			fs.close(self._fd,safe.sure(cb, function () {
				cb(null,true);
			}));
		} else
			cb(null,false);
	},true,cb);
};

tcoll.prototype.createIndex = tcoll.prototype.ensureIndex = function (obj, options, cb) {
	var self = this;
	if (_.isFunction(options)) {
		cb = options;
		options = {};
	}
	cb = cb || function () {};
	options = options || {};

	var c = new tcursor(this,{},{},{});
	c.sort(obj);
	if (c._err)
		return safe.back(cb,c._err);
	var key = c._sort;

	if (key===null)
		return safe.back(cb,new Error("No fields are specified"));

	var index = self._idx[key];
	if (index)
		return safe.back(cb,null, index.name);

	// force array support when global option is set
	if (_.isUndefined(options._tiarr) && self._tdb._gopts.searchInArray)
		options._tiarr = true;

	var name = options.name || _.map(key, function (v) { return v[0] + '_' + v[1]; }).join('_');
	index = new tindex(key, self, options, name);

	if (self._tq._tc==-1) {
		// if no operation is pending just register index
		self._idx[key] = index;
		safe.back(cb, null, index.name);
	}
	else {
		// overwise register index operation
		this._tq.add(function (cb) {
			var range = _.values(self._store);
			safe.forEachSeries(range, function (rec, cb) {
				self._get(rec.pos, false, safe.sure(cb, function (obj) {
					index.set(obj,simplifyKey(obj._id));
					cb();
				}));
			}, safe.sure(cb, function () {
				self._idx[key] = index;
				cb();
			}));
		}, true, function (err) {
			if (err) cb(err);
			else cb(null, index.name);
		});
	}
};

tcoll.prototype.indexExists = function (idx, cb) {
	if (!_.isArray(idx))
		idx = [idx];
	var i = _.intersection(idx,_(this._idx).values().map('name').value());
	cb(null,i.length == idx.length);
};

tcoll.prototype.indexes = function (cb) {
	var self = this;
	this._tq.add(function (cb) {
		cb(null, _.values(self._idx));
	},false,cb);
};

tcoll.prototype._getM = function (pos, unsafe, cb) {
	safe.back(cb,null,unsafe?this._mstore[pos-1]:this._tdb._cloneDeep(this._mstore[pos-1]));
};

tcoll.prototype._getFS = function (pos, unsafe, cb) {
	var self = this;
	var cached = self._cache.get(pos,unsafe);
	if (cached)
		return safe.back(cb,null,cached);
	var b1 = new Buffer(45);
	fs.read(self._fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {
		var h1 = JSON.parse(data.toString());
		h1.o = parseInt(h1.o,10);
		h1.k = parseInt(h1.k,10);
		var b2 = new Buffer(h1.o);
		fs.read(self._fd,b2,0,h1.o,pos+45+2+h1.k, safe.trap_sure(cb, function (bytes, data) {
			var obj = self._unwrapTypes(JSON.parse(data.toString()));
			if (bytes <= self._cmaxobj)
				self._cache.set(pos, obj);
			cb(null,obj);
		}))
	}))
}

tcoll.prototype.insert = function (docs, opts, cb ) {
	var self = this;
	if (_.isFunction(opts) && cb == null) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	if (opts.w>0 && !_.isFunction(cb))
		throw new Error("Callback is required for safe update");
	cb = cb || function () {};
	if (!_.isArray(docs))
		docs = [docs];
	this._tq.add(function (cb) {
		safe.forEachSeries(docs, function (doc, cb) {
			if (_.isUndefined(doc._id)) {
				doc._id = new self._tdb.ObjectID();
			}
			self._put(doc, false, cb);
		}, safe.sure(cb, function () {
			cb(null, docs);
		}))
	}, true, cb)
}

tcoll.prototype._wrapTypes = function(obj) {
	var self = this;
	_.each(obj, function (v,k) {
		if (_.isDate(v))
			obj[k] = {$wrap:"$date",v:v.valueOf(),h:v}
		else if (v instanceof self._tdb.ObjectID)
			obj[k] = {$wrap:"$oid",v:v.toJSON()}
		else if (v instanceof self._tdb.Binary)
			obj[k] = {$wrap: "$bin", v: v.toJSON()};
		else if (_.isObject(v))
			self._wrapTypes(v)

	})
	return obj;
}

tcoll.prototype._ensureIds = function(obj) {
	var self = this;
	_.each(obj, function (v,k) {
		if (k.length >0) {
			if (k[0]=='$')
				throw new Error("key "+k+" must not start with '$'");;
			if (k.indexOf('.')!=-1)
				throw new Error("key "+k+" must not contain '.'");
		}
		if (_.isObject(v)) {
			if (v instanceof self._tdb.ObjectID) {
				if (v.id<0) {
					v._persist(++self._id)
				}
			}
			else
				self._ensureIds(v)
		}
	})
	return obj;
}


tcoll.prototype._unwrapTypes = function(obj) {
	var self = this;
	_.each(obj, function (v,k) {
		if (_.isObject(v)) {
			switch (v.$wrap) {
				case "$date": obj[k] = new Date(v.v); break;
				case "$oid":
					var oid = new self._tdb.ObjectID(v.v);
					obj[k]=oid;
				break;
				case "$bin":
					var bin = new self._tdb.Binary(new Buffer(v.v, 'base64'));
					obj[k] = bin;
				break;
				default: self._unwrapTypes(v);
			}
		}
	})
	return obj;
}

tcoll.prototype._putM = function (item_, remove, cb) {
	var item = this._tdb._cloneDeep(item_);
	var self = this;
	self._wq.add(function (cb) {
		try {
			item = self._ensureIds(item);
		} catch (err) {
			err.errmsg = err.toString();
			return cb(err)
		}
		if (_.isUndefined(item._id))
			return cb(new Error("Invalid object key (_id)"));

		var key = {_id:simplifyKey(item._id)};

		// check index update
		if (item && !remove) {
			try {
				_.forEach(self._idx,function(v,k) {
					v.set(item,key._id,true);
				})
			} catch (err) {
				err.errmsg = err.toString();
				return cb(err)
			}
		}

		if (remove) {
			self._mstore[self._store[key._id].pos-1]=null;
			delete self._store[key._id];
		}
		else {
			if (self._store[key._id]) {
				self._mstore[self._store[key._id].pos-1] = item;
			} else {
				self._mstore.push(item);
				self._store[key._id] = {pos: self._mstore.length};
			}
		}

		// update index
		_.forEach(self._idx,function(v,k) {
			if (!remove)
				v.set(item,key._id);
			else
				v.del(item,key._id);
		})
		cb(null);
	}, true, cb);
}


tcoll.prototype._putFS = function (item, remove, cb) {
	var self = this;
	self._wq.add(function (cb) {
		try {
			item = self._ensureIds(item);
		} catch (err) {
			err.errmsg = err.toString();
			return cb(err)
		}
		if (_.isUndefined(item._id))
			return cb(new Error("Invalid object key (_id)"));
		item = self._wrapTypes(item);
		var sobj = new Buffer(remove?"":JSON.stringify(item));
		item = self._unwrapTypes(item);
		var key = {_id:simplifyKey(item._id),_uid:self._id,_dt:(new Date()).valueOf()};
		if (remove) key._a = "del";
		else {
			var hash = crypto.createHash('md5');
			hash.update(sobj, 'utf8');
			key._s = hash.digest('hex');
		}
		var skey = new Buffer(JSON.stringify(key));
		var zeros = "0000000000";
		var lobj = sobj.length.toString();
		var lkey = skey.length.toString();
		lobj = zeros.substr(0,zeros.length - lobj.length)+lobj;
		lkey = zeros.substr(0,zeros.length - lkey.length)+lkey;
		var h1={k:lkey,o:lobj,v:"001"};
		var buf = new Buffer(JSON.stringify(h1)+"\n"+skey+"\n"+sobj+"\n");

		// check index update
		if (item && !remove) {
			try {
				_.forEach(self._idx,function(v,k) {
					v.set(item,key._id,true);
				})
			} catch (err) {
				err.errmsg = err.toString();
				return cb(err)
			}
		}

		safe.run(function (cb) {
			var rec = self._store[key._id];
			if (rec && rec.sum == key._s) return safe.back(cb);
			fs.write(self._fd, buf, 0, buf.length, self._fsize, safe.sure(cb, function (written) {
				if (remove)
					delete self._store[key._id];
				else
					self._store[key._id] = { pos: self._fsize, sum: key._s };

				if (remove || sobj.length > self._cmaxobj)
					self._cache.unset(self._fsize)
				else
					self._cache.set(self._fsize,item);
				self._fsize+=written;
				// randomly check for non exclusive file usage
				// which is growth of file that we are nor aware
				// randomly to avoid overhead
				if (self._check1==0) {
					this._check1 = Math.random()*100+1;
					fs.fstat(self._fd, safe.sure(cb, function (stat) {
						if (self._fsize!=stat.size)
							cb(new Error("File size mismatch. Are you use db/collection exclusively?"))
						else
							cb()
					}))
				} else {
					self._check1--;
					cb();
				}
			}));
		},
		function () {
			// update index
			_.forEach(self._idx,function(v,k) {
				if (!remove)
					v.set(item,key._id);
				else
					v.del(item,key._id);
			})
			cb(null);
		});
	}, true, cb);
}

tcoll.prototype.count = function (query, options, cb) {
	var self = this;
	if (arguments.length == 1) {
		cb = arguments[0];
        options = null;
		query = null;
	}
	if (arguments.length == 2) {
        query = arguments[0];
		cb = arguments[1];
        options = null;
	}
	if (query==null || _.size(query)==0) {
		this._tq.add(function (cb) {
			cb(null, _.size(self._store));
		},false,cb);
	} else
		self.find(query, options).count(cb);
}

tcoll.prototype.stats = function (cb) {
	var self = this;
	this._tq.add(function (cb) {
		cb(null, {count:_.size(self._store)});
	},false,cb);
}


var findOpts = ['limit','sort','fields','skip','hint','timeout','batchSize','safe','w'];

tcoll.prototype.findOne = function () {
	var findArgs = Array.prototype.slice.call(arguments,0,arguments.length-1);
	var cb = arguments[arguments.length-1];
	this.find.apply(this,findArgs).limit(1).nextObject(cb);
}

tcoll.prototype.find = function () {
	var cb = null, query = {}, opts = {}, fields = null, skip = null, limit = null, sort = null;
	var argc = arguments.length;
	if (argc>0) {
		// guess callback, it is always latest
		cb = arguments[argc-1];
		if (!_.isFunction(cb))
			cb=null
		else
			argc--;
		if (argc>0) {
			// query should always exist
			query = arguments[0]
			if (argc>1) {
				if (argc==2) {
					var val = arguments[1];
					// worst case we get either options either fiels
					if (_.intersection(_.keys(val),findOpts).length!=0)
						opts = val
					else
						fields = val;
				} else {
					fields = arguments[1];
					if (argc == 3)
						opts = arguments[2]
					else {
						skip = arguments[2];
						limit = arguments[3]
					}
				}
			}
		}
	}

	opts = opts || {};
	skip = skip || opts.skip || null;
	limit = limit || opts.limit || null;
	fields = fields || opts.fields || null;
	sort = sort || opts.sort || null;


	var c = new tcursor(this,query, fields, opts);

	if (skip) c.skip(skip);
	if (limit) c.limit(limit);
	if (sort) c.sort(sort);
	if (cb)
		cb(null, c)
	else
		return c;
}


function simplifyKey(key) {
	var k = key;
	if (key.toJSON)
		k = key.toJSON();
	if (_.isNumber(k)||_.isString(k))
		return k;
	return k.toString();
}

tcoll.prototype.update = function (query, doc, opts, cb) {
	var self = this;
	if (_.isFunction(opts) && cb == null) {
		cb = opts;
	}
	opts = opts || {};
	if (opts.w>0 && !_.isFunction(cb))
		throw new Error("Callback is required for safe update");
	cb = cb || function () {}
	if (!_.isObject(query))
		throw new Error("selector must be a valid JavaScript object");
	if (!_.isObject(doc))
		throw new Error("document must be a valid JavaScript object");

	var multi = opts.multi || false;
    var updater = new Updater(doc, self._tdb);
	var $doc = updater.hasAtomic()?null:doc;
	this._tq.add(function (cb) {
		self.__find(query, null, 0, multi ? null : 1, null, opts.hint, {}, safe.sure(cb, function (res) {
			if (res.length==0) {
				if (opts.upsert) {
					$doc = $doc || query;
					$doc = self._tdb._cloneDeep($doc);
					updater.update($doc,true);
					if (_.isUndefined($doc._id))
						$doc._id = new self._tdb.ObjectID();
					self._put($doc, false, safe.sure(cb, function () {
						cb(null, 1,{updatedExisting:false,upserted:$doc._id,n:1})
					}))
				} else
					cb(null,0);
			} else {
				safe.forEachSeries(res, function (pos, cb) {
					self._get(pos, false, safe.sure(cb, function (obj) {
						// remove current version of doc from indexes
						_.forEach(self._idx,function(v,k) {
							v.del(obj,simplifyKey(obj._id));
						})
						var udoc = $doc;
						if (!$doc) {
							udoc = obj;
							updater.update(udoc);
						}
						udoc._id = obj._id;
						// put will add it back to indexes
						self._put(udoc, false, cb);
					}))
				}, safe.sure(cb,function () {
					cb(null, res.length, {updatedExisting:true,n:res.length});
				}))
			}
		}))
	},true,cb);
}

tcoll.prototype.findAndModify = function (query, sort, doc, opts, cb) {
	var self = this;
	if (_.isFunction(opts) && cb == null) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	doc = doc || {};

	var updater = new Updater(doc, self._tdb);
	var $doc = updater.hasAtomic()?null:doc;

	var c = new tcursor(this,{}, opts.fields || {},{});
	c.sort(sort);
	if (c._err)
		return safe.back(cb,c._err);

	this._tq.add(function (cb) {
		self.__find(query, null, 0, 1, c._sort, opts.hint, {}, safe.sure(cb, function (res) {
			if (res.length==0) {
				if (opts.upsert) {
					$doc = $doc || query;
					$doc = self._tdb._cloneDeep($doc);
					updater.update($doc,true);
					if (_.isUndefined($doc._id))
						$doc._id = new self._tdb.ObjectID();
					self._put($doc, false, safe.sure(cb, function () {
						cb(null,opts.new?c._projectFields($doc):{})
					}))
				} else
					cb();
			} else {
				self._get(res[0], false, safe.sure(cb, function (obj) {
					var robj = (opts.new && !opts.remove) ? obj : self._tdb._cloneDeep(obj);
					// remove current version of doc from indexes
					_.forEach(self._idx,function(v,k) {
						v.del(obj,simplifyKey(obj._id));
					})
					var udoc = $doc;
					if (!$doc) {
						udoc = obj;
						updater.update(udoc);
					}
					udoc._id = obj._id;
					// put will add it back to indexes
					self._put(udoc, opts.remove?true:false, safe.sure(cb,function () {
						cb(null,c._projectFields(robj))
					}))
				}))
			}
		}))
	},true,cb);
}

tcoll.prototype.save = function (doc, opts, cb) {
	var self = this;
	cb = _.isFunction(doc)?doc:_.isFunction(opts)?opts:cb;
	cb = cb || function () {};
	doc = doc || {};
	opts = opts || {};
	this._tq.add(function (cb) {
		var res = doc;
		(function(cb) {
			if (_.isUndefined(doc._id)) {
				doc._id = new self._tdb.ObjectID();
				cb()
			} else {
				var id = simplifyKey(doc._id);
				var pos = self._store[id];
				// check if document with this id already exist
				if (pos) {
					// if so we need to fetch it to update index
					self._get(pos.pos, false, safe.sure(cb, function (oldDoc) {
						// remove current version of doc from indexes
						_.forEach(self._idx,function(v,k) {
							v.del(oldDoc,id);
						})
						res = 1;
						cb();
					}))
				} else cb();
			}
		})(safe.sure(cb, function () {
			self._put(doc, false, safe.sure(cb, function () {
				cb(null,res); // when update return 1 when new save return obj
			}))
		}))
	},true,cb);
}

tcoll.prototype.remove = function (query, opts, cb) {
	var self = this;
	if (_.isFunction(query)) {
		cb = query;
		query = opts = {};
	} else if (_.isFunction(opts)) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	if (opts.w>0 && !_.isFunction(cb))
		throw new Error("Callback is required");
	cb = cb || function () {};
	var single = opts.single || false;
	this._tq.add(function (cb) {
		self.__find(query, null, 0, single ? 1 : null, null, opts.hint, {}, safe.sure(cb, function (res) {
			safe.forEachSeries(res, function (pos, cb) {
				self._get(pos, false, safe.sure(cb, function (obj) {
					self._put(obj,true,cb);
				}))
			}, safe.sure(cb, function () {
				cb(null,res.length);
			}))
		}))
	},true,cb);
}

tcoll.prototype.findAndRemove = function (query,sort,opts,cb) {
	var self = this;

	if (_.isFunction(sort) && cb == null && opts==null) {
		cb = sort;
		sort = {}
		opts = {};
	} else if (_.isFunction(opts) && cb == null) {
		cb = opts;
		opts = {};
	}
	opts = opts || {};
	sort = sort || {};

	var c = new tcursor(this,{},{},{});

	// Fix for mongoouse/tungus they pass sort as undefined
	c.sort(sort);

	if (c._err)
		return safe.back(cb,c._err);

	this._tq.add(function (cb) {
		self.__find(query, null, 0, 1, c._sort, opts.hint, {}, safe.sure(cb, function (res) {
			if (res.length==0)
				return cb();
			self._get(res[0], false, safe.sure(cb, function (obj) {
				self._put(obj,true,safe.sure(cb, function () {
					cb(null,obj);
				}))
			}))
		}))
	},true,cb);
}

tcoll.prototype._bestSortIndex = function (sort) {
	// no sort
	if (!sort) return null;
	// exact match
	if (this._idx[sort]) return this._idx[sort];
	// find potential sort indexes
	var pi = [];
	_.forEach(this._idx,function (idx) {
		var fields = idx.fields();
		var match = _.takeWhile(fields, function (kv, i) {
			return i < sort.length ? kv[0] == sort[i][0] : false;
		});
		if (match.length == sort.length) {
			var score = fields.length;
			_.forEach(sort,function (kv, i) {
				if (kv[1] != fields[i][1]) score += 1;
			});
			pi.push({ value: idx, score: score });
		}
	});
	if (pi.length === 0) return null;
	// select best index
	pi = pi.sort(function (l, r) { return l.score < r.score; });
	return pi[0].value;
};

function reduceIndexSet(pi) {
	var hit;
	do {
		hit = false;
		// compare each potential index with each other
		_.forEach(pi,function (v1, i1) {
			_.forEach(pi,function (v2, i2) {
				if (i1 == i2) return;
				// compare the set of possible keys for both indexes
				if (_.union(v1.k, v2.k).length == v1.k.length) {
					// key for v2 is a subset of key for v1, check equality
					if (v1.k.length == v2.k.length && v1.i.depth() > v2.i.depth()) {
						// keys are equal, but the depth of v2 is lower;
						// v2 is preferable, strike out v1
						pi.splice(i1, 1);
					} else {
						// in other two cases v1 is preferable, strike out v2
						pi.splice(i2, 1);
					}
					hit = true;
					return false;
				}
			});
			if (hit) return false;
		});
	} while (hit);
};

tcoll.prototype.__find = function (query, fields, skip, limit, sort, hint, arFields, cb) {
	var self = this;
	var range = [];
	// find sort index
	var si = this._bestSortIndex(sort);
	// for non empty query check indexes that we can use
	var qt = self._tdb.Finder.matcher(query);
	var pi = [];
	if (_.size(qt)>0) {
		_.forEach(self._idx,function (i) {
			var f = _.pluck(i.fields(), 0);
			var e = _.takeWhile(f, function (k) {
				return qt._ex(k) == 1 && (!hint || hint[k]);
			});
			if (e.length > 0) pi.push({ i: i, k: e, e: f.length > e.length });
		});
	}

	// if possible indexes found split the query and process
	// indexes separately
	if (!_.isEmpty(pi)) {
		// choose the most appropriate indexes
		reduceIndexSet(pi);
		// split query
		var io = {};
		_.forEach(pi,function (v) {
			_.forEach(v.k,function (k) {
				if (!io[k]) io[k] = qt.split(k);
			});
		});
		// process indexes
		var p = [];
		_.forEach(pi,function (st) {
			// this action applies to all indexes
			var r = io[st.k[0]]._index(st.i);
			// process subfields of compound index
			_.forEach(st.k.slice(1),function (k) {
				var v = io[k];
				r = _.flatten(_.map(r, function (si) { return v._index(si); }));
			});
			// expand subindexes to plain ids
			if (st.e) r = _.flatten(_.map(r, function (si) { return si.all(); }));
			// store result of index search
			p.push(r);
		});
		if (p.length == 1) {
			p = p[0];
			// optimization for the case when search and sorting indexes are the same
			if (si && pi[0].i === si) {
				var sif = si.fields();
				if (_.every(sort, function (v, i) { return sif[i][1] == v[1]; })) {
					// sort order exactly matches index order,
					// so the result is already sorted
					sort = null;
				} else if (_.every(sort, function (v, i) { return sif[i][1] == -v[1]; })) {
					// sort order is exactly opposite to index order,
					// so the result is sorted, but in reverse direction
					p.reverse();
					sort = null;
				}
			}
		} else {
			// TODO: use sort index as intersect base to speedup sorting
			p = tutils.intersectIndexes(p);
		}
		// nowe we have ids, need to convert them to positions
		_.forEach(p,function (_id) {
			range.push(self._store[_id].pos)
		})
	} else {
		if (si) {
			_.each(si.all(_.pluck(sort, 1)), function (_id) {
				range.push(self._store[_id].pos)
			})
			//if (order==-1)
			//	range.reverse();
			sort = null;
		} else
			range = _.values(self._store).map(function (rec) { return rec.pos; });
	}

	if (sort && si) {
		var ps = {};
		_.each(range,function (pos) {
			ps[pos] = true;
		});
		range = [];
		_.each(si.all(_.pluck(sort, 1)),function (_id) {
			var pos = self._store[_id].pos;
			if (_.has(ps,pos)) range.push(pos);
		});
		//if (order == -1)
		//	range.reverse();
		sort = null;
	}

	// no sort, no query then return right away
	if (sort==null && (_.size(qt)==0 || qt._args.length==0)) {
		if (skip!=0 || limit!=null) {
			var c = Math.min(range.length-skip,limit?limit:range.length-skip);
			range = range.splice(skip,c)
		}
		return safe.back(cb,null,range);
	}

	var matcher = null;
	// check if we can use simple match or array match function
	var arrayMatch = false;
	if (self._tdb._gopts.searchInArray)
		arrayMatch = true;
	else {
		var fields = qt.fields();
		_.each(fields, function (v,k) {
			if (arFields[k])
				arrayMatch = true;
		})
	}

	eval("matcher = function (obj) { return "+ (arrayMatch?qt.native3():qt.native()) + " }");

	// create sort index
	if (sort) {
		si = new tindex(sort,self);
	}

	// now simple non-index search
	var res = [];
	var found = 0;
	safe.forEachSeries(range, function (pos, cb) {
		if (sort==null && limit && res.length>=limit)
			return safe.back(cb);
		self._get(pos, true, safe.sure(cb, function (obj) {
			if (matcher(obj)) {
				if (sort!=null || found>=skip) {
					if (sort==null)
						res.push(pos);
					else
						si.set(obj,pos);
				}
				found++;
			}
			cb()
		}))
	}, safe.sure(cb, function () {
		if (sort) {
			res = si.all();
			//if (order==-1) {
			//	res.reverse();
			//}
			if (skip!=0 || limit!=null) {
				var c = Math.min(res.length-skip,limit?limit:res.length-skip);
				res = res.splice(skip,c)
			}
		}
		cb(null, res);
	}))
}

tcoll.prototype._find = function (query, fields, skip, limit, sort_, hint, arFields, cb) {
	var self = this;
	this._tq.add(function (cb) {
		self.__find(query, fields, skip, limit, sort_, hint, arFields, cb);
	}, false, cb);
}

function code2fn(obj) {
	if (_.isObject(obj)) {
		_.each(obj,function (value, key) {
			if (value instanceof Code) {
				with (value.scope) {
					obj[key] = eval('(' + value.code + ')');
				}
			}
			else code2fn(value);
		});
	}
}

tcoll.prototype.mapReduce = function (map, reduce, opts, cb) {
	var self = this;
	if (_.isFunction(opts)) {
		cb = opts;
		opts = {};
	}

	if (!opts.out) return safe.back(cb, new Error('the out option parameter must be defined'));
	if (!opts.out.inline && !opts.out.replace) {
		return safe.back(cb, new Error('the only supported out options are inline and replace'));
	}

	code2fn(opts.scope);

	var m = {};

	function emit(k, v) {
		var values = m[k];
		if (!values) m[k] = [ v ];
		else {
			values.push(v);
			if (values.length > 1000) values = [ reduce(k, values) ];
		}
	}

	with (opts.scope || {}) {
		try {
			if (map instanceof Code) {
				with (map.scope) {
					map = eval('(' + map.code + ')');
				}
			} else map = eval('(' + map + ')');
			if (reduce instanceof Code) {
				with (reduce.scope) {
					reduce = eval('(' + reduce.code + ')');
				}
			} else reduce = eval('(' + reduce + ')');
			if (finalize instanceof Code) {
				with (finalize.scope) {
					finalize = eval('(' + finalize.code + ')');
				}
			} else var finalize = eval('(' + opts.finalize + ')');
		} catch (e) {
			return safe.back(cb,e);
		}
	}

	self.find(opts.query, null, { limit: opts.limit, sort: opts.sort }, safe.sure(cb, function (c) {
		var doc;
		safe.doUntil(
			function (cb) {
				c.nextObject(safe.trap_sure(cb, function (_doc) {
					doc = _doc;
					if (doc) map.call(doc);
					return cb();
				}));
			},
			function () {
				return doc === null;
			},
			safe.trap_sure(cb, function () {
				_.each(m,function (v, k) {
					v = v.length > 1 ? reduce(k, v) : v[0];
					if (finalize) v = finalize(k, v);
					m[k] = v;
				});

				var stats = {};
				if (opts.out.inline) return process.nextTick(function () {
					cb(null, _.values(m), stats); // execute outside of trap
				});

				// write results to collection
				safe.waterfall([
					function (cb) {
						self._tdb.collection(opts.out.replace, { strict: 1 }, function (err, col) {
							if (err) return cb(null, null);
							col.drop(cb);
						});
					},
					function (arg, cb) {
						self._tdb.collection(opts.out.replace, {}, cb);
					},
					function (col, cb) {
						var docs = [];
						_.each(m,function (value, key) {
							var doc = {
								_id: key,
								value: value
							};
							docs.push(doc);
						});
						col.insert(docs, safe.sure(cb, function () {
							if (opts.verbose) cb(null, col, stats);
							else cb(null, col);
						}));
					}
				], cb);
			}
		)); // doUntil
	}));
};

tcoll.prototype.group = function (keys, condition, initial, reduce, finalize, command, options, callback) {
	var self = this;

	var args = Array.prototype.slice.call(arguments, 3);
	callback = args.pop();
	reduce = args.length ? args.shift() : null;
	finalize = args.length ? args.shift() : null;
	command = args.length ? args.shift() : null;
	options = args.length ? args.shift() : {};

	if (!_.isFunction(finalize)) {
		command = finalize;
		finalize = null;
	}

	code2fn(options.scope);

	with (options.scope || {}) {
		try {
			if (_.isFunction(keys)) keys = eval('(' + keys + ')');
			else if (keys instanceof Code) {
				with (keys.scope) {
					keys = eval('(' + keys.code + ')');
				}
			}
			if (reduce instanceof Code) {
				with (reduce.scope) {
					reduce = eval('(' + reduce.code + ')');
				}
			} else reduce = eval('(' + reduce + ')');
			if (finalize instanceof Code) {
				with (finalize.scope) {
					finalize = eval('(' + finalize.code + ')');
				}
			} else finalize = eval('(' + finalize + ')');
		} catch (e) {
			return callback(e);
		}
	}

	var m = {};
	self.find(condition, safe.sure(callback, function (c) {
		var doc;
		safe.doUntil(
			function (cb) {
				c.nextObject(safe.sure(cb, function (_doc) {
					doc = _doc;
					if (!doc) return cb();
					var keys2 = keys;
					if (_.isFunction(keys)) keys2 = keys(doc);
					if (!_.isArray(keys2)) {
						var keys3 = [];
						_.each(keys2,function (v, k) {
							if (v) keys3.push(k);
						});
						keys2 = keys3;
					}
					var key = {};
					_.each(keys2,function (k) {
						key[k] = doc[k];
					});
					var skey = JSON.stringify(key);
					var obj = m[skey];
					if (!obj) obj = m[skey] = _.extend({}, key, initial);
					try {
						reduce(doc, obj);
					} catch (e) {
						return cb(e);
					}
					cb();
				}));
			},
			function () {
				return doc === null;
			},
			safe.sure(callback, function () {
				var result = _.values(m);
				if (finalize) {
					_.each(result,function (value) {
						finalize(value);
					});
				}
				callback(null, result);
			})
		);
	}));
};
 at SyntaxError: 'with' in strict mode (1134:4)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp$1.parseWithStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:932:27)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:708:32)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseBlock (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:981:25)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:709:33)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
    at Parser.pp$1.parseIfStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:824:28)
    at Parser.pp$1.parseStatement (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:698:30)
    at Parser.parseStatement (/root/ExpoSE/lib/Tropigate/bin/Statements.js:104:30)
