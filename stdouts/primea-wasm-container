/root/Targets/primea-wasm-container
└─┬ primea-wasm-container@0.0.2 
  ├── primea-abstract-container@0.0.4 
  ├── primea-container-table@0.0.0 
  └── reference-map@1.0.0 

Setup Done exists, not setting up
:../FeatureTester/libs/:/root/Targets/primea-wasm-container/node_modules
Set Default Z3_PATH to ./node_modules/z3javascript/bin/libz3.so
ExpoSE Master: /root/ExpoSE/lib/Harness/src/harness.js max concurrent: 16 max paths: 1000000
Setting timeout to 900000
*** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [0 done /0 queued / 1 running / 0 errors / 0% coverage ] ****** [1 done /0 queued / 0 running / 1 errors / 33% coverage ] ***
*-- Stat Module Output --*
*-- concretizations: ["defineProperty","bound log"]
*-- Stat Module Done --*
*-- Test Case {"_bound":0} start 0.046 took 4.269s
*-- Errors occured in test {"_bound":0}
* Error: Tropigate failed because SyntaxError: Unexpected token (19:8) on program const ReferanceMap = require('reference-map')
const AbstractContainer = require('primea-abstract-container')
const ContainerTable = require('primea-container-table')

module.exports = class WasmContainer extends AbstractContainer {
  /**
   * The wasm container runs wasm code and provides a basic API for wasm
   * interfaces for interacting with the kernel
   * @param {object} kernel - the kernel instance
   * @param {object} interfaces - a map of interfaces to expose to the wasm binary
   */
  constructor (kernel, interfaces) {
    super()
    this.kernel = kernel
    this.imports = interfaces
    this.referanceMap = new ReferanceMap()
  }

  async onCreation (message) {
    let code = message.data
    if (!WebAssembly.validate(code)) {
      throw new Error('invalid wasm binary')
    } else {
      for (const name in this.imports) {
        const interf = this.imports[name]
        if (interf.initialize) {
          code = await interf.initialize(code)
        }
      }
      this.kernel.state.code = code
    }
    return this._run(message, 'onCreation')
  }

  /**
   * Runs the wasm VM given a message
   * @param {object} message
   * @returns {Promise} a promise that resolves once the compuation is finished
   */
  onMessage (message) {
    return this._run(message, 'onMessage')
  }

  async _run (message, method) {
    // Builds a import map with an array of given interfaces
    const importMap = {}
    for (const name in this.imports) {
      importMap[name] = {}
      const Import = this.imports[name]
      const newInterface = new Import(this)
      const props = Object.getOwnPropertyNames(Import.prototype)

      // bind the methods to the correct 'this'
      for (const prop of props) {
        if (prop !== 'constructor') {
          importMap[name][prop] = newInterface[prop].bind(newInterface)
        }
      }
    }

    const result = await WebAssembly.instantiate(this.kernel.state.code, importMap)
    this.instance = result.instance

    // add the message and ports to the refereance map
    const messageRef = this.referanceMap.add(message)

    // runs the wasm code
    this.instance.exports[method](messageRef)
    return this.onDone()
  }

  /**
   * returns a promise that resolves when the wasm instance is done running
   * @returns {Promise}
   */
  async onDone () {
    let prevOps
    while (prevOps !== this._opsQueue) {
      prevOps = this._opsQueue
      await prevOps
    }
    this.referanceMap.clear()
  }

  /**
   * Pushed an async operation to the a promise queue that
   * @returns {Promise} the returned promise resolves in the order the intail
   * operation was pushed to the queue
   */
  pushOpsQueue (promise) {
    this._opsQueue = Promise.all([this._opsQueue, promise])
    return this._opsQueue
  }

  /**
   * executes a callback given an index in the exported callback container
   * @param {integer} cb
   * @param {*} val - a value to return to the callback function
   */
  execute (cb, val) {
    this.instance.exports.callbacks.get(cb)(val)
  }

  /**
   * returns a section of memory from the wasm instance
   * @param {integer} offset
   * @param {integer} length
   * @returns {Uint8Array}
   */
  getMemory (offset, length) {
    return new Uint8Array(this.instance.exports.memory.buffer, offset, length)
  }

  setMemory (offset, val) {
    const mem = this.getMemory(offset, val.length)
    mem.set(val)
  }

  static get typeId () {
    return ContainerTable.WebAssembly
  }
}
 at SyntaxError: Unexpected token (19:8)
    at Parser.pp$4.raise (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2221:15)
    at Parser.pp.unexpected (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:603:10)
    at Parser.pp.expect (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:597:28)
    at Parser.pp$3.parseMethod (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:2071:10)
    at Parser.pp$1.parseClassMethod (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1137:25)
    at Parser.pp$1.parseClass (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1118:14)
    at Parser.pp$3.parseExprAtom (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1813:19)
    at Parser.parseExprAtom (/root/ExpoSE/lib/Tropigate/bin/Expression.js:28:30)
    at Parser.pp$3.parseExprSubscripts (/root/ExpoSE/lib/Tropigate/node_modules/acorn/dist/acorn.js:1715:21)
    at Parser.parseMaybeUnary (/root/ExpoSE/lib/Tropigate/bin/Unary.js:34:29)
*-- Replay with NO_COMPILE=1 expoSE replay '/root/ExpoSE/lib/Harness/src/harness.js' '{"_bound":0}'
*-- Coverage Data
*- File /root/ExpoSE/lib/Harness/src/harness.js. Coverage (Term): 18% Coverage (LOC): 24%
*- File /root/ExpoSE/lib/S$/bin/symbols.js. Coverage (Term): 16% Coverage (LOC): 34%
*- Re-run with EXPOSE_PRINT_COVERAGE=1 to print line by line coverage information
** ExpoSE Finished. 1 paths with 1 errors **
